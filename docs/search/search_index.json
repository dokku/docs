{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"advanced-usage/backup-recovery/","text":"Backup and Recovery Info The backup plugin was deprecated in 0.4.x, below are backup recommendations for 0.5.x and later. The best plan for disaster recovery is to always keep multiple (remote) copies of your local repo, static assets and periodic database dumps. Backups should be regularly tested for data integrity and completeness. TLDR Warning This method has many caveats. Please read this entire document before assuming these backups work as expected, and test your backups on a regular basis. Creating a backup To create a backup, run the following command at a time when not executing any Dokku commands or app deployments: export BACKUP_TIME = $( date +%Y-%m-%d-%H-%M ) sudo mkdir -p /var/lib/dokku/services sudo chown dokku:dokku /var/lib/dokku/services mkdir -p /tmp/dokku-backups/ sudo tar -czvf \"/tmp/dokku-backups/ ${ BACKUP_TIME } .tar.gz\" /home/dokku /var/lib/dokku/config /var/lib/dokku/data /var/lib/dokku/services /var/lib/dokku/plugins This will create a point-in-time backup of your entire Dokku installation in the /tmp/dokku-backups directory. This backup may be moved offsite to another location via rsync, sftp, or some other protocol. It is recommended that backups are regularly cleaned from the originating server and tested as necessary. Restoring a backup To extract the backup onto another server, copy the backup to the server and extract it using the following command. sudo tar -xzvf path/to/dokku/backup.tar.gz -C / At this point, all datastores should be individually started and checked for data integrity. Once this is complete, individual apps can be rebuilt. Please consult the process management documentation for more information on how to rebuild apps. Caveats App config Application config is largely held in a small number of places: /var/lib/dokku/config : Properties set and managed by plugins /var/lib/dokku/data : Files generated or extracted by various plugins /home/dokku : Certain parts of Dokku core store data in this location Compressing these directories when no Dokku commands are running is enough to ensure a complete backup of the system. Code Repositories Because Dokku is git based, rebuilding a deployed app is as easy as pushing from git. You can push to a new server by updating the dokku remote in you local app's repo. git remote rm dokku git remote add dokku dokku@ [ dokku.me:dokku.me ] git push dokku [ master ] Docker Networks Docker networks generated by Dokku should be recreated. Running dokku network:report will output all networks in use by various apps, which can then be used to recreate them via dokku network:create $NETWORK . Networks created by tools other than Dokku may be created as they initially were. Docker Image and Tar-based Apps These apps may fail to rebuild via the normal ps:rebuild method. Redeploy these apps by running the original commands used to deploy them Datastores Info Please note that point-in-time backups of the /var/lib/dokku/services directory may contain partially written data due to how various datastores work. Consult the official datastore documentation for the best documentation surrounding proper backup and restore procedures. Some plugins, like the official dokku-postgres plugin, have built-in commands that allow non-volatile data be exported and imported. For dokku-postgres , use: dokku postgres:export [ db_name ] > [ db_name ] .dump dokku postgres:import [ db_name ] < [ db_name ] .dump Additionally, data for official datastores is located in the /var/lib/dokku/services directory. If the directory is restored and the plugin is available, a dokku $SERVICE:start may be enough to restart the service with the underlying data, so long as the datastore version does not change and the underlying data is not corrupt. If this is the case, it may be necessary to re-import all the data onto a fresh version of the datastore service. Plugins The plugin directory is contained at the /var/lib/dokku/plugins directory. Core plugins will automatically be included in new installs, but custom plugins may not. The aforementioned tar creation command will back all plugins up, and the tar extract command will restore the plugins. Note that restoring a plugin will not trigger any install or dependencies triggers. You will need to run these manually. See the plugin management documentation for more information on how to trigger these two hooks. Volumes and Static Assets Dokku doesn't enforce a 300mb limit on apps, but it's best practice to keep binary assets outside of git. Since containers are considered volatile in Dokku, external stores like s3 or storage mounts should be used for non-volatile items like user uploads. The Dokku storage core plugin can be used to mount local directories / volumes inside the docker container. System administrators are highly encouraged to store persistent data in app-specific subdirectories of the path /var/lib/dokku/data/storage . This will help ensure restores of the aforementioned primary Dokku directories will restore service to all apps. See the persistent storage documentation for more information on how to attach persistent storage to your app. Recovering app code In case of an emergency when your git repo and backups are completely lost, you can recover the last pushed copy from your remote Dokku server (assuming you still have the ssh key). mkdir [ app-name ] ; cd !$ git init && git remote add dokku dokku@ [ dokku.me:app-name ] git pull dokku/master && git checkout dokku/master","title":"Backup and Recovery"},{"location":"advanced-usage/backup-recovery/#backup-and-recovery","text":"Info The backup plugin was deprecated in 0.4.x, below are backup recommendations for 0.5.x and later. The best plan for disaster recovery is to always keep multiple (remote) copies of your local repo, static assets and periodic database dumps. Backups should be regularly tested for data integrity and completeness.","title":"Backup and Recovery"},{"location":"advanced-usage/backup-recovery/#tldr","text":"Warning This method has many caveats. Please read this entire document before assuming these backups work as expected, and test your backups on a regular basis.","title":"TLDR"},{"location":"advanced-usage/backup-recovery/#creating-a-backup","text":"To create a backup, run the following command at a time when not executing any Dokku commands or app deployments: export BACKUP_TIME = $( date +%Y-%m-%d-%H-%M ) sudo mkdir -p /var/lib/dokku/services sudo chown dokku:dokku /var/lib/dokku/services mkdir -p /tmp/dokku-backups/ sudo tar -czvf \"/tmp/dokku-backups/ ${ BACKUP_TIME } .tar.gz\" /home/dokku /var/lib/dokku/config /var/lib/dokku/data /var/lib/dokku/services /var/lib/dokku/plugins This will create a point-in-time backup of your entire Dokku installation in the /tmp/dokku-backups directory. This backup may be moved offsite to another location via rsync, sftp, or some other protocol. It is recommended that backups are regularly cleaned from the originating server and tested as necessary.","title":"Creating a backup"},{"location":"advanced-usage/backup-recovery/#restoring-a-backup","text":"To extract the backup onto another server, copy the backup to the server and extract it using the following command. sudo tar -xzvf path/to/dokku/backup.tar.gz -C / At this point, all datastores should be individually started and checked for data integrity. Once this is complete, individual apps can be rebuilt. Please consult the process management documentation for more information on how to rebuild apps.","title":"Restoring a backup"},{"location":"advanced-usage/backup-recovery/#caveats","text":"","title":"Caveats"},{"location":"advanced-usage/backup-recovery/#app-config","text":"Application config is largely held in a small number of places: /var/lib/dokku/config : Properties set and managed by plugins /var/lib/dokku/data : Files generated or extracted by various plugins /home/dokku : Certain parts of Dokku core store data in this location Compressing these directories when no Dokku commands are running is enough to ensure a complete backup of the system.","title":"App config"},{"location":"advanced-usage/backup-recovery/#code-repositories","text":"Because Dokku is git based, rebuilding a deployed app is as easy as pushing from git. You can push to a new server by updating the dokku remote in you local app's repo. git remote rm dokku git remote add dokku dokku@ [ dokku.me:dokku.me ] git push dokku [ master ]","title":"Code Repositories"},{"location":"advanced-usage/backup-recovery/#docker-networks","text":"Docker networks generated by Dokku should be recreated. Running dokku network:report will output all networks in use by various apps, which can then be used to recreate them via dokku network:create $NETWORK . Networks created by tools other than Dokku may be created as they initially were.","title":"Docker Networks"},{"location":"advanced-usage/backup-recovery/#docker-image-and-tar-based-apps","text":"These apps may fail to rebuild via the normal ps:rebuild method. Redeploy these apps by running the original commands used to deploy them","title":"Docker Image and Tar-based Apps"},{"location":"advanced-usage/backup-recovery/#datastores","text":"Info Please note that point-in-time backups of the /var/lib/dokku/services directory may contain partially written data due to how various datastores work. Consult the official datastore documentation for the best documentation surrounding proper backup and restore procedures. Some plugins, like the official dokku-postgres plugin, have built-in commands that allow non-volatile data be exported and imported. For dokku-postgres , use: dokku postgres:export [ db_name ] > [ db_name ] .dump dokku postgres:import [ db_name ] < [ db_name ] .dump Additionally, data for official datastores is located in the /var/lib/dokku/services directory. If the directory is restored and the plugin is available, a dokku $SERVICE:start may be enough to restart the service with the underlying data, so long as the datastore version does not change and the underlying data is not corrupt. If this is the case, it may be necessary to re-import all the data onto a fresh version of the datastore service.","title":"Datastores"},{"location":"advanced-usage/backup-recovery/#plugins","text":"The plugin directory is contained at the /var/lib/dokku/plugins directory. Core plugins will automatically be included in new installs, but custom plugins may not. The aforementioned tar creation command will back all plugins up, and the tar extract command will restore the plugins. Note that restoring a plugin will not trigger any install or dependencies triggers. You will need to run these manually. See the plugin management documentation for more information on how to trigger these two hooks.","title":"Plugins"},{"location":"advanced-usage/backup-recovery/#volumes-and-static-assets","text":"Dokku doesn't enforce a 300mb limit on apps, but it's best practice to keep binary assets outside of git. Since containers are considered volatile in Dokku, external stores like s3 or storage mounts should be used for non-volatile items like user uploads. The Dokku storage core plugin can be used to mount local directories / volumes inside the docker container. System administrators are highly encouraged to store persistent data in app-specific subdirectories of the path /var/lib/dokku/data/storage . This will help ensure restores of the aforementioned primary Dokku directories will restore service to all apps. See the persistent storage documentation for more information on how to attach persistent storage to your app.","title":"Volumes and Static Assets"},{"location":"advanced-usage/backup-recovery/#recovering-app-code","text":"In case of an emergency when your git repo and backups are completely lost, you can recover the last pushed copy from your remote Dokku server (assuming you still have the ssh key). mkdir [ app-name ] ; cd !$ git init && git remote add dokku dokku@ [ dokku.me:app-name ] git pull dokku/master && git checkout dokku/master","title":"Recovering app code"},{"location":"advanced-usage/deployment-tasks/","text":"Deployment Tasks New Introduced in 0.5.0 Usage Overview Sometimes you need to run a command on deployment time, but before an app is completely deployed. Common use cases include: Checking a database is initialized Running database migrations Any commands required to set up the server (e.g. something like a Django collectstatic ) To support this, Dokku provides support for a special release command within your app's Procfile , as well as a special scripts.dokku key inside of your app's app.json file. Be aware that all commands are run within the context of the built docker image - no commands affect the host unless there are volume mounts attached to your app. Each \"phase\" has different expectations and limitations: app.json : scripts.dokku.predeploy When to use: This should be used if your app does not support arbitrary build commands and you need to make changes to the built image. Are changes committed to the image at this phase: Yes Example use-cases Bundling assets in a slightly different way Installing a custom package from source or copying a binary into place app.json : scripts.dokku.postdeploy When to use: This should be used in conjunction with external systems to signal the completion of your deploy. Are changes committed to the image at this phase: No Example use-cases Notifying slack that your app is deployed Coordinating traffic routing with a central load balancer app.json : scripts.postdeploy When to use: This should be used when you wish to run a command once , after the app is created and not on subsequent deploys to the app. Are changes committed to the image at this phase: No Example use-cases Setting up OAuth clients and DNS Loading seed/test data into the app\u2019s test database Procfile : release When to use: This should be used in conjunction with external systems to signal the completion of your app image build. Are changes committed to the image at this phase: No Example use-cases Sending CSS, JS, and other assets from your app\u2019s slug to a CDN or S3 bucket Priming or invalidating cache stores Running database migrations Additionally, if using a Dockerfile with an ENTRYPOINT , the deployment task is passed to that entrypoint as is. The exceptions are if the entrypoint is one of the following: [\"/tini\", \"--\"] [\"/bin/tini\", \"--\"] [\"/usr/bin/tini\", \"--\"] [\"/usr/local/bin/tini\", \"--\"] Please keep the above in mind when utilizing deployment tasks. Info To execute commands on the host during a release phase, see the plugin creation documentation docs for more information on building your own custom plugin. Changing the app.json location When deploying a monorepo, it may be desirable to specify the specific path of the app.json file to use for a given app. This can be done via the app-json:set command. If a value is specified and that file does not exist within the repository, Dokku will continue the build process as if the repository has no app.json file. dokku app-json:set node-js-app appjson-path second-app.json The default value may be set by passing an empty value for the option: dokku app-json:set node-js-app appjson-path The appjson-path property can also be set globally. The global default is app.json , and the global value is used when no app-specific value is set. dokku app-json:set --global appjson-path global-app.json The default value may be set by passing an empty value for the option. dokku app-json:set --global appjson-path Displaying app-json reports for an app New Introduced in 0.25.0 You can get a report about the app's storage status using the app-json:report command: Shell Output dokku app-json:report =====> node-js-app app-json information App-json computed appjson path: app2.json App-json global appjson path: app.json App-json appjson path: app2.json =====> python-sample app-json information App-json computed appjson path: app.json App-json global appjson path: app.json App-json appjson path: =====> ruby-sample app-json information App-json computed appjson path: app.json App-json global appjson path: app.json App-json appjson path: You can run the command for a specific app also. Shell Output dokku app-json:report node-js-app =====> node-js-app app-json information App-json computed appjson path: app2.json App-json global appjson path: app.json App-json appjson path: app2.json You can pass flags which will output only the value of the specific information you want. For example: Shell Output dokku app-json:report node-js-app --app-json-appjson-path app2.json Deployment tasks app.json deployment tasks Dokku provides limited support for the app.json manifest from Heroku (documentation available here ). The keys available for use with Deployment Tasks are: scripts.dokku.predeploy : This is run after an app's docker image is built, but before any containers are scheduled. Changes made to your image are committed at this phase. scripts.dokku.postdeploy : This is run after an app's containers are scheduled. Changes made to your image are not committed at this phase. scripts.postdeploy : This is run after an app's containers are scheduled. Changes made to your image are not committed at this phase. For buildpack-based deployments, the location of the app.json file should be at the root of your repository. Dockerfile-based app deploys should have the app.json in the configured WORKDIR directory; otherwise Dokku defaults to the buildpack app behavior of looking in /app . Warning Any failed app.json deployment task will fail the deploy. In the case of either phase, a failure will not affect any running containers. The following is an example app.json file. Please note that only the scripts.dokku.predeploy and scripts.dokku.postdeploy tasks are supported by Dokku at this time. All other fields will be ignored and can be omitted. { \"scripts\" : { \"dokku\" : { \"predeploy\" : \"touch /app/predeploy.test\" , \"postdeploy\" : \"curl https://some.external.api.service.com/deployment?state=success\" }, \"postdeploy\" : \"curl https://some.external.api.service.com/created?state=success\" } } Procfile Release command New Introduced in 0.14.0 The Procfile also supports a special release command which acts in a similar way to the Heroku Release Phase . This command is executed after an app's docker image is built, but before any containers are scheduled. This is also run after any command executed by scripts.dokku.predeploy . To use the release command, simply add a release stanza to your Procfile. release : curl https : //some.external.api.service.com/deployment ? state = built Unlike the scripts.dokku.predeploy command, changes made during by the release command are not persisted to disk.","title":"Deployment Tasks"},{"location":"advanced-usage/deployment-tasks/#deployment-tasks","text":"New Introduced in 0.5.0","title":"Deployment Tasks"},{"location":"advanced-usage/deployment-tasks/#usage","text":"","title":"Usage"},{"location":"advanced-usage/deployment-tasks/#overview","text":"Sometimes you need to run a command on deployment time, but before an app is completely deployed. Common use cases include: Checking a database is initialized Running database migrations Any commands required to set up the server (e.g. something like a Django collectstatic ) To support this, Dokku provides support for a special release command within your app's Procfile , as well as a special scripts.dokku key inside of your app's app.json file. Be aware that all commands are run within the context of the built docker image - no commands affect the host unless there are volume mounts attached to your app. Each \"phase\" has different expectations and limitations: app.json : scripts.dokku.predeploy When to use: This should be used if your app does not support arbitrary build commands and you need to make changes to the built image. Are changes committed to the image at this phase: Yes Example use-cases Bundling assets in a slightly different way Installing a custom package from source or copying a binary into place app.json : scripts.dokku.postdeploy When to use: This should be used in conjunction with external systems to signal the completion of your deploy. Are changes committed to the image at this phase: No Example use-cases Notifying slack that your app is deployed Coordinating traffic routing with a central load balancer app.json : scripts.postdeploy When to use: This should be used when you wish to run a command once , after the app is created and not on subsequent deploys to the app. Are changes committed to the image at this phase: No Example use-cases Setting up OAuth clients and DNS Loading seed/test data into the app\u2019s test database Procfile : release When to use: This should be used in conjunction with external systems to signal the completion of your app image build. Are changes committed to the image at this phase: No Example use-cases Sending CSS, JS, and other assets from your app\u2019s slug to a CDN or S3 bucket Priming or invalidating cache stores Running database migrations Additionally, if using a Dockerfile with an ENTRYPOINT , the deployment task is passed to that entrypoint as is. The exceptions are if the entrypoint is one of the following: [\"/tini\", \"--\"] [\"/bin/tini\", \"--\"] [\"/usr/bin/tini\", \"--\"] [\"/usr/local/bin/tini\", \"--\"] Please keep the above in mind when utilizing deployment tasks. Info To execute commands on the host during a release phase, see the plugin creation documentation docs for more information on building your own custom plugin.","title":"Overview"},{"location":"advanced-usage/deployment-tasks/#changing-the-appjson-location","text":"When deploying a monorepo, it may be desirable to specify the specific path of the app.json file to use for a given app. This can be done via the app-json:set command. If a value is specified and that file does not exist within the repository, Dokku will continue the build process as if the repository has no app.json file. dokku app-json:set node-js-app appjson-path second-app.json The default value may be set by passing an empty value for the option: dokku app-json:set node-js-app appjson-path The appjson-path property can also be set globally. The global default is app.json , and the global value is used when no app-specific value is set. dokku app-json:set --global appjson-path global-app.json The default value may be set by passing an empty value for the option. dokku app-json:set --global appjson-path","title":"Changing the app.json location"},{"location":"advanced-usage/deployment-tasks/#displaying-app-json-reports-for-an-app","text":"New Introduced in 0.25.0 You can get a report about the app's storage status using the app-json:report command: Shell Output dokku app-json:report =====> node-js-app app-json information App-json computed appjson path: app2.json App-json global appjson path: app.json App-json appjson path: app2.json =====> python-sample app-json information App-json computed appjson path: app.json App-json global appjson path: app.json App-json appjson path: =====> ruby-sample app-json information App-json computed appjson path: app.json App-json global appjson path: app.json App-json appjson path: You can run the command for a specific app also. Shell Output dokku app-json:report node-js-app =====> node-js-app app-json information App-json computed appjson path: app2.json App-json global appjson path: app.json App-json appjson path: app2.json You can pass flags which will output only the value of the specific information you want. For example: Shell Output dokku app-json:report node-js-app --app-json-appjson-path app2.json","title":"Displaying app-json reports for an app"},{"location":"advanced-usage/deployment-tasks/#deployment-tasks_1","text":"","title":"Deployment tasks"},{"location":"advanced-usage/deployment-tasks/#appjson-deployment-tasks","text":"Dokku provides limited support for the app.json manifest from Heroku (documentation available here ). The keys available for use with Deployment Tasks are: scripts.dokku.predeploy : This is run after an app's docker image is built, but before any containers are scheduled. Changes made to your image are committed at this phase. scripts.dokku.postdeploy : This is run after an app's containers are scheduled. Changes made to your image are not committed at this phase. scripts.postdeploy : This is run after an app's containers are scheduled. Changes made to your image are not committed at this phase. For buildpack-based deployments, the location of the app.json file should be at the root of your repository. Dockerfile-based app deploys should have the app.json in the configured WORKDIR directory; otherwise Dokku defaults to the buildpack app behavior of looking in /app . Warning Any failed app.json deployment task will fail the deploy. In the case of either phase, a failure will not affect any running containers. The following is an example app.json file. Please note that only the scripts.dokku.predeploy and scripts.dokku.postdeploy tasks are supported by Dokku at this time. All other fields will be ignored and can be omitted. { \"scripts\" : { \"dokku\" : { \"predeploy\" : \"touch /app/predeploy.test\" , \"postdeploy\" : \"curl https://some.external.api.service.com/deployment?state=success\" }, \"postdeploy\" : \"curl https://some.external.api.service.com/created?state=success\" } }","title":"app.json deployment tasks"},{"location":"advanced-usage/deployment-tasks/#procfile-release-command","text":"New Introduced in 0.14.0 The Procfile also supports a special release command which acts in a similar way to the Heroku Release Phase . This command is executed after an app's docker image is built, but before any containers are scheduled. This is also run after any command executed by scripts.dokku.predeploy . To use the release command, simply add a release stanza to your Procfile. release : curl https : //some.external.api.service.com/deployment ? state = built Unlike the scripts.dokku.predeploy command, changes made during by the release command are not persisted to disk.","title":"Procfile Release command"},{"location":"advanced-usage/docker-options/","text":"Docker Container Options New Introduced in 0.3.17 Pass container options to the docker run command during Dokku's build , deploy and run phases docker-options:add <app> <phase(s)> OPTION # Add Docker option to app for phase (comma-separated phase list) docker-options:clear <app> [<phase(s)>...] # Clear a docker options from application docker-options:remove <app> <phase(s)> OPTION # Remove Docker option from app for phase (comma-separated phase list) docker-options:report [<app>] [<flag>] # Displays a docker options report for one or more apps Info When specifying multiple phases, they must be comma-separated without spaces in between each phase, like so: dokku docker-options:add node-js-app deploy,run \"-v /var/log/node-js-app:/app/logs\" About Dokku phases Dokku deploys your application in multiple \"phases\" and the docker-options plugin allows you to pass arguments to their underlying docker container: build : the container that executes the appropriate buildpack deploy : the container that executes your running/deployed application run : the container that executes any arbitrary command via dokku run Manipulation of docker options will not restart running containers. This enables multiple options to be set/unset before final application. As such, changing an app's docker options must be followed by a dokku ps:rebuild in order to take effect. More information on supported Docker options can be found here: https://docs.docker.com/engine/reference/commandline/run/. Container options configured via the docker-options plugin are not used to modify the process a container runs. Container options are the [OPTIONS] portion of the following, where [CONTAINER_COMMAND] and [ARG] are the process and the arguments passed to it that are launched in the created container: docker run [OPTIONS] [CONTAINER_COMMAND] [ARG...] . Please see the documentation for customizing the run command or use a Procfile to modify the command used by a Dockerfile-based container. Examples Add Docker options Add some options for the deployed/running app and when executing dokku run : # Mount a host volume in a Docker container: \"-v /host/path:/container/path\" dokku docker-options:add node-js-app deploy \"-v /var/log/node-js-app:/app/logs\" dokku docker-options:add node-js-app run \"-v /var/log/node-js-app:/app/logs\" Note When mounting a host directory in a Dokku app you should first create that directory as user dokku and then mount the directory under /app in the container using docker-options as above. Otherwise the app will lack write permission in the directory. Remove a Docker option dokku docker-options:remove node-js-app run \"-v /var/log/node-js-app:/app/logs\" Clear all Docker options for an app Docker options can be removed for a specific app using the docker-options:clear command. Shell Output dokku docker-options:clear node-js-app -----> Clearing docker-options for node-js-app on all phases One or more valid phases can also be specified. Phases are comma delimited, and specifying an invalid phase will result in an error. Shell Output Shell Output dokku docker-options:clear node-js-app run -----> Clearing docker-options for node-js-app on phase run dokku docker-options:clear node-js-app build,run -----> Clearing docker-options for node-js-app on phase build -----> Clearing docker-options for node-js-app on phase run Displaying docker-options reports for an app New Introduced in 0.8.1 You can get a report about the app's docker-options status using the docker-options:report command: Shell Output dokku docker-options:report =====> node-js-app docker options information Docker options build: Docker options deploy: -v /var/log/node-js-app:/app/logs Docker options run: -v /var/log/node-js-app:/app/logs =====> python-sample docker options information Docker options build: Docker options deploy: Docker options run: =====> ruby-sample docker options information Docker options build: Docker options deploy: Docker options run: You can run the command for a specific app also. Shell Output dokku docker-options:report node-js-app =====> node-js-app docker options information Docker options build: Docker options deploy: -v /var/log/node-js-app:/app/logs Docker options run: -v /var/log/node-js-app:/app/logs You can pass flags which will output only the value of the specific information you want. For example: dokku docker-options:report node-js-app --docker-options-build","title":"Docker Container Options"},{"location":"advanced-usage/docker-options/#docker-container-options","text":"New Introduced in 0.3.17 Pass container options to the docker run command during Dokku's build , deploy and run phases docker-options:add <app> <phase(s)> OPTION # Add Docker option to app for phase (comma-separated phase list) docker-options:clear <app> [<phase(s)>...] # Clear a docker options from application docker-options:remove <app> <phase(s)> OPTION # Remove Docker option from app for phase (comma-separated phase list) docker-options:report [<app>] [<flag>] # Displays a docker options report for one or more apps Info When specifying multiple phases, they must be comma-separated without spaces in between each phase, like so: dokku docker-options:add node-js-app deploy,run \"-v /var/log/node-js-app:/app/logs\"","title":"Docker Container Options"},{"location":"advanced-usage/docker-options/#about-dokku-phases","text":"Dokku deploys your application in multiple \"phases\" and the docker-options plugin allows you to pass arguments to their underlying docker container: build : the container that executes the appropriate buildpack deploy : the container that executes your running/deployed application run : the container that executes any arbitrary command via dokku run Manipulation of docker options will not restart running containers. This enables multiple options to be set/unset before final application. As such, changing an app's docker options must be followed by a dokku ps:rebuild in order to take effect. More information on supported Docker options can be found here: https://docs.docker.com/engine/reference/commandline/run/. Container options configured via the docker-options plugin are not used to modify the process a container runs. Container options are the [OPTIONS] portion of the following, where [CONTAINER_COMMAND] and [ARG] are the process and the arguments passed to it that are launched in the created container: docker run [OPTIONS] [CONTAINER_COMMAND] [ARG...] . Please see the documentation for customizing the run command or use a Procfile to modify the command used by a Dockerfile-based container.","title":"About Dokku phases"},{"location":"advanced-usage/docker-options/#examples","text":"","title":"Examples"},{"location":"advanced-usage/docker-options/#add-docker-options","text":"Add some options for the deployed/running app and when executing dokku run : # Mount a host volume in a Docker container: \"-v /host/path:/container/path\" dokku docker-options:add node-js-app deploy \"-v /var/log/node-js-app:/app/logs\" dokku docker-options:add node-js-app run \"-v /var/log/node-js-app:/app/logs\" Note When mounting a host directory in a Dokku app you should first create that directory as user dokku and then mount the directory under /app in the container using docker-options as above. Otherwise the app will lack write permission in the directory.","title":"Add Docker options"},{"location":"advanced-usage/docker-options/#remove-a-docker-option","text":"dokku docker-options:remove node-js-app run \"-v /var/log/node-js-app:/app/logs\"","title":"Remove a Docker option"},{"location":"advanced-usage/docker-options/#clear-all-docker-options-for-an-app","text":"Docker options can be removed for a specific app using the docker-options:clear command. Shell Output dokku docker-options:clear node-js-app -----> Clearing docker-options for node-js-app on all phases One or more valid phases can also be specified. Phases are comma delimited, and specifying an invalid phase will result in an error. Shell Output Shell Output dokku docker-options:clear node-js-app run -----> Clearing docker-options for node-js-app on phase run dokku docker-options:clear node-js-app build,run -----> Clearing docker-options for node-js-app on phase build -----> Clearing docker-options for node-js-app on phase run","title":"Clear all Docker options for an app"},{"location":"advanced-usage/docker-options/#displaying-docker-options-reports-for-an-app","text":"New Introduced in 0.8.1 You can get a report about the app's docker-options status using the docker-options:report command: Shell Output dokku docker-options:report =====> node-js-app docker options information Docker options build: Docker options deploy: -v /var/log/node-js-app:/app/logs Docker options run: -v /var/log/node-js-app:/app/logs =====> python-sample docker options information Docker options build: Docker options deploy: Docker options run: =====> ruby-sample docker options information Docker options build: Docker options deploy: Docker options run: You can run the command for a specific app also. Shell Output dokku docker-options:report node-js-app =====> node-js-app docker options information Docker options build: Docker options deploy: -v /var/log/node-js-app:/app/logs Docker options run: -v /var/log/node-js-app:/app/logs You can pass flags which will output only the value of the specific information you want. For example: dokku docker-options:report node-js-app --docker-options-build","title":"Displaying docker-options reports for an app"},{"location":"advanced-usage/event-logs/","text":"Dokku Event Logs New Introduced in 0.3.21 Docker provides an events command to show system's real time events. Likewise, Dokku can record events as syslog entries and also provides a plugin to display the last ones. events [-t] # Show the last events (-t follows) events:list # List logged events events:on # Enable events logger events:off # Disable events logger Usage Enable the plugin: Shell Output dokku events:on Enabling dokku events logger Dokku will then write log entries to /var/log/syslog as well as a Dokku-specific logs sub-directory /var/log/dokku/events.log , which can be easily displayed with the command dokku events : Shell Output dokku events Jul 3 16:09:48 dokku.me dokku[127630]: INVOKED: pre-release-buildpack( pythonapp ) Jul 3 16:10:02 dokku.me dokku[128095]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:10:02 dokku.me dokku[128114]: INVOKED: docker-args-run( nhl ) Jul 3 16:10:03 dokku.me dokku[128136]: INVOKED: post-release-buildpack( pythonapp ) Jul 3 16:10:03 dokku.me dokku[128195]: INVOKED: pre-deploy( pythonapp ) Jul 3 16:10:23 dokku.me dokku[129253]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:24 dokku.me dokku[129451]: INVOKED: check-deploy( pythonapp 6274ced0d4be11af4490cd18abaf77cdd593f025133f403d984e80d86a39acec web 5000 10.0.16.80 ) Jul 3 16:10:35 dokku.me dokku[129561]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:36 dokku.me dokku[129760]: INVOKED: check-deploy( pythonapp ac88a56ee4161ff37e4b92d1498c3eadc91f0aa7c8b81b44fc077e2a51d54cc0 worker ) Jul 3 16:10:46 dokku.me dokku[129851]: INVOKED: post-deploy( pythonapp ) Jul 3 16:10:46 dokku.me dokku[129945]: INVOKED: nginx-pre-reload( pythonapp ) Jul 3 16:15:02 dokku.me dokku[130397]: INVOKED: docker-args-run( goapp ) Jul 3 16:21:02 dokku.me dokku[130796]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:30:02 dokku.me dokku[131384]: INVOKED: docker-args-run( rubyapp ) You can list all events that are currently being recorded via dokku events:list : Shell Output dokku events:list =====> Events currently logged check-deploy dependencies docker-args-build docker-args-deploy docker-args-run git-post-pull git-pre-pull nginx-hostname nginx-pre-reload post-build-buildpack post-build-dockerfile post-delete post-deploy post-domains-update post-release-buildpack post-release-dockerfile pre-build-buildpack pre-build-dockerfile pre-delete pre-deploy pre-release-buildpack pre-release-dockerfile receive-app update","title":"Dokku Event Logs"},{"location":"advanced-usage/event-logs/#dokku-event-logs","text":"New Introduced in 0.3.21 Docker provides an events command to show system's real time events. Likewise, Dokku can record events as syslog entries and also provides a plugin to display the last ones. events [-t] # Show the last events (-t follows) events:list # List logged events events:on # Enable events logger events:off # Disable events logger","title":"Dokku Event Logs"},{"location":"advanced-usage/event-logs/#usage","text":"Enable the plugin: Shell Output dokku events:on Enabling dokku events logger Dokku will then write log entries to /var/log/syslog as well as a Dokku-specific logs sub-directory /var/log/dokku/events.log , which can be easily displayed with the command dokku events : Shell Output dokku events Jul 3 16:09:48 dokku.me dokku[127630]: INVOKED: pre-release-buildpack( pythonapp ) Jul 3 16:10:02 dokku.me dokku[128095]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:10:02 dokku.me dokku[128114]: INVOKED: docker-args-run( nhl ) Jul 3 16:10:03 dokku.me dokku[128136]: INVOKED: post-release-buildpack( pythonapp ) Jul 3 16:10:03 dokku.me dokku[128195]: INVOKED: pre-deploy( pythonapp ) Jul 3 16:10:23 dokku.me dokku[129253]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:24 dokku.me dokku[129451]: INVOKED: check-deploy( pythonapp 6274ced0d4be11af4490cd18abaf77cdd593f025133f403d984e80d86a39acec web 5000 10.0.16.80 ) Jul 3 16:10:35 dokku.me dokku[129561]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:36 dokku.me dokku[129760]: INVOKED: check-deploy( pythonapp ac88a56ee4161ff37e4b92d1498c3eadc91f0aa7c8b81b44fc077e2a51d54cc0 worker ) Jul 3 16:10:46 dokku.me dokku[129851]: INVOKED: post-deploy( pythonapp ) Jul 3 16:10:46 dokku.me dokku[129945]: INVOKED: nginx-pre-reload( pythonapp ) Jul 3 16:15:02 dokku.me dokku[130397]: INVOKED: docker-args-run( goapp ) Jul 3 16:21:02 dokku.me dokku[130796]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:30:02 dokku.me dokku[131384]: INVOKED: docker-args-run( rubyapp ) You can list all events that are currently being recorded via dokku events:list : Shell Output dokku events:list =====> Events currently logged check-deploy dependencies docker-args-build docker-args-deploy docker-args-run git-post-pull git-pre-pull nginx-hostname nginx-pre-reload post-build-buildpack post-build-dockerfile post-delete post-deploy post-domains-update post-release-buildpack post-release-dockerfile pre-build-buildpack pre-build-dockerfile pre-delete pre-deploy pre-release-buildpack pre-release-dockerfile receive-app update","title":"Usage"},{"location":"advanced-usage/persistent-storage/","text":"Persistent Storage New Introduced in 0.5.0 The preferred method to mount external containers to a Dokku managed container, is to use the Dokku storage plugin. storage:ensure-directory [--chown option] <directory> # Creates a persistent storage directory in the recommended storage path storage:list <app> # List bind mounts for app's container(s) (host:container) storage:mount <app> <host-dir:container-dir> # Create a new bind mount storage:report [<app>] [<flag>] # Displays a checks report for one or more apps storage:unmount <app> <host-dir:container-dir> # Remove an existing bind mount Info The storage plugin is compatible with storage mounts created with the docker-options. The storage plugin will only list mounts from the deploy/run phase. The storage plugin supports the following mount points: explicit paths that exist on the host docker volumes Usage Creating storage directories New Introduced in 0.25.5 A storage directory can be created with the storage:ensure-directory command. This command will create a subdirectory in the recommended /var/lib/dokku/data/storage path - created during Dokku installation - and prepare it for use with an app. Shell Output dokku storage:ensure-directory lollipop -----> Ensuring /var/lib/dokku/data/storage/lollipop exists Setting directory ownership to 32767:32767 Directory ready for mounting By default, permissions are set for usage with Herokuish buildpacks. These permissions can be changed via the --chown option according to the following table: --chown herokuish (default): Use 32767:32767 as the folder permissions. This is used for apps deployed with Buildpacks via Herokuish. --chown heroku : Use 1000:1000 as the folder permissions. This is used for apps deployed with Cloud Native Buildpacks using the heroku/buildpacks builder. --chown packeto : Use 2000:2000 as the folder permissions. This is used for apps deployed with Cloud Native Buildpacks using the cloudfoundry/cnb or packeto builders. --chown false : Skips the chown call. Users deploying via Dockerfile will want to specify --chown false and manually chown the created directory if the user and/or group id of the runnning process in the deployed container do not correspond to any of the above options. Warning Failing to set the correct directory ownership may result in issues in persisting files written to the mounted storage directory. Mounting storage into apps Dokku supports mounting both explicit host paths as well as docker volumes via the storage:mount command. This takes two arguments, an app name and a host-path:container-path or docker-volume:container-path combination. # mount the directory into your container's /app/storage directory, relative to the container root (/) # explicit host paths _must_ exist prior to usage. dokku storage:mount node-js-app /var/lib/dokku/data/storage/node-js-app:/app/storage # mount the docker volume into your container's /app/storage directory, relative to the container root (/) # docker volumes _must_ exist prior to usage. dokku storage:mount node-js-app some-docker-volume:/app/storage In the first example, Dokku will then mount the shared contents of /var/lib/dokku/data/storage/node-js-app to /app/storage inside the container. The mount point is not relative to your app's working directory, and is instead relative to the root ( / ) of the container. Mounts are only available for containers created via run and by the deploy process, and not during the build process. In addition, the host path is never auto-created by either Dokku or Docker, and should be an explicit path, not one relative to the current working directory. Info If the /storage path within the container had pre-existing content, the container files will be over-written. This may be an issue for users that create assets at build time but then mount a directory at the same place during runtime. Files are not merged. Once persistent storage is mounted, the app requires a restart. See the process scaling documentation for more information. dokku ps:restart app-name Unmounting storage If an app no longer requires a mounted volume or directory, the storage:unmount command can be called. This takes the same arguments as the storage:mount command, an app name and a host-path:container-path or docker-volume:container-path combination. # unmount the directory from your container's /app/storage directory, relative to the container root (/) dokku storage:unmount node-js-app /var/lib/dokku/data/storage/node-js-app:/app/storage # unmount the docker volume from your container's /app/storage directory, relative to the container root (/) dokku storage:unmount node-js-app some-docker-volume:/app/storage Once persistent storage is unmounted, the app requires a restart. See the process scaling documentation for more information. dokku ps:restart app-name Displaying storage reports for an app New Introduced in 0.8.1 You can get a report about the app's storage status using the storage:report command: Shell Output dokku storage:report =====> node-js-app storage information Storage build mounts: Storage deploy mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage Storage run mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage =====> python-sample storage information Storage build mounts: Storage deploy mounts: Storage run mounts: =====> ruby-sample storage information Storage build mounts: Storage deploy mounts: Storage run mounts: You can run the command for a specific app also. Shell Output dokku storage:report node-js-app =====> node-js-app storage information Storage build mounts: Storage deploy mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage Storage run mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage You can pass flags which will output only the value of the specific information you want. For example: dokku storage:report node-js-app --storage-deploy-mounts Use Cases Sharing storage across deploys Dokku is powered by Docker containers, which recommends in their best practices that containers be treated as ephemeral. In order to manage persistent storage for web apps, like user uploads or large binary assets like images, a directory outside the container should be mounted. Shared storage between containers When scaling your app, you may require a common location to access shared assets between containers, a storage mount can be used in this situation. Shared storage across environments Your app may be used in a cluster that requires containers or resources not running on the same host access your data. Mounting a shared file service (like S3FS or EFS) inside your container will give you great flexibility. Backing up Your app may have services that are running in memory and need to be backed up locally (like a key store). Mount a non ephemeral storage mount will allow backups that are not lost when the app is shut down. Build phase By default, Dokku will only bind storage mounts during the deploy and run phases. Under certain conditions, one might want to bind a storage mount during the build phase. This can be accomplished by using the docker-options plugin directly. dokku docker-options:add node-js-app build \"-v /tmp/python-test:/opt/test\" You cannot use mounted volumes during the build phase of a Dockerfile deploy. This is because Docker does not support volumes when executing docker build . Note This can cause data loss if you bind a mount under /app in buildpack apps as herokuish will attempt to remove the original app path during the build phase. App User and Persistent Storage file ownership (buildpack apps only) New Introduced in 0.7.1 By default, Dokku will execute your buildpack app processes as the herokuishuser user. You may override this by setting the DOKKU_APP_USER config variable. Info NOTE: this user must exist in your herokuish image. Additionally, the default docker-local scheduler that comes with Dokku will ensure your storage mounts are owned by either herokuishuser or the overridden value you have set in DOKKU_APP_USER . See the docker-local scheduler documentation docs for more information.","title":"Persistent Storage"},{"location":"advanced-usage/persistent-storage/#persistent-storage","text":"New Introduced in 0.5.0 The preferred method to mount external containers to a Dokku managed container, is to use the Dokku storage plugin. storage:ensure-directory [--chown option] <directory> # Creates a persistent storage directory in the recommended storage path storage:list <app> # List bind mounts for app's container(s) (host:container) storage:mount <app> <host-dir:container-dir> # Create a new bind mount storage:report [<app>] [<flag>] # Displays a checks report for one or more apps storage:unmount <app> <host-dir:container-dir> # Remove an existing bind mount Info The storage plugin is compatible with storage mounts created with the docker-options. The storage plugin will only list mounts from the deploy/run phase. The storage plugin supports the following mount points: explicit paths that exist on the host docker volumes","title":"Persistent Storage"},{"location":"advanced-usage/persistent-storage/#usage","text":"","title":"Usage"},{"location":"advanced-usage/persistent-storage/#creating-storage-directories","text":"New Introduced in 0.25.5 A storage directory can be created with the storage:ensure-directory command. This command will create a subdirectory in the recommended /var/lib/dokku/data/storage path - created during Dokku installation - and prepare it for use with an app. Shell Output dokku storage:ensure-directory lollipop -----> Ensuring /var/lib/dokku/data/storage/lollipop exists Setting directory ownership to 32767:32767 Directory ready for mounting By default, permissions are set for usage with Herokuish buildpacks. These permissions can be changed via the --chown option according to the following table: --chown herokuish (default): Use 32767:32767 as the folder permissions. This is used for apps deployed with Buildpacks via Herokuish. --chown heroku : Use 1000:1000 as the folder permissions. This is used for apps deployed with Cloud Native Buildpacks using the heroku/buildpacks builder. --chown packeto : Use 2000:2000 as the folder permissions. This is used for apps deployed with Cloud Native Buildpacks using the cloudfoundry/cnb or packeto builders. --chown false : Skips the chown call. Users deploying via Dockerfile will want to specify --chown false and manually chown the created directory if the user and/or group id of the runnning process in the deployed container do not correspond to any of the above options. Warning Failing to set the correct directory ownership may result in issues in persisting files written to the mounted storage directory.","title":"Creating storage directories"},{"location":"advanced-usage/persistent-storage/#mounting-storage-into-apps","text":"Dokku supports mounting both explicit host paths as well as docker volumes via the storage:mount command. This takes two arguments, an app name and a host-path:container-path or docker-volume:container-path combination. # mount the directory into your container's /app/storage directory, relative to the container root (/) # explicit host paths _must_ exist prior to usage. dokku storage:mount node-js-app /var/lib/dokku/data/storage/node-js-app:/app/storage # mount the docker volume into your container's /app/storage directory, relative to the container root (/) # docker volumes _must_ exist prior to usage. dokku storage:mount node-js-app some-docker-volume:/app/storage In the first example, Dokku will then mount the shared contents of /var/lib/dokku/data/storage/node-js-app to /app/storage inside the container. The mount point is not relative to your app's working directory, and is instead relative to the root ( / ) of the container. Mounts are only available for containers created via run and by the deploy process, and not during the build process. In addition, the host path is never auto-created by either Dokku or Docker, and should be an explicit path, not one relative to the current working directory. Info If the /storage path within the container had pre-existing content, the container files will be over-written. This may be an issue for users that create assets at build time but then mount a directory at the same place during runtime. Files are not merged. Once persistent storage is mounted, the app requires a restart. See the process scaling documentation for more information. dokku ps:restart app-name","title":"Mounting storage into apps"},{"location":"advanced-usage/persistent-storage/#unmounting-storage","text":"If an app no longer requires a mounted volume or directory, the storage:unmount command can be called. This takes the same arguments as the storage:mount command, an app name and a host-path:container-path or docker-volume:container-path combination. # unmount the directory from your container's /app/storage directory, relative to the container root (/) dokku storage:unmount node-js-app /var/lib/dokku/data/storage/node-js-app:/app/storage # unmount the docker volume from your container's /app/storage directory, relative to the container root (/) dokku storage:unmount node-js-app some-docker-volume:/app/storage Once persistent storage is unmounted, the app requires a restart. See the process scaling documentation for more information. dokku ps:restart app-name","title":"Unmounting storage"},{"location":"advanced-usage/persistent-storage/#displaying-storage-reports-for-an-app","text":"New Introduced in 0.8.1 You can get a report about the app's storage status using the storage:report command: Shell Output dokku storage:report =====> node-js-app storage information Storage build mounts: Storage deploy mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage Storage run mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage =====> python-sample storage information Storage build mounts: Storage deploy mounts: Storage run mounts: =====> ruby-sample storage information Storage build mounts: Storage deploy mounts: Storage run mounts: You can run the command for a specific app also. Shell Output dokku storage:report node-js-app =====> node-js-app storage information Storage build mounts: Storage deploy mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage Storage run mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage You can pass flags which will output only the value of the specific information you want. For example: dokku storage:report node-js-app --storage-deploy-mounts","title":"Displaying storage reports for an app"},{"location":"advanced-usage/persistent-storage/#use-cases","text":"","title":"Use Cases"},{"location":"advanced-usage/persistent-storage/#sharing-storage-across-deploys","text":"Dokku is powered by Docker containers, which recommends in their best practices that containers be treated as ephemeral. In order to manage persistent storage for web apps, like user uploads or large binary assets like images, a directory outside the container should be mounted.","title":"Sharing storage across deploys"},{"location":"advanced-usage/persistent-storage/#shared-storage-between-containers","text":"When scaling your app, you may require a common location to access shared assets between containers, a storage mount can be used in this situation.","title":"Shared storage between containers"},{"location":"advanced-usage/persistent-storage/#shared-storage-across-environments","text":"Your app may be used in a cluster that requires containers or resources not running on the same host access your data. Mounting a shared file service (like S3FS or EFS) inside your container will give you great flexibility.","title":"Shared storage across environments"},{"location":"advanced-usage/persistent-storage/#backing-up","text":"Your app may have services that are running in memory and need to be backed up locally (like a key store). Mount a non ephemeral storage mount will allow backups that are not lost when the app is shut down.","title":"Backing up"},{"location":"advanced-usage/persistent-storage/#build-phase","text":"By default, Dokku will only bind storage mounts during the deploy and run phases. Under certain conditions, one might want to bind a storage mount during the build phase. This can be accomplished by using the docker-options plugin directly. dokku docker-options:add node-js-app build \"-v /tmp/python-test:/opt/test\" You cannot use mounted volumes during the build phase of a Dockerfile deploy. This is because Docker does not support volumes when executing docker build . Note This can cause data loss if you bind a mount under /app in buildpack apps as herokuish will attempt to remove the original app path during the build phase.","title":"Build phase"},{"location":"advanced-usage/persistent-storage/#app-user-and-persistent-storage-file-ownership-buildpack-apps-only","text":"New Introduced in 0.7.1 By default, Dokku will execute your buildpack app processes as the herokuishuser user. You may override this by setting the DOKKU_APP_USER config variable. Info NOTE: this user must exist in your herokuish image. Additionally, the default docker-local scheduler that comes with Dokku will ensure your storage mounts are owned by either herokuishuser or the overridden value you have set in DOKKU_APP_USER . See the docker-local scheduler documentation docs for more information.","title":"App User and Persistent Storage file ownership (buildpack apps only)"},{"location":"advanced-usage/plugin-management/","text":"Plugin Management New Introduced in 0.4.0 plugin:disable <name> # Disable an installed plugin (third-party only) plugin:enable <name> # Enable a previously disabled plugin plugin:install [--core|git-url [--committish tag|branch|commit|--name custom-plugin-name]] # Optionally download git-url (with custom tag/committish) & run install trigger for active plugins (or only core ones) plugin:installed <name> # Checks if a plugin is installed plugin:install-dependencies [--core] # Run install-dependencies trigger for active plugins (or only core ones) plugin:list # Print active plugins plugin:trigger <args...>. # Trigger an arbitrary plugin hook plugin:uninstall <name> # Uninstall a plugin (third-party only) plugin:update [name [committish]] # Optionally update named plugin from git (with custom tag/committish) & run update trigger for active plugins # for 0.3.x cd /var/lib/dokku/plugins git clone <git url> dokku plugins-install Info These commands require root permissions as the install and install-dependencies plugin triggers may utilize commands such as apt-get . For non-core plugins, please inspect those plugins before running the following command as root user. Usage Listing Plugins Installed plugins can be listed via the plugin:list command: Shell Output dokku plugin:list plugn: dev 00_dokku-standard 0.28.4 enabled dokku core standard plugin 20_events 0.28.4 enabled dokku core events logging plugin app-json 0.28.4 enabled dokku core app-json plugin apps 0.28.4 enabled dokku core apps plugin build-env 0.28.4 enabled dokku core build-env plugin buildpacks 0.28.4 enabled dokku core buildpacks plugin certs 0.28.4 enabled dokku core certificate management plugin checks 0.28.4 enabled dokku core checks plugin common 0.28.4 enabled dokku core common plugin config 0.28.4 enabled dokku core config plugin docker-options 0.28.4 enabled dokku core docker-options plugin domains 0.28.4 enabled dokku core domains plugin enter 0.28.4 enabled dokku core enter plugin git 0.28.4 enabled dokku core git plugin logs 0.28.4 enabled dokku core logs plugin network 0.28.4 enabled dokku core network plugin nginx-vhosts 0.28.4 enabled dokku core nginx-vhosts plugin plugin 0.28.4 enabled dokku core plugin plugin proxy 0.28.4 enabled dokku core proxy plugin ps 0.28.4 enabled dokku core ps plugin repo 0.28.4 enabled dokku core repo plugin resource 0.28.4 enabled dokku core resource plugin scheduler-docker-local 0.28.4 enabled dokku core scheduler-docker-local plugin shell 0.28.4 enabled dokku core shell plugin ssh-keys 0.28.4 enabled dokku core ssh-keys plugin storage 0.28.4 enabled dokku core storage plugin tags 0.28.4 enabled dokku core tags plugin tar 0.28.4 enabled dokku core tar plugin trace 0.28.4 enabled dokku core trace plugin Warning All plugin commands other than plugin:list and plugin:help require sudo access and must be run directly from the Dokku server. Checking if a plugin is installed You can check if a plugin has been installed via the plugin:installed command: dokku plugin:installed postgres Installing a plugin Installing a plugin is easy as well using the plugin:install command. This command will also trigger the install pluginhook on all existing plugins. The most common usage is to install a plugin from a url. This url may be any of the following: git : For git+ssh based plugin repository clones. ssh : For git+ssh based plugin repository clones. file : For copying plugins from a path on disk. https : For http based plugin repository clones. Additionally, any urls with the extensions .tar.gz or .tgz are treated as Gzipped Tarballs for installation purposes and will be downloaded and extracted into place. Shell Output dokku plugin:install https://github.com/dokku/dokku-postgres.git -----> Cloning plugin repo https://github.com/dokku/dokku-postgres.git to /var/lib/dokku/plugins/available/postgres Cloning into 'postgres'... remote: Counting objects: 646, done. remote: Total 646 (delta 0), reused 0 (delta 0), pack-reused 646 Receiving objects: 100% (646/646), 134.24 KiB | 0 bytes/s, done. Resolving deltas: 100% (406/406), done. Checking connectivity... done. -----> Plugin postgres enabled For git-based plugin installation, a commit SHA-like object may be specified (tag/branch/commit sha) via the --committish argument and Dokku will attempt to install the specified commit object. # where 2.0.0 is a potential git tag dokku plugin:install https://github.com/dokku/dokku-postgres.git --committish 2 .0.0 Plugin names are interpolated based on the repository name minus the dokku- prefix. If the plugin being installed has a name other than what matches the repository name - or another name is desired - the --name flag can be used to override this interpolation. dokku plugin:install https://github.com/dokku/smoke-test-plugin.git --name smoke-test-plugin The --core flag may also be indicated as the sole argument, though it is only for installation of core plugins, and thus not useful for end-user installations. dokku plugin:install --core Finally, all flags may be omitted to trigger the install procedures for both core and third-party plugins: dokku plugin:install Installing plugin dependencies In some cases, plugins will have system-level dependencies. These are not automatically installed via plugin:install , and must be separately via the plugin:install-dependencies command. This will run through all the dependencies trigger for all plugins. dokku plugin:install-dependencies This command may also target just core plugins via the --core flag. This is usually only useful for source-based installs of Dokku. dokku plugin:install-dependencies --core Updating a plugin An installed, third-party plugin can be updated can updated via the plugin:update command. This should be done after any upgrades of Dokku as there may be changes in the internal api that require an update of how the plugin interfaces with Dokku. Please note that this command is only valid for plugin installs that were backed by a git-repository. Shell Output dokku plugin:update postgres Plugin (postgres) updated An optional commit SHA-like object may be specified. dokku plugin:update postgres 2 .0.0 Uninstalling a plugin Third party plugins can be uninstalled using the plugin:uninstall command: Shell Output dokku plugin:uninstall postgres -----> Plugin postgres uninstalled Disabling a plugin Disabling a plugin can also be useful for debugging whether a third-party plugin is causing issues in a Dokku installation. Another common use case is for disabling core functionality for replacement with a third-party plugin. Shell Output dokku plugin:disable postgres -----> Plugin postgres disabled Enabling a plugin Disabled plugins can be re-enabled via the plugin:enable command. Shell Output dokku plugin:enable postgres -----> Plugin postgres enabled Triggering a plugin trigger The plugin:trigger can be used to call any internal plugin trigger. This may have unintended consequences, and thus should only be called for development or debugging purposes. dokku plugin:trigger some-internal-trigger args-go-here","title":"Plugin Management"},{"location":"advanced-usage/plugin-management/#plugin-management","text":"New Introduced in 0.4.0 plugin:disable <name> # Disable an installed plugin (third-party only) plugin:enable <name> # Enable a previously disabled plugin plugin:install [--core|git-url [--committish tag|branch|commit|--name custom-plugin-name]] # Optionally download git-url (with custom tag/committish) & run install trigger for active plugins (or only core ones) plugin:installed <name> # Checks if a plugin is installed plugin:install-dependencies [--core] # Run install-dependencies trigger for active plugins (or only core ones) plugin:list # Print active plugins plugin:trigger <args...>. # Trigger an arbitrary plugin hook plugin:uninstall <name> # Uninstall a plugin (third-party only) plugin:update [name [committish]] # Optionally update named plugin from git (with custom tag/committish) & run update trigger for active plugins # for 0.3.x cd /var/lib/dokku/plugins git clone <git url> dokku plugins-install Info These commands require root permissions as the install and install-dependencies plugin triggers may utilize commands such as apt-get . For non-core plugins, please inspect those plugins before running the following command as root user.","title":"Plugin Management"},{"location":"advanced-usage/plugin-management/#usage","text":"","title":"Usage"},{"location":"advanced-usage/plugin-management/#listing-plugins","text":"Installed plugins can be listed via the plugin:list command: Shell Output dokku plugin:list plugn: dev 00_dokku-standard 0.28.4 enabled dokku core standard plugin 20_events 0.28.4 enabled dokku core events logging plugin app-json 0.28.4 enabled dokku core app-json plugin apps 0.28.4 enabled dokku core apps plugin build-env 0.28.4 enabled dokku core build-env plugin buildpacks 0.28.4 enabled dokku core buildpacks plugin certs 0.28.4 enabled dokku core certificate management plugin checks 0.28.4 enabled dokku core checks plugin common 0.28.4 enabled dokku core common plugin config 0.28.4 enabled dokku core config plugin docker-options 0.28.4 enabled dokku core docker-options plugin domains 0.28.4 enabled dokku core domains plugin enter 0.28.4 enabled dokku core enter plugin git 0.28.4 enabled dokku core git plugin logs 0.28.4 enabled dokku core logs plugin network 0.28.4 enabled dokku core network plugin nginx-vhosts 0.28.4 enabled dokku core nginx-vhosts plugin plugin 0.28.4 enabled dokku core plugin plugin proxy 0.28.4 enabled dokku core proxy plugin ps 0.28.4 enabled dokku core ps plugin repo 0.28.4 enabled dokku core repo plugin resource 0.28.4 enabled dokku core resource plugin scheduler-docker-local 0.28.4 enabled dokku core scheduler-docker-local plugin shell 0.28.4 enabled dokku core shell plugin ssh-keys 0.28.4 enabled dokku core ssh-keys plugin storage 0.28.4 enabled dokku core storage plugin tags 0.28.4 enabled dokku core tags plugin tar 0.28.4 enabled dokku core tar plugin trace 0.28.4 enabled dokku core trace plugin Warning All plugin commands other than plugin:list and plugin:help require sudo access and must be run directly from the Dokku server.","title":"Listing Plugins"},{"location":"advanced-usage/plugin-management/#checking-if-a-plugin-is-installed","text":"You can check if a plugin has been installed via the plugin:installed command: dokku plugin:installed postgres","title":"Checking if a plugin is installed"},{"location":"advanced-usage/plugin-management/#installing-a-plugin","text":"Installing a plugin is easy as well using the plugin:install command. This command will also trigger the install pluginhook on all existing plugins. The most common usage is to install a plugin from a url. This url may be any of the following: git : For git+ssh based plugin repository clones. ssh : For git+ssh based plugin repository clones. file : For copying plugins from a path on disk. https : For http based plugin repository clones. Additionally, any urls with the extensions .tar.gz or .tgz are treated as Gzipped Tarballs for installation purposes and will be downloaded and extracted into place. Shell Output dokku plugin:install https://github.com/dokku/dokku-postgres.git -----> Cloning plugin repo https://github.com/dokku/dokku-postgres.git to /var/lib/dokku/plugins/available/postgres Cloning into 'postgres'... remote: Counting objects: 646, done. remote: Total 646 (delta 0), reused 0 (delta 0), pack-reused 646 Receiving objects: 100% (646/646), 134.24 KiB | 0 bytes/s, done. Resolving deltas: 100% (406/406), done. Checking connectivity... done. -----> Plugin postgres enabled For git-based plugin installation, a commit SHA-like object may be specified (tag/branch/commit sha) via the --committish argument and Dokku will attempt to install the specified commit object. # where 2.0.0 is a potential git tag dokku plugin:install https://github.com/dokku/dokku-postgres.git --committish 2 .0.0 Plugin names are interpolated based on the repository name minus the dokku- prefix. If the plugin being installed has a name other than what matches the repository name - or another name is desired - the --name flag can be used to override this interpolation. dokku plugin:install https://github.com/dokku/smoke-test-plugin.git --name smoke-test-plugin The --core flag may also be indicated as the sole argument, though it is only for installation of core plugins, and thus not useful for end-user installations. dokku plugin:install --core Finally, all flags may be omitted to trigger the install procedures for both core and third-party plugins: dokku plugin:install","title":"Installing a plugin"},{"location":"advanced-usage/plugin-management/#installing-plugin-dependencies","text":"In some cases, plugins will have system-level dependencies. These are not automatically installed via plugin:install , and must be separately via the plugin:install-dependencies command. This will run through all the dependencies trigger for all plugins. dokku plugin:install-dependencies This command may also target just core plugins via the --core flag. This is usually only useful for source-based installs of Dokku. dokku plugin:install-dependencies --core","title":"Installing plugin dependencies"},{"location":"advanced-usage/plugin-management/#updating-a-plugin","text":"An installed, third-party plugin can be updated can updated via the plugin:update command. This should be done after any upgrades of Dokku as there may be changes in the internal api that require an update of how the plugin interfaces with Dokku. Please note that this command is only valid for plugin installs that were backed by a git-repository. Shell Output dokku plugin:update postgres Plugin (postgres) updated An optional commit SHA-like object may be specified. dokku plugin:update postgres 2 .0.0","title":"Updating a plugin"},{"location":"advanced-usage/plugin-management/#uninstalling-a-plugin","text":"Third party plugins can be uninstalled using the plugin:uninstall command: Shell Output dokku plugin:uninstall postgres -----> Plugin postgres uninstalled","title":"Uninstalling a plugin"},{"location":"advanced-usage/plugin-management/#disabling-a-plugin","text":"Disabling a plugin can also be useful for debugging whether a third-party plugin is causing issues in a Dokku installation. Another common use case is for disabling core functionality for replacement with a third-party plugin. Shell Output dokku plugin:disable postgres -----> Plugin postgres disabled","title":"Disabling a plugin"},{"location":"advanced-usage/plugin-management/#enabling-a-plugin","text":"Disabled plugins can be re-enabled via the plugin:enable command. Shell Output dokku plugin:enable postgres -----> Plugin postgres enabled","title":"Enabling a plugin"},{"location":"advanced-usage/plugin-management/#triggering-a-plugin-trigger","text":"The plugin:trigger can be used to call any internal plugin trigger. This may have unintended consequences, and thus should only be called for development or debugging purposes. dokku plugin:trigger some-internal-trigger args-go-here","title":"Triggering a plugin trigger"},{"location":"advanced-usage/registry-management/","text":"Registry Management New Introduced in 0.25.0 registry:login [--password-stdin] <server> <username> [<password>] # Login to a docker registry registry:report [<app>] [<flag>] # Displays a registry report for one or more apps registry:set <app> <key> (<value>) # Set or clear a registry property for an app The registry plugin enables interacting with remote registries, which is useful when either deploying images via git:from-image or when interacting with custom schedulers to deploy built image artifacts. Usage Logging into a registry The registry:login command can be used to log into a docker registry. The following are examples for logging into various common registries: # hub.docker.com dokku registry:login docker.io $USERNAME $PASSWORD # digitalocean # the username and password are both defined as the same api token dokku registry:login registry.digitalocean.com $DIGITALOCEAN_API_TOKEN $DIGITALOCEAN_API_TOKEN # github container registry # see the following link for information on retrieving a personal access token # https://docs.github.com/en/packages/guides/pushing-and-pulling-docker-images#authenticating-to-github-container-registry dokku registry:login ghcr.io $USERNAME $REGISTRY_PAT_TOKEN # quay # a robot user may be used to login dokku registry:login quay.io $USERNAME $PASSWORD For security reasons, the password may also be specified as stdin by specifying the --password-stdin flag. This is supported regardless of the registry being logged into. echo \" $PASSWORD \" | dokku registry:login --password-stdin docker.io $USERNAME For certain Docker registries - such as Amazon ECR or Google's GCR registries - users may instead wish to use a docker credential helper to automatically authenticate against a server; please see the documentation regarding the credential helper in question for further setup instructions. Setting a remote server To specify a remote server registry for pushes, set the server property via the registry:set command. The default value for this property is empty string. Setting the value to docker.io or hub.docker.com will result in the computed value being empty string (as that is the default, implicit registry), while any non-zero length value will have a / appended to it if there is not one already. dokku registry:set node-js-app server docker.io This property can be set for a single app or globally via the --global flag. When set globally, the app-specific value will always overide the global value. The default global value for this property is empty string. dokku registry:set --global server docker.io Setting the property value to an empty string will reset the value to the system default. Resetting the value can be done per app or globally. # per-app dokku registry:set node-js-app server # globally dokku registry:set --global server The following are the values that should be used for common remote servers: Amazon Elastic Container Registry: value: $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/ notes: The $AWS_ACCOUNT_ID and $AWS_REGION should match the values for your account and region, respectively. Additionally, an IAM profile that allows push access to the repository specified by image-repo should be attached to your Dokku server. Azure Container Registry: value $REGISTRY_NAME.azurecr.io/ notes: The $AKS_REGISTRY_NAME should match the name of the registry created on your account. Docker Hub: value: docker.io/ notes: Requires owning the namespace used in the image-repo value. Digitalocean: value: registry.digitalocean.com/ notes: Requires setting the correct image-repo value for your registry. Github Container Registry: value: ghcr.io/ notes: Requires that the authenticated user has access to the namespace used in the image-repo value. Quay.io: value: quay.io/ Specifying an image repository name By default, Dokku uses the value dokku/$APP_NAME as the image repository that is pushed and deployed. For certain registries, the dokku namespace may not be available to your user. In these cases, the value can be set by changing the value of the image-repo property via the registry:set command. dokku registry:set node-js-app image-repo my-awesome-prefix/node-js-app Setting the property value to an empty string will reset the value to the system default. Resetting the value has to be done per-app. # per-app dokku registry:set node-js-app push-on-release Pushing images on build To push the image on release, set the push-on-release property to true via the registry:set command. The default value for this property is false . Setting the property to true will result in the image being tagged with an ID that is incremented with every release. This tag will be what is used for running app code. dokku registry:set node-js-app push-on-release true This property can be set for a single app or globally via the --global flag. When set globally, the app-specific value will always overide the global value. The default global value for this property is false . dokku registry:set --global push-on-release true Setting the property value to an empty string will reset the value to the system default. Resetting the value can be done per app or globally. # per-app dokku registry:set node-js-app push-on-release # globally dokku registry:set --global push-on-release","title":"Registry Management"},{"location":"advanced-usage/registry-management/#registry-management","text":"New Introduced in 0.25.0 registry:login [--password-stdin] <server> <username> [<password>] # Login to a docker registry registry:report [<app>] [<flag>] # Displays a registry report for one or more apps registry:set <app> <key> (<value>) # Set or clear a registry property for an app The registry plugin enables interacting with remote registries, which is useful when either deploying images via git:from-image or when interacting with custom schedulers to deploy built image artifacts.","title":"Registry Management"},{"location":"advanced-usage/registry-management/#usage","text":"","title":"Usage"},{"location":"advanced-usage/registry-management/#logging-into-a-registry","text":"The registry:login command can be used to log into a docker registry. The following are examples for logging into various common registries: # hub.docker.com dokku registry:login docker.io $USERNAME $PASSWORD # digitalocean # the username and password are both defined as the same api token dokku registry:login registry.digitalocean.com $DIGITALOCEAN_API_TOKEN $DIGITALOCEAN_API_TOKEN # github container registry # see the following link for information on retrieving a personal access token # https://docs.github.com/en/packages/guides/pushing-and-pulling-docker-images#authenticating-to-github-container-registry dokku registry:login ghcr.io $USERNAME $REGISTRY_PAT_TOKEN # quay # a robot user may be used to login dokku registry:login quay.io $USERNAME $PASSWORD For security reasons, the password may also be specified as stdin by specifying the --password-stdin flag. This is supported regardless of the registry being logged into. echo \" $PASSWORD \" | dokku registry:login --password-stdin docker.io $USERNAME For certain Docker registries - such as Amazon ECR or Google's GCR registries - users may instead wish to use a docker credential helper to automatically authenticate against a server; please see the documentation regarding the credential helper in question for further setup instructions.","title":"Logging into a registry"},{"location":"advanced-usage/registry-management/#setting-a-remote-server","text":"To specify a remote server registry for pushes, set the server property via the registry:set command. The default value for this property is empty string. Setting the value to docker.io or hub.docker.com will result in the computed value being empty string (as that is the default, implicit registry), while any non-zero length value will have a / appended to it if there is not one already. dokku registry:set node-js-app server docker.io This property can be set for a single app or globally via the --global flag. When set globally, the app-specific value will always overide the global value. The default global value for this property is empty string. dokku registry:set --global server docker.io Setting the property value to an empty string will reset the value to the system default. Resetting the value can be done per app or globally. # per-app dokku registry:set node-js-app server # globally dokku registry:set --global server The following are the values that should be used for common remote servers: Amazon Elastic Container Registry: value: $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/ notes: The $AWS_ACCOUNT_ID and $AWS_REGION should match the values for your account and region, respectively. Additionally, an IAM profile that allows push access to the repository specified by image-repo should be attached to your Dokku server. Azure Container Registry: value $REGISTRY_NAME.azurecr.io/ notes: The $AKS_REGISTRY_NAME should match the name of the registry created on your account. Docker Hub: value: docker.io/ notes: Requires owning the namespace used in the image-repo value. Digitalocean: value: registry.digitalocean.com/ notes: Requires setting the correct image-repo value for your registry. Github Container Registry: value: ghcr.io/ notes: Requires that the authenticated user has access to the namespace used in the image-repo value. Quay.io: value: quay.io/","title":"Setting a remote server"},{"location":"advanced-usage/registry-management/#specifying-an-image-repository-name","text":"By default, Dokku uses the value dokku/$APP_NAME as the image repository that is pushed and deployed. For certain registries, the dokku namespace may not be available to your user. In these cases, the value can be set by changing the value of the image-repo property via the registry:set command. dokku registry:set node-js-app image-repo my-awesome-prefix/node-js-app Setting the property value to an empty string will reset the value to the system default. Resetting the value has to be done per-app. # per-app dokku registry:set node-js-app push-on-release","title":"Specifying an image repository name"},{"location":"advanced-usage/registry-management/#pushing-images-on-build","text":"To push the image on release, set the push-on-release property to true via the registry:set command. The default value for this property is false . Setting the property to true will result in the image being tagged with an ID that is incremented with every release. This tag will be what is used for running app code. dokku registry:set node-js-app push-on-release true This property can be set for a single app or globally via the --global flag. When set globally, the app-specific value will always overide the global value. The default global value for this property is false . dokku registry:set --global push-on-release true Setting the property value to an empty string will reset the value to the system default. Resetting the value can be done per app or globally. # per-app dokku registry:set node-js-app push-on-release # globally dokku registry:set --global push-on-release","title":"Pushing images on build"},{"location":"advanced-usage/repository-management/","text":"Repository Management New Introduced in 0.6.0 repo:gc <app> # Runs 'git gc --aggressive' against the application's repo repo:purge-cache <app> # Deletes the contents of the build cache stored in the repository The repository plugin is meant to allow users to perform management commands against a repository. Usage Git Garbage Collection This will run a git gc --aggressive against the applications repo. This is performed on the Dokku host, and not within an application container. Shell Output dokku repo:gc node-js-app Counting objects: 396, done. Delta compression using up to 2 threads. Compressing objects: 100% (365/365), done. Writing objects: 100% (396/396), done. Total 396 (delta 79), reused 315 (delta 0) Clearing Application cache Building containers with buildpacks currently results in a persistent cache directory between deploys. If you need to clear this cache directory for any reason, you may do so by running the following shell command: dokku repo:purge-cache node-js-app","title":"Repository Management"},{"location":"advanced-usage/repository-management/#repository-management","text":"New Introduced in 0.6.0 repo:gc <app> # Runs 'git gc --aggressive' against the application's repo repo:purge-cache <app> # Deletes the contents of the build cache stored in the repository The repository plugin is meant to allow users to perform management commands against a repository.","title":"Repository Management"},{"location":"advanced-usage/repository-management/#usage","text":"","title":"Usage"},{"location":"advanced-usage/repository-management/#git-garbage-collection","text":"This will run a git gc --aggressive against the applications repo. This is performed on the Dokku host, and not within an application container. Shell Output dokku repo:gc node-js-app Counting objects: 396, done. Delta compression using up to 2 threads. Compressing objects: 100% (365/365), done. Writing objects: 100% (396/396), done. Total 396 (delta 79), reused 315 (delta 0)","title":"Git Garbage Collection"},{"location":"advanced-usage/repository-management/#clearing-application-cache","text":"Building containers with buildpacks currently results in a persistent cache directory between deploys. If you need to clear this cache directory for any reason, you may do so by running the following shell command: dokku repo:purge-cache node-js-app","title":"Clearing Application cache"},{"location":"advanced-usage/resource-management/","text":"Resource Management New Introduced in 0.15.0 resource:limit [--process-type <process-type>] [RESOURCE_OPTS...] <app> # Limit resources for a given app/process-type combination resource:limit-clear [--process-type <process-type>] <app> # Limit resources for a given app/process-type combination resource:report [<app>] [<flag>] # Displays a resource report for one or more apps resource:reserve [--process-type <process-type>] [RESOURCE_OPTS...] <app> # Reserve resources for a given app/process-type combination resource:reserve-clear [--process-type <process-type>] <app> # Reserve resources for a given app/process-type combination The resource plugin is meant to allow users to limit or reserve resources for a given app/process-type combination. Usage By default, Dokku allows unlimited resource access to apps deployed on a server. In some cases, it may be desirable to limit this on a per-app or per-process-type basis. The resource plugin allows management of both resource \"limits\" and resource \"reservations\", where each resource request type has specific meaning to the scheduler in use for a given app. Warning The meaning of a values and it's units are specific to the scheduler in use for a given app. If a value is incorrect for a scheduler, this may result in containers failing to start correctly. If a scheduler does not support a given resource type combination, it will be ignored. All resource commands require an app rebuild or deploy in order to take effect. Valid resource options include: --cpu --memory --memory-swap --network --network-ingress --network-egress --nvidia-gpu See the Supported Resource Management Properties section of the docker local scheduler documentation for more information on how each resource limit maps to Docker. Resource limits and reservations are applied only during the run and deploy phases of an application, and will not impact the build phase of an application. Resource Limits When specified and supported, a resource limit will ensure that your app does not go over the specified value. If this occurs, the underlying scheduler may either cap resource utilization, or it may decide to terminate and reschedule your process. Resource limits may be set via the resource:limit command: Shell Output dokku resource:limit --memory 100 node-js-app =====> Setting resource limits for node-js-app memory: 100 Multiple resources can be limited in a single call: Shell Output dokku resource:limit --cpu 100 --memory 100 node-js-app =====> Setting resource limits for node-js-app cpu: 100 memory: 100 Resources can also be limited on a per-process type basis. If specified, this will override any generic limits set for the app. Shell Output dokku resource:limit --cpu 100 --memory 100 --process-type worker node-js-app =====> Setting resource limits for node-js-app (worker) cpu: 100 memory: 100 A resource value can be individually cleared by setting the value to the special value clear . Shell Output dokku resource:limit --cpu clear node-js-app =====> Setting resource limits for node-js-app cpu: cleared Displaying Resource Limits Running the resource:limit command without any flags will display the currently configured default app limits. Shell Output dokku resource:limit node-js-app =====> resource limits node-js-app information [defaults] cpu: memory: memory-swap: 100 network: 100 network-ingress: network-egress: nvidia-gpu: This may also be combined with the --process-type flag to see app limits on a process-type level. Note that the displayed values are not merged with the defaults. Shell Output dokku resource:limit --process-type web node-js-app =====> resource limits node-js-app information (web) cpu: 100 memory: 100 memory-swap: network: network-ingress: network-egress: nvidia-gpu: Clearing Resource Limits In cases where the values are incorrect - or there is no desire to limit resources - resource limits may be cleared using the resource:limit-clear command. Shell Output dokku resource:limit-clear node-js-app -----> Clearing resource limit for node-js-app Defaults can also be cleared by leaving the app unspecified. Shell Output dokku resource:limit-clear -----> Clearing default resource limits Resource Reservations When specified and supported, a resource reservation will ensure that your server has at least the specified resources before placing a given app's process. If there a resource exhaustion, future rebuilds and deploys may fail. Resource reservations may be set via the resource:reserve command: Shell Output dokku resource:reserve --memory 100 node-js-app =====> Setting resource reservation for node-js-app memory: 100 Multiple resources can be limited in a single call: Shell Output dokku resource:reserve --cpu 100 --memory 100 node-js-app =====> Setting resource reservation for node-js-app cpu: 100 memory: 100 Resources can also be limited on a per-process type basis. If specified, this will override any generic limits set for the app. Shell Output dokku resource:reserve --cpu 100 --memory 100 --process-type worker node-js-app =====> Setting resource reservation for node-js-app (worker) cpu: 100 memory: 100 A resource value can be individually cleared by setting the value to the special value clear . Shell Output dokku resource:reserve --cpu clear node-js-app =====> Setting resource reservation for node-js-app cpu: cleared Displaying Resource Reservations Running the resource:reserve command without any flags will display the currently configured default app reservations. Shell Output dokku resource:reserve node-js-app =====> resource reservation node-js-app information [defaults] cpu: 100 memory: 100 memory-swap: network: network-ingress: network-egress: nvidia-gpu: This may also be combined with the --process-type flag to see app reservations on a process-type level. Note that the displayed values are not merged with the defaults. Shell Output dokku resource:reserve --process-type web node-js-app =====> resource reservation node-js-app information (web) cpu: 100 memory: 100 memory-swap: network: network-ingress: network-egress: nvidia-gpu: Clearing Resource Reservations In cases where the values are incorrect - or there is no desire to reserve resources - resource reservations may be cleared using the resource:reserve-clear command. Shell Output dokku resource:reserve-clear node-js-app -----> Clearing resource reservation for node-js-app Defaults can also be cleared by leaving the app unspecified. Shell Output dokku resource:reserve-clear -----> Clearing default resource reservation Displaying resource reports for an app You can get a report about the app's resource status using the resource:report command: Shell Output dokku resource:report =====> node-js-app resource information web limit cpu: web limit memory: 1024 web limit memory swap: 0 web limit network: 10 web limit network ingress: web limit network egress: web limit nvidia gpu: web reservation cpu: web reservation memory: 512 web reservation memory swap: web reservation network: 8 web reservation network ingress: web reservation network egress: web reservation nvidia gpu: =====> python-sample resource information web limit cpu: web limit memory: web limit memory swap: web limit network: web limit network ingress: web limit network egress: web limit nvidia gpu: web reservation cpu: web reservation memory: web reservation memory swap: web reservation network: web reservation network ingress: web reservation network egress: web reservation nvidia gpu: =====> ruby-sample resource information web limit cpu: web limit memory: web limit memory swap: web limit network: web limit network ingress: web limit network egress: web limit nvidia gpu: web reservation cpu: web reservation memory: web reservation memory swap: web reservation network: web reservation network ingress: web reservation network egress: web reservation nvidia gpu: You can run the command for a specific app also. Shell Output dokku resource:report node-js-app =====> node-js-app resource information web limit cpu: web limit memory: 1024 web limit memory swap: 0 web limit network: 10 web limit network ingress: web limit network egress: web limit nvidia gpu: web reservation cpu: web reservation memory: 512 web reservation memory swap: web reservation network: 8 web reservation network ingress: web reservation network egress: web reservation nvidia gpu: You can pass flags which will output only the value of the specific information you want. For example: Shell Output # Note the periods in the flag name dokku resource:report node-js-app --resource-web.limit.memory 1024","title":"Resource Management"},{"location":"advanced-usage/resource-management/#resource-management","text":"New Introduced in 0.15.0 resource:limit [--process-type <process-type>] [RESOURCE_OPTS...] <app> # Limit resources for a given app/process-type combination resource:limit-clear [--process-type <process-type>] <app> # Limit resources for a given app/process-type combination resource:report [<app>] [<flag>] # Displays a resource report for one or more apps resource:reserve [--process-type <process-type>] [RESOURCE_OPTS...] <app> # Reserve resources for a given app/process-type combination resource:reserve-clear [--process-type <process-type>] <app> # Reserve resources for a given app/process-type combination The resource plugin is meant to allow users to limit or reserve resources for a given app/process-type combination.","title":"Resource Management"},{"location":"advanced-usage/resource-management/#usage","text":"By default, Dokku allows unlimited resource access to apps deployed on a server. In some cases, it may be desirable to limit this on a per-app or per-process-type basis. The resource plugin allows management of both resource \"limits\" and resource \"reservations\", where each resource request type has specific meaning to the scheduler in use for a given app. Warning The meaning of a values and it's units are specific to the scheduler in use for a given app. If a value is incorrect for a scheduler, this may result in containers failing to start correctly. If a scheduler does not support a given resource type combination, it will be ignored. All resource commands require an app rebuild or deploy in order to take effect. Valid resource options include: --cpu --memory --memory-swap --network --network-ingress --network-egress --nvidia-gpu See the Supported Resource Management Properties section of the docker local scheduler documentation for more information on how each resource limit maps to Docker. Resource limits and reservations are applied only during the run and deploy phases of an application, and will not impact the build phase of an application.","title":"Usage"},{"location":"advanced-usage/resource-management/#resource-limits","text":"When specified and supported, a resource limit will ensure that your app does not go over the specified value. If this occurs, the underlying scheduler may either cap resource utilization, or it may decide to terminate and reschedule your process. Resource limits may be set via the resource:limit command: Shell Output dokku resource:limit --memory 100 node-js-app =====> Setting resource limits for node-js-app memory: 100 Multiple resources can be limited in a single call: Shell Output dokku resource:limit --cpu 100 --memory 100 node-js-app =====> Setting resource limits for node-js-app cpu: 100 memory: 100 Resources can also be limited on a per-process type basis. If specified, this will override any generic limits set for the app. Shell Output dokku resource:limit --cpu 100 --memory 100 --process-type worker node-js-app =====> Setting resource limits for node-js-app (worker) cpu: 100 memory: 100 A resource value can be individually cleared by setting the value to the special value clear . Shell Output dokku resource:limit --cpu clear node-js-app =====> Setting resource limits for node-js-app cpu: cleared","title":"Resource Limits"},{"location":"advanced-usage/resource-management/#displaying-resource-limits","text":"Running the resource:limit command without any flags will display the currently configured default app limits. Shell Output dokku resource:limit node-js-app =====> resource limits node-js-app information [defaults] cpu: memory: memory-swap: 100 network: 100 network-ingress: network-egress: nvidia-gpu: This may also be combined with the --process-type flag to see app limits on a process-type level. Note that the displayed values are not merged with the defaults. Shell Output dokku resource:limit --process-type web node-js-app =====> resource limits node-js-app information (web) cpu: 100 memory: 100 memory-swap: network: network-ingress: network-egress: nvidia-gpu:","title":"Displaying Resource Limits"},{"location":"advanced-usage/resource-management/#clearing-resource-limits","text":"In cases where the values are incorrect - or there is no desire to limit resources - resource limits may be cleared using the resource:limit-clear command. Shell Output dokku resource:limit-clear node-js-app -----> Clearing resource limit for node-js-app Defaults can also be cleared by leaving the app unspecified. Shell Output dokku resource:limit-clear -----> Clearing default resource limits","title":"Clearing Resource Limits"},{"location":"advanced-usage/resource-management/#resource-reservations","text":"When specified and supported, a resource reservation will ensure that your server has at least the specified resources before placing a given app's process. If there a resource exhaustion, future rebuilds and deploys may fail. Resource reservations may be set via the resource:reserve command: Shell Output dokku resource:reserve --memory 100 node-js-app =====> Setting resource reservation for node-js-app memory: 100 Multiple resources can be limited in a single call: Shell Output dokku resource:reserve --cpu 100 --memory 100 node-js-app =====> Setting resource reservation for node-js-app cpu: 100 memory: 100 Resources can also be limited on a per-process type basis. If specified, this will override any generic limits set for the app. Shell Output dokku resource:reserve --cpu 100 --memory 100 --process-type worker node-js-app =====> Setting resource reservation for node-js-app (worker) cpu: 100 memory: 100 A resource value can be individually cleared by setting the value to the special value clear . Shell Output dokku resource:reserve --cpu clear node-js-app =====> Setting resource reservation for node-js-app cpu: cleared","title":"Resource Reservations"},{"location":"advanced-usage/resource-management/#displaying-resource-reservations","text":"Running the resource:reserve command without any flags will display the currently configured default app reservations. Shell Output dokku resource:reserve node-js-app =====> resource reservation node-js-app information [defaults] cpu: 100 memory: 100 memory-swap: network: network-ingress: network-egress: nvidia-gpu: This may also be combined with the --process-type flag to see app reservations on a process-type level. Note that the displayed values are not merged with the defaults. Shell Output dokku resource:reserve --process-type web node-js-app =====> resource reservation node-js-app information (web) cpu: 100 memory: 100 memory-swap: network: network-ingress: network-egress: nvidia-gpu:","title":"Displaying Resource Reservations"},{"location":"advanced-usage/resource-management/#clearing-resource-reservations","text":"In cases where the values are incorrect - or there is no desire to reserve resources - resource reservations may be cleared using the resource:reserve-clear command. Shell Output dokku resource:reserve-clear node-js-app -----> Clearing resource reservation for node-js-app Defaults can also be cleared by leaving the app unspecified. Shell Output dokku resource:reserve-clear -----> Clearing default resource reservation","title":"Clearing Resource Reservations"},{"location":"advanced-usage/resource-management/#displaying-resource-reports-for-an-app","text":"You can get a report about the app's resource status using the resource:report command: Shell Output dokku resource:report =====> node-js-app resource information web limit cpu: web limit memory: 1024 web limit memory swap: 0 web limit network: 10 web limit network ingress: web limit network egress: web limit nvidia gpu: web reservation cpu: web reservation memory: 512 web reservation memory swap: web reservation network: 8 web reservation network ingress: web reservation network egress: web reservation nvidia gpu: =====> python-sample resource information web limit cpu: web limit memory: web limit memory swap: web limit network: web limit network ingress: web limit network egress: web limit nvidia gpu: web reservation cpu: web reservation memory: web reservation memory swap: web reservation network: web reservation network ingress: web reservation network egress: web reservation nvidia gpu: =====> ruby-sample resource information web limit cpu: web limit memory: web limit memory swap: web limit network: web limit network ingress: web limit network egress: web limit nvidia gpu: web reservation cpu: web reservation memory: web reservation memory swap: web reservation network: web reservation network ingress: web reservation network egress: web reservation nvidia gpu: You can run the command for a specific app also. Shell Output dokku resource:report node-js-app =====> node-js-app resource information web limit cpu: web limit memory: 1024 web limit memory swap: 0 web limit network: 10 web limit network ingress: web limit network egress: web limit nvidia gpu: web reservation cpu: web reservation memory: 512 web reservation memory swap: web reservation network: 8 web reservation network ingress: web reservation network egress: web reservation nvidia gpu: You can pass flags which will output only the value of the specific information you want. For example: Shell Output # Note the periods in the flag name dokku resource:report node-js-app --resource-web.limit.memory 1024","title":"Displaying resource reports for an app"},{"location":"appendices/0.10.0-migration-guide/","text":"0.10.0 Migration Guide PCI Compliance By default, Dokku will ship a PCI Compliant nginx configuration. For developers whose users are on older browsers or mobile devices, you may need to ship a custom nginx.conf.sigil to enable ciphers for older browsers. See the nginx customization docs for more details. Nginx Error Pages We now ship with nicer error pages by default. You are free to customize your Dokku installation via a custom nginx.conf.sigil to change what error pages are displayed in different circumstances. See the nginx customization docs for more details.","title":"0.10.0 Migration Guide"},{"location":"appendices/0.10.0-migration-guide/#0100-migration-guide","text":"","title":"0.10.0 Migration Guide"},{"location":"appendices/0.10.0-migration-guide/#pci-compliance","text":"By default, Dokku will ship a PCI Compliant nginx configuration. For developers whose users are on older browsers or mobile devices, you may need to ship a custom nginx.conf.sigil to enable ciphers for older browsers. See the nginx customization docs for more details.","title":"PCI Compliance"},{"location":"appendices/0.10.0-migration-guide/#nginx-error-pages","text":"We now ship with nicer error pages by default. You are free to customize your Dokku installation via a custom nginx.conf.sigil to change what error pages are displayed in different circumstances. See the nginx customization docs for more details.","title":"Nginx Error Pages"},{"location":"appendices/0.20.0-migration-guide/","text":"0.20.0 Migration Guide Removals Command removals The following commands were previously deprecated and were removed in this release. apps : Use apps:list instead. certs : Use certs:report instead. certs:info : Use certs:report instead. checks : Use checks:report instead. docker-options : Use docker-options:report instead. domains : Use domains:report instead. plugin : Use plugin:list instead. proxy : Use proxy:report instead. trace : Use trace:on or trace:off instead. ps : Use enter with a container ID instead to run ps auxww within a container. The refactor of the proxy plugin removes the following functions from being sourced in plugins: proxy#get_app_proxy_port_map() proxy#list_app_proxy_ports() proxy#filter_app_proxy_ports() proxy#add_proxy_ports() proxy#remove_proxy_ports() proxy#set_proxy_ports() The informal policy is to allow removal of functions within a functions file if they are not used in OSS plugins. Should you be affected by any such removals, please file an issue to expose the functionality via a plugin trigger. Function renames tar#tar_in_cmd was renamed to tar#cmd-tar-in . Users should avoid using cmd-* commands directly, and instead file an issue to have them exposed via a plugin trigger. tar#tar_from_cmd was renamed to tar#cmd-tar-from . Users should avoid using cmd-* commands directly, and instead file an issue to have them exposed via a plugin trigger. Remove support for Unsupported Operating Systems Dokku will no longer distribute packages for Ubuntu versions that have reached either End of Life or End of Standard Support (for LTS releases). This currently includes the following releases: Ubuntu 14.04 (trusty) Ubuntu 14.10 (utopic) Ubuntu 15.04 (vivid) Ubuntu 15.10 (wily) Ubuntu 16.10 (yakkety) Ubuntu 17.04 (zesty) Ubuntu 17.10 (artful) Dokku will no longer distribute packages for Debian versions that are not stable or oldstable . This currently includes the following releases: Debian 7 (wheezy) Debian 8 (jessie) Removed App report flags The --git-sha flag was moved from the apps:report command to the git:report command. App report output When an app is not deployed, the apps:report command no longer shows the message not deployed . Please use the --deployed flag on ps:report instead to see if the app has been deployed. Changes App report flags The following changes on the apps:report command were made in this release: The --deploy-source flag was renamed to --app-deploy-source . The --locked flag was renamed to --app-locked . Network report flags The following changes on the network:report command were made in this release: The --network-listeners flag was renamed to --network-web-listeners . Plugin Triggers The network-get-port trigger was incorrectly documented to have the isHerokuishContainer argument as the third argument. The code has been fixed to respect the documentation. The network-get-listeners trigger now takes an additional processType argument. If not specified, it defaults to web . This default will be removed in an upcoming release. Deprecations nginx:show-conf has been deprecated in favor of nginx:show-config . proxy#is_app_proxy_enabled() is deprecated in favor of plugn trigger proxy-is-enabled . proxy#get_app_proxy_type() is deprecated in favor of plugn trigger proxy-type . apps#apps_create() is deprecated in favor of plugn trigger app-create . apps#apps_destroy() is deprecated in favor of plugn trigger app-destroy . apps#apps_exists() is deprecated in favor of plugn trigger app-exists . apps#apps_maybe_create() is deprecated in favor of plugn trigger app-maybe-create . plugin trigger network-get-listeners usage without a second processType argument is deprecated. .NGINX_PORT variable usage within nginx.conf.sigil templates is deprecated in favor of .PROXY_PORT . .NGINX_SSL_PORT variable usage within nginx.conf.sigil templates is deprecated in favor of .PROXY_SSL_PORT . .DOKKU_APP_LISTENERS variable usage within nginx.conf.sigil templates is deprecated in favor of .DOKKU_APP_WEB_LISTENERS .","title":"0.20.0 Migration Guide"},{"location":"appendices/0.20.0-migration-guide/#0200-migration-guide","text":"","title":"0.20.0 Migration Guide"},{"location":"appendices/0.20.0-migration-guide/#removals","text":"","title":"Removals"},{"location":"appendices/0.20.0-migration-guide/#command-removals","text":"The following commands were previously deprecated and were removed in this release. apps : Use apps:list instead. certs : Use certs:report instead. certs:info : Use certs:report instead. checks : Use checks:report instead. docker-options : Use docker-options:report instead. domains : Use domains:report instead. plugin : Use plugin:list instead. proxy : Use proxy:report instead. trace : Use trace:on or trace:off instead. ps : Use enter with a container ID instead to run ps auxww within a container. The refactor of the proxy plugin removes the following functions from being sourced in plugins: proxy#get_app_proxy_port_map() proxy#list_app_proxy_ports() proxy#filter_app_proxy_ports() proxy#add_proxy_ports() proxy#remove_proxy_ports() proxy#set_proxy_ports() The informal policy is to allow removal of functions within a functions file if they are not used in OSS plugins. Should you be affected by any such removals, please file an issue to expose the functionality via a plugin trigger.","title":"Command removals"},{"location":"appendices/0.20.0-migration-guide/#function-renames","text":"tar#tar_in_cmd was renamed to tar#cmd-tar-in . Users should avoid using cmd-* commands directly, and instead file an issue to have them exposed via a plugin trigger. tar#tar_from_cmd was renamed to tar#cmd-tar-from . Users should avoid using cmd-* commands directly, and instead file an issue to have them exposed via a plugin trigger.","title":"Function renames"},{"location":"appendices/0.20.0-migration-guide/#remove-support-for-unsupported-operating-systems","text":"Dokku will no longer distribute packages for Ubuntu versions that have reached either End of Life or End of Standard Support (for LTS releases). This currently includes the following releases: Ubuntu 14.04 (trusty) Ubuntu 14.10 (utopic) Ubuntu 15.04 (vivid) Ubuntu 15.10 (wily) Ubuntu 16.10 (yakkety) Ubuntu 17.04 (zesty) Ubuntu 17.10 (artful) Dokku will no longer distribute packages for Debian versions that are not stable or oldstable . This currently includes the following releases: Debian 7 (wheezy) Debian 8 (jessie)","title":"Remove support for Unsupported Operating Systems"},{"location":"appendices/0.20.0-migration-guide/#removed-app-report-flags","text":"The --git-sha flag was moved from the apps:report command to the git:report command.","title":"Removed App report flags"},{"location":"appendices/0.20.0-migration-guide/#app-report-output","text":"When an app is not deployed, the apps:report command no longer shows the message not deployed . Please use the --deployed flag on ps:report instead to see if the app has been deployed.","title":"App report output"},{"location":"appendices/0.20.0-migration-guide/#changes","text":"","title":"Changes"},{"location":"appendices/0.20.0-migration-guide/#app-report-flags","text":"The following changes on the apps:report command were made in this release: The --deploy-source flag was renamed to --app-deploy-source . The --locked flag was renamed to --app-locked .","title":"App report flags"},{"location":"appendices/0.20.0-migration-guide/#network-report-flags","text":"The following changes on the network:report command were made in this release: The --network-listeners flag was renamed to --network-web-listeners .","title":"Network report flags"},{"location":"appendices/0.20.0-migration-guide/#plugin-triggers","text":"The network-get-port trigger was incorrectly documented to have the isHerokuishContainer argument as the third argument. The code has been fixed to respect the documentation. The network-get-listeners trigger now takes an additional processType argument. If not specified, it defaults to web . This default will be removed in an upcoming release.","title":"Plugin Triggers"},{"location":"appendices/0.20.0-migration-guide/#deprecations","text":"nginx:show-conf has been deprecated in favor of nginx:show-config . proxy#is_app_proxy_enabled() is deprecated in favor of plugn trigger proxy-is-enabled . proxy#get_app_proxy_type() is deprecated in favor of plugn trigger proxy-type . apps#apps_create() is deprecated in favor of plugn trigger app-create . apps#apps_destroy() is deprecated in favor of plugn trigger app-destroy . apps#apps_exists() is deprecated in favor of plugn trigger app-exists . apps#apps_maybe_create() is deprecated in favor of plugn trigger app-maybe-create . plugin trigger network-get-listeners usage without a second processType argument is deprecated. .NGINX_PORT variable usage within nginx.conf.sigil templates is deprecated in favor of .PROXY_PORT . .NGINX_SSL_PORT variable usage within nginx.conf.sigil templates is deprecated in favor of .PROXY_SSL_PORT . .DOKKU_APP_LISTENERS variable usage within nginx.conf.sigil templates is deprecated in favor of .DOKKU_APP_WEB_LISTENERS .","title":"Deprecations"},{"location":"appendices/0.21.0-migration-guide/","text":"0.21.0 Migration Guide Changes The tls name is no longer a reserved app name, and can be used by applications. This was previously a reserved app name due to it's use as a place for global SSL certificate files; Dokku has not supported global SSL certificates for many releases, and thus there is no need to reserve the name. Deprecations git#git_deploy_branch() is deprecated in favor of plugn trigger git-deploy-branch . The config command is deprecated in favor of config:show . Usage of this command in conjunction with either the --export or --shell flag is deprecated in favor of config:export --format with the correct format value ( exports or shell , respectively). The nginx:build-config command is deprecated in favor of proxy:build-config . Removals The apps:destroy command no longer takes a second argument force . Instead, this can be passed as the --force flag, either globally or as a flag to the command itself. The proxy:enable and proxy:disable no longer restart apps when setting the DOKKU_DISABLE_PROXY environment variable. A future release will disable usage of DOKKU_DISABLE_PROXY altogether.","title":"0.21.0 Migration Guide"},{"location":"appendices/0.21.0-migration-guide/#0210-migration-guide","text":"","title":"0.21.0 Migration Guide"},{"location":"appendices/0.21.0-migration-guide/#changes","text":"The tls name is no longer a reserved app name, and can be used by applications. This was previously a reserved app name due to it's use as a place for global SSL certificate files; Dokku has not supported global SSL certificates for many releases, and thus there is no need to reserve the name.","title":"Changes"},{"location":"appendices/0.21.0-migration-guide/#deprecations","text":"git#git_deploy_branch() is deprecated in favor of plugn trigger git-deploy-branch . The config command is deprecated in favor of config:show . Usage of this command in conjunction with either the --export or --shell flag is deprecated in favor of config:export --format with the correct format value ( exports or shell , respectively). The nginx:build-config command is deprecated in favor of proxy:build-config .","title":"Deprecations"},{"location":"appendices/0.21.0-migration-guide/#removals","text":"The apps:destroy command no longer takes a second argument force . Instead, this can be passed as the --force flag, either globally or as a flag to the command itself. The proxy:enable and proxy:disable no longer restart apps when setting the DOKKU_DISABLE_PROXY environment variable. A future release will disable usage of DOKKU_DISABLE_PROXY altogether.","title":"Removals"},{"location":"appendices/0.22.0-migration-guide/","text":"0.22.0 Migration Guide Deprecations Calling logs:failed without either a <name> or the --all flag is deprecated. Changes Underscores are no longer valid characters in app names. Please rename applications before upgrading. Process type names specified in Procfile may no longer use characters not valid in DNS Label Names ( RFC 1123 ). The minimum Docker version is now 17.05.0. The common.GetDeployingAppImageName() function now returns an error as the second return argument instead of calling common.LogFail() internally. Setting DOKKU_DISABLE_ANSI_PREFIX_REMOVAL is deprecated; Dokku 0.23.0 will avoid removing the remote: ansi prefix entirely. No warning will be added in this release. Removals The ps command has had a few removals as a result of a rewrite to Golang: The ps:set-restart-policy command has been removed in favor the ps:set command. The ps:restart-policy command has been removed in favor of the ps:report command. The ps:rebuildall command has been removed in favor of calling the ps:rebuild with the --all flag instead of an app name. The ps:restartall command has been removed in favor of calling the ps:restart with the --all flag instead of an app name. The ps:stopall command has been removed in favor of calling the ps:stop with the --all flag instead of an app name. The ps:startall command has been removed in favor of calling the ps:start with the --all flag instead of an app name. The DOKKU_PROCFILE file is no longer located in the git directory for a given app on the server. It's location is currently not exposed. The procfile-get-command plugin trigger no longer takes a procfile path as the final argument. All ps functions have been removed. Please us a trigger as appropriate or file a PR to have a new trigger/wrapper function added.","title":"0.22.0 Migration Guide"},{"location":"appendices/0.22.0-migration-guide/#0220-migration-guide","text":"","title":"0.22.0 Migration Guide"},{"location":"appendices/0.22.0-migration-guide/#deprecations","text":"Calling logs:failed without either a <name> or the --all flag is deprecated.","title":"Deprecations"},{"location":"appendices/0.22.0-migration-guide/#changes","text":"Underscores are no longer valid characters in app names. Please rename applications before upgrading. Process type names specified in Procfile may no longer use characters not valid in DNS Label Names ( RFC 1123 ). The minimum Docker version is now 17.05.0. The common.GetDeployingAppImageName() function now returns an error as the second return argument instead of calling common.LogFail() internally. Setting DOKKU_DISABLE_ANSI_PREFIX_REMOVAL is deprecated; Dokku 0.23.0 will avoid removing the remote: ansi prefix entirely. No warning will be added in this release.","title":"Changes"},{"location":"appendices/0.22.0-migration-guide/#removals","text":"The ps command has had a few removals as a result of a rewrite to Golang: The ps:set-restart-policy command has been removed in favor the ps:set command. The ps:restart-policy command has been removed in favor of the ps:report command. The ps:rebuildall command has been removed in favor of calling the ps:rebuild with the --all flag instead of an app name. The ps:restartall command has been removed in favor of calling the ps:restart with the --all flag instead of an app name. The ps:stopall command has been removed in favor of calling the ps:stop with the --all flag instead of an app name. The ps:startall command has been removed in favor of calling the ps:start with the --all flag instead of an app name. The DOKKU_PROCFILE file is no longer located in the git directory for a given app on the server. It's location is currently not exposed. The procfile-get-command plugin trigger no longer takes a procfile path as the final argument. All ps functions have been removed. Please us a trigger as appropriate or file a PR to have a new trigger/wrapper function added.","title":"Removals"},{"location":"appendices/0.23.0-migration-guide/","text":"0.23.0 Migration Guide Changes The plugin:list command no longer outputs the version for the plugn binary. Users building docker images that run Dokku will need to use a new sudoer wrapper for the docker-image-labeler binary to work correctly. A reference version has been placed in the docker skeleton directory. This should only impact platform developers, and users of our Docker image will already have the file available. The dokku user's cron is now in use by Dokku itself. Customizations will be overwritten. Users are encouraged to use a cron entry in /etc/cron.d/dokku to avoid this issue. As of 0.23.0, Dokku will now inject the max-size log driver option for applications. This is restricted to app-configured log driver values empty, local or json-file in 0.23.1 to increase setup compatibility. Users who configure alternative log drivers at the system level will need to either set the global max-size property to unlimited or switch to the built-in vector logging support.","title":"0.23.0 Migration Guide"},{"location":"appendices/0.23.0-migration-guide/#0230-migration-guide","text":"","title":"0.23.0 Migration Guide"},{"location":"appendices/0.23.0-migration-guide/#changes","text":"The plugin:list command no longer outputs the version for the plugn binary. Users building docker images that run Dokku will need to use a new sudoer wrapper for the docker-image-labeler binary to work correctly. A reference version has been placed in the docker skeleton directory. This should only impact platform developers, and users of our Docker image will already have the file available. The dokku user's cron is now in use by Dokku itself. Customizations will be overwritten. Users are encouraged to use a cron entry in /etc/cron.d/dokku to avoid this issue. As of 0.23.0, Dokku will now inject the max-size log driver option for applications. This is restricted to app-configured log driver values empty, local or json-file in 0.23.1 to increase setup compatibility. Users who configure alternative log drivers at the system level will need to either set the global max-size property to unlimited or switch to the built-in vector logging support.","title":"Changes"},{"location":"appendices/0.24.0-migration-guide/","text":"0.24.0 Migration Guide Changes The commands proxy:enable , proxy:disable and proxy:build-config now support the --all flag in addition to general parallelism. The builder-cnb plugin has been renamed builder-pack , and all related plugin triggers have had the suffix -cnb changed to -pack . Deprecations The 1.0.0 release of Dokku will no longer select buildpack builders over dockerfile builders if both builders match. Instead, Dokku will choose the first builder that responds to the builder-detect trigger. Users that wish to use a specific builder may set a builder using the builder:set command, which will force Dokku to use the specified builder regardless of what might be auto-detected. The tags plugin is deprecated in favor of the git:from-image command. It will be removed in the next minor release, and is considered unmaintained. Users are highly encouraged to switch their workflows to git:from-image . The tar plugin is deprecated in favor of the git:from-archive command. It will be removed in the next minor release, and is considered unmaintained. Users are highly encouraged to switch their workflows to git:from-archive .","title":"0.24.0 Migration Guide"},{"location":"appendices/0.24.0-migration-guide/#0240-migration-guide","text":"","title":"0.24.0 Migration Guide"},{"location":"appendices/0.24.0-migration-guide/#changes","text":"The commands proxy:enable , proxy:disable and proxy:build-config now support the --all flag in addition to general parallelism. The builder-cnb plugin has been renamed builder-pack , and all related plugin triggers have had the suffix -cnb changed to -pack .","title":"Changes"},{"location":"appendices/0.24.0-migration-guide/#deprecations","text":"The 1.0.0 release of Dokku will no longer select buildpack builders over dockerfile builders if both builders match. Instead, Dokku will choose the first builder that responds to the builder-detect trigger. Users that wish to use a specific builder may set a builder using the builder:set command, which will force Dokku to use the specified builder regardless of what might be auto-detected. The tags plugin is deprecated in favor of the git:from-image command. It will be removed in the next minor release, and is considered unmaintained. Users are highly encouraged to switch their workflows to git:from-image . The tar plugin is deprecated in favor of the git:from-archive command. It will be removed in the next minor release, and is considered unmaintained. Users are highly encouraged to switch their workflows to git:from-archive .","title":"Deprecations"},{"location":"appendices/0.25.0-migration-guide/","text":"0.25.0 Migration Guide Registry Plugin The dokku-registry plugin is now built-in. This comes with a few changes: Builder plugins should call post-release-builder at the end of the build. The push and pull command are not implemented. Users wishing to deploy a remote image should use git:from-image . Image pushing is not available at this time. At this time, remote docker repositories are not automatically created for AWS, and users must create those repositories for their applications as necessary. This may be implemented in the future. Docker images are only pushed when configured to do so. See the registry management documentation for more details. Before upgrading, uninstall the registry plugin via dokku plugin:uninstall registry . Not doing so will cause issues with Dokku. Other Changes The network plugin can now set an initial-network for all containers on creation. This is a replacement for specifying the --network flag via the docker-options plugin. Please see the network documentation for more information. The dokku run command now always removes the ephemeral container on exit. Users that need a persistent container should instead specify a console process type in their Procfile specifying an available shell (usually either bash or sh ) and scale that container appropriately. The pre-deploy plugin trigger is now called internally by Dokku. Scheduler plugins should avoid calling this trigger, as any image changes introduced by subsequent trigger calls will be ignored. The default image used for Herokuish Buildpack builds is now gliderlabs/herokuish:latest-20 , and is based on both the heroku-20 stack as well as Ubuntu 20.04. Users that wish to stick with the old, heroku-18 /Ubuntu 18.04 builder may specify gliderlabs/herokuish:latest-18 as their builder image. Please see the herokuish buildpack deployment documentation for more information on how to specify a custom buildpack stack builder. This change does not impact any users of Cloud Native Buildpacks. We fixed an issue that required extracting Procfiles at the beginning of a deploy. Due to this change, a Dockerfile app contains a Procfile that does not specify a web process will fail to start. Usage of a Procfile with only a release command should be replaced with a scripts.dokku.postdeploy deployment task in the app.json file. The alternative is to define the web process in the Procfile . See the deployment task documentation for more information. Deprecations In previous versions of Dokku, the only way to specify a custom Dockerfile was to use the docker-options plugin to set the --file flag for a docker build. As of 0.25.0, the builder-dockerfile:set command should be used instead, as outlined in the docs here . Usage of the old method should be migrated to the new method. The --rm and --rm-container flags may be specified but no longer have any effect on dokku run . The --detach flag is deprecated in favor of the run:detached command. The DOKKU_SCALE file is deprecated. Please see the process management documentation for more information on it's replacement with the formation key of the app.json file. The hooks post-release-buildpack , post-release-dockerfile , and post-release-pack are deprecated in favor of post-release-builder . See the plugin triggers documentation for more details. Removals As of April 2021, Ubuntu 16.04 is no longer an LTS release, and support has been removed. Packages may still install on older versions of Ubuntu, but are no longer tested, and therefore no support will be provided. The web installer has been removed. Users are now required to setup Dokku via cli commands. This change was made to combat potential security issues where users ignored the web installer, allowing unauthorized users to add their keys to the host. The scheduler-docker-cleanup plugin trigger has been removed from the scheduler interface, and is no longer invoked.","title":"0.25.0 Migration Guide"},{"location":"appendices/0.25.0-migration-guide/#0250-migration-guide","text":"","title":"0.25.0 Migration Guide"},{"location":"appendices/0.25.0-migration-guide/#registry-plugin","text":"The dokku-registry plugin is now built-in. This comes with a few changes: Builder plugins should call post-release-builder at the end of the build. The push and pull command are not implemented. Users wishing to deploy a remote image should use git:from-image . Image pushing is not available at this time. At this time, remote docker repositories are not automatically created for AWS, and users must create those repositories for their applications as necessary. This may be implemented in the future. Docker images are only pushed when configured to do so. See the registry management documentation for more details. Before upgrading, uninstall the registry plugin via dokku plugin:uninstall registry . Not doing so will cause issues with Dokku.","title":"Registry Plugin"},{"location":"appendices/0.25.0-migration-guide/#other","text":"","title":"Other"},{"location":"appendices/0.25.0-migration-guide/#changes","text":"The network plugin can now set an initial-network for all containers on creation. This is a replacement for specifying the --network flag via the docker-options plugin. Please see the network documentation for more information. The dokku run command now always removes the ephemeral container on exit. Users that need a persistent container should instead specify a console process type in their Procfile specifying an available shell (usually either bash or sh ) and scale that container appropriately. The pre-deploy plugin trigger is now called internally by Dokku. Scheduler plugins should avoid calling this trigger, as any image changes introduced by subsequent trigger calls will be ignored. The default image used for Herokuish Buildpack builds is now gliderlabs/herokuish:latest-20 , and is based on both the heroku-20 stack as well as Ubuntu 20.04. Users that wish to stick with the old, heroku-18 /Ubuntu 18.04 builder may specify gliderlabs/herokuish:latest-18 as their builder image. Please see the herokuish buildpack deployment documentation for more information on how to specify a custom buildpack stack builder. This change does not impact any users of Cloud Native Buildpacks. We fixed an issue that required extracting Procfiles at the beginning of a deploy. Due to this change, a Dockerfile app contains a Procfile that does not specify a web process will fail to start. Usage of a Procfile with only a release command should be replaced with a scripts.dokku.postdeploy deployment task in the app.json file. The alternative is to define the web process in the Procfile . See the deployment task documentation for more information.","title":"Changes"},{"location":"appendices/0.25.0-migration-guide/#deprecations","text":"In previous versions of Dokku, the only way to specify a custom Dockerfile was to use the docker-options plugin to set the --file flag for a docker build. As of 0.25.0, the builder-dockerfile:set command should be used instead, as outlined in the docs here . Usage of the old method should be migrated to the new method. The --rm and --rm-container flags may be specified but no longer have any effect on dokku run . The --detach flag is deprecated in favor of the run:detached command. The DOKKU_SCALE file is deprecated. Please see the process management documentation for more information on it's replacement with the formation key of the app.json file. The hooks post-release-buildpack , post-release-dockerfile , and post-release-pack are deprecated in favor of post-release-builder . See the plugin triggers documentation for more details.","title":"Deprecations"},{"location":"appendices/0.25.0-migration-guide/#removals","text":"As of April 2021, Ubuntu 16.04 is no longer an LTS release, and support has been removed. Packages may still install on older versions of Ubuntu, but are no longer tested, and therefore no support will be provided. The web installer has been removed. Users are now required to setup Dokku via cli commands. This change was made to combat potential security issues where users ignored the web installer, allowing unauthorized users to add their keys to the host. The scheduler-docker-cleanup plugin trigger has been removed from the scheduler interface, and is no longer invoked.","title":"Removals"},{"location":"appendices/0.26.0-migration-guide/","text":"0.26.0 Migration Guide Removals The tags plugin - deprecated in 0.24.0 - was removed. Users are highly encouraged to switch their workflows to git:from-image . The tar plugin - deprecated in 0.24.0 - was removed. Users are highly encouraged to switch their workflows to git:from-archive . Changes The scheduler plugin now controls the scheduler in use for deploys. Apps will have their DOKKU_SCHEDULER environment variables migrated to the scheduler plugin, after which that value will be removed from said app. Please see the scheduler documentation for more information. The deploy-source metadata from apps:report is now no longer computed on the fly, but hydrated at deploy time via the deploy-source-set trigger. This value may be empty until your next deploy. Additionally, the deploy-source trigger has now been removed.","title":"0.26.0 Migration Guide"},{"location":"appendices/0.26.0-migration-guide/#0260-migration-guide","text":"","title":"0.26.0 Migration Guide"},{"location":"appendices/0.26.0-migration-guide/#removals","text":"The tags plugin - deprecated in 0.24.0 - was removed. Users are highly encouraged to switch their workflows to git:from-image . The tar plugin - deprecated in 0.24.0 - was removed. Users are highly encouraged to switch their workflows to git:from-archive .","title":"Removals"},{"location":"appendices/0.26.0-migration-guide/#changes","text":"The scheduler plugin now controls the scheduler in use for deploys. Apps will have their DOKKU_SCHEDULER environment variables migrated to the scheduler plugin, after which that value will be removed from said app. Please see the scheduler documentation for more information. The deploy-source metadata from apps:report is now no longer computed on the fly, but hydrated at deploy time via the deploy-source-set trigger. This value may be empty until your next deploy. Additionally, the deploy-source trigger has now been removed.","title":"Changes"},{"location":"appendices/0.27.0-migration-guide/","text":"0.27.0 Migration Guide Changes Renaming an application will now only rename domains that are associated with global domains. As an example: dokku domains:set-global dokku.me dokku apps:create node-js-app dokku domains:set node-js-app node-js-app.dokku.me node-js-app.dokku.com dokku apps:rename node-js-app other-name dokku domains:report node-js-app --domains-app-vhosts # output: other-name.dokku.me node-js-app.dokku.com","title":"0.27.0 Migration Guide"},{"location":"appendices/0.27.0-migration-guide/#0270-migration-guide","text":"","title":"0.27.0 Migration Guide"},{"location":"appendices/0.27.0-migration-guide/#changes","text":"Renaming an application will now only rename domains that are associated with global domains. As an example: dokku domains:set-global dokku.me dokku apps:create node-js-app dokku domains:set node-js-app node-js-app.dokku.me node-js-app.dokku.com dokku apps:rename node-js-app other-name dokku domains:report node-js-app --domains-app-vhosts # output: other-name.dokku.me node-js-app.dokku.com","title":"Changes"},{"location":"appendices/0.28.0-migration-guide/","text":"0.28.0 Migration Guide Removals Support for the following operating systems has been removed: CentOS 7 Debian 9 (Stretch) Fedora OpenSuse Dokku will no longer provide packages for RPM based systems. Debian 9 users may use new Debian packages, though support is not guaranteed. All users are encouraged to install Dokku via the Docker-based installation method , or switch to a supported operating system. Deprecations Ubuntu 18.04 is now a deprecated installation target. The operating system will be considered EOL by Canonical in April 2023. Users are encouraged to upgrade to Ubuntu 22.04 or consider switching their instllation method to the Docker-based installation method to avoid any disruption in usage. Additions New in 0.28.0 are the Caddy and Traefik plugins. As community plugins wrapping these proxies exist, users should: Recommended: Uninstall the community plugin in question and switch all config to the new plugins. Upgrade the community plugin to a version that does not use the proxy:set value of caddy or traefik .","title":"0.28.0 Migration Guide"},{"location":"appendices/0.28.0-migration-guide/#0280-migration-guide","text":"","title":"0.28.0 Migration Guide"},{"location":"appendices/0.28.0-migration-guide/#removals","text":"Support for the following operating systems has been removed: CentOS 7 Debian 9 (Stretch) Fedora OpenSuse Dokku will no longer provide packages for RPM based systems. Debian 9 users may use new Debian packages, though support is not guaranteed. All users are encouraged to install Dokku via the Docker-based installation method , or switch to a supported operating system.","title":"Removals"},{"location":"appendices/0.28.0-migration-guide/#deprecations","text":"Ubuntu 18.04 is now a deprecated installation target. The operating system will be considered EOL by Canonical in April 2023. Users are encouraged to upgrade to Ubuntu 22.04 or consider switching their instllation method to the Docker-based installation method to avoid any disruption in usage.","title":"Deprecations"},{"location":"appendices/0.28.0-migration-guide/#additions","text":"New in 0.28.0 are the Caddy and Traefik plugins. As community plugins wrapping these proxies exist, users should: Recommended: Uninstall the community plugin in question and switch all config to the new plugins. Upgrade the community plugin to a version that does not use the proxy:set value of caddy or traefik .","title":"Additions"},{"location":"appendices/0.29.0-migration-guide/","text":"0.29.0 Migration Guide Changes The output of run:detached now uses the container name - eg. node-js-app.run.1 - vs the container id. The ID of cron tasks is now base36-encoded instead of base64-encoded. The nginx.conf.sigil is now extracted when source code is extracted for a build and not from the built image. Users can specify alternative paths via the nginx-conf-sigil-path property of the nginx plugin. See the nginx documentation for more information on how to configure the nginx.conf.sigil path for your application. The existing pre-restore hook has been renamed to scheduler-pre-restore . There is a new pre-restore hook that is triggered within the ps:restore command prior to restoring any apps. Nginx init commands are now performed via systemctl on Ubuntu systems when /usr/bin/systemctl is available. Removals The DOKKU_WAIT_TO_RETIRE environment variable has been migrated to a checks property named wait-to-retire and will be ignored if set as an environment variable. The Procfile is now extracted when source code is extracted for a build and not from the built image. Users can specify alternative paths via the procfile-path property of the ps plugin. See the process management documentation for more information on how to configure the Procfile path for your application.","title":"0.29.0 Migration Guide"},{"location":"appendices/0.29.0-migration-guide/#0290-migration-guide","text":"","title":"0.29.0 Migration Guide"},{"location":"appendices/0.29.0-migration-guide/#changes","text":"The output of run:detached now uses the container name - eg. node-js-app.run.1 - vs the container id. The ID of cron tasks is now base36-encoded instead of base64-encoded. The nginx.conf.sigil is now extracted when source code is extracted for a build and not from the built image. Users can specify alternative paths via the nginx-conf-sigil-path property of the nginx plugin. See the nginx documentation for more information on how to configure the nginx.conf.sigil path for your application. The existing pre-restore hook has been renamed to scheduler-pre-restore . There is a new pre-restore hook that is triggered within the ps:restore command prior to restoring any apps. Nginx init commands are now performed via systemctl on Ubuntu systems when /usr/bin/systemctl is available.","title":"Changes"},{"location":"appendices/0.29.0-migration-guide/#removals","text":"The DOKKU_WAIT_TO_RETIRE environment variable has been migrated to a checks property named wait-to-retire and will be ignored if set as an environment variable. The Procfile is now extracted when source code is extracted for a build and not from the built image. Users can specify alternative paths via the procfile-path property of the ps plugin. See the process management documentation for more information on how to configure the Procfile path for your application.","title":"Removals"},{"location":"appendices/0.5.0-migration-guide/","text":"0.5.0 Migration Guide nginx-vhosts plugin The nginx-vhosts template language is now sigil No need to escape literal $ characters (or other \"bash-isms\") Template variables are represented as {{ .VARIABLE_NAME }} A detailed list of template variables can be found here A custom nginx-vhosts template must be named nginx.conf.sigil The default path for this custom template is the root of your repo (i.e. /app in the container or WORKDIR if defined in a dockerfile app) Dokku no longer looks for this file in /home/dokku/node-js-app on the Dokku server Check out an example template here Support for server-wide SSL certs have been dropped in favor of using the certs plugin dokku certs:add node-js-app < certs.tar All domains for an SSL-enabled app will be redirected to https by default This can be overridden with a custom template Replaced \"magic\" NO_VHOST variable with domains:enable/disable Simplified zero downtime control checks:enable/disable Dockerfile apps with exposed ports Dockerfiles with EXPOSE clauses will get all tcp ports proxied by default Note that nginx will proxy the same port numbers to listen publicly UDP ports can be exposed by disabling the nginx proxy with dokku proxy:disable node-js-app","title":"0.5.0 Migration Guide"},{"location":"appendices/0.5.0-migration-guide/#050-migration-guide","text":"","title":"0.5.0 Migration Guide"},{"location":"appendices/0.5.0-migration-guide/#nginx-vhosts-plugin","text":"The nginx-vhosts template language is now sigil No need to escape literal $ characters (or other \"bash-isms\") Template variables are represented as {{ .VARIABLE_NAME }} A detailed list of template variables can be found here A custom nginx-vhosts template must be named nginx.conf.sigil The default path for this custom template is the root of your repo (i.e. /app in the container or WORKDIR if defined in a dockerfile app) Dokku no longer looks for this file in /home/dokku/node-js-app on the Dokku server Check out an example template here Support for server-wide SSL certs have been dropped in favor of using the certs plugin dokku certs:add node-js-app < certs.tar All domains for an SSL-enabled app will be redirected to https by default This can be overridden with a custom template Replaced \"magic\" NO_VHOST variable with domains:enable/disable Simplified zero downtime control checks:enable/disable","title":"nginx-vhosts plugin"},{"location":"appendices/0.5.0-migration-guide/#dockerfile-apps-with-exposed-ports","text":"Dockerfiles with EXPOSE clauses will get all tcp ports proxied by default Note that nginx will proxy the same port numbers to listen publicly UDP ports can be exposed by disabling the nginx proxy with dokku proxy:disable node-js-app","title":"Dockerfile apps with exposed ports"},{"location":"appendices/0.6.0-migration-guide/","text":"0.6.0 Migration Guide Zero-downtime deployment You can now actually disable zero-downtime deployments per-app and per-process-type Some config variables have been moved around DOKKU_CHECKS_ENABLED has been migrated to DOKKU_CHECKS_SKIPPED DOKKU_CHECKS_DISABLED is now a thing The values for the above can be a comma-separated list of process-types or the literal string _all_ See the updated checks docs for more info Proxy port mapping You can now configure host -> container proxy port mappings The UI is handled by the proxy interface plugin by setting the DOKKU_PROXY_PORT_MAP config variable in the format of scheme:host-port:container-port . The default nginx-vhosts proxy plugin supports both the http and https schemes. Default port mappings buildpack apps will be set to http:80:5000 and will also include https:443:5000 if SSL is enabled. dockerfile apps with explicitly exposed ports (i.e. using the EXPOSE directive) will be configured with a listener on each exposed port that proxies to the same port of the deployed application container. You may override this behavior with the proxy:ports-* commands or by directly setting DOKKU_PROXY_PORT_MAP with the config:set command dockerfile apps without explicitly exposed ports will behave the same as a buildpack app NOTE: These defaults are not automatically changed on subsequent pushes and must be manipulated with the aforementioned commands Calling the dokku binary Plugins should not call the dokku binary directly. Clients using the --app argument are potentially broken, amongst others, when doing so. Instead, please source the functions file for a given plugin when attempting to call Dokku internal functions. As a result, the following Dokku commands are no longer publicly exposed: dokku build dokku receive dokku release dokku tar:build dokku tar:build-locked dokku git:build dokku git:build-locked","title":"0.6.0 Migration Guide"},{"location":"appendices/0.6.0-migration-guide/#060-migration-guide","text":"","title":"0.6.0 Migration Guide"},{"location":"appendices/0.6.0-migration-guide/#zero-downtime-deployment","text":"You can now actually disable zero-downtime deployments per-app and per-process-type Some config variables have been moved around DOKKU_CHECKS_ENABLED has been migrated to DOKKU_CHECKS_SKIPPED DOKKU_CHECKS_DISABLED is now a thing The values for the above can be a comma-separated list of process-types or the literal string _all_ See the updated checks docs for more info","title":"Zero-downtime deployment"},{"location":"appendices/0.6.0-migration-guide/#proxy-port-mapping","text":"You can now configure host -> container proxy port mappings The UI is handled by the proxy interface plugin by setting the DOKKU_PROXY_PORT_MAP config variable in the format of scheme:host-port:container-port . The default nginx-vhosts proxy plugin supports both the http and https schemes. Default port mappings buildpack apps will be set to http:80:5000 and will also include https:443:5000 if SSL is enabled. dockerfile apps with explicitly exposed ports (i.e. using the EXPOSE directive) will be configured with a listener on each exposed port that proxies to the same port of the deployed application container. You may override this behavior with the proxy:ports-* commands or by directly setting DOKKU_PROXY_PORT_MAP with the config:set command dockerfile apps without explicitly exposed ports will behave the same as a buildpack app NOTE: These defaults are not automatically changed on subsequent pushes and must be manipulated with the aforementioned commands","title":"Proxy port mapping"},{"location":"appendices/0.6.0-migration-guide/#calling-the-dokku-binary","text":"Plugins should not call the dokku binary directly. Clients using the --app argument are potentially broken, amongst others, when doing so. Instead, please source the functions file for a given plugin when attempting to call Dokku internal functions. As a result, the following Dokku commands are no longer publicly exposed: dokku build dokku receive dokku release dokku tar:build dokku tar:build-locked dokku git:build dokku git:build-locked","title":"Calling the dokku binary"},{"location":"appendices/0.7.0-migration-guide/","text":"0.7.0 Migration Guide Persistent Storage We should now properly handle file ownership for mounted directories. This was enhanced in 0.7.1. See the persistent storage documentation for more details. Restart Policies If you previously managed container restart policies via docker-options, these can now be managed natively via the built-in ps plugin. There is no migration necessary. See the restart policy documentation for more details. SSH Keys Dokku now has an ssh-keys plugin that can be used to manage ssh keys for the dokku user on the host operating system. See the user management documentation for more details.","title":"0.7.0 Migration Guide"},{"location":"appendices/0.7.0-migration-guide/#070-migration-guide","text":"","title":"0.7.0 Migration Guide"},{"location":"appendices/0.7.0-migration-guide/#persistent-storage","text":"We should now properly handle file ownership for mounted directories. This was enhanced in 0.7.1. See the persistent storage documentation for more details.","title":"Persistent Storage"},{"location":"appendices/0.7.0-migration-guide/#restart-policies","text":"If you previously managed container restart policies via docker-options, these can now be managed natively via the built-in ps plugin. There is no migration necessary. See the restart policy documentation for more details.","title":"Restart Policies"},{"location":"appendices/0.7.0-migration-guide/#ssh-keys","text":"Dokku now has an ssh-keys plugin that can be used to manage ssh keys for the dokku user on the host operating system. See the user management documentation for more details.","title":"SSH Keys"},{"location":"appendices/0.8.0-migration-guide/","text":"0.8.0 Migration Guide Domain Management You can now set global and app domains via domains:set and domains:set-global . See the domains documentation for more details. Plugin Uninstallation A new uninstall plugin trigger was introduced. This functionality may be in use for newer plugins, so be aware that older Dokku versions may require manual cleanup. See the uninstall trigger documentation for implementation instructions. Deployment Tasks Should a pre or post deployment task fail, we now fail the entire deploy. Nginx HTTP2 Support Due to bugs in Nginx, the minimum version for HTTP2 is now 1.11.5.","title":"0.8.0 Migration Guide"},{"location":"appendices/0.8.0-migration-guide/#080-migration-guide","text":"","title":"0.8.0 Migration Guide"},{"location":"appendices/0.8.0-migration-guide/#domain-management","text":"You can now set global and app domains via domains:set and domains:set-global . See the domains documentation for more details.","title":"Domain Management"},{"location":"appendices/0.8.0-migration-guide/#plugin-uninstallation","text":"A new uninstall plugin trigger was introduced. This functionality may be in use for newer plugins, so be aware that older Dokku versions may require manual cleanup. See the uninstall trigger documentation for implementation instructions.","title":"Plugin Uninstallation"},{"location":"appendices/0.8.0-migration-guide/#deployment-tasks","text":"Should a pre or post deployment task fail, we now fail the entire deploy.","title":"Deployment Tasks"},{"location":"appendices/0.8.0-migration-guide/#nginx-http2-support","text":"Due to bugs in Nginx, the minimum version for HTTP2 is now 1.11.5.","title":"Nginx HTTP2 Support"},{"location":"appendices/0.9.0-migration-guide/","text":"0.9.0 Migration Guide Golang Migration There is an ongoing migration to rewrite Dokku in Golang. The reasons are beyond the scope of this document, but this may impact any patches you have for Dokku. As of 0.9.0, only the repo plugin is in Golang. The following shall remain true, regardless of the state of our rewrite: You will be able to write custom plugins in any language. You will be able to enable or disable core plugins. plugn will continue to be used for executing plugin triggers. We will provide bash wrappers that can be sourced to execute core functionality that is implemented in golang.","title":"0.9.0 Migration Guide"},{"location":"appendices/0.9.0-migration-guide/#090-migration-guide","text":"","title":"0.9.0 Migration Guide"},{"location":"appendices/0.9.0-migration-guide/#golang-migration","text":"There is an ongoing migration to rewrite Dokku in Golang. The reasons are beyond the scope of this document, but this may impact any patches you have for Dokku. As of 0.9.0, only the repo plugin is in Golang. The following shall remain true, regardless of the state of our rewrite: You will be able to write custom plugins in any language. You will be able to enable or disable core plugins. plugn will continue to be used for executing plugin triggers. We will provide bash wrappers that can be sourced to execute core functionality that is implemented in golang.","title":"Golang Migration"},{"location":"community/clients/","text":"Clients Given the constraints, running Dokku commands remotely via SSH is fine. For certain configurations, the extra complication of manually invoking ssh can be a burden. The easiest way to interact with Dokku remotely is by using the official client. Documented below are the various clients that you may wish to use. Official Client See the remote commands documentation for more information on how to install and use the official client. (nodejs) dokku-toolbelt Dokku-toolbelt is a node-based cli wrapper that proxies requests to the Dokku command running on remote hosts. You can install it via the following shell command (assuming you have nodejs and npm installed): npm install -g dokku-toolbelt See documentation here for more information. (ruby) Dokku CLI Dokku CLI is a rubygem that acts as a client for your Dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku-cli See documentation here for more information. (ruby) DokkuClient DokkuClient is another rubygem that acts as a client for your Dokku installation with built-in support for certain external plugins. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku_client See documentation here for more information. (ruby) Dokkufy Dokkufy is a rubygem that handles automation of certain tasks, such as Dokku setup, plugin installation, etc. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokkufy See documentation here for more information. (ruby) Dockland Dockland is a rubygem that acts as a client for your Dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dockland See documentation here for more information.","title":"Clients"},{"location":"community/clients/#clients","text":"Given the constraints, running Dokku commands remotely via SSH is fine. For certain configurations, the extra complication of manually invoking ssh can be a burden. The easiest way to interact with Dokku remotely is by using the official client. Documented below are the various clients that you may wish to use.","title":"Clients"},{"location":"community/clients/#official-client","text":"See the remote commands documentation for more information on how to install and use the official client.","title":"Official Client"},{"location":"community/clients/#nodejs-dokku-toolbelt","text":"Dokku-toolbelt is a node-based cli wrapper that proxies requests to the Dokku command running on remote hosts. You can install it via the following shell command (assuming you have nodejs and npm installed): npm install -g dokku-toolbelt See documentation here for more information.","title":"(nodejs) dokku-toolbelt"},{"location":"community/clients/#ruby-dokku-cli","text":"Dokku CLI is a rubygem that acts as a client for your Dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku-cli See documentation here for more information.","title":"(ruby) Dokku CLI"},{"location":"community/clients/#ruby-dokkuclient","text":"DokkuClient is another rubygem that acts as a client for your Dokku installation with built-in support for certain external plugins. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku_client See documentation here for more information.","title":"(ruby) DokkuClient"},{"location":"community/clients/#ruby-dokkufy","text":"Dokkufy is a rubygem that handles automation of certain tasks, such as Dokku setup, plugin installation, etc. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokkufy See documentation here for more information.","title":"(ruby) Dokkufy"},{"location":"community/clients/#ruby-dockland","text":"Dockland is a rubygem that acts as a client for your Dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dockland See documentation here for more information.","title":"(ruby) Dockland"},{"location":"community/plugins/","text":"Plugins Dokku itself is built out of plugins and uses plugn for its plugin system. In essence a plugin is a collection of scripts that will be run based on naming convention. Let's take a quick look at the current Dokku nginx plugin that's shipped with Dokku by default. nginx-vhosts/ \u251c\u2500\u2500 plugin.toml # plugin metadata \u251c\u2500\u2500 commands # contains additional commands \u251c\u2500\u2500 install # runs on Dokku installation \u2514\u2500\u2500 post-deploy # runs after an app is deployed Installing a plugin See the plugin management documentation . Creating your own plugin See the full documentation . Official Plugins The following plugins are available and provided by Dokku maintainers. Please file issues against their respective issue trackers. Plugin Author Compatibility CouchDB dokku 0.4.0+ Elasticsearch dokku 0.4.0+ Grafana/Graphite/Statsd dokku 0.4.0+ MariaDB dokku 0.4.0+ Memcached dokku 0.4.0+ Mongo dokku 0.4.0+ MySQL dokku 0.4.0+ Nats dokku 0.4.0+ Postgres dokku 0.4.0+ RabbitMQ dokku 0.4.0+ Redis dokku 0.4.0+ RethinkDB dokku 0.4.0+ Copy Files to Image dokku 0.4.0+ HTTP Auth dokku 0.4.0+ Let's Encrypt dokku 0.4.0+ Maintenance mode dokku 0.4.0+ Redirect dokku 0.4.0+ Registry dokku 0.12.0+ Community plugins Warning The following plugins have been supplied by our community and may not have been tested by Dokku maintainers. Datastores Relational Plugin Author Compatibility MariaDB kloadut 0.3.x MariaDB (single container) ohardy 0.3.x MariaDB (single container) krisrang 0.3.26+ PostgreSQL jlachowski 0.3.x PostgreSQL (single container) ohardy 0.3.x PostgreSQL (single container) flink 0.3.26+ Edgedb ignisda 0.27.0+ Caching Plugin Author Compatibility Nginx Cache aluxian 0.5.0+ Redis (single container) ohardy 0.3.x Varnish zenedith Varnish cache between nginx and application with base configuration Queuing Plugin Author Compatibility RabbitMQ jlachowski 0.3.x RabbitMQ (single container) jlachowski 0.3.x ElasticMQ (SQS compatible) cu12 0.5.0+ VerneMQ (MQTT Broker) mrname 0.4.0+ Other Plugin Author Compatibility etcd basgys 0.4.x FakeSNS cu12 0.5.0+ InfluxDB basgys 0.4.x RethinkDB stuartpb 0.3.x Headless Chrome lazyatom 0.8.1+ Plugins Implementing New Dokku Functionality Plugin Author Compatibility App name as env cjblomqvist 0.3.x Docker Direct josegonzalez 0.4.0+ Dokku Clone crisward 0.4.0+ Dokku Copy App Config Files josegonzalez 0.4.0+ Dockerfile custom path mimischi 0.8.0+ Dokku Require 1 crisward 0.4.0+ Global Certificates josegonzalez 0.5.0+ Graduate (Environment Management) benjamin-dobell 0.4.0+ Haproxy tcp load balancer 256dpi 0.4.0+ Hostname michaelshobbs 0.4.0+ HTTP Auth Secure Apps matto1990 0.4.0+ Litestream 2 AxelTheGerman 0.27.0+ Monit (Health Checks) mbreit 0.8.0+ Nuke Containers josegonzalez 0.4.0+ Open App Ports josegonzalez 0.3.x Proctype Filter michaelshobbs 0.4.0+ robots.txt candlewaster 0.4.x SSH Deployment Keys 2 cedricziel 0.4.0+ SSH Hostkeys 3 cedricziel 0.3.x Application build hook fteychene 0.4.0+ Post Deploy Script baikunz 0.4.0+ Auto Sync 4 fomojola 0.8.1+ Deploy Webhook 5 fomojola 0.8.1+ 1 Extends app.json support to include creating volumes and creating / linking databases on push 2 Adds SQLite replication to external object storage via Litestream 3 Adds the possibility to add SSH deployment keys to receive private hosted packages 4 Adds the ability to add custom hosts to the containers known_hosts file to be able to ssh them easily (useful with deployment keys) 5 Adds the ability to sync an application repo with a remote GitHub repo (useful for automated rebuilds without needing a git push from an external system 6 Adds the ability to invoke a post-deploy webhook with the IP, port and app name, all with a single config:set). Other Plugins Plugin Author Compatibility Airbrake deploy flink 0.4.0+ APT dokku-community 0.18.x+ Bower install alexanderbeletsky 0.3.x Bower/Grunt thrashr888 0.3.x Bower/Gulp gdi2290 0.3.x Bower/Gulp jagandecapri 0.3.x Builders: bower, compass, gulp, grunt ignlg 0.4.0+ Chef cookbook nickcharlton Docker auto persist volumes flink 0.4.0+ Hostname michaelshobbs 0.4.0+ Limit (Resource management) sarendsen 0.9.0+ Logspout michaelshobbs 0.4.0+ Syslog michaelshobbs 0.10.4+ Long Timeout investtools 0.4.0+ Monit cjblomqvist 0.3.x Monorepo iamale 0.4.0+ Multi Dockerfile artofrawr 0.4.0+ Node ademuk 0.3.x Node pnegahdar 0.3.x Rollbar iloveitaly 0.5.0+ Slack Notifications ribot 0.4.0+ Telegram Notifications m0rth1um 0.4.0+ Tor michaelshobbs 0.4.0+ User ACL maciej \u0142ebkowski 0.4.0+ Webhooks nickstenning 0.3.x Wkhtmltopdf mbriskar 0.4.0+ Dokku Wordpress dokku-community 0.4.0+ Access mainto 0.4.0+ Dokku Nginx Trust Proxy kingsquare 0.4.0+ Fonts ollej 0.19.11+ Discourse badsyntax 0.21.4+ Deprecated Plugins The following plugins have been removed as their functionality is now in Dokku Core. Plugin Author In Dokku Since App User michaelshobbs v0.7.1 (herokuish 0.3.18) Custom Domains neam v0.3.10 (domains plugin) Debug josegonzalez v0.3.9 (trace command) Docker Options dyson v0.3.17 (docker-options plugin) Dokku Name alex-sherwin v0.4.2 (named containers plugin) Events Logger alessio v0.3.21 (events plugin) git rev-parse HEAD in env cjblomqvist v0.12.0 (enhanced core git plugin) Host Port binding stuartpb v0.3.17 (docker-options plugin) Link Containers rlaneve v0.3.17 (docker-options plugin) List Containers josegonzalez v0.3.14 (ps plugin) Multi-Buildpack pauldub v0.4.0 (herokuish) Multiple Domains 1 wmluke v0.3.10 (domains plugin) Named-containers flink v0.4.2 (named-containers plugin) Nginx-Alt mikexstudios v0.3.10 (domains plugin) Persistent Storage dyson v0.3.17 (docker-options plugin) Pre-Deploy Tasks michaelshobbs v0.5.0 (deployment tasks) PrimeCache darkpixel v0.3.0 (zero downtime deploys) Process Manager: Circus apmorton v0.3.14/0.7.0 (ps/restart policy plugin) Process Manager: Forego flink v0.3.14/0.7.0 (ps plugin) Process Manager: Forego iskandar v0.3.14/0.7.0 (ps plugin) Process Manager: Logging Supervisord sehrope v0.3.14/0.7.0 (ps plugin) Process Manager: Shoreman statianzo v0.3.14/0.7.0 (ps plugin) Process Manager: Supervisord statianzo v0.3.14/0.7.0 (ps plugin) Rebuild application scottatron v0.3.14 (ps plugin) Reset mtime mixxorz Docker 1.8+ Supply env vars to buildpacks 2 cameron-martin v0.3.9 (build-env plugin) user-env-compile 2 motin v0.3.9 (build-env plugin) user-env-compile 2 musicglue v0.3.9 (build-env plugin) Volume (persistent storage) ohardy v0.5.0 (storage plugin) 1 Conflicts with VHOSTS Custom Configuration 2 Similar to the heroku-labs feature (see https://devcenter.heroku.com/articles/labs-user-env-compile) Unmaintained Plugins The following plugins are no longer maintained by their developers. Plugin Author Compatibility app-url mikecsh Works with 0.2.0 Chef cookbooks fgrehm CouchDB (multi containers) flink 0.4.0+ CouchDB raceHub Compatible with 0.2.0 Dokku Copy App Config Files alexkruegger Compatible with 0.3.17+ Dokku Registry agco-adm 0.4.0+ Elasticsearch robv Not compatible with >= 0.3.0 (still uses /home/git) Elasticsearch 1 blag Compatible with 0.2.0 Graphite/statsd jlachowski < 0.4.0 HipChat Notifications cef Memcached flink 0.4.0+ MongoDB (single container) jeffutter MySQL hughfletcher Neo4j aomitayo PostGIS fermuch PostgreSQL (single container) jeffutter This plugin creates a single postgresql container that all your apps can use. Thus only one instance of postgresql running (good for servers without a ton of memory). RiakCS (single container) jeffutter Incompatible with 0.2.0 Redis luxifer Redis sekjun9878 0.3.26+ 1 Forked from jezdez/dokku-elasticsearch-plugin : uses Elasticsearch 1.2 (instead of 0.90), doesn't depend on dokku-link, runs as elasticsearch user instead of root, and turns off multicast autodiscovery for use in a VPS environment.","title":"Plugins"},{"location":"community/plugins/#plugins","text":"Dokku itself is built out of plugins and uses plugn for its plugin system. In essence a plugin is a collection of scripts that will be run based on naming convention. Let's take a quick look at the current Dokku nginx plugin that's shipped with Dokku by default. nginx-vhosts/ \u251c\u2500\u2500 plugin.toml # plugin metadata \u251c\u2500\u2500 commands # contains additional commands \u251c\u2500\u2500 install # runs on Dokku installation \u2514\u2500\u2500 post-deploy # runs after an app is deployed","title":"Plugins"},{"location":"community/plugins/#installing-a-plugin","text":"See the plugin management documentation .","title":"Installing a plugin"},{"location":"community/plugins/#creating-your-own-plugin","text":"See the full documentation .","title":"Creating your own plugin"},{"location":"community/plugins/#official-plugins","text":"The following plugins are available and provided by Dokku maintainers. Please file issues against their respective issue trackers. Plugin Author Compatibility CouchDB dokku 0.4.0+ Elasticsearch dokku 0.4.0+ Grafana/Graphite/Statsd dokku 0.4.0+ MariaDB dokku 0.4.0+ Memcached dokku 0.4.0+ Mongo dokku 0.4.0+ MySQL dokku 0.4.0+ Nats dokku 0.4.0+ Postgres dokku 0.4.0+ RabbitMQ dokku 0.4.0+ Redis dokku 0.4.0+ RethinkDB dokku 0.4.0+ Copy Files to Image dokku 0.4.0+ HTTP Auth dokku 0.4.0+ Let's Encrypt dokku 0.4.0+ Maintenance mode dokku 0.4.0+ Redirect dokku 0.4.0+ Registry dokku 0.12.0+","title":"Official Plugins"},{"location":"community/plugins/#community-plugins","text":"Warning The following plugins have been supplied by our community and may not have been tested by Dokku maintainers.","title":"Community plugins"},{"location":"community/plugins/#datastores","text":"","title":"Datastores"},{"location":"community/plugins/#relational","text":"Plugin Author Compatibility MariaDB kloadut 0.3.x MariaDB (single container) ohardy 0.3.x MariaDB (single container) krisrang 0.3.26+ PostgreSQL jlachowski 0.3.x PostgreSQL (single container) ohardy 0.3.x PostgreSQL (single container) flink 0.3.26+ Edgedb ignisda 0.27.0+","title":"Relational"},{"location":"community/plugins/#caching","text":"Plugin Author Compatibility Nginx Cache aluxian 0.5.0+ Redis (single container) ohardy 0.3.x Varnish zenedith Varnish cache between nginx and application with base configuration","title":"Caching"},{"location":"community/plugins/#queuing","text":"Plugin Author Compatibility RabbitMQ jlachowski 0.3.x RabbitMQ (single container) jlachowski 0.3.x ElasticMQ (SQS compatible) cu12 0.5.0+ VerneMQ (MQTT Broker) mrname 0.4.0+","title":"Queuing"},{"location":"community/plugins/#other","text":"Plugin Author Compatibility etcd basgys 0.4.x FakeSNS cu12 0.5.0+ InfluxDB basgys 0.4.x RethinkDB stuartpb 0.3.x Headless Chrome lazyatom 0.8.1+","title":"Other"},{"location":"community/plugins/#plugins-implementing-new-dokku-functionality","text":"Plugin Author Compatibility App name as env cjblomqvist 0.3.x Docker Direct josegonzalez 0.4.0+ Dokku Clone crisward 0.4.0+ Dokku Copy App Config Files josegonzalez 0.4.0+ Dockerfile custom path mimischi 0.8.0+ Dokku Require 1 crisward 0.4.0+ Global Certificates josegonzalez 0.5.0+ Graduate (Environment Management) benjamin-dobell 0.4.0+ Haproxy tcp load balancer 256dpi 0.4.0+ Hostname michaelshobbs 0.4.0+ HTTP Auth Secure Apps matto1990 0.4.0+ Litestream 2 AxelTheGerman 0.27.0+ Monit (Health Checks) mbreit 0.8.0+ Nuke Containers josegonzalez 0.4.0+ Open App Ports josegonzalez 0.3.x Proctype Filter michaelshobbs 0.4.0+ robots.txt candlewaster 0.4.x SSH Deployment Keys 2 cedricziel 0.4.0+ SSH Hostkeys 3 cedricziel 0.3.x Application build hook fteychene 0.4.0+ Post Deploy Script baikunz 0.4.0+ Auto Sync 4 fomojola 0.8.1+ Deploy Webhook 5 fomojola 0.8.1+ 1 Extends app.json support to include creating volumes and creating / linking databases on push 2 Adds SQLite replication to external object storage via Litestream 3 Adds the possibility to add SSH deployment keys to receive private hosted packages 4 Adds the ability to add custom hosts to the containers known_hosts file to be able to ssh them easily (useful with deployment keys) 5 Adds the ability to sync an application repo with a remote GitHub repo (useful for automated rebuilds without needing a git push from an external system 6 Adds the ability to invoke a post-deploy webhook with the IP, port and app name, all with a single config:set).","title":"Plugins Implementing New Dokku Functionality"},{"location":"community/plugins/#other-plugins","text":"Plugin Author Compatibility Airbrake deploy flink 0.4.0+ APT dokku-community 0.18.x+ Bower install alexanderbeletsky 0.3.x Bower/Grunt thrashr888 0.3.x Bower/Gulp gdi2290 0.3.x Bower/Gulp jagandecapri 0.3.x Builders: bower, compass, gulp, grunt ignlg 0.4.0+ Chef cookbook nickcharlton Docker auto persist volumes flink 0.4.0+ Hostname michaelshobbs 0.4.0+ Limit (Resource management) sarendsen 0.9.0+ Logspout michaelshobbs 0.4.0+ Syslog michaelshobbs 0.10.4+ Long Timeout investtools 0.4.0+ Monit cjblomqvist 0.3.x Monorepo iamale 0.4.0+ Multi Dockerfile artofrawr 0.4.0+ Node ademuk 0.3.x Node pnegahdar 0.3.x Rollbar iloveitaly 0.5.0+ Slack Notifications ribot 0.4.0+ Telegram Notifications m0rth1um 0.4.0+ Tor michaelshobbs 0.4.0+ User ACL maciej \u0142ebkowski 0.4.0+ Webhooks nickstenning 0.3.x Wkhtmltopdf mbriskar 0.4.0+ Dokku Wordpress dokku-community 0.4.0+ Access mainto 0.4.0+ Dokku Nginx Trust Proxy kingsquare 0.4.0+ Fonts ollej 0.19.11+ Discourse badsyntax 0.21.4+","title":"Other Plugins"},{"location":"community/plugins/#deprecated-plugins","text":"The following plugins have been removed as their functionality is now in Dokku Core. Plugin Author In Dokku Since App User michaelshobbs v0.7.1 (herokuish 0.3.18) Custom Domains neam v0.3.10 (domains plugin) Debug josegonzalez v0.3.9 (trace command) Docker Options dyson v0.3.17 (docker-options plugin) Dokku Name alex-sherwin v0.4.2 (named containers plugin) Events Logger alessio v0.3.21 (events plugin) git rev-parse HEAD in env cjblomqvist v0.12.0 (enhanced core git plugin) Host Port binding stuartpb v0.3.17 (docker-options plugin) Link Containers rlaneve v0.3.17 (docker-options plugin) List Containers josegonzalez v0.3.14 (ps plugin) Multi-Buildpack pauldub v0.4.0 (herokuish) Multiple Domains 1 wmluke v0.3.10 (domains plugin) Named-containers flink v0.4.2 (named-containers plugin) Nginx-Alt mikexstudios v0.3.10 (domains plugin) Persistent Storage dyson v0.3.17 (docker-options plugin) Pre-Deploy Tasks michaelshobbs v0.5.0 (deployment tasks) PrimeCache darkpixel v0.3.0 (zero downtime deploys) Process Manager: Circus apmorton v0.3.14/0.7.0 (ps/restart policy plugin) Process Manager: Forego flink v0.3.14/0.7.0 (ps plugin) Process Manager: Forego iskandar v0.3.14/0.7.0 (ps plugin) Process Manager: Logging Supervisord sehrope v0.3.14/0.7.0 (ps plugin) Process Manager: Shoreman statianzo v0.3.14/0.7.0 (ps plugin) Process Manager: Supervisord statianzo v0.3.14/0.7.0 (ps plugin) Rebuild application scottatron v0.3.14 (ps plugin) Reset mtime mixxorz Docker 1.8+ Supply env vars to buildpacks 2 cameron-martin v0.3.9 (build-env plugin) user-env-compile 2 motin v0.3.9 (build-env plugin) user-env-compile 2 musicglue v0.3.9 (build-env plugin) Volume (persistent storage) ohardy v0.5.0 (storage plugin) 1 Conflicts with VHOSTS Custom Configuration 2 Similar to the heroku-labs feature (see https://devcenter.heroku.com/articles/labs-user-env-compile)","title":"Deprecated Plugins"},{"location":"community/plugins/#unmaintained-plugins","text":"The following plugins are no longer maintained by their developers. Plugin Author Compatibility app-url mikecsh Works with 0.2.0 Chef cookbooks fgrehm CouchDB (multi containers) flink 0.4.0+ CouchDB raceHub Compatible with 0.2.0 Dokku Copy App Config Files alexkruegger Compatible with 0.3.17+ Dokku Registry agco-adm 0.4.0+ Elasticsearch robv Not compatible with >= 0.3.0 (still uses /home/git) Elasticsearch 1 blag Compatible with 0.2.0 Graphite/statsd jlachowski < 0.4.0 HipChat Notifications cef Memcached flink 0.4.0+ MongoDB (single container) jeffutter MySQL hughfletcher Neo4j aomitayo PostGIS fermuch PostgreSQL (single container) jeffutter This plugin creates a single postgresql container that all your apps can use. Thus only one instance of postgresql running (good for servers without a ton of memory). RiakCS (single container) jeffutter Incompatible with 0.2.0 Redis luxifer Redis sekjun9878 0.3.26+ 1 Forked from jezdez/dokku-elasticsearch-plugin : uses Elasticsearch 1.2 (instead of 0.90), doesn't depend on dokku-link, runs as elasticsearch user instead of root, and turns off multicast autodiscovery for use in a VPS environment.","title":"Unmaintained Plugins"},{"location":"community/tutorials/run-on-external-volume/","text":"Run Dokku on External Volume In order to leverage cloud-provider facilities like attachable volumes , ( a.k.a. block storage ) the following is an easy tutorial to achieve Dokku runs on them. Warning If the block storage is not available and attached on boot it is possible that containers will not correctly start. Please keep this in mind when considering moving Dokku and/or Docker to network attached storage. Tutorial The following is intended to be executed on the dokku host machine as root . Say, for instance , that our volume is mapped into the systems as /dev/vdb1 . Stop docker daemon systemctl stop docker Prepare the filesystem: mkfs -t ext4 /dev/vdb1 mkdir /mnt/volume mount /dev/vdb1 /mnt/volume Move the old data directories: mv /home/dokku /home/dokku.OLD mv /var/lib/docker /var/lib/docker.OLD mv /var/lib/dokku /var/lib/dokku.OLD Move the data on the volume mkdir /mnt/volume/home/ mkdir -p /mnt/volume/var/lib/ mv /home/dokku.OLD /mnt/volume/home/dokku mv /var/lib/dokku.OLD /mnt/volume/var/lib/dokku mv /var/lib/docker.OLD /mnt/volume/var/lib/docker Prepare the mountpoints mkdir /home/dokku mkdir /var/lib/dokku mkdir /var/lib/docker chown dokku:dokku /home/dokku # respect the original ownership chmod 711 /var/lib/docker # respect the original permissions Mount bind mount -o bind /mnt/volume/home/dokku /home/dokku mount -o bind /mnt/volume/var/lib/dokku /var/lib/dokku mount -o bind /mnt/volume/var/lib/docker /var/lib/docker Start docker daemon systemctl start docker At this point all should be working fine, please check it out. Then, let the changes be reboot-persistent echo '/dev/vdb1 /mnt/volume ext4 defaults 0 2' | sudo tee -a /etc/fstab echo '/mnt/volume/home/dokku /home/dokku none defaults,bind 0 0' | sudo tee -a /etc/fstab echo '/mnt/volume/var/lib/dokku /var/lib/dokku none defaults,bind 0 0' | sudo tee -a /etc/fstab echo '/mnt/volume/var/lib/docker /var/lib/docker none defaults,bind 0 0' | sudo tee -a /etc/fstab","title":"Run Dokku on External Volume"},{"location":"community/tutorials/run-on-external-volume/#run-dokku-on-external-volume","text":"In order to leverage cloud-provider facilities like attachable volumes , ( a.k.a. block storage ) the following is an easy tutorial to achieve Dokku runs on them. Warning If the block storage is not available and attached on boot it is possible that containers will not correctly start. Please keep this in mind when considering moving Dokku and/or Docker to network attached storage.","title":"Run Dokku on External Volume"},{"location":"community/tutorials/run-on-external-volume/#tutorial","text":"The following is intended to be executed on the dokku host machine as root . Say, for instance , that our volume is mapped into the systems as /dev/vdb1 . Stop docker daemon systemctl stop docker Prepare the filesystem: mkfs -t ext4 /dev/vdb1 mkdir /mnt/volume mount /dev/vdb1 /mnt/volume Move the old data directories: mv /home/dokku /home/dokku.OLD mv /var/lib/docker /var/lib/docker.OLD mv /var/lib/dokku /var/lib/dokku.OLD Move the data on the volume mkdir /mnt/volume/home/ mkdir -p /mnt/volume/var/lib/ mv /home/dokku.OLD /mnt/volume/home/dokku mv /var/lib/dokku.OLD /mnt/volume/var/lib/dokku mv /var/lib/docker.OLD /mnt/volume/var/lib/docker Prepare the mountpoints mkdir /home/dokku mkdir /var/lib/dokku mkdir /var/lib/docker chown dokku:dokku /home/dokku # respect the original ownership chmod 711 /var/lib/docker # respect the original permissions Mount bind mount -o bind /mnt/volume/home/dokku /home/dokku mount -o bind /mnt/volume/var/lib/dokku /var/lib/dokku mount -o bind /mnt/volume/var/lib/docker /var/lib/docker Start docker daemon systemctl start docker At this point all should be working fine, please check it out. Then, let the changes be reboot-persistent echo '/dev/vdb1 /mnt/volume ext4 defaults 0 2' | sudo tee -a /etc/fstab echo '/mnt/volume/home/dokku /home/dokku none defaults,bind 0 0' | sudo tee -a /etc/fstab echo '/mnt/volume/var/lib/dokku /var/lib/dokku none defaults,bind 0 0' | sudo tee -a /etc/fstab echo '/mnt/volume/var/lib/docker /var/lib/docker none defaults,bind 0 0' | sudo tee -a /etc/fstab","title":"Tutorial"},{"location":"configuration/domains/","text":"Domain Configuration New Introduced in 0.3.10 domains:add <app> <domain> [<domain> ...] # Add domains to app domains:add-global <domain> [<domain> ...] # Add global domain names domains:clear <app> # Clear all domains for app domains:clear-global # Clear global domain names domains:disable <app> # Disable VHOST support domains:enable <app> # Enable VHOST support domains:remove <app> <domain> [<domain> ...] # Remove domains from app domains:remove-global <domain> [<domain> ...] # Remove global domain names domains:report [<app>|--global] [<flag>] # Displays a domains report for one or more apps domains:set <app> <domain> [<domain> ...] # Set domains for app domains:set-global <domain> [<domain> ...] # Set global domain names Info Adding a domain before deploying an application will result in port mappings being set. This may cause issues for applications that use non-standard ports, as those will not be automatically detected. Please refer to the proxy documentation for information as to how to reconfigure the mappings. Customizing hostnames Applications typically have the following structure for their hostname: scheme://subdomain.domain.tld The subdomain is inferred from the pushed application name, while the domain.tld is set during initial dokku configuration. It can then be modified with dokku domains:add-global and dokku domains:remove-global . This value is used as a default TLD for all applications on a host. If an FQDN such as dokku.org is used as the application name, the global virtualhost will be ignored and the resulting vhost URL for that application will be dokku.org . You can optionally override this in a plugin by implementing the nginx-hostname plugin trigger. If the nginx-hostname plugin has no output, the normal hostname algorithm will be executed. See the plugin trigger documentation for more information. Disabling VHOSTS If desired, it is possible to disable vhosts with the domains plugin. dokku domains:disable node-js-app On subsequent deploys, the nginx virtualhost will be discarded. This is useful when deploying internal-facing services that should not be publicly routeable. As of 0.4.0, nginx will still be configured to proxy your app on some random high port. This allows internal services to maintain the same port between deployments. You may change this port by setting DOKKU_PROXY_PORT and/or DOKKU_PROXY_SSL_PORT (for services configured to use SSL.) The domains plugin allows you to specify custom domains for applications. This plugin is aware of any ssl certificates that are imported via certs:add . Be aware that disabling domains (with domains:disable ) will override any custom domains. # where `node-js-app` is the name of your app # add a domain to an app dokku domains:add node-js-app dokku.me # list custom domains for app dokku domains:report node-js-app # clear all custom domains for app dokku domains:clear node-js-app # remove a custom domain from app dokku domains:remove node-js-app dokku.me # set all custom domains for app dokku domains:set node-js-app dokku.me dokku.org Displaying domains reports for an app New Introduced in 0.8.1 You can get a report about the app's domains status using the domains:report command: Shell Output dokku domains:report =====> node-js-app domains information Domains app enabled: true Domains app vhosts: node-js-app.dokku.org Domains global enabled: true Domains global vhosts: dokku.org =====> python-app domains information Domains app enabled: true Domains app vhosts: python-app.dokku.org Domains global enabled: true Domains global vhosts: dokku.org =====> ruby-app domains information Domains app enabled: true Domains app vhosts: ruby-app.dokku.org Domains global enabled: true Domains global vhosts: dokku.org You can run the command for a specific app also. Shell Output dokku domains:report node-js-app =====> node-js-app domains information Domains app enabled: true Domains app vhosts: node-js-app.dokku.org Domains global enabled: true Domains global vhosts: dokku.org You can pass flags which will output only the value of the specific information you want. For example: dokku domains:report node-js-app --domains-app-enabled Default site This is specific to your proxy plugin of choice. See the nginx documentation for more information on how to configure this for the default nginx proxy implementation.","title":"Domain Configuration"},{"location":"configuration/domains/#domain-configuration","text":"New Introduced in 0.3.10 domains:add <app> <domain> [<domain> ...] # Add domains to app domains:add-global <domain> [<domain> ...] # Add global domain names domains:clear <app> # Clear all domains for app domains:clear-global # Clear global domain names domains:disable <app> # Disable VHOST support domains:enable <app> # Enable VHOST support domains:remove <app> <domain> [<domain> ...] # Remove domains from app domains:remove-global <domain> [<domain> ...] # Remove global domain names domains:report [<app>|--global] [<flag>] # Displays a domains report for one or more apps domains:set <app> <domain> [<domain> ...] # Set domains for app domains:set-global <domain> [<domain> ...] # Set global domain names Info Adding a domain before deploying an application will result in port mappings being set. This may cause issues for applications that use non-standard ports, as those will not be automatically detected. Please refer to the proxy documentation for information as to how to reconfigure the mappings.","title":"Domain Configuration"},{"location":"configuration/domains/#customizing-hostnames","text":"Applications typically have the following structure for their hostname: scheme://subdomain.domain.tld The subdomain is inferred from the pushed application name, while the domain.tld is set during initial dokku configuration. It can then be modified with dokku domains:add-global and dokku domains:remove-global . This value is used as a default TLD for all applications on a host. If an FQDN such as dokku.org is used as the application name, the global virtualhost will be ignored and the resulting vhost URL for that application will be dokku.org . You can optionally override this in a plugin by implementing the nginx-hostname plugin trigger. If the nginx-hostname plugin has no output, the normal hostname algorithm will be executed. See the plugin trigger documentation for more information.","title":"Customizing hostnames"},{"location":"configuration/domains/#disabling-vhosts","text":"If desired, it is possible to disable vhosts with the domains plugin. dokku domains:disable node-js-app On subsequent deploys, the nginx virtualhost will be discarded. This is useful when deploying internal-facing services that should not be publicly routeable. As of 0.4.0, nginx will still be configured to proxy your app on some random high port. This allows internal services to maintain the same port between deployments. You may change this port by setting DOKKU_PROXY_PORT and/or DOKKU_PROXY_SSL_PORT (for services configured to use SSL.) The domains plugin allows you to specify custom domains for applications. This plugin is aware of any ssl certificates that are imported via certs:add . Be aware that disabling domains (with domains:disable ) will override any custom domains. # where `node-js-app` is the name of your app # add a domain to an app dokku domains:add node-js-app dokku.me # list custom domains for app dokku domains:report node-js-app # clear all custom domains for app dokku domains:clear node-js-app # remove a custom domain from app dokku domains:remove node-js-app dokku.me # set all custom domains for app dokku domains:set node-js-app dokku.me dokku.org","title":"Disabling VHOSTS"},{"location":"configuration/domains/#displaying-domains-reports-for-an-app","text":"New Introduced in 0.8.1 You can get a report about the app's domains status using the domains:report command: Shell Output dokku domains:report =====> node-js-app domains information Domains app enabled: true Domains app vhosts: node-js-app.dokku.org Domains global enabled: true Domains global vhosts: dokku.org =====> python-app domains information Domains app enabled: true Domains app vhosts: python-app.dokku.org Domains global enabled: true Domains global vhosts: dokku.org =====> ruby-app domains information Domains app enabled: true Domains app vhosts: ruby-app.dokku.org Domains global enabled: true Domains global vhosts: dokku.org You can run the command for a specific app also. Shell Output dokku domains:report node-js-app =====> node-js-app domains information Domains app enabled: true Domains app vhosts: node-js-app.dokku.org Domains global enabled: true Domains global vhosts: dokku.org You can pass flags which will output only the value of the specific information you want. For example: dokku domains:report node-js-app --domains-app-enabled","title":"Displaying domains reports for an app"},{"location":"configuration/domains/#default-site","text":"This is specific to your proxy plugin of choice. See the nginx documentation for more information on how to configure this for the default nginx proxy implementation.","title":"Default site"},{"location":"configuration/environment-variables/","text":"Environment Variables Typically an application will require some configuration to run properly. Dokku supports application configuration via environment variables. Environment variables may contain private data, such as passwords or API keys, so it is not recommended to store them in your application's repository. The config plugin provides the following commands to manage your variables: config:show (<app>|--global) Pretty-print an app or global environment config:bundle (<app>|--global) [--merged] Bundle environment into tarfile config:clear (<app>|--global) Clears environment variables config:export (<app>|--global) [--envfile] Export a global or app environment config:get (<app>|--global) KEY Display a global or app-specific config value config:keys (<app>|--global) [--merged] Show keys set in environment config:set [--encoded] [--no-restart] (<app>|--global) KEY1=VALUE1 [KEY2=VALUE2 ...] Set one or more config vars config:unset [--no-restart] (<app>|--global) KEY1 [KEY2 ...] Unset one or more config vars Info For security reasons - and as per docker recommendations - Dockerfile-based deploys have variables available only during runtime, as noted in this issue . Consider using build arguments to expose variables during build-time for Dockerfile apps. Environment variables are available both at run time and during the application build/compilation step for buildpack-based deploys. For buildpack deploys, Dokku will create a /app/.env file that can be used for legacy buildpacks. Note that this is not updated when config:set or config:unset is called, and is only written during a deploy or ps:rebuild . Developers are encouraged to instead read from the application environment directly, as the proper values will be available then. Note Global ENV files are sourced before app-specific ENV files. This means that app-specific variables will take precedence over global variables. Configuring your global ENV file is manual, and should be considered potentially dangerous as configuration applies to all applications. You can set multiple environment variables at once: Note Whitespace and special characters get tricky. If you are using dokku locally you don't need to do any special escaping. If you are using dokku over ssh you will need to backslash-escape spaces: dokku config:set node-js-app ENV = prod COMPILE_ASSETS = 1 dokku config:set node-js-app KEY = \"VAL\\ WITH\\ SPACES\" Dokku can also read base64 encoded values. That's the easiest way to set a value with newlines or spaces. To set a value with newlines you need to base64 encode it first and pass the --encoded flag: dokku config:set --encoded node-js-app KEY = \" $( base64 ~/.ssh/id_rsa ) \" When setting or unsetting environment variables, you may wish to avoid an application restart. This is useful when developing plugins or when setting multiple environment variables in a scripted manner. To do so, use the --no-restart flag: dokku config:set --no-restart node-js-app ENV = prod If you wish to have the variables output in an eval -compatible form, you can use the config:export command dokku config:export node-js-app # outputs variables in the form: # # export ENV='prod' # export COMPILE_ASSETS='1' # source in all the node-js-app app environment variables eval $( dokku config:export node-js-app ) You can control the format of the exported variables with the --format flag. --format=shell will output the variables in a single-line for usage in command-line utilities: dokku config:export --format shell node-js-app # outputs variables in the form: # # ENV='prod' COMPILE_ASSETS='1' Special Config Variables The following config variables have special meanings and can be set in a variety of ways. Unless specified via global app config, the values may not be passed into applications. Usage of these values within applications should be considered unsafe, as they are an internal configuration values that may be moved to the internal properties system in the future. Warning This list is not exhaustive, and may vary from version to version. Name Default How to modify Description DOKKU_ROOT ~dokku /etc/environment The root directory where dokku will store application repositories, as well as certain configuration files. DOKKU_IMAGE gliderlabs/herokuish /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The default image to use when building herokuish containers. Deprecated in favor of using buildpacks:set-property DOKKU_LIB_ROOT /var/lib/dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory where plugins, certain data, and general configuration is stored. PLUGIN_PATH $DOKKU_LIB_ROOT/plugins\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The top-level directory where plugins are stored. PLUGIN_AVAILABLE_PATH $PLUGIN_PATH/available\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that holds all available plugins, including core. PLUGIN_ENABLED_PATH $PLUGIN_PATH/enabled\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that holds all enabled plugins, including core. PLUGIN_CORE_PATH $DOKKU_LIB_ROOT/core-plugins\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that stores all core plugins. PLUGIN_CORE_AVAILABLE_PATH $PLUGIN_CORE_PATH/available\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that stores all available core plugins. PLUGIN_CORE_ENABLED_PATH $PLUGIN_CORE_PATH/enabled\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that stores all enabled core plugins. DOKKU_LOGS_DIR /var/log/dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Where dokku logs should be written to. DOKKU_LOGS_HOST_DIR $DOKKU_LOGS_DIR /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* A path on the host that will be mounted into the vector logging container. DOKKU_EVENTS_LOGFILE $DOKKU_LOGS_DIR/events.log /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Where the events log file is written to. DOKKU_APP_NAME none --app APP flag Name of application to work on. Respected by core plugins. DOKKU_APPS_FORCE_DELETE none --force flag Whether to force delete an application. Also used by other plugins for destructive actions. DOKKU_CHECKS_URL https://dokku.com/docs/deployment/zero-downtime-deploys/ /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Url displayed during deployment when no CHECKS file exists. DOKKU_DETACH_CONTAINER none --detach flag Deprecated: Whether to detach a container started via dokku run . DOKKU_QUIET_OUTPUT none --quiet flag Silences certain header output for dokku commands. DOKKU_RM_CONTAINER none dokku config:set Deprecated: Whether to keep dokku run containers around or not. DOKKU_TRACE none dokku trace:on dokku trace:off --trace flag Turn on very verbose debugging. DOKKU_APP_PROXY_TYPE nginx dokku proxy:set DOKKU_APP_RESTORE 1 dokku config:set dokku ps:stop DOKKU_APP_SHELL /bin/bash dokku config:set Allows users to change the default shell used by Dokku for dokku enter and execution of deployment tasks. DOKKU_APP_TYPE herokuish Auto-detected by using buildpacks or dockerfile DOKKU_CHECKS_DISABLED none dokku checks:disable DOKKU_CHECKS_ENABLED none dokku checks:enable DOKKU_CHECKS_SKIPPED none dokku checks:skip DOKKU_CHECKS_WAIT 5 dokku config:set Wait this many seconds for the container to start before running checks. DOKKU_CHECKS_TIMEOUT 30 dokku config:set Wait this many seconds for each response before marking it as a failure. DOKKU_CHECKS_ATTEMPTS 5 dokku config:set Number of retries for to run for a specific check before marking it as a failure DOKKU_DEFAULT_CHECKS_WAIT 10 dokku config:set If no user-defined checks are specified - or if the process being checked is not a web process - this is the period of time Dokku will wait before checking that a container is still running. DOKKU_DISABLE_PROXY none dokku proxy:disable dokku proxy:enable Disables the proxy in front of your application, resulting in publicly routing the docker container. DOKKU_DISABLE_ANSI_PREFIX_REMOVAL none dokku config:set /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Disables removal of the ANSI prefix during deploys. Can be used in cases where the client deployer does not understand ansi escape codes. DOKKU_DISABLE_APP_AUTOCREATION none dokku config:set Disables automatic creation of a non-existent app on deploy. DOKKU_DOCKER_STOP_TIMEOUT 10 dokku config:set Configurable grace period given to the docker stop command. If a container has not stopped by this time, a kill -9 signal or equivalent is sent in order to force-terminate the container. Both the ps:stop and apps:destroy commands also respect this value. If not specified, the docker defaults for the docker stop command will be used. DOKKU_DOCKERFILE_CACHE_BUILD none dokku config:set DOKKU_DOCKERFILE_PORTS dockerfile ports dokku config:set DOKKU_DOCKERFILE_START_CMD none dokku config:set DOKKU_PARALLEL_ARGUMENTS . none dokku config:set Allows passing custom arguments to parallel for ps:*all commands DOKKU_PROXY_PORT automatically assigned /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* dokku config:set DOKKU_PROXY_SSL_PORT automatically assigned /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* dokku config:set DOKKU_PROXY_PORT_MAP automatically assigned dokku proxy:ports-add dokku proxy:ports-remove , dokku proxy:ports-clear DOKKU_SKIP_ALL_CHECKS none dokku config:set DOKKU_SKIP_CLEANUP /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* When a deploy is triggered, if this is set to a non-empty value, then old docker containers and images will not be removed. DOKKU_SKIP_DEFAULT_CHECKS dokku config:set DOKKU_SKIP_DEPLOY dokku config:set DOKKU_START_CMD none dokku config:set Command to run instead of /start $PROC_TYPE DOKKU_SYSTEM_GROUP dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* System group to chown files as. DOKKU_SYSTEM_USER dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* System user to chown files as.","title":"Environment Variables"},{"location":"configuration/environment-variables/#environment-variables","text":"Typically an application will require some configuration to run properly. Dokku supports application configuration via environment variables. Environment variables may contain private data, such as passwords or API keys, so it is not recommended to store them in your application's repository. The config plugin provides the following commands to manage your variables: config:show (<app>|--global) Pretty-print an app or global environment config:bundle (<app>|--global) [--merged] Bundle environment into tarfile config:clear (<app>|--global) Clears environment variables config:export (<app>|--global) [--envfile] Export a global or app environment config:get (<app>|--global) KEY Display a global or app-specific config value config:keys (<app>|--global) [--merged] Show keys set in environment config:set [--encoded] [--no-restart] (<app>|--global) KEY1=VALUE1 [KEY2=VALUE2 ...] Set one or more config vars config:unset [--no-restart] (<app>|--global) KEY1 [KEY2 ...] Unset one or more config vars Info For security reasons - and as per docker recommendations - Dockerfile-based deploys have variables available only during runtime, as noted in this issue . Consider using build arguments to expose variables during build-time for Dockerfile apps. Environment variables are available both at run time and during the application build/compilation step for buildpack-based deploys. For buildpack deploys, Dokku will create a /app/.env file that can be used for legacy buildpacks. Note that this is not updated when config:set or config:unset is called, and is only written during a deploy or ps:rebuild . Developers are encouraged to instead read from the application environment directly, as the proper values will be available then. Note Global ENV files are sourced before app-specific ENV files. This means that app-specific variables will take precedence over global variables. Configuring your global ENV file is manual, and should be considered potentially dangerous as configuration applies to all applications. You can set multiple environment variables at once: Note Whitespace and special characters get tricky. If you are using dokku locally you don't need to do any special escaping. If you are using dokku over ssh you will need to backslash-escape spaces: dokku config:set node-js-app ENV = prod COMPILE_ASSETS = 1 dokku config:set node-js-app KEY = \"VAL\\ WITH\\ SPACES\" Dokku can also read base64 encoded values. That's the easiest way to set a value with newlines or spaces. To set a value with newlines you need to base64 encode it first and pass the --encoded flag: dokku config:set --encoded node-js-app KEY = \" $( base64 ~/.ssh/id_rsa ) \" When setting or unsetting environment variables, you may wish to avoid an application restart. This is useful when developing plugins or when setting multiple environment variables in a scripted manner. To do so, use the --no-restart flag: dokku config:set --no-restart node-js-app ENV = prod If you wish to have the variables output in an eval -compatible form, you can use the config:export command dokku config:export node-js-app # outputs variables in the form: # # export ENV='prod' # export COMPILE_ASSETS='1' # source in all the node-js-app app environment variables eval $( dokku config:export node-js-app ) You can control the format of the exported variables with the --format flag. --format=shell will output the variables in a single-line for usage in command-line utilities: dokku config:export --format shell node-js-app # outputs variables in the form: # # ENV='prod' COMPILE_ASSETS='1'","title":"Environment Variables"},{"location":"configuration/environment-variables/#special-config-variables","text":"The following config variables have special meanings and can be set in a variety of ways. Unless specified via global app config, the values may not be passed into applications. Usage of these values within applications should be considered unsafe, as they are an internal configuration values that may be moved to the internal properties system in the future. Warning This list is not exhaustive, and may vary from version to version. Name Default How to modify Description DOKKU_ROOT ~dokku /etc/environment The root directory where dokku will store application repositories, as well as certain configuration files. DOKKU_IMAGE gliderlabs/herokuish /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The default image to use when building herokuish containers. Deprecated in favor of using buildpacks:set-property DOKKU_LIB_ROOT /var/lib/dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory where plugins, certain data, and general configuration is stored. PLUGIN_PATH $DOKKU_LIB_ROOT/plugins\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The top-level directory where plugins are stored. PLUGIN_AVAILABLE_PATH $PLUGIN_PATH/available\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that holds all available plugins, including core. PLUGIN_ENABLED_PATH $PLUGIN_PATH/enabled\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that holds all enabled plugins, including core. PLUGIN_CORE_PATH $DOKKU_LIB_ROOT/core-plugins\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that stores all core plugins. PLUGIN_CORE_AVAILABLE_PATH $PLUGIN_CORE_PATH/available\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that stores all available core plugins. PLUGIN_CORE_ENABLED_PATH $PLUGIN_CORE_PATH/enabled\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that stores all enabled core plugins. DOKKU_LOGS_DIR /var/log/dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Where dokku logs should be written to. DOKKU_LOGS_HOST_DIR $DOKKU_LOGS_DIR /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* A path on the host that will be mounted into the vector logging container. DOKKU_EVENTS_LOGFILE $DOKKU_LOGS_DIR/events.log /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Where the events log file is written to. DOKKU_APP_NAME none --app APP flag Name of application to work on. Respected by core plugins. DOKKU_APPS_FORCE_DELETE none --force flag Whether to force delete an application. Also used by other plugins for destructive actions. DOKKU_CHECKS_URL https://dokku.com/docs/deployment/zero-downtime-deploys/ /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Url displayed during deployment when no CHECKS file exists. DOKKU_DETACH_CONTAINER none --detach flag Deprecated: Whether to detach a container started via dokku run . DOKKU_QUIET_OUTPUT none --quiet flag Silences certain header output for dokku commands. DOKKU_RM_CONTAINER none dokku config:set Deprecated: Whether to keep dokku run containers around or not. DOKKU_TRACE none dokku trace:on dokku trace:off --trace flag Turn on very verbose debugging. DOKKU_APP_PROXY_TYPE nginx dokku proxy:set DOKKU_APP_RESTORE 1 dokku config:set dokku ps:stop DOKKU_APP_SHELL /bin/bash dokku config:set Allows users to change the default shell used by Dokku for dokku enter and execution of deployment tasks. DOKKU_APP_TYPE herokuish Auto-detected by using buildpacks or dockerfile DOKKU_CHECKS_DISABLED none dokku checks:disable DOKKU_CHECKS_ENABLED none dokku checks:enable DOKKU_CHECKS_SKIPPED none dokku checks:skip DOKKU_CHECKS_WAIT 5 dokku config:set Wait this many seconds for the container to start before running checks. DOKKU_CHECKS_TIMEOUT 30 dokku config:set Wait this many seconds for each response before marking it as a failure. DOKKU_CHECKS_ATTEMPTS 5 dokku config:set Number of retries for to run for a specific check before marking it as a failure DOKKU_DEFAULT_CHECKS_WAIT 10 dokku config:set If no user-defined checks are specified - or if the process being checked is not a web process - this is the period of time Dokku will wait before checking that a container is still running. DOKKU_DISABLE_PROXY none dokku proxy:disable dokku proxy:enable Disables the proxy in front of your application, resulting in publicly routing the docker container. DOKKU_DISABLE_ANSI_PREFIX_REMOVAL none dokku config:set /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Disables removal of the ANSI prefix during deploys. Can be used in cases where the client deployer does not understand ansi escape codes. DOKKU_DISABLE_APP_AUTOCREATION none dokku config:set Disables automatic creation of a non-existent app on deploy. DOKKU_DOCKER_STOP_TIMEOUT 10 dokku config:set Configurable grace period given to the docker stop command. If a container has not stopped by this time, a kill -9 signal or equivalent is sent in order to force-terminate the container. Both the ps:stop and apps:destroy commands also respect this value. If not specified, the docker defaults for the docker stop command will be used. DOKKU_DOCKERFILE_CACHE_BUILD none dokku config:set DOKKU_DOCKERFILE_PORTS dockerfile ports dokku config:set DOKKU_DOCKERFILE_START_CMD none dokku config:set DOKKU_PARALLEL_ARGUMENTS . none dokku config:set Allows passing custom arguments to parallel for ps:*all commands DOKKU_PROXY_PORT automatically assigned /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* dokku config:set DOKKU_PROXY_SSL_PORT automatically assigned /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* dokku config:set DOKKU_PROXY_PORT_MAP automatically assigned dokku proxy:ports-add dokku proxy:ports-remove , dokku proxy:ports-clear DOKKU_SKIP_ALL_CHECKS none dokku config:set DOKKU_SKIP_CLEANUP /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* When a deploy is triggered, if this is set to a non-empty value, then old docker containers and images will not be removed. DOKKU_SKIP_DEFAULT_CHECKS dokku config:set DOKKU_SKIP_DEPLOY dokku config:set DOKKU_START_CMD none dokku config:set Command to run instead of /start $PROC_TYPE DOKKU_SYSTEM_GROUP dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* System group to chown files as. DOKKU_SYSTEM_USER dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* System user to chown files as.","title":"Special Config Variables"},{"location":"configuration/ssl/","text":"SSL Configuration New Introduced in 0.4.0 Dokku supports SSL/TLS certificate inspection and CSR/Self-signed certificate generation via the certs plugin. Note that whenever SSL/TLS support is enabled SPDY is also enabled. certs:add <app> CRT KEY # Add an ssl endpoint to an app. Can also import from a tarball on stdin. certs:generate <app> DOMAIN # Generate a key and certificate signing request (and self-signed certificate) certs:remove <app> # Remove an SSL Endpoint from an app. certs:report [<app>] [<flag>] # Displays an ssl report for one or more apps certs:show <app> <crt|key> # Show the server.crt or server.key on stdout certs:update <app> CRT KEY # Update an SSL Endpoint on an app. Can also import from a tarball on stdin # for 0.3.x dokku nginx:import-ssl <app> < certs.tar Info Adding an ssl certificate before deploying an application will result in port mappings being updated. This may cause issues for applications that use non-standard ports, as those may not be automatically detected. Please refer to the proxy documentation for information as to how to reconfigure the mappings. Per-application certificate management Dokku provides built-in support for managing SSL certificates on a per-application basis. SSL is managed via nginx outside of application containers, and as such can be updated on-the-fly without rebuilding containers. At this time, applications only support a single SSL certificate at a time. To support multiple domains for a single application, wildcard certificate usage is encouraged. Certificate setting The certs:add command can be used to push a tar containing a certificate .crt and .key file to a single application. The command should correctly handle cases where the .crt and .key are not named properly or are nested in a subdirectory of said tar file. You can import it as follows: tar cvf cert-key.tar server.crt server.key dokku certs:add node-js-app < cert-key.tar Note If your .crt file came alongside a .ca-bundle , you'll want to concatenate those into a single .crt file before adding it to the .tar . cat yourdomain_com.crt yourdomain_com.ca-bundle > server.crt SSL and Multiple Domains When an SSL certificate is associated to an application, the certificate will be associated with all domains currently associated with said application. Your certificate should be associated with all of those domains, otherwise accessing the application will result in SSL errors. If you wish to remove one of the domains from the application, refer to the domain configuration documentation . Note that with the default nginx template, requests will be redirected to the https version of the domain. If this is not the desired state of request resolution, you may customize the nginx template in use. For more details, see the nginx documentation . Certificate generation Note Using this method will create a self-signed certificate, which is only recommended for development or staging use, not production environments. The certs:generate command will walk you through the correct openssl commands to create a key, csr and a self-signed cert for a given app/domain. We automatically put the self-signed cert in place as well as add the specified domain to the application configuration. If you decide to obtain a CA signed certificate, you can import that certificate using the aforementioned dokku certs:add command. Certificate removal The certs:remove command only works on app-specific certificates. It will rm the app-specific tls directory, rebuild the nginx configuration, and reload nginx. Showing the certificate The certs:show command can be used to show your configured certs for an app. The show command can be used for example to export Let's Encrypt certificates after they've been generated. You can export it as follows: dokku certs:show node-js-app crt > server.crt dokku certs:show node-js-app key > server.key Displaying certificate reports for an app New Introduced in 0.8.1 You can get a report about the apps ssl status using the certs:report command: Shell Output dokku certs:report =====> node-js-app Ssl dir: /home/dokku/node-js-app/tls Ssl enabled: true Ssl hostnames: *.node-js-app.org node-js-app.org Ssl expires at: Oct 5 23:59:59 2019 GMT Ssl issuer: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited, CN=COMODO RSA Domain Validation Secure Server CA Ssl starts at: Oct 5 00:00:00 2016 GMT Ssl subject: OU=Domain Control Validated; OU=PositiveSSL Wildcard; CN=*.node-js-app.org Ssl verified: self signed. =====> python-app Ssl dir: /home/dokku/python-app/tls Ssl enabled: false Ssl hostnames: Ssl expires at: Ssl issuer: Ssl starts at: Ssl subject: Ssl verified: You can run the command for a specific app also. Shell Output dokku certs:report node-js-app =====> node-js-app ssl information Ssl dir: /home/dokku/node-js-app/tls Ssl enabled: true Ssl hostnames: *.dokku.org dokku.org Ssl expires at: Oct 5 23:59:59 2019 GMT Ssl issuer: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited, CN=COMODO RSA Domain Validation Secure Server CA Ssl starts at: Oct 5 00:00:00 2016 GMT Ssl subject: OU=Domain Control Validated; OU=PositiveSSL Wildcard; CN=*.dokku.org Ssl verified: self signed. You can pass flags which will output only the value of the specific information you want. For example: dokku certs:report node-js-app --ssl-enabled HSTS Header The HSTS header is an HTTP header that can inform browsers that all requests to a given site should be made via HTTPS. Dokku does enables this header by default for HTTPS requests. See the NGINX HSTS documentation for more information on how the HSTS configuration can be managed for your application. HTTP/2 support Certain versions of nginx have bugs that prevent HTTP/2 from properly responding to all clients, thus causing applications to be unavailable. For HTTP/2 to be enabled in your applications' nginx configs, you need to have installed nginx 1.11.5 or higher. See issue 2435 for more details. Running behind a load balancer Your application has access to the HTTP headers X-Forwarded-Proto , X-Forwarded-Port and X-Forwarded-For . These headers indicate the protocol of the original request (HTTP or HTTPS), the port number, and the IP address of the client making the request, respectively. The default configuration is for Nginx to set these headers. If your server runs behind an HTTP(S) load balancer, then Nginx will see all requests as coming from the load balancer. If your load balancer sets the X-Forwarded- headers, you can tell Nginx to pass these headers from load balancer to your application via nginx:set : dokku nginx:set node-js-app x-forwarded-for-value \"\\$http_x_forwarded_for\" dokku nginx:set node-js-app x-forwarded-port-value \"\\$http_x_forwarded_port\" dokku nginx:set node-js-app x-forwarded-proto-value \"\\$http_x_forwarded_proto\" Only use this option if: 1. All requests are terminated at the load balancer, and forwarded to Nginx 2. The load balancer is configured to send the X-Forwarded- headers (this may be off by default) If it's possible to make HTTP(S) requests directly to Nginx, bypassing the load balancer, or if the load balancer is not configured to set these headers, then it becomes possible for a client to set these headers to arbitrary values. The x-forwarded-ssl property may also be set for application frameworks that require this value. Note that this is a non-standard version of setting x-forwarded-proto to https , and should only be done as a last resort. # force-setting value to `on` dokku nginx:set node-js-app x-forwarded-ssl on # force-setting value to `off` dokku nginx:set node-js-app x-forwarded-ssl on # removing the value from nginx.conf (default) dokku nginx:set node-js-app x-forwarded-ssl SSL Port Exposure When your app is served from port 80 then the /home/dokku/APP/nginx.conf file will automatically be updated to instruct nginx to respond to ssl on port 443 as a new cert is added. If your app uses a non-standard port (perhaps you have a dockerfile deploy exposing port 99999 ) you may need to manually expose an ssl port via dokku proxy:ports-add <APP> https:443:99999 .","title":"SSL Configuration"},{"location":"configuration/ssl/#ssl-configuration","text":"New Introduced in 0.4.0 Dokku supports SSL/TLS certificate inspection and CSR/Self-signed certificate generation via the certs plugin. Note that whenever SSL/TLS support is enabled SPDY is also enabled. certs:add <app> CRT KEY # Add an ssl endpoint to an app. Can also import from a tarball on stdin. certs:generate <app> DOMAIN # Generate a key and certificate signing request (and self-signed certificate) certs:remove <app> # Remove an SSL Endpoint from an app. certs:report [<app>] [<flag>] # Displays an ssl report for one or more apps certs:show <app> <crt|key> # Show the server.crt or server.key on stdout certs:update <app> CRT KEY # Update an SSL Endpoint on an app. Can also import from a tarball on stdin # for 0.3.x dokku nginx:import-ssl <app> < certs.tar Info Adding an ssl certificate before deploying an application will result in port mappings being updated. This may cause issues for applications that use non-standard ports, as those may not be automatically detected. Please refer to the proxy documentation for information as to how to reconfigure the mappings.","title":"SSL Configuration"},{"location":"configuration/ssl/#per-application-certificate-management","text":"Dokku provides built-in support for managing SSL certificates on a per-application basis. SSL is managed via nginx outside of application containers, and as such can be updated on-the-fly without rebuilding containers. At this time, applications only support a single SSL certificate at a time. To support multiple domains for a single application, wildcard certificate usage is encouraged.","title":"Per-application certificate management"},{"location":"configuration/ssl/#certificate-setting","text":"The certs:add command can be used to push a tar containing a certificate .crt and .key file to a single application. The command should correctly handle cases where the .crt and .key are not named properly or are nested in a subdirectory of said tar file. You can import it as follows: tar cvf cert-key.tar server.crt server.key dokku certs:add node-js-app < cert-key.tar Note If your .crt file came alongside a .ca-bundle , you'll want to concatenate those into a single .crt file before adding it to the .tar . cat yourdomain_com.crt yourdomain_com.ca-bundle > server.crt","title":"Certificate setting"},{"location":"configuration/ssl/#ssl-and-multiple-domains","text":"When an SSL certificate is associated to an application, the certificate will be associated with all domains currently associated with said application. Your certificate should be associated with all of those domains, otherwise accessing the application will result in SSL errors. If you wish to remove one of the domains from the application, refer to the domain configuration documentation . Note that with the default nginx template, requests will be redirected to the https version of the domain. If this is not the desired state of request resolution, you may customize the nginx template in use. For more details, see the nginx documentation .","title":"SSL and Multiple Domains"},{"location":"configuration/ssl/#certificate-generation","text":"Note Using this method will create a self-signed certificate, which is only recommended for development or staging use, not production environments. The certs:generate command will walk you through the correct openssl commands to create a key, csr and a self-signed cert for a given app/domain. We automatically put the self-signed cert in place as well as add the specified domain to the application configuration. If you decide to obtain a CA signed certificate, you can import that certificate using the aforementioned dokku certs:add command.","title":"Certificate generation"},{"location":"configuration/ssl/#certificate-removal","text":"The certs:remove command only works on app-specific certificates. It will rm the app-specific tls directory, rebuild the nginx configuration, and reload nginx.","title":"Certificate removal"},{"location":"configuration/ssl/#showing-the-certificate","text":"The certs:show command can be used to show your configured certs for an app. The show command can be used for example to export Let's Encrypt certificates after they've been generated. You can export it as follows: dokku certs:show node-js-app crt > server.crt dokku certs:show node-js-app key > server.key","title":"Showing the certificate"},{"location":"configuration/ssl/#displaying-certificate-reports-for-an-app","text":"New Introduced in 0.8.1 You can get a report about the apps ssl status using the certs:report command: Shell Output dokku certs:report =====> node-js-app Ssl dir: /home/dokku/node-js-app/tls Ssl enabled: true Ssl hostnames: *.node-js-app.org node-js-app.org Ssl expires at: Oct 5 23:59:59 2019 GMT Ssl issuer: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited, CN=COMODO RSA Domain Validation Secure Server CA Ssl starts at: Oct 5 00:00:00 2016 GMT Ssl subject: OU=Domain Control Validated; OU=PositiveSSL Wildcard; CN=*.node-js-app.org Ssl verified: self signed. =====> python-app Ssl dir: /home/dokku/python-app/tls Ssl enabled: false Ssl hostnames: Ssl expires at: Ssl issuer: Ssl starts at: Ssl subject: Ssl verified: You can run the command for a specific app also. Shell Output dokku certs:report node-js-app =====> node-js-app ssl information Ssl dir: /home/dokku/node-js-app/tls Ssl enabled: true Ssl hostnames: *.dokku.org dokku.org Ssl expires at: Oct 5 23:59:59 2019 GMT Ssl issuer: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited, CN=COMODO RSA Domain Validation Secure Server CA Ssl starts at: Oct 5 00:00:00 2016 GMT Ssl subject: OU=Domain Control Validated; OU=PositiveSSL Wildcard; CN=*.dokku.org Ssl verified: self signed. You can pass flags which will output only the value of the specific information you want. For example: dokku certs:report node-js-app --ssl-enabled","title":"Displaying certificate reports for an app"},{"location":"configuration/ssl/#hsts-header","text":"The HSTS header is an HTTP header that can inform browsers that all requests to a given site should be made via HTTPS. Dokku does enables this header by default for HTTPS requests. See the NGINX HSTS documentation for more information on how the HSTS configuration can be managed for your application.","title":"HSTS Header"},{"location":"configuration/ssl/#http2-support","text":"Certain versions of nginx have bugs that prevent HTTP/2 from properly responding to all clients, thus causing applications to be unavailable. For HTTP/2 to be enabled in your applications' nginx configs, you need to have installed nginx 1.11.5 or higher. See issue 2435 for more details.","title":"HTTP/2 support"},{"location":"configuration/ssl/#running-behind-a-load-balancer","text":"Your application has access to the HTTP headers X-Forwarded-Proto , X-Forwarded-Port and X-Forwarded-For . These headers indicate the protocol of the original request (HTTP or HTTPS), the port number, and the IP address of the client making the request, respectively. The default configuration is for Nginx to set these headers. If your server runs behind an HTTP(S) load balancer, then Nginx will see all requests as coming from the load balancer. If your load balancer sets the X-Forwarded- headers, you can tell Nginx to pass these headers from load balancer to your application via nginx:set : dokku nginx:set node-js-app x-forwarded-for-value \"\\$http_x_forwarded_for\" dokku nginx:set node-js-app x-forwarded-port-value \"\\$http_x_forwarded_port\" dokku nginx:set node-js-app x-forwarded-proto-value \"\\$http_x_forwarded_proto\" Only use this option if: 1. All requests are terminated at the load balancer, and forwarded to Nginx 2. The load balancer is configured to send the X-Forwarded- headers (this may be off by default) If it's possible to make HTTP(S) requests directly to Nginx, bypassing the load balancer, or if the load balancer is not configured to set these headers, then it becomes possible for a client to set these headers to arbitrary values. The x-forwarded-ssl property may also be set for application frameworks that require this value. Note that this is a non-standard version of setting x-forwarded-proto to https , and should only be done as a last resort. # force-setting value to `on` dokku nginx:set node-js-app x-forwarded-ssl on # force-setting value to `off` dokku nginx:set node-js-app x-forwarded-ssl on # removing the value from nginx.conf (default) dokku nginx:set node-js-app x-forwarded-ssl","title":"Running behind a load balancer"},{"location":"configuration/ssl/#ssl-port-exposure","text":"When your app is served from port 80 then the /home/dokku/APP/nginx.conf file will automatically be updated to instruct nginx to respond to ssl on port 443 as a new cert is added. If your app uses a non-standard port (perhaps you have a dockerfile deploy exposing port 99999 ) you may need to manually expose an ssl port via dokku proxy:ports-add <APP> https:443:99999 .","title":"SSL Port Exposure"},{"location":"deployment/application-deployment/","text":"Deploying an Application Note This walkthrough uses the hostname dokku.me in commands. When deploying to your own server, you should substitute the domain dokku.me for the domain name or IP address associated with your server. Users of the Vagrant VM included with Dokku can use dokku.me which points to the IP of the VM. Deploy tutorial Once you have configured Dokku with at least one user, you can deploy applications using git push . To quickly see Dokku deployment in action, try using the Heroku Ruby on Rails \"Getting Started\" app . # from your local machine # SSH access to github must be enabled on this host git clone https://github.com/heroku/ruby-getting-started Create the app SSH into the Dokku host and create the application as follows: # on the Dokku host dokku apps:create ruby-getting-started Create the backing services Dokku by default does not provide datastores (e.g. MySQL, PostgreSQL) on a newly created app. You can add datastore support by installing plugins, and the Dokku project provides official plugins for common datastores. The Getting Started app requires a PostgreSQL service, so install the plugin and create the related service as follows: # on the Dokku host # install the postgres plugin # plugin installation requires root, hence the user change sudo dokku plugin:install https://github.com/dokku/dokku-postgres.git # create a postgres service with the name railsdatabase dokku postgres:create railsdatabase Each service may take a few moments to create. Linking backing services to applications Once the services have been created, you then set the DATABASE_URL environment variable by linking the service, as follows: # on the Dokku host # each official datastore offers a `link` method to link a service to any application dokku postgres:link railsdatabase ruby-getting-started Dokku supports linking a single service to multiple applications as well as linking only one service per application. Deploy the app Warning Your app should respect the PORT environment variable, otherwise it may not respond to web requests. You can find more information in the port management documentation .** Now you can deploy the ruby-getting-started app to your Dokku server. All you have to do is add a remote to name the app. Applications are created on-the-fly on the Dokku server. # from your local machine # the remote username *must* be dokku or pushes will fail cd ruby-getting-started git remote add dokku dokku@dokku.me:ruby-getting-started git push dokku main:master Note Some tools may not support the short-upstream syntax referenced above, and you may need to prefix the upstream with the scheme ssh:// like so: ssh://dokku@dokku.me:ruby-getting-started Please see the Git documentation for more details. Note Your private key should be registered with ssh-agent in your local development environment. If you get a permission denied error when pushing, you can register your private key as follows: ssh-add -k ~/<your private key> . After running git push dokku main:master , you should have output similar to this in your terminal: Counting objects: 231, done. Delta compression using up to 8 threads. Compressing objects: 100% (162/162), done. Writing objects: 100% (231/231), 36.96 KiB | 0 bytes/s, done. Total 231 (delta 93), reused 147 (delta 53) -----> Cleaning up... -----> Building ruby-getting-started from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.2.1 -----> Installing dependencies using 1.9.7 Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin -j4 --deployment Fetching gem metadata from https://rubygems.org/........... Fetching version metadata from https://rubygems.org/... Fetching dependency metadata from https://rubygems.org/.. Using rake 10.4.2 ... =====> Application deployed: http://ruby-getting-started.dokku.me Once the deploy is complete, the application's web URL will be generated as above. Dokku supports deploying applications in a few ways: Heroku buildpacks via Herokuish : See the herokuish buildpacks documentation to learn about the different ways to specify a buildpack. This is the default method used by Dokku. Dockerfile : See the dockerfile documentation to learn about the different ways to configure Dockerfile-based deploys. Docker Image : See the docker image documentation to learn about how to deploy a Docker Image. Setting up SSL Info While SSL certificates can be imported, automated SSL via Letsencrypt requires that all domains on an app correctly point at your server's public ip address. Please keep this in mind when using Letsencrypt. For many users, responding to requests via https will be desirable. Dokku has a complete ssl plugin built in that can be used to import SSL certificates (below is a short example, please refer to the ssl documentation for more information): dokku certs:add ruby-getting-started server.crt server.key As an alternative, the Dokku project offers an optional letsencrypt plugin that can be used to automate SSL certificate retrieval and renewal. # on the Dokku host # install the letsencrypt plugin # plugin installation requires root, hence the user change sudo dokku plugin:install https://github.com/dokku/dokku-letsencrypt.git # configure the plugin dokku config:set --global DOKKU_LETSENCRYPT_EMAIL = your-email@your.domain.com # set a custom domain that you own for your application dokku domains:set ruby-getting-started ruby-getting-started.your.domain.com # enable letsencrypt dokku letsencrypt:enable ruby-getting-started # enable auto-renewal dokku letsencrypt:cron-job --add Skipping deployment If you only want to rebuild and tag a container, you can skip the deployment phase by setting $DOKKU_SKIP_DEPLOY to true by running: # on the Dokku host dokku config:set ruby-getting-started DOKKU_SKIP_DEPLOY = true Redeploying or restarting If you need to redeploy or restart your app: # on the Dokku host dokku ps:rebuild ruby-getting-started See the process scaling documentation for more information on how to manage your app processes. Deploying with private Git submodules Dokku uses Git locally (i.e. not a Docker image) to build its own copy of your app repo, including submodules, as the dokku user. This means that in order to deploy private Git submodules, you need to put your deploy key in /home/dokku/.ssh/ and potentially add github.com (or your VCS host key) into /home/dokku/.ssh/known_hosts . You can use the following test to confirm your setup is correct: # on the Dokku host su - dokku ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts ssh -T git@github.com Warning if the buildpack or Dockerfile build process require SSH key access for other reasons, the above may not always apply. Deploying to subdomains If you do not enter a fully qualified domain name when pushing your app, Dokku deploys the app to <remotename>.yourdomain.tld as follows: Shell Output # from your local machine # the remote username *must* be dokku or pushes will fail # the below example assumes your app server domain or IP is dokku.me. Push in the form of: dokku@{serveripordomain}:{dokkuappname} git remote add dokku dokku@dokku.me:ruby-getting-started git push dokku main:master remote: -----> Application deployed: remote: http://ruby-getting-started.dokku.me You can also specify the fully qualified name as follows: Shell Output # from your local machine # the remote username *must* be dokku or pushes will fail git remote add dokku dokku@dokku.me:app.dokku.me git push dokku main:master remote: -----> Application deployed: remote: http://app.dokku.me This is useful when you want to deploy to the root domain: Shell Output # from your local machine # the remote username *must* be dokku or pushes will fail git remote add dokku dokku@dokku.me:dokku.me git push dokku main:master ... deployment ... remote: -----> Application deployed: remote: http://dokku.me Dokku/Docker container management compatibility Dokku is, at its core, a Docker container manager. Thus, it does not necessarily play well with other out-of-band processes interacting with the Docker daemon. Prior to every deployment, Dokku will execute a cleanup function. As of 0.5.x, the cleanup removes all containers with the dokku label where the status is either dead or exited (previous versions would remove all dead or exited containers). The cleanup function also removes all images with dangling status. Adding deploy users See the user management documentation for more information on how to manage users with access to your Dokku server. Default vhost See the domains documentation for more information on how to manage the default site. Deploying non-master branch See the Git documentation for more information on deploying a non-master branch to your application. Dockerfile deployment See the Dockerfile documentation for information Dokku's Dockerfile support. Image tagging See the image tagging documentation for more information on how Docker images can be tagged and deployed for a given application. Specifying a custom buildpack See the herokuish buildpack documentation for more information on how to specify a set of custom buildpacks for your application. Removing a deployed app See the application management documentation for more information on how to remove an application from your Dokku server. Renaming a deployed app See the application management documentation for more information on how an application can be renamed and the impact of doing so upon the application and associated resources. Zero downtime deploy See the zero-downtime deploy documentation for more information on how Dokku enables zero-downtime deploys.","title":"Deploying an Application"},{"location":"deployment/application-deployment/#deploying-an-application","text":"Note This walkthrough uses the hostname dokku.me in commands. When deploying to your own server, you should substitute the domain dokku.me for the domain name or IP address associated with your server. Users of the Vagrant VM included with Dokku can use dokku.me which points to the IP of the VM.","title":"Deploying an Application"},{"location":"deployment/application-deployment/#deploy-tutorial","text":"Once you have configured Dokku with at least one user, you can deploy applications using git push . To quickly see Dokku deployment in action, try using the Heroku Ruby on Rails \"Getting Started\" app . # from your local machine # SSH access to github must be enabled on this host git clone https://github.com/heroku/ruby-getting-started","title":"Deploy tutorial"},{"location":"deployment/application-deployment/#create-the-app","text":"SSH into the Dokku host and create the application as follows: # on the Dokku host dokku apps:create ruby-getting-started","title":"Create the app"},{"location":"deployment/application-deployment/#create-the-backing-services","text":"Dokku by default does not provide datastores (e.g. MySQL, PostgreSQL) on a newly created app. You can add datastore support by installing plugins, and the Dokku project provides official plugins for common datastores. The Getting Started app requires a PostgreSQL service, so install the plugin and create the related service as follows: # on the Dokku host # install the postgres plugin # plugin installation requires root, hence the user change sudo dokku plugin:install https://github.com/dokku/dokku-postgres.git # create a postgres service with the name railsdatabase dokku postgres:create railsdatabase Each service may take a few moments to create.","title":"Create the backing services"},{"location":"deployment/application-deployment/#linking-backing-services-to-applications","text":"Once the services have been created, you then set the DATABASE_URL environment variable by linking the service, as follows: # on the Dokku host # each official datastore offers a `link` method to link a service to any application dokku postgres:link railsdatabase ruby-getting-started Dokku supports linking a single service to multiple applications as well as linking only one service per application.","title":"Linking backing services to applications"},{"location":"deployment/application-deployment/#deploy-the-app","text":"Warning Your app should respect the PORT environment variable, otherwise it may not respond to web requests. You can find more information in the port management documentation .** Now you can deploy the ruby-getting-started app to your Dokku server. All you have to do is add a remote to name the app. Applications are created on-the-fly on the Dokku server. # from your local machine # the remote username *must* be dokku or pushes will fail cd ruby-getting-started git remote add dokku dokku@dokku.me:ruby-getting-started git push dokku main:master Note Some tools may not support the short-upstream syntax referenced above, and you may need to prefix the upstream with the scheme ssh:// like so: ssh://dokku@dokku.me:ruby-getting-started Please see the Git documentation for more details. Note Your private key should be registered with ssh-agent in your local development environment. If you get a permission denied error when pushing, you can register your private key as follows: ssh-add -k ~/<your private key> . After running git push dokku main:master , you should have output similar to this in your terminal: Counting objects: 231, done. Delta compression using up to 8 threads. Compressing objects: 100% (162/162), done. Writing objects: 100% (231/231), 36.96 KiB | 0 bytes/s, done. Total 231 (delta 93), reused 147 (delta 53) -----> Cleaning up... -----> Building ruby-getting-started from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.2.1 -----> Installing dependencies using 1.9.7 Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin -j4 --deployment Fetching gem metadata from https://rubygems.org/........... Fetching version metadata from https://rubygems.org/... Fetching dependency metadata from https://rubygems.org/.. Using rake 10.4.2 ... =====> Application deployed: http://ruby-getting-started.dokku.me Once the deploy is complete, the application's web URL will be generated as above. Dokku supports deploying applications in a few ways: Heroku buildpacks via Herokuish : See the herokuish buildpacks documentation to learn about the different ways to specify a buildpack. This is the default method used by Dokku. Dockerfile : See the dockerfile documentation to learn about the different ways to configure Dockerfile-based deploys. Docker Image : See the docker image documentation to learn about how to deploy a Docker Image.","title":"Deploy the app"},{"location":"deployment/application-deployment/#setting-up-ssl","text":"Info While SSL certificates can be imported, automated SSL via Letsencrypt requires that all domains on an app correctly point at your server's public ip address. Please keep this in mind when using Letsencrypt. For many users, responding to requests via https will be desirable. Dokku has a complete ssl plugin built in that can be used to import SSL certificates (below is a short example, please refer to the ssl documentation for more information): dokku certs:add ruby-getting-started server.crt server.key As an alternative, the Dokku project offers an optional letsencrypt plugin that can be used to automate SSL certificate retrieval and renewal. # on the Dokku host # install the letsencrypt plugin # plugin installation requires root, hence the user change sudo dokku plugin:install https://github.com/dokku/dokku-letsencrypt.git # configure the plugin dokku config:set --global DOKKU_LETSENCRYPT_EMAIL = your-email@your.domain.com # set a custom domain that you own for your application dokku domains:set ruby-getting-started ruby-getting-started.your.domain.com # enable letsencrypt dokku letsencrypt:enable ruby-getting-started # enable auto-renewal dokku letsencrypt:cron-job --add","title":"Setting up SSL"},{"location":"deployment/application-deployment/#skipping-deployment","text":"If you only want to rebuild and tag a container, you can skip the deployment phase by setting $DOKKU_SKIP_DEPLOY to true by running: # on the Dokku host dokku config:set ruby-getting-started DOKKU_SKIP_DEPLOY = true","title":"Skipping deployment"},{"location":"deployment/application-deployment/#redeploying-or-restarting","text":"If you need to redeploy or restart your app: # on the Dokku host dokku ps:rebuild ruby-getting-started See the process scaling documentation for more information on how to manage your app processes.","title":"Redeploying or restarting"},{"location":"deployment/application-deployment/#deploying-with-private-git-submodules","text":"Dokku uses Git locally (i.e. not a Docker image) to build its own copy of your app repo, including submodules, as the dokku user. This means that in order to deploy private Git submodules, you need to put your deploy key in /home/dokku/.ssh/ and potentially add github.com (or your VCS host key) into /home/dokku/.ssh/known_hosts . You can use the following test to confirm your setup is correct: # on the Dokku host su - dokku ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts ssh -T git@github.com Warning if the buildpack or Dockerfile build process require SSH key access for other reasons, the above may not always apply.","title":"Deploying with private Git submodules"},{"location":"deployment/application-deployment/#deploying-to-subdomains","text":"If you do not enter a fully qualified domain name when pushing your app, Dokku deploys the app to <remotename>.yourdomain.tld as follows: Shell Output # from your local machine # the remote username *must* be dokku or pushes will fail # the below example assumes your app server domain or IP is dokku.me. Push in the form of: dokku@{serveripordomain}:{dokkuappname} git remote add dokku dokku@dokku.me:ruby-getting-started git push dokku main:master remote: -----> Application deployed: remote: http://ruby-getting-started.dokku.me You can also specify the fully qualified name as follows: Shell Output # from your local machine # the remote username *must* be dokku or pushes will fail git remote add dokku dokku@dokku.me:app.dokku.me git push dokku main:master remote: -----> Application deployed: remote: http://app.dokku.me This is useful when you want to deploy to the root domain: Shell Output # from your local machine # the remote username *must* be dokku or pushes will fail git remote add dokku dokku@dokku.me:dokku.me git push dokku main:master ... deployment ... remote: -----> Application deployed: remote: http://dokku.me","title":"Deploying to subdomains"},{"location":"deployment/application-deployment/#dokkudocker-container-management-compatibility","text":"Dokku is, at its core, a Docker container manager. Thus, it does not necessarily play well with other out-of-band processes interacting with the Docker daemon. Prior to every deployment, Dokku will execute a cleanup function. As of 0.5.x, the cleanup removes all containers with the dokku label where the status is either dead or exited (previous versions would remove all dead or exited containers). The cleanup function also removes all images with dangling status.","title":"Dokku/Docker container management compatibility"},{"location":"deployment/application-deployment/#adding-deploy-users","text":"See the user management documentation for more information on how to manage users with access to your Dokku server.","title":"Adding deploy users"},{"location":"deployment/application-deployment/#default-vhost","text":"See the domains documentation for more information on how to manage the default site.","title":"Default vhost"},{"location":"deployment/application-deployment/#deploying-non-master-branch","text":"See the Git documentation for more information on deploying a non-master branch to your application.","title":"Deploying non-master branch"},{"location":"deployment/application-deployment/#dockerfile-deployment","text":"See the Dockerfile documentation for information Dokku's Dockerfile support.","title":"Dockerfile deployment"},{"location":"deployment/application-deployment/#image-tagging","text":"See the image tagging documentation for more information on how Docker images can be tagged and deployed for a given application.","title":"Image tagging"},{"location":"deployment/application-deployment/#specifying-a-custom-buildpack","text":"See the herokuish buildpack documentation for more information on how to specify a set of custom buildpacks for your application.","title":"Specifying a custom buildpack"},{"location":"deployment/application-deployment/#removing-a-deployed-app","text":"See the application management documentation for more information on how to remove an application from your Dokku server.","title":"Removing a deployed app"},{"location":"deployment/application-deployment/#renaming-a-deployed-app","text":"See the application management documentation for more information on how an application can be renamed and the impact of doing so upon the application and associated resources.","title":"Renaming a deployed app"},{"location":"deployment/application-deployment/#zero-downtime-deploy","text":"See the zero-downtime deploy documentation for more information on how Dokku enables zero-downtime deploys.","title":"Zero downtime deploy"},{"location":"deployment/application-management/","text":"Application Management New Introduced in 0.3.1 apps:clone <old-app> <new-app> # Clones an app apps:create <app> # Create a new app apps:destroy <app> # Permanently destroy an app apps:exists <app> # Checks if an app exists apps:list # List your apps apps:lock <app> # Locks an app for deployment apps:locked <app> # Checks if an app is locked for deployment apps:rename <old-app> <new-app> # Rename an app apps:report [<app>] [<flag>] # Display report about an app apps:unlock <app> # Unlocks an app for deployment Usage Listing applications New Introduced in 0.8.1. Use the apps command for older versions. You can easily list all available applications using the apps:list command: Shell Output dokku apps:list =====> My Apps node-js-app python-app Note that you can easily hide extra output from Dokku commands by using the --quiet flag, which makes it easier to parse on the command line. Shell Output dokku --quiet apps:list node-js-app python-app Checking if an application exists For CI/CD pipelines, it may be useful to see if an application exists before creating a \"review\" application for a specific branch. You can do so via the apps:exists command: Shell Output dokku apps:exists node-js-app App does not exist The apps:exists command will return non-zero if the application does not exist, and zero if it does. Manually creating an application A common pattern for deploying applications to Dokku is to configure an application before deploying it. You can do so via the apps:create command: Shell Output dokku apps:create node-js-app Creating node-js-app... done Once created, you can configure the application as normal, and deploy the application whenever ready. This is useful for cases where you may wish to do any of the following kinds of tasks: Configure domain names and SSL certificates. Create and link datastores. Set environment variables. Removing a deployed app In some cases, you may need to destroy an application, whether it is because the application is temporary or because it was misconfigured. In these cases, you can use the apps:destroy command. Performing any destructive actions in Dokku requires confirmation, and this command will ask for the name of the application being deleted before doing so. Shell Output dokku apps:destroy node-js-app ! WARNING: Potentially Destructive Action ! This command will destroy node-js-app (including all add-ons). ! To proceed, type \"node-js-app\" Destroying node-js-app (including all add-ons) Info node-js-app This will prompt you to verify the application's name before destroying it. You may also use the --force flag to circumvent this verification process: Shell Output dokku --force apps:destroy node-js-app Destroying node-js-app (including all add-ons) The --force flag can also be specified on the command vs globally: Shell Output dokku apps:destroy --force node-js-app Destroying node-js-app (including all add-ons) Destroying an application will unlink all linked services and destroy any config related to the application. Note that linked services will retain their data for later use (or removal). Renaming a deployed app New Introduced in 0.4.7 You can rename a deployed app using the apps:rename command. Note that the application must have been deployed at least once, or the rename will not complete successfully: Shell Output dokku apps:rename node-js-app io-js-app Destroying node-js-app (including all add-ons) -----> Cleaning up... -----> Building io-js-app from herokuish... -----> Adding BUILD_ENV to build environment... -----> Node.js app detected -----> Creating runtime environment ... =====> Application deployed: http://io-js-app.ci.dokku.me Renaming node-js-app to io-js-app... done This will copy all of your app's contents into a new app directory with the name of your choice, delete your old app, then rebuild the new version of the app and deploy it. All of your config variables, including database urls, will be preserved. By default, Dokku will deploy the renamed app, though you can skip the deploy by using the --skip-deploy flag: dokku apps:rename --skip-deploy node-js-app io-js-app Remember to also change your git remote on your local machine in order to make git push dokku main:master work again. For this you can use git remote set-url . git remote set-url dokku dokku@dokku.me:io-js-app Cloning an existing app New Introduced in 0.11.5 You can clone an existing app using the apps:clone command. Note that the application must have been deployed at least once, or cloning will not complete successfully: Shell Output dokku apps:clone node-js-app io-js-app Cloning node-js-app to io-js-app... done This will copy all of your app's contents into a new app directory with the name of your choice and then rebuild the new version of the app and deploy it with the following caveats: All of your environment variables, including database urls, will be preserved. Custom domains are not applied to the new app. SSL certificates will not be copied to the new app. Port mappings with the scheme https and host-port 443 will be skipped. Warning If you have exposed specific ports via docker-options plugin, or performed anything that cannot be done against multiple applications, apps:clone may result in errors. By default, Dokku will deploy this new app, though you can skip the deploy by using the --skip-deploy flag: dokku apps:clone --skip-deploy node-js-app io-js-app Finally, if the application already exists, you may wish to ignore errors resulting from attempting to clone over it. To do so, you can use the --ignore-existing flag. A warning will be emitted, but the command will return 0 . dokku apps:clone --ignore-existing node-js-app io-js-app Locking app deploys New Introduced in 0.11.6 If you wish to disable deploying for a period of time, this can be done via deploy locks. Normally, deploy locks exist only for the duration of a deploy so as to avoid deploys from colliding, but a deploy lock can be created by running the apps:lock command. Shell Output dokku apps:lock node-js-app -----> Deploy lock created Unlocking app deploys New Introduced in 0.11.6 In some cases, it may be necessary to remove an existing deploy lock. This can be performed via the apps:unlock command. Warning Removing the deploy lock will not stop in progress deploys. At this time, in progress deploys will need to be manually terminated by someone with server access. Shell Output dokku apps:unlock node-js-app ! A deploy may be in progress. ! Removing the app lock will not stop in progress deploys. -----> Deploy lock removed. Checking lock status New Introduced in 0.13.0 In some cases, you may wish to inspect the state of an app lock. To do so, you can issue an apps:lock command. This will exit non-zero if there is no app lock in place. Shell Output dokku apps:locked node-js-app Deploy lock does not exist Displaying reports for an app New Introduced in 0.8.1 You can get a report about the deployed apps using the apps:report command: Shell Output dokku apps:report =====> node-js-app app information App created at: 1635126111 App dir: /home/dokku/node-js-app App deploy source: git App deploy source metadata: cd7b8afccb202f222e7dc7b427553e71ba5ddafd App locked: false =====> python-sample app information App created at: 1635126000 App dir: /home/dokku/python-sample App deploy source: App deploy source metadata: App locked: false =====> ruby-sample app information App created at: 1635122462 App dir: /home/dokku/ruby-sample App deploy source: git App deploy source metadata: c60921ea2799ca108276414b95ea197f16798d51 App locked: false You can run the command for a specific app also. Shell Output dokku apps:report node-js-app =====> node-js-app app information App dir: /home/dokku/node-js-app App deploy source: git App deploy source metadata: cd7b8afccb202f222e7dc7b427553e71ba5ddafd App locked: false You can pass flags which will output only the value of the specific information you want. For example: dokku apps:report node-js-app --app-dir","title":"Application Management"},{"location":"deployment/application-management/#application-management","text":"New Introduced in 0.3.1 apps:clone <old-app> <new-app> # Clones an app apps:create <app> # Create a new app apps:destroy <app> # Permanently destroy an app apps:exists <app> # Checks if an app exists apps:list # List your apps apps:lock <app> # Locks an app for deployment apps:locked <app> # Checks if an app is locked for deployment apps:rename <old-app> <new-app> # Rename an app apps:report [<app>] [<flag>] # Display report about an app apps:unlock <app> # Unlocks an app for deployment","title":"Application Management"},{"location":"deployment/application-management/#usage","text":"","title":"Usage"},{"location":"deployment/application-management/#listing-applications","text":"New Introduced in 0.8.1. Use the apps command for older versions. You can easily list all available applications using the apps:list command: Shell Output dokku apps:list =====> My Apps node-js-app python-app Note that you can easily hide extra output from Dokku commands by using the --quiet flag, which makes it easier to parse on the command line. Shell Output dokku --quiet apps:list node-js-app python-app","title":"Listing applications"},{"location":"deployment/application-management/#checking-if-an-application-exists","text":"For CI/CD pipelines, it may be useful to see if an application exists before creating a \"review\" application for a specific branch. You can do so via the apps:exists command: Shell Output dokku apps:exists node-js-app App does not exist The apps:exists command will return non-zero if the application does not exist, and zero if it does.","title":"Checking if an application exists"},{"location":"deployment/application-management/#manually-creating-an-application","text":"A common pattern for deploying applications to Dokku is to configure an application before deploying it. You can do so via the apps:create command: Shell Output dokku apps:create node-js-app Creating node-js-app... done Once created, you can configure the application as normal, and deploy the application whenever ready. This is useful for cases where you may wish to do any of the following kinds of tasks: Configure domain names and SSL certificates. Create and link datastores. Set environment variables.","title":"Manually creating an application"},{"location":"deployment/application-management/#removing-a-deployed-app","text":"In some cases, you may need to destroy an application, whether it is because the application is temporary or because it was misconfigured. In these cases, you can use the apps:destroy command. Performing any destructive actions in Dokku requires confirmation, and this command will ask for the name of the application being deleted before doing so. Shell Output dokku apps:destroy node-js-app ! WARNING: Potentially Destructive Action ! This command will destroy node-js-app (including all add-ons). ! To proceed, type \"node-js-app\" Destroying node-js-app (including all add-ons) Info node-js-app This will prompt you to verify the application's name before destroying it. You may also use the --force flag to circumvent this verification process: Shell Output dokku --force apps:destroy node-js-app Destroying node-js-app (including all add-ons) The --force flag can also be specified on the command vs globally: Shell Output dokku apps:destroy --force node-js-app Destroying node-js-app (including all add-ons) Destroying an application will unlink all linked services and destroy any config related to the application. Note that linked services will retain their data for later use (or removal).","title":"Removing a deployed app"},{"location":"deployment/application-management/#renaming-a-deployed-app","text":"New Introduced in 0.4.7 You can rename a deployed app using the apps:rename command. Note that the application must have been deployed at least once, or the rename will not complete successfully: Shell Output dokku apps:rename node-js-app io-js-app Destroying node-js-app (including all add-ons) -----> Cleaning up... -----> Building io-js-app from herokuish... -----> Adding BUILD_ENV to build environment... -----> Node.js app detected -----> Creating runtime environment ... =====> Application deployed: http://io-js-app.ci.dokku.me Renaming node-js-app to io-js-app... done This will copy all of your app's contents into a new app directory with the name of your choice, delete your old app, then rebuild the new version of the app and deploy it. All of your config variables, including database urls, will be preserved. By default, Dokku will deploy the renamed app, though you can skip the deploy by using the --skip-deploy flag: dokku apps:rename --skip-deploy node-js-app io-js-app Remember to also change your git remote on your local machine in order to make git push dokku main:master work again. For this you can use git remote set-url . git remote set-url dokku dokku@dokku.me:io-js-app","title":"Renaming a deployed app"},{"location":"deployment/application-management/#cloning-an-existing-app","text":"New Introduced in 0.11.5 You can clone an existing app using the apps:clone command. Note that the application must have been deployed at least once, or cloning will not complete successfully: Shell Output dokku apps:clone node-js-app io-js-app Cloning node-js-app to io-js-app... done This will copy all of your app's contents into a new app directory with the name of your choice and then rebuild the new version of the app and deploy it with the following caveats: All of your environment variables, including database urls, will be preserved. Custom domains are not applied to the new app. SSL certificates will not be copied to the new app. Port mappings with the scheme https and host-port 443 will be skipped. Warning If you have exposed specific ports via docker-options plugin, or performed anything that cannot be done against multiple applications, apps:clone may result in errors. By default, Dokku will deploy this new app, though you can skip the deploy by using the --skip-deploy flag: dokku apps:clone --skip-deploy node-js-app io-js-app Finally, if the application already exists, you may wish to ignore errors resulting from attempting to clone over it. To do so, you can use the --ignore-existing flag. A warning will be emitted, but the command will return 0 . dokku apps:clone --ignore-existing node-js-app io-js-app","title":"Cloning an existing app"},{"location":"deployment/application-management/#locking-app-deploys","text":"New Introduced in 0.11.6 If you wish to disable deploying for a period of time, this can be done via deploy locks. Normally, deploy locks exist only for the duration of a deploy so as to avoid deploys from colliding, but a deploy lock can be created by running the apps:lock command. Shell Output dokku apps:lock node-js-app -----> Deploy lock created","title":"Locking app deploys"},{"location":"deployment/application-management/#unlocking-app-deploys","text":"New Introduced in 0.11.6 In some cases, it may be necessary to remove an existing deploy lock. This can be performed via the apps:unlock command. Warning Removing the deploy lock will not stop in progress deploys. At this time, in progress deploys will need to be manually terminated by someone with server access. Shell Output dokku apps:unlock node-js-app ! A deploy may be in progress. ! Removing the app lock will not stop in progress deploys. -----> Deploy lock removed.","title":"Unlocking app deploys"},{"location":"deployment/application-management/#checking-lock-status","text":"New Introduced in 0.13.0 In some cases, you may wish to inspect the state of an app lock. To do so, you can issue an apps:lock command. This will exit non-zero if there is no app lock in place. Shell Output dokku apps:locked node-js-app Deploy lock does not exist","title":"Checking lock status"},{"location":"deployment/application-management/#displaying-reports-for-an-app","text":"New Introduced in 0.8.1 You can get a report about the deployed apps using the apps:report command: Shell Output dokku apps:report =====> node-js-app app information App created at: 1635126111 App dir: /home/dokku/node-js-app App deploy source: git App deploy source metadata: cd7b8afccb202f222e7dc7b427553e71ba5ddafd App locked: false =====> python-sample app information App created at: 1635126000 App dir: /home/dokku/python-sample App deploy source: App deploy source metadata: App locked: false =====> ruby-sample app information App created at: 1635122462 App dir: /home/dokku/ruby-sample App deploy source: git App deploy source metadata: c60921ea2799ca108276414b95ea197f16798d51 App locked: false You can run the command for a specific app also. Shell Output dokku apps:report node-js-app =====> node-js-app app information App dir: /home/dokku/node-js-app App deploy source: git App deploy source metadata: cd7b8afccb202f222e7dc7b427553e71ba5ddafd App locked: false You can pass flags which will output only the value of the specific information you want. For example: dokku apps:report node-js-app --app-dir","title":"Displaying reports for an app"},{"location":"deployment/logs/","text":"Log Management logs <app> [-h|--help] [-t|--tail] [-n|--num num] [-q|--quiet] [-p|--ps process] # Display recent log output logs:failed [--all|<app>] # Shows the last failed deploy logs logs:report [<app>] [<flag>] # Displays a logs report for one or more apps logs:set [--global|<app>] <key> <value> # Set or clear a logs property for an app logs:vector-logs [--num num] [--tail] # Display vector log output logs:vector-start # Start the vector logging container logs:vector-stop # Stop the vector logging container Usage Application logs You can easily get logs of an app using the logs command: dokku logs node-js-app Logs are pulled via integration with the scheduler for the specified application via \"live tailing\". As such, logs from previously running deployments are usually not available. Users that desire to see logs from previous deployments for debugging purposes should persist those logs to external services. Please see Dokku's vector integration for more information on how to persist logs across deployments to ship logs to another service or a third-party platform. Behavioral modifiers Dokku also supports certain command-line arguments that augment the log command's behavior. -n, --num NUM # the number of lines to display -p, --ps PS # only display logs from the given process -t, --tail # continually stream logs -q, --quiet # display raw logs without colors, time and names You can use these modifiers as follows: dokku logs node-js-app -t -p web The above command will show logs continually from the web process. Failed deploy logs Warning The default docker-local scheduler will \"store\" these until the next deploy or until the old containers are garbage collected - whichever runs first. If you require the logs beyond this point in time, please ship the logs to a centralized log server. In some cases, it may be useful to retrieve the logs from a previously failed deploy. You can retrieve these logs by using the logs:failed command. dokku logs:failed node-js-app You may also fetch all failed app logs by using the --all flag. dokku logs:failed --all Docker Log Retention Docker log retention can be specified via the logs:set command by specifying a value for max-size . Log retention is set via injected docker options for all applications, but is also available via the logs-get-property trigger for alternative schedulers. dokku logs:set node-js-app max-size 20m The default value may be set by passing an empty value for the option: dokku logs:set node-js-app max-size Valid values include any integer number followed by a unit of measure ( k , m , or g ) or the string unlimited . Setting to unlimited will result in Dokku omitting the log option. The max-size property can also be set globally. The global default is 10m , and the global value is used when no app-specific value is set. dokku logs:set --global max-size 20m The default value may be set by passing an empty value for the option. dokku logs:set --global max-size Vector Logging Shipping New Introduced in 0.22.6 Vector is an open-source, lightweight and ultra-fast tool for building observability pipelines. Dokku integrates with it for shipping container logs for the docker-local scheduler. Users may configure log-shipping on a per-app or global basis, neither of which interfere with the dokku logs commands. Starting the Vector container Warning While the default vector image may be updated over time, this will not impact running vector containers. Users are encouraged to view any Dokku and Vector changelogs to ensure their system will continue running as expected. Vector may be started via the logs:vector-start command. dokku logs:vector-start This will start a new container named vector with Dokku's vector config mounted and ready for use. If a running container already exists, this command will do nothing. Additionally, if a container exists but is not running, this command will attempt to start the container. While the default vector image is hardcoded, users may specify an alternative via the --vector-image flag: dokku logs:vector-start --vector-image timberio/vector:latest-debian The vector container will be started with the following volume mounts: /var/lib/dokku/data/logs/vector.json:/etc/vector/vector.json /var/run/docker.sock:/var/run/docker.sock /var/log/dokku/apps:/var/log/dokku/apps The final volume mount - /var/log/dokku/apps - may be used for users that wish to ship logs to a file on disk that may be later logrotated. This directory is owned by the dokku user and group, with permissions set to 0755 . At this time, log-rotation is not configured for this directory. Stopping the Vector container Vector may be stopped via the logs:vector-stop command. dokku logs:vector-stop The vector container will be stopped and removed from the system. If the container is not running, this command will do nothing. Checking Vector's Logs It may be necessary to check the vector container's logs to ensure that vector is operating as expected. This can be performed with the logs:vector-logs command. dokku logs:vector-logs This command also supports the following modifiers: --num NUM # the number of lines to display --tail # continually stream logs You can use these modifiers as follows: dokku logs:vector-logs --tail --num 10 The above command will show logs continually from the vector container, with an initial history of 10 log lines Configuring a log sink Vector uses the concept of log \"sinks\" to send logs to a given endpoint. Log sinks may be configured globally or on a per-app basis by specifying a vector-sink in DSN form with the logs:set command. Specifying a sink value will reload any running vector container. # setting the sink value in quotes is encouraged to avoid # issues with ampersand encoding in shell commands dokku logs:set node-js-app vector-sink \"console://?encoding[codec]=json\" A sink may be removed by setting an empty value, which will also reload the running vector container. dokku logs:set node-js-app vector-sink Only one sink may be specified on a per-app basis at a given time. Log sinks can also be specified globally by specifying the --global flag to logs:set with no app name specified: dokku logs:set --global vector-sink \"console://?encoding[codec]=json\" As with app-specific sink settings, the global value may also be cleared by setting no value. dokku logs:set --global vector-sink Log Sink DSN Format The DSN form of a sink is as follows: SINK_TYPE://?SINK_OPTIONS Valid values for SINK_TYPE include all log vector log sinks, while SINK_OPTIONS is a query-string form for the sink's options. The following is a short description on how to set various values: bool : form: key=bool string : form: key=string int : form: key=int [string] : form: key[]=string [int] : form: key[]=int table : form: option[key]=value For some sinks - such as the http sink - it may be useful to use special characters such as & . These characters must be url escaped as per RFC 3986 . # the following command will set the `http` sink with a uri config value # for a uri config value: https://loggerservice.com:1234/?token=abc1234&type=vector # the url quoted version: https%3A//loggerservice.com%3A1234/%3Ftoken%3Dabc1234%26type%3Dvector dokku logs:set test vector-sink \"http://?uri=https%3A//loggerservice.com%3A1234/%3Ftoken%3Dabc1234%26type%3Dvector\" Please read the sink documentation for your sink of choice to configure the sink as desired.","title":"Log Management"},{"location":"deployment/logs/#log-management","text":"logs <app> [-h|--help] [-t|--tail] [-n|--num num] [-q|--quiet] [-p|--ps process] # Display recent log output logs:failed [--all|<app>] # Shows the last failed deploy logs logs:report [<app>] [<flag>] # Displays a logs report for one or more apps logs:set [--global|<app>] <key> <value> # Set or clear a logs property for an app logs:vector-logs [--num num] [--tail] # Display vector log output logs:vector-start # Start the vector logging container logs:vector-stop # Stop the vector logging container","title":"Log Management"},{"location":"deployment/logs/#usage","text":"","title":"Usage"},{"location":"deployment/logs/#application-logs","text":"You can easily get logs of an app using the logs command: dokku logs node-js-app Logs are pulled via integration with the scheduler for the specified application via \"live tailing\". As such, logs from previously running deployments are usually not available. Users that desire to see logs from previous deployments for debugging purposes should persist those logs to external services. Please see Dokku's vector integration for more information on how to persist logs across deployments to ship logs to another service or a third-party platform.","title":"Application logs"},{"location":"deployment/logs/#behavioral-modifiers","text":"Dokku also supports certain command-line arguments that augment the log command's behavior. -n, --num NUM # the number of lines to display -p, --ps PS # only display logs from the given process -t, --tail # continually stream logs -q, --quiet # display raw logs without colors, time and names You can use these modifiers as follows: dokku logs node-js-app -t -p web The above command will show logs continually from the web process.","title":"Behavioral modifiers"},{"location":"deployment/logs/#failed-deploy-logs","text":"Warning The default docker-local scheduler will \"store\" these until the next deploy or until the old containers are garbage collected - whichever runs first. If you require the logs beyond this point in time, please ship the logs to a centralized log server. In some cases, it may be useful to retrieve the logs from a previously failed deploy. You can retrieve these logs by using the logs:failed command. dokku logs:failed node-js-app You may also fetch all failed app logs by using the --all flag. dokku logs:failed --all","title":"Failed deploy logs"},{"location":"deployment/logs/#docker-log-retention","text":"Docker log retention can be specified via the logs:set command by specifying a value for max-size . Log retention is set via injected docker options for all applications, but is also available via the logs-get-property trigger for alternative schedulers. dokku logs:set node-js-app max-size 20m The default value may be set by passing an empty value for the option: dokku logs:set node-js-app max-size Valid values include any integer number followed by a unit of measure ( k , m , or g ) or the string unlimited . Setting to unlimited will result in Dokku omitting the log option. The max-size property can also be set globally. The global default is 10m , and the global value is used when no app-specific value is set. dokku logs:set --global max-size 20m The default value may be set by passing an empty value for the option. dokku logs:set --global max-size","title":"Docker Log Retention"},{"location":"deployment/logs/#vector-logging-shipping","text":"New Introduced in 0.22.6 Vector is an open-source, lightweight and ultra-fast tool for building observability pipelines. Dokku integrates with it for shipping container logs for the docker-local scheduler. Users may configure log-shipping on a per-app or global basis, neither of which interfere with the dokku logs commands.","title":"Vector Logging Shipping"},{"location":"deployment/logs/#starting-the-vector-container","text":"Warning While the default vector image may be updated over time, this will not impact running vector containers. Users are encouraged to view any Dokku and Vector changelogs to ensure their system will continue running as expected. Vector may be started via the logs:vector-start command. dokku logs:vector-start This will start a new container named vector with Dokku's vector config mounted and ready for use. If a running container already exists, this command will do nothing. Additionally, if a container exists but is not running, this command will attempt to start the container. While the default vector image is hardcoded, users may specify an alternative via the --vector-image flag: dokku logs:vector-start --vector-image timberio/vector:latest-debian The vector container will be started with the following volume mounts: /var/lib/dokku/data/logs/vector.json:/etc/vector/vector.json /var/run/docker.sock:/var/run/docker.sock /var/log/dokku/apps:/var/log/dokku/apps The final volume mount - /var/log/dokku/apps - may be used for users that wish to ship logs to a file on disk that may be later logrotated. This directory is owned by the dokku user and group, with permissions set to 0755 . At this time, log-rotation is not configured for this directory.","title":"Starting the Vector container"},{"location":"deployment/logs/#stopping-the-vector-container","text":"Vector may be stopped via the logs:vector-stop command. dokku logs:vector-stop The vector container will be stopped and removed from the system. If the container is not running, this command will do nothing.","title":"Stopping the Vector container"},{"location":"deployment/logs/#checking-vectors-logs","text":"It may be necessary to check the vector container's logs to ensure that vector is operating as expected. This can be performed with the logs:vector-logs command. dokku logs:vector-logs This command also supports the following modifiers: --num NUM # the number of lines to display --tail # continually stream logs You can use these modifiers as follows: dokku logs:vector-logs --tail --num 10 The above command will show logs continually from the vector container, with an initial history of 10 log lines","title":"Checking Vector's Logs"},{"location":"deployment/logs/#configuring-a-log-sink","text":"Vector uses the concept of log \"sinks\" to send logs to a given endpoint. Log sinks may be configured globally or on a per-app basis by specifying a vector-sink in DSN form with the logs:set command. Specifying a sink value will reload any running vector container. # setting the sink value in quotes is encouraged to avoid # issues with ampersand encoding in shell commands dokku logs:set node-js-app vector-sink \"console://?encoding[codec]=json\" A sink may be removed by setting an empty value, which will also reload the running vector container. dokku logs:set node-js-app vector-sink Only one sink may be specified on a per-app basis at a given time. Log sinks can also be specified globally by specifying the --global flag to logs:set with no app name specified: dokku logs:set --global vector-sink \"console://?encoding[codec]=json\" As with app-specific sink settings, the global value may also be cleared by setting no value. dokku logs:set --global vector-sink","title":"Configuring a log sink"},{"location":"deployment/logs/#log-sink-dsn-format","text":"The DSN form of a sink is as follows: SINK_TYPE://?SINK_OPTIONS Valid values for SINK_TYPE include all log vector log sinks, while SINK_OPTIONS is a query-string form for the sink's options. The following is a short description on how to set various values: bool : form: key=bool string : form: key=string int : form: key=int [string] : form: key[]=string [int] : form: key[]=int table : form: option[key]=value For some sinks - such as the http sink - it may be useful to use special characters such as & . These characters must be url escaped as per RFC 3986 . # the following command will set the `http` sink with a uri config value # for a uri config value: https://loggerservice.com:1234/?token=abc1234&type=vector # the url quoted version: https%3A//loggerservice.com%3A1234/%3Ftoken%3Dabc1234%26type%3Dvector dokku logs:set test vector-sink \"http://?uri=https%3A//loggerservice.com%3A1234/%3Ftoken%3Dabc1234%26type%3Dvector\" Please read the sink documentation for your sink of choice to configure the sink as desired.","title":"Log Sink DSN Format"},{"location":"deployment/remote-commands/","text":"Remote Commands Dokku commands can be run over SSH. Anywhere you would run dokku <command> , just run ssh -t dokku@dokku.me <command> The -t is used to request a pty. It is highly recommended to do so. To avoid the need to type the -t option each time, create/modify a section in the .ssh/config on the client side, as follows: Host dokku.me RequestTTY yes Behavioral modifiers Dokku also supports certain command line arguments that augment its behavior. If using these over SSH, you must use the form ssh -t dokku@dokku.me -- <command> to avoid SSH interpreting Dokku arguments for itself. --quiet suppress output headers --trace enable DOKKU_TRACE for current execution only --force force flag. currently used in apps:destroy and other \":destroy\" commands Official Client You may optionally use the official client when connecting to the Dokku server. Of all methods, this is the most official method of interacting with your Dokku installation. It is a bash script that interacts with a remote Dokku installation via ssh . It is available in contrib/dokku_client.sh in the root of the Dokku repository. It can be installed either via the Homebrew package manager (macOS only), or manually. Installation via Homebrew To install, simply run the following command: brew install dokku/repo/dokku Manual installation To install manually, simply clone the Dokku repository down and add the dokku alias pointing at the script: git clone git@github.com:dokku/dokku.git ~/.dokku # optional: make sure that the dokku_client.sh version matches your Dokku version cd ~/.dokku git checkout <tag/branch> # add the following to either your # .bashrc, .bash_profile, or .profile file alias dokku = '$HOME/.dokku/contrib/dokku_client.sh' Alternatively, if using another shell such as zsh , create an alias command which invokes the script using bash : # zsh: add the following to either .zshenv or .zshrc alias dokku = 'bash $HOME/.dokku/contrib/dokku_client.sh' # fish: add the following to ~/.config/fish/config.fish alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' # csh: add the following to .cshrc alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' Usage All commands have the application name automatically set via the --app flag on the remote server, and thus the app name does not need to be specified manually for core plugins. The client supports several environment variables: DOKKU_HOST (default: dokku git remote): Used to interact with a specific remote server. Can be overridden via the --remote flag. DOKKU_PORT (default: 22 ): Used to specify a port to connect to the Dokku server on. It also supports several flags (all flags unspecified here are passed as is to the server): --app : Override the remote app in use. --trace : Enable trace mode. --remote : Override the remote server. --global : Unsets the \"app\" value. May not be supported for the specified command. In addition, the following commands have special local side-effects: apps:create : If no local --app flag is specified or detected from a dokku git remote, a random name is generated and used for the app. The dokku git remote is set if not already set. apps:destroy : Removes the local dokku git remote if set. Unofficial Clients Please refer to the community clients list for more details.","title":"Remote Commands"},{"location":"deployment/remote-commands/#remote-commands","text":"Dokku commands can be run over SSH. Anywhere you would run dokku <command> , just run ssh -t dokku@dokku.me <command> The -t is used to request a pty. It is highly recommended to do so. To avoid the need to type the -t option each time, create/modify a section in the .ssh/config on the client side, as follows: Host dokku.me RequestTTY yes","title":"Remote Commands"},{"location":"deployment/remote-commands/#behavioral-modifiers","text":"Dokku also supports certain command line arguments that augment its behavior. If using these over SSH, you must use the form ssh -t dokku@dokku.me -- <command> to avoid SSH interpreting Dokku arguments for itself. --quiet suppress output headers --trace enable DOKKU_TRACE for current execution only --force force flag. currently used in apps:destroy and other \":destroy\" commands","title":"Behavioral modifiers"},{"location":"deployment/remote-commands/#official-client","text":"You may optionally use the official client when connecting to the Dokku server. Of all methods, this is the most official method of interacting with your Dokku installation. It is a bash script that interacts with a remote Dokku installation via ssh . It is available in contrib/dokku_client.sh in the root of the Dokku repository. It can be installed either via the Homebrew package manager (macOS only), or manually.","title":"Official Client"},{"location":"deployment/remote-commands/#installation-via-homebrew","text":"To install, simply run the following command: brew install dokku/repo/dokku","title":"Installation via Homebrew"},{"location":"deployment/remote-commands/#manual-installation","text":"To install manually, simply clone the Dokku repository down and add the dokku alias pointing at the script: git clone git@github.com:dokku/dokku.git ~/.dokku # optional: make sure that the dokku_client.sh version matches your Dokku version cd ~/.dokku git checkout <tag/branch> # add the following to either your # .bashrc, .bash_profile, or .profile file alias dokku = '$HOME/.dokku/contrib/dokku_client.sh' Alternatively, if using another shell such as zsh , create an alias command which invokes the script using bash : # zsh: add the following to either .zshenv or .zshrc alias dokku = 'bash $HOME/.dokku/contrib/dokku_client.sh' # fish: add the following to ~/.config/fish/config.fish alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' # csh: add the following to .cshrc alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh'","title":"Manual installation"},{"location":"deployment/remote-commands/#usage","text":"All commands have the application name automatically set via the --app flag on the remote server, and thus the app name does not need to be specified manually for core plugins. The client supports several environment variables: DOKKU_HOST (default: dokku git remote): Used to interact with a specific remote server. Can be overridden via the --remote flag. DOKKU_PORT (default: 22 ): Used to specify a port to connect to the Dokku server on. It also supports several flags (all flags unspecified here are passed as is to the server): --app : Override the remote app in use. --trace : Enable trace mode. --remote : Override the remote server. --global : Unsets the \"app\" value. May not be supported for the specified command. In addition, the following commands have special local side-effects: apps:create : If no local --app flag is specified or detected from a dokku git remote, a random name is generated and used for the app. The dokku git remote is set if not already set. apps:destroy : Removes the local dokku git remote if set.","title":"Usage"},{"location":"deployment/remote-commands/#unofficial-clients","text":"Please refer to the community clients list for more details.","title":"Unofficial Clients"},{"location":"deployment/user-management/","text":"User Management New Introduced in 0.7.0 ssh-keys:add <name> [/path/to/key] # Add a new public key by pipe or path ssh-keys:list [--format text|json] [<name>] # List of all authorized Dokku public ssh keys ssh-keys:remove [--fingerprint fingerprint|<name>] # Remove SSH public key by name When pushing to Dokku, SSH key-based authorization is the preferred authentication method, for ease of use and increased security. Users in Dokku are managed via the ~/dokku/.ssh/authorized_keys file. It is highly recommended that you follow the steps below to manage users on a Dokku server. Info Users of older versions of Dokku may use the sshcommand binary to manage keys instead of the ssh-keys plugin. Please refer to the Dokku documentation for your version for more details. Usage Listing SSH keys You can use the ssh-keys:list command to show all configured SSH keys. Shell Output dokku ssh-keys:list SHA256:ABC123ABC123+abc123abc123Zabc123abcZ123abc NAME=\"admin\" SSHCOMMAND_ALLOWED_KEYS=\"no-agent-forwarding,no-user-rc,no-X11-forwarding,no-port-forwarding\" The output contains the following information: SSH Key Fingerprint. The KEY_NAME . A comma separated list of SSH options under the SSHCOMMAND_ALLOWED_KEYS name. New Introduced in 0.20.2 The keys for a specific user may be listed by specifying a second argument to the ssh-keys:list command: dokku ssh-keys:list admin Info 0.22.3 The output format may be specified via the --format flag. Supported values include json and text . dokku ssh-keys:list --format json This can additionally be used to filter to keys for a particular user: dokku ssh-keys:list --format json admin Adding SSH keys You can add your public key to Dokku with the ssh-keys:add command. The output will be the fingerprint of the SSH key: Shell Output dokku ssh-keys:add KEY_NAME path/to/id_rsa.pub SHA256:ABC123ABC123+abc123abc123Zabc123abcZ123abc KEY_NAME is the name you want to use to refer to this particular key. Including the word admin in the name will grant the user privileges to add additional keys remotely. Info KEY_NAME is a unique name which is used to identify public keys. Attempting to re-use a key name will result in an error. The SSH (Git) user is always dokku , as this is the system user that the dokku binary uses to perform all its actions. Admin users and root can add keys remotely by specifying the dokku bin on their ssh command: cat ~/.ssh/id_rsa.pub | ssh root@dokku.me dokku ssh-keys:add KEY_NAME If you are using the Vagrant installation, you can also use the make vagrant-acl-add target to add your public key to Dokku (it will use your host username as the USER ): cat ~/.ssh/id_rsa.pub | make vagrant-acl-add Removing SSH keys As key names are unique, they can be used to remove a public SSH key. dokku ssh-keys:remove KEY_NAME An SSH Key can also be removed by fingerprint. dokku ssh-keys:remove --fingerprint FINGERPRINT Scoping commands to specific users Support for scoping commands to specific users can be added through plugins that take advantage of the user-auth plugin trigger to handle command authorization. See also the list of community-provided plugins . Granting other Unix user accounts Dokku access Any Unix user account which belongs to the sudo Unix group can run Dokku. However, you may want to give them Dokku access but not full sudo privileges. To allow other Unix user accounts to be able to run Dokku commands, without giving them full sudo access, modify your sudoers configuration. Use visudo /etc/sudoers.d/dokku-users , or visudo /etc/sudoers to add the following line: %dokku ALL=(ALL:ALL) NOPASSWD:SETENV: /usr/bin/dokku","title":"User Management"},{"location":"deployment/user-management/#user-management","text":"New Introduced in 0.7.0 ssh-keys:add <name> [/path/to/key] # Add a new public key by pipe or path ssh-keys:list [--format text|json] [<name>] # List of all authorized Dokku public ssh keys ssh-keys:remove [--fingerprint fingerprint|<name>] # Remove SSH public key by name When pushing to Dokku, SSH key-based authorization is the preferred authentication method, for ease of use and increased security. Users in Dokku are managed via the ~/dokku/.ssh/authorized_keys file. It is highly recommended that you follow the steps below to manage users on a Dokku server. Info Users of older versions of Dokku may use the sshcommand binary to manage keys instead of the ssh-keys plugin. Please refer to the Dokku documentation for your version for more details.","title":"User Management"},{"location":"deployment/user-management/#usage","text":"","title":"Usage"},{"location":"deployment/user-management/#listing-ssh-keys","text":"You can use the ssh-keys:list command to show all configured SSH keys. Shell Output dokku ssh-keys:list SHA256:ABC123ABC123+abc123abc123Zabc123abcZ123abc NAME=\"admin\" SSHCOMMAND_ALLOWED_KEYS=\"no-agent-forwarding,no-user-rc,no-X11-forwarding,no-port-forwarding\" The output contains the following information: SSH Key Fingerprint. The KEY_NAME . A comma separated list of SSH options under the SSHCOMMAND_ALLOWED_KEYS name. New Introduced in 0.20.2 The keys for a specific user may be listed by specifying a second argument to the ssh-keys:list command: dokku ssh-keys:list admin Info 0.22.3 The output format may be specified via the --format flag. Supported values include json and text . dokku ssh-keys:list --format json This can additionally be used to filter to keys for a particular user: dokku ssh-keys:list --format json admin","title":"Listing SSH keys"},{"location":"deployment/user-management/#adding-ssh-keys","text":"You can add your public key to Dokku with the ssh-keys:add command. The output will be the fingerprint of the SSH key: Shell Output dokku ssh-keys:add KEY_NAME path/to/id_rsa.pub SHA256:ABC123ABC123+abc123abc123Zabc123abcZ123abc KEY_NAME is the name you want to use to refer to this particular key. Including the word admin in the name will grant the user privileges to add additional keys remotely. Info KEY_NAME is a unique name which is used to identify public keys. Attempting to re-use a key name will result in an error. The SSH (Git) user is always dokku , as this is the system user that the dokku binary uses to perform all its actions. Admin users and root can add keys remotely by specifying the dokku bin on their ssh command: cat ~/.ssh/id_rsa.pub | ssh root@dokku.me dokku ssh-keys:add KEY_NAME If you are using the Vagrant installation, you can also use the make vagrant-acl-add target to add your public key to Dokku (it will use your host username as the USER ): cat ~/.ssh/id_rsa.pub | make vagrant-acl-add","title":"Adding SSH keys"},{"location":"deployment/user-management/#removing-ssh-keys","text":"As key names are unique, they can be used to remove a public SSH key. dokku ssh-keys:remove KEY_NAME An SSH Key can also be removed by fingerprint. dokku ssh-keys:remove --fingerprint FINGERPRINT","title":"Removing SSH keys"},{"location":"deployment/user-management/#scoping-commands-to-specific-users","text":"Support for scoping commands to specific users can be added through plugins that take advantage of the user-auth plugin trigger to handle command authorization. See also the list of community-provided plugins .","title":"Scoping commands to specific users"},{"location":"deployment/user-management/#granting-other-unix-user-accounts-dokku-access","text":"Any Unix user account which belongs to the sudo Unix group can run Dokku. However, you may want to give them Dokku access but not full sudo privileges. To allow other Unix user accounts to be able to run Dokku commands, without giving them full sudo access, modify your sudoers configuration. Use visudo /etc/sudoers.d/dokku-users , or visudo /etc/sudoers to add the following line: %dokku ALL=(ALL:ALL) NOPASSWD:SETENV: /usr/bin/dokku","title":"Granting other Unix user accounts Dokku access"},{"location":"deployment/zero-downtime-deploys/","text":"Zero Downtime Deploy Checks New Introduced in 0.5.0 checks:disable <app> [process-type(s)] Disable zero-downtime deployment for all processes (or comma-separated process-type list) ***WARNING: this will cause downtime during deployments*** checks:enable <app> [process-type(s)] Enable zero-downtime deployment for all processes (or comma-separated process-type list) checks:report [<app>] [<flag>] Displays a checks report for one or more apps checks:run <app> [process-type(s)] Runs zero-downtime checks for all processes (or comma-separated process-type list) checks:set [--global|<app>] <key> <value> Set or clear a logs property for an app checks:skip <app> [process-type(s)] Skip zero-downtime checks for all processes (or comma-separated process-type list) By default, Dokku will wait 10 seconds after starting each container before assuming it is up and proceeding with the deploy. Once this has occurred for all containers started by an application, traffic will be switched to point to your new containers. Dokku will also wait a further 60 seconds after the deploy is complete before terminating old containers in order to give time for long running connections to terminate. In either case, you may have more than one container running for a given application. You may both create user-defined checks for web processes using a CHECKS file, as well as customize any and all parts of this experience using the checks plugin. Info Web checks are performed via curl on Dokku host. Some application code - such as the Django framework - checks for specific hostnames or header values, these checks will fail. To avoid this: Remove such checks from your code: Modify your application to remove the hostname check completely. Allow checks from all hostnames: Modify your application to accept a dynamically provided hostname. Specify the domain within the check: See below for further documentation. Configuring checks settings wait-to-retire After a successful deploy, the grace period given to old containers before they are stopped/terminated is determined by the value of wait-to-retire . This is useful for ensuring completion of long-running HTTP connections. dokku checks:set node-js-app wait-to-retire 30 Defaults to 60 . Configuring check settings using the config plugin There are certain settings that can be configured via environment variables: DOKKU_DEFAULT_CHECKS_WAIT : (default: 10 ) If no user-defined checks are specified - or if the process being checked is not a web process - this is the period of time Dokku will wait before checking that a container is still running. DOKKU_DOCKER_STOP_TIMEOUT : (default: 10 ) Configurable grace period given to the docker stop command. If a container has not stopped by this time, a kill -9 signal or equivalent is sent in order to force-terminate the container. Both the ps:stop and apps:destroy commands also respect this value. If not specified, the Docker defaults for the docker stop command will be used. The following settings may also be specified in the CHECKS file, though are available as environment variables in order to ease application reuse. DOKKU_CHECKS_WAIT : (default: 5 ) Wait this many seconds for the container to start before running checks. DOKKU_CHECKS_TIMEOUT : (default: 30 ) Wait this many seconds for each response before marking it as a failure. DOKKU_CHECKS_ATTEMPTS : (default: 5 ) Number of retries for to run for a specific check before marking it as a failure Skipping and Disabling Checks Info Note that checks:disable will now (as of 0.6.0) cause downtime for that process-type during deployments. Previously, it acted as checks:skip currently does. You can choose to skip checks completely on a per-application/per-process basis. Skipping checks will avoid the default 10 second waiting period entirely, as well as any other user-defined checks. Shell Output # process type specification is optional dokku checks:skip node-js-app worker,web -----> Skipping zero downtime for app's (node-js-app) proctypes (worker,web) -----> Unsetting node-js-app -----> Unsetting DOKKU_CHECKS_DISABLED -----> Setting config vars DOKKU_CHECKS_SKIPPED: worker,web Zero downtime checks can also be disabled completely. This will stop old containers before new ones start, which may result in broken connections and downtime if your application fails to boot properly. Shell Output dokku checks:disable node-js-app worker -----> Disabling zero downtime for app's (node-js-app) proctypes (worker) -----> Setting config vars DOKKU_CHECKS_DISABLED: worker -----> Setting config vars DOKKU_CHECKS_SKIPPED: web Displaying checks reports for an app New Introduced in 0.8.1 You can get a report about the app's checks status using the checks:report command: Shell Output dokku checks:report =====> node-js-app checks information Checks disabled list: none Checks skipped list: none Checks computed wait to retire: 60 Checks global wait to retire: 60 Checks wait to retire: =====> python-app checks information Checks disabled list: none Checks skipped list: none Checks computed wait to retire: 60 Checks global wait to retire: 60 Checks wait to retire: =====> ruby-app checks information Checks disabled list: _all_ Checks skipped list: none Checks computed wait to retire: 60 Checks global wait to retire: 60 Checks wait to retire: You can run the command for a specific app also. Shell Output dokku checks:report node-js-app =====> node-js-app checks information Checks disabled list: none Checks skipped list: none Checks computed wait to retire: 60 Checks global wait to retire: 60 Checks wait to retire: You can pass flags which will output only the value of the specific information you want. For example: dokku checks:report node-js-app --checks-disabled-list Customizing checks If your application needs a longer period to boot up - perhaps to load data into memory, or because of slow boot time - you may also use Dokku's checks functionality to more precisely check whether an application can serve traffic or not. Checks are run against the detected web process from your application's Procfile . For non-web processes, Dokku will fallback to the aforementioned process uptime check. To specify checks, add a CHECKS file to the root of your project directory. The CHECKS file should be plain text and may contain: check instructions settings (NAME=VALUE) comments (lines starting with #) empty lines Info For Dockerfile and Docker Image based deploys, the file must be in the WORKDIR directory of the built image. /app is used by default as the root container directory for buildpack-based deploys. Check instructions The format of a check instruction is a path or relative URL, optionally followed by the expected content: /about Our Amazing Team The CHECKS file can contain multiple checks: / My Amazing App /stylesheets/index.css .body /scripts/index.js $(function() /images/logo.png To check an application that supports multiple hostnames, use relative URLs that include the hostname: //admin.dokku.me Admin Dashboard //static.dokku.me/logo.png You can also specify the protocol to explicitly check HTTPS requests: https://admin.dokku.me Admin Dashboard https://static.dokku.me/logo.png While a full URL may be used in order to invoke checks, if you are using relative URLs, the port must be omitted. Info Changed as of 0.22.5 Please note that dollar sign bracket characters ( { and } ) must be escaped when used within a CHECKS file. Escaping follows golang template rules. The proper way to do this is via one of the following methods: # escaping the `{` character # using double-quotes {{\"{\"}} # using raw string constants {{`{`}} # escaping the `}` character # using double-quotes {{\"}\"}} # using raw string constants {{`}`}} Templating Checks Files New Introduced in 0.22.5 An app's CHECKS file is sent through a single pass of the sigil templating tool. This enables usage of Golang templating within application CHECKS files. In addition to general templating access, access to app environment variables is also allowed via the var function: {{ var \"SOME_ENV_VAR\" }} This may be useful if certain zero-downtime checks require access to an app-specific value, such as a domain name. Check settings The default behavior is to wait for 5 seconds before running the checks, to timeout the checks after 30 seconds, and to attempt the checks 5 times. If the checks fail 5 times, the deployment is considered failed and the old container will continue serving traffic. You can change the default behavior by setting WAIT , TIMEOUT , and ATTEMPTS to different values in the CHECKS file: WAIT=30 # Wait 1/2 minute TIMEOUT=60 # Timeout after a minute ATTEMPTS=10 # Attempt checks 10 times / My Amazing App Manually invoking checks Checks can also be manually invoked via the checks:run command. This can be used to check the status of an application via cron to provide integration with external healthchecking software. Checks are run against a specific application: Shell Output dokku checks:run APP -----> Running pre-flight checks -----> Running checks for app (APP.web.1) For more efficient zero downtime deployments, create a file CHECKS. See https://dokku.com/docs/deployment/zero-downtime-deploys/ for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! -----> Running checks for app (APP.web.2) For more efficient zero downtime deployments, create a file CHECKS. See https://dokku.com/docs/deployment/zero-downtime-deploys/ for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! -----> Running checks for app (APP.worker.1) For more efficient zero downtime deployments, create a file CHECKS. See https://dokku.com/docs/deployment/zero-downtime-deploys/ for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! Checks can be scoped to a particular process type: Shell Output dokku checks:run node-js-app worker -----> Running pre-flight checks -----> Running checks for app (APP.worker.1) For more efficient zero downtime deployments, create a file CHECKS. See https://dokku.com/docs/deployment/zero-downtime-deploys/ for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! An app process ID may also be specified: Shell Output dokku checks:run node-js-app web.2 -----> Running pre-flight checks -----> Running checks for app (APP.web.2) For more efficient zero downtime deployments, create a file CHECKS. See https://dokku.com/docs/deployment/zero-downtime-deploys/ for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! Non-existent process types will result in an error: Shell Output dokku checks:run node-js-app non-existent -----> Running pre-flight checks Invalid process type specified (APP.non-existent) Non-existent process IDs will also result in an error Shell Output dokku checks:run node-js-app web.3 -----> Running pre-flight checks Invalid container id specified (APP.web.3) Example: Successful Rails deployment In this example, a Rails application is successfully deployed to Dokku. The initial round of checks fails while the server is starting, but once it starts they succeed and the deployment is successful. WAIT is set to 10 because our application takes a while to boot up. ATTEMPTS is set to 6 , but the third attempt succeeds. Successful CHECKS file WAIT=10 ATTEMPTS=6 /check.txt simple_check For this check to work, we've added a line to config/routes.rb that simply returns a string: get '/check.txt', to: proc {[200, {}, ['simple_check']]} Successful deploy output Note The output has been trimmed for brevity. Shell Output git push dokku master -----> Cleaning up... -----> Building node-js-app from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... -----> Discovering process types Procfile declares types -> web -----> Releasing node-js-app... -----> Deploying node-js-app... -----> Running pre-flight checks -----> Attempt 1/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" -----> All checks successful! =====> node-js-app container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop =====> end node-js-app container output -----> Running post-deploy -----> Configuring myapp.dokku.me... -----> Creating http nginx.conf Reloading nginx -----> Shutting down old container in 60 seconds =====> Application deployed: http://myapp.dokku.me Example: Failing Rails deployment In this example, a Rails application fails to deploy. The reason for the failure is that the PostgreSQL database connection fails. The initial checks will fail while we wait for the server to start up, just like in the above example. However, once the server does start accepting connections, we will see an error 500 due to the PostgreSQL database connection failure. Once the attempts have been exceeded, the deployment fails and we see the container output, which shows the PostgreSQL connection errors. Failing CHECKS file WAIT=10 ATTEMPTS=6 / Info The check to the root url / would normally access the database. Failing deploy output Note The output has been trimmed for brevity. Shell Output git push dokku master -----> Cleaning up... -----> Building node-js-app from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... Discovering process types Procfile declares types -> web Releasing node-js-app... Deploying node-js-app... Running pre-flight checks -----> Attempt 1/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 3/6 failed. -----> Attempt 4/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 4/6 failed. -----> Attempt 5/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 5/6 failed. -----> Attempt 6/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error Could not start due to 1 failed checks. ! Check attempt 6/6 failed. =====> node-js-app container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop Started GET \"/\" for 172.17.42.1 at 2015-03-26 21:36:47 +0000 Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? PG::ConnectionBad (could not connect to server: Connection refused Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? ): vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `connect' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:242:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `postgresql_connection =====> end node-js-app container output /usr/bin/dokku: line 49: 23409 Killed dokku deploy \"$APP\" To dokku@dokku.me:myapp ! [remote rejected] dokku -> master (pre-receive hook declined) error: failed to push some refs to 'dokku@dokku.me:myapp'","title":"Zero Downtime Deploy Checks"},{"location":"deployment/zero-downtime-deploys/#zero-downtime-deploy-checks","text":"New Introduced in 0.5.0 checks:disable <app> [process-type(s)] Disable zero-downtime deployment for all processes (or comma-separated process-type list) ***WARNING: this will cause downtime during deployments*** checks:enable <app> [process-type(s)] Enable zero-downtime deployment for all processes (or comma-separated process-type list) checks:report [<app>] [<flag>] Displays a checks report for one or more apps checks:run <app> [process-type(s)] Runs zero-downtime checks for all processes (or comma-separated process-type list) checks:set [--global|<app>] <key> <value> Set or clear a logs property for an app checks:skip <app> [process-type(s)] Skip zero-downtime checks for all processes (or comma-separated process-type list) By default, Dokku will wait 10 seconds after starting each container before assuming it is up and proceeding with the deploy. Once this has occurred for all containers started by an application, traffic will be switched to point to your new containers. Dokku will also wait a further 60 seconds after the deploy is complete before terminating old containers in order to give time for long running connections to terminate. In either case, you may have more than one container running for a given application. You may both create user-defined checks for web processes using a CHECKS file, as well as customize any and all parts of this experience using the checks plugin. Info Web checks are performed via curl on Dokku host. Some application code - such as the Django framework - checks for specific hostnames or header values, these checks will fail. To avoid this: Remove such checks from your code: Modify your application to remove the hostname check completely. Allow checks from all hostnames: Modify your application to accept a dynamically provided hostname. Specify the domain within the check: See below for further documentation.","title":"Zero Downtime Deploy Checks"},{"location":"deployment/zero-downtime-deploys/#configuring-checks-settings","text":"","title":"Configuring checks settings"},{"location":"deployment/zero-downtime-deploys/#wait-to-retire","text":"After a successful deploy, the grace period given to old containers before they are stopped/terminated is determined by the value of wait-to-retire . This is useful for ensuring completion of long-running HTTP connections. dokku checks:set node-js-app wait-to-retire 30 Defaults to 60 .","title":"wait-to-retire"},{"location":"deployment/zero-downtime-deploys/#configuring-check-settings-using-the-config-plugin","text":"There are certain settings that can be configured via environment variables: DOKKU_DEFAULT_CHECKS_WAIT : (default: 10 ) If no user-defined checks are specified - or if the process being checked is not a web process - this is the period of time Dokku will wait before checking that a container is still running. DOKKU_DOCKER_STOP_TIMEOUT : (default: 10 ) Configurable grace period given to the docker stop command. If a container has not stopped by this time, a kill -9 signal or equivalent is sent in order to force-terminate the container. Both the ps:stop and apps:destroy commands also respect this value. If not specified, the Docker defaults for the docker stop command will be used. The following settings may also be specified in the CHECKS file, though are available as environment variables in order to ease application reuse. DOKKU_CHECKS_WAIT : (default: 5 ) Wait this many seconds for the container to start before running checks. DOKKU_CHECKS_TIMEOUT : (default: 30 ) Wait this many seconds for each response before marking it as a failure. DOKKU_CHECKS_ATTEMPTS : (default: 5 ) Number of retries for to run for a specific check before marking it as a failure","title":"Configuring check settings using the config plugin"},{"location":"deployment/zero-downtime-deploys/#skipping-and-disabling-checks","text":"Info Note that checks:disable will now (as of 0.6.0) cause downtime for that process-type during deployments. Previously, it acted as checks:skip currently does. You can choose to skip checks completely on a per-application/per-process basis. Skipping checks will avoid the default 10 second waiting period entirely, as well as any other user-defined checks. Shell Output # process type specification is optional dokku checks:skip node-js-app worker,web -----> Skipping zero downtime for app's (node-js-app) proctypes (worker,web) -----> Unsetting node-js-app -----> Unsetting DOKKU_CHECKS_DISABLED -----> Setting config vars DOKKU_CHECKS_SKIPPED: worker,web Zero downtime checks can also be disabled completely. This will stop old containers before new ones start, which may result in broken connections and downtime if your application fails to boot properly. Shell Output dokku checks:disable node-js-app worker -----> Disabling zero downtime for app's (node-js-app) proctypes (worker) -----> Setting config vars DOKKU_CHECKS_DISABLED: worker -----> Setting config vars DOKKU_CHECKS_SKIPPED: web","title":"Skipping and Disabling Checks"},{"location":"deployment/zero-downtime-deploys/#displaying-checks-reports-for-an-app","text":"New Introduced in 0.8.1 You can get a report about the app's checks status using the checks:report command: Shell Output dokku checks:report =====> node-js-app checks information Checks disabled list: none Checks skipped list: none Checks computed wait to retire: 60 Checks global wait to retire: 60 Checks wait to retire: =====> python-app checks information Checks disabled list: none Checks skipped list: none Checks computed wait to retire: 60 Checks global wait to retire: 60 Checks wait to retire: =====> ruby-app checks information Checks disabled list: _all_ Checks skipped list: none Checks computed wait to retire: 60 Checks global wait to retire: 60 Checks wait to retire: You can run the command for a specific app also. Shell Output dokku checks:report node-js-app =====> node-js-app checks information Checks disabled list: none Checks skipped list: none Checks computed wait to retire: 60 Checks global wait to retire: 60 Checks wait to retire: You can pass flags which will output only the value of the specific information you want. For example: dokku checks:report node-js-app --checks-disabled-list","title":"Displaying checks reports for an app"},{"location":"deployment/zero-downtime-deploys/#customizing-checks","text":"If your application needs a longer period to boot up - perhaps to load data into memory, or because of slow boot time - you may also use Dokku's checks functionality to more precisely check whether an application can serve traffic or not. Checks are run against the detected web process from your application's Procfile . For non-web processes, Dokku will fallback to the aforementioned process uptime check. To specify checks, add a CHECKS file to the root of your project directory. The CHECKS file should be plain text and may contain: check instructions settings (NAME=VALUE) comments (lines starting with #) empty lines Info For Dockerfile and Docker Image based deploys, the file must be in the WORKDIR directory of the built image. /app is used by default as the root container directory for buildpack-based deploys.","title":"Customizing checks"},{"location":"deployment/zero-downtime-deploys/#check-instructions","text":"The format of a check instruction is a path or relative URL, optionally followed by the expected content: /about Our Amazing Team The CHECKS file can contain multiple checks: / My Amazing App /stylesheets/index.css .body /scripts/index.js $(function() /images/logo.png To check an application that supports multiple hostnames, use relative URLs that include the hostname: //admin.dokku.me Admin Dashboard //static.dokku.me/logo.png You can also specify the protocol to explicitly check HTTPS requests: https://admin.dokku.me Admin Dashboard https://static.dokku.me/logo.png While a full URL may be used in order to invoke checks, if you are using relative URLs, the port must be omitted. Info Changed as of 0.22.5 Please note that dollar sign bracket characters ( { and } ) must be escaped when used within a CHECKS file. Escaping follows golang template rules. The proper way to do this is via one of the following methods: # escaping the `{` character # using double-quotes {{\"{\"}} # using raw string constants {{`{`}} # escaping the `}` character # using double-quotes {{\"}\"}} # using raw string constants {{`}`}}","title":"Check instructions"},{"location":"deployment/zero-downtime-deploys/#templating-checks-files","text":"New Introduced in 0.22.5 An app's CHECKS file is sent through a single pass of the sigil templating tool. This enables usage of Golang templating within application CHECKS files. In addition to general templating access, access to app environment variables is also allowed via the var function: {{ var \"SOME_ENV_VAR\" }} This may be useful if certain zero-downtime checks require access to an app-specific value, such as a domain name.","title":"Templating Checks Files"},{"location":"deployment/zero-downtime-deploys/#check-settings","text":"The default behavior is to wait for 5 seconds before running the checks, to timeout the checks after 30 seconds, and to attempt the checks 5 times. If the checks fail 5 times, the deployment is considered failed and the old container will continue serving traffic. You can change the default behavior by setting WAIT , TIMEOUT , and ATTEMPTS to different values in the CHECKS file: WAIT=30 # Wait 1/2 minute TIMEOUT=60 # Timeout after a minute ATTEMPTS=10 # Attempt checks 10 times / My Amazing App","title":"Check settings"},{"location":"deployment/zero-downtime-deploys/#manually-invoking-checks","text":"Checks can also be manually invoked via the checks:run command. This can be used to check the status of an application via cron to provide integration with external healthchecking software. Checks are run against a specific application: Shell Output dokku checks:run APP -----> Running pre-flight checks -----> Running checks for app (APP.web.1) For more efficient zero downtime deployments, create a file CHECKS. See https://dokku.com/docs/deployment/zero-downtime-deploys/ for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! -----> Running checks for app (APP.web.2) For more efficient zero downtime deployments, create a file CHECKS. See https://dokku.com/docs/deployment/zero-downtime-deploys/ for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! -----> Running checks for app (APP.worker.1) For more efficient zero downtime deployments, create a file CHECKS. See https://dokku.com/docs/deployment/zero-downtime-deploys/ for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! Checks can be scoped to a particular process type: Shell Output dokku checks:run node-js-app worker -----> Running pre-flight checks -----> Running checks for app (APP.worker.1) For more efficient zero downtime deployments, create a file CHECKS. See https://dokku.com/docs/deployment/zero-downtime-deploys/ for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! An app process ID may also be specified: Shell Output dokku checks:run node-js-app web.2 -----> Running pre-flight checks -----> Running checks for app (APP.web.2) For more efficient zero downtime deployments, create a file CHECKS. See https://dokku.com/docs/deployment/zero-downtime-deploys/ for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! Non-existent process types will result in an error: Shell Output dokku checks:run node-js-app non-existent -----> Running pre-flight checks Invalid process type specified (APP.non-existent) Non-existent process IDs will also result in an error Shell Output dokku checks:run node-js-app web.3 -----> Running pre-flight checks Invalid container id specified (APP.web.3)","title":"Manually invoking checks"},{"location":"deployment/zero-downtime-deploys/#example-successful-rails-deployment","text":"In this example, a Rails application is successfully deployed to Dokku. The initial round of checks fails while the server is starting, but once it starts they succeed and the deployment is successful. WAIT is set to 10 because our application takes a while to boot up. ATTEMPTS is set to 6 , but the third attempt succeeds.","title":"Example: Successful Rails deployment"},{"location":"deployment/zero-downtime-deploys/#successful-checks-file","text":"WAIT=10 ATTEMPTS=6 /check.txt simple_check For this check to work, we've added a line to config/routes.rb that simply returns a string: get '/check.txt', to: proc {[200, {}, ['simple_check']]}","title":"Successful CHECKS file"},{"location":"deployment/zero-downtime-deploys/#successful-deploy-output","text":"Note The output has been trimmed for brevity. Shell Output git push dokku master -----> Cleaning up... -----> Building node-js-app from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... -----> Discovering process types Procfile declares types -> web -----> Releasing node-js-app... -----> Deploying node-js-app... -----> Running pre-flight checks -----> Attempt 1/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" -----> All checks successful! =====> node-js-app container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop =====> end node-js-app container output -----> Running post-deploy -----> Configuring myapp.dokku.me... -----> Creating http nginx.conf Reloading nginx -----> Shutting down old container in 60 seconds =====> Application deployed: http://myapp.dokku.me","title":"Successful deploy output"},{"location":"deployment/zero-downtime-deploys/#example-failing-rails-deployment","text":"In this example, a Rails application fails to deploy. The reason for the failure is that the PostgreSQL database connection fails. The initial checks will fail while we wait for the server to start up, just like in the above example. However, once the server does start accepting connections, we will see an error 500 due to the PostgreSQL database connection failure. Once the attempts have been exceeded, the deployment fails and we see the container output, which shows the PostgreSQL connection errors.","title":"Example: Failing Rails deployment"},{"location":"deployment/zero-downtime-deploys/#failing-checks-file","text":"WAIT=10 ATTEMPTS=6 / Info The check to the root url / would normally access the database.","title":"Failing CHECKS file"},{"location":"deployment/zero-downtime-deploys/#failing-deploy-output","text":"Note The output has been trimmed for brevity. Shell Output git push dokku master -----> Cleaning up... -----> Building node-js-app from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... Discovering process types Procfile declares types -> web Releasing node-js-app... Deploying node-js-app... Running pre-flight checks -----> Attempt 1/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 3/6 failed. -----> Attempt 4/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 4/6 failed. -----> Attempt 5/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 5/6 failed. -----> Attempt 6/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error Could not start due to 1 failed checks. ! Check attempt 6/6 failed. =====> node-js-app container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop Started GET \"/\" for 172.17.42.1 at 2015-03-26 21:36:47 +0000 Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? PG::ConnectionBad (could not connect to server: Connection refused Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? ): vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `connect' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:242:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `postgresql_connection =====> end node-js-app container output /usr/bin/dokku: line 49: 23409 Killed dokku deploy \"$APP\" To dokku@dokku.me:myapp ! [remote rejected] dokku -> master (pre-receive hook declined) error: failed to push some refs to 'dokku@dokku.me:myapp'","title":"Failing deploy output"},{"location":"deployment/builders/builder-management/","text":"Builder Management New Introduced in 0.24.0 builder:report [<app>] [<flag>] # Displays a builder report for one or more apps builder:set <app> <key> (<value>) # Set or clear a builder property for an app Builders are a way of customizing how an app is built from a source, allowing users flexibility in how artifacts are created for later scheduling. Usage Builder selection Dokku supports the following built-in builders: builder-dockerfile : Builds apps using a Dockerfile via docker build . See the dockerfile builder documentation for more information on how this builder functions. builder-herokuish : Builds apps with Heroku's v2a Buildpack specification via gliderlabs/herokuish . See the herokuish builder documentation for more information on how this builder functions. builder-lambda : Builds AWS Lambda functions in an environment simulating AWS Lambda runtimes via lambda-builder . See the lambda builder documentation for more information on how this builder functions. builder-null : Does nothing during the build phase. See the null builder documentation for more information on how this builder functions. builder-pack : Builds apps with Cloud Native Buildpacks via the pack-cli tool. See the cloud native buildpacks builder documentation for more information on how this builder functions. Builders run a detection script against a source code repository, and the first detected builder will be used to build the app artifact. The exception to this is when a Dockerfile is detected and the app is also able to use either herokuish or pack-cli for building, in which case one of the latter will be chosen. Overriding the auto-selected builder If desired, the builder can be specified via the builder:set command by speifying a value for selected . The selected builder will always be used. dokku builder:set node-js-app selected dockerfile The default value may be set by passing an empty value for the option: dokku builder:set node-js-app selected The selected property can also be set globally. The global default is an empty string, and auto-detection will be performed when no value is set per-app or globally. dokku builder:set --global selected herokuish The default value may be set by passing an empty value for the option. dokku builder:set --global selected Changing the build directory Warning Please keep in mind that setting a custom build directory will result in loss of any changes to the top-level directory, such as the git.keep-git-dir property. When deploying a monorepo, it may be desirable to specify the specific build directory to use for a given app. This can be done via the builder:set command. If a value is specified and that directory does not exist within the repository, the build will fail. dokku builder:set node-js-app build-dir app2 The default value may be set by passing an empty value for the option: dokku builder:set node-js-app build-dir The build-dir property can also be set globally. The global default is empty string, and the global value is used when no app-specific value is set. dokku builder:set --global build-dir app2 The default value may be set by passing an empty value for the option. dokku builder:set --global build-dir Displaying builder reports for an app You can get a report about the app's builder status using the builder:report command: Shell Output dokku builder:report =====> node-js-app builder information Builder build dir: custom Builder computed build dir: custom Builder computed selected: herokuish Builder global build dir: Builder global selected: herokuish Builder selected: herokuish =====> python-sample builder information Builder build dir: Builder computed build dir: Builder computed selected: dockerfile Builder global build dir: Builder global selected: herokuish Builder selected: dockerfile =====> ruby-sample builder information Builder build dir: Builder computed build dir: Builder computed selected: herokuish Builder global build dir: Builder global selected: herokuish Builder selected: You can run the command for a specific app also. Shell Output dokku builder:report node-js-app =====> node-js-app builder information Builder selected: herokuish You can pass flags which will output only the value of the specific information you want. For example: dokku builder:report node-js-app --builder-selected Custom builders To create a custom builder, the following triggers must be implemented: builder-build : arguments: BUILDER_TYPE APP SOURCECODE_WORK_DIR description: Creates a docker image named with the output of common#get_app_image_name $APP . builder-detect : arguments: APP SOURCECODE_WORK_DIR description: Outputs the name of the builder (without the builder- prefix) to use to build the app. builder-release : arguments: BUILDER_TYPE APP IMAGE_AG description: A post-build, pre-release trigger that can be used to post-process the image. Usually simply tags and labels the image appropriately. Custom plugins names must have the prefix builder- or builder overriding via builder:set may not function as expected. Builders can use any tools available on the system to build the docker image, and may even be used to schedule building off-server. The only current requirement is that the image must exist on the server at the end of the builder-build command, though this requirement may be relaxed in a future release. For a simple example of how to implement this trigger, see builder-pack , which utilizes a cli tool - pack-cli - to generate an OCI image that is compatible with Docker and can be scheduled by the official scheduling plugins.","title":"Builder Management"},{"location":"deployment/builders/builder-management/#builder-management","text":"New Introduced in 0.24.0 builder:report [<app>] [<flag>] # Displays a builder report for one or more apps builder:set <app> <key> (<value>) # Set or clear a builder property for an app Builders are a way of customizing how an app is built from a source, allowing users flexibility in how artifacts are created for later scheduling.","title":"Builder Management"},{"location":"deployment/builders/builder-management/#usage","text":"","title":"Usage"},{"location":"deployment/builders/builder-management/#builder-selection","text":"Dokku supports the following built-in builders: builder-dockerfile : Builds apps using a Dockerfile via docker build . See the dockerfile builder documentation for more information on how this builder functions. builder-herokuish : Builds apps with Heroku's v2a Buildpack specification via gliderlabs/herokuish . See the herokuish builder documentation for more information on how this builder functions. builder-lambda : Builds AWS Lambda functions in an environment simulating AWS Lambda runtimes via lambda-builder . See the lambda builder documentation for more information on how this builder functions. builder-null : Does nothing during the build phase. See the null builder documentation for more information on how this builder functions. builder-pack : Builds apps with Cloud Native Buildpacks via the pack-cli tool. See the cloud native buildpacks builder documentation for more information on how this builder functions. Builders run a detection script against a source code repository, and the first detected builder will be used to build the app artifact. The exception to this is when a Dockerfile is detected and the app is also able to use either herokuish or pack-cli for building, in which case one of the latter will be chosen.","title":"Builder selection"},{"location":"deployment/builders/builder-management/#overriding-the-auto-selected-builder","text":"If desired, the builder can be specified via the builder:set command by speifying a value for selected . The selected builder will always be used. dokku builder:set node-js-app selected dockerfile The default value may be set by passing an empty value for the option: dokku builder:set node-js-app selected The selected property can also be set globally. The global default is an empty string, and auto-detection will be performed when no value is set per-app or globally. dokku builder:set --global selected herokuish The default value may be set by passing an empty value for the option. dokku builder:set --global selected","title":"Overriding the auto-selected builder"},{"location":"deployment/builders/builder-management/#changing-the-build-directory","text":"Warning Please keep in mind that setting a custom build directory will result in loss of any changes to the top-level directory, such as the git.keep-git-dir property. When deploying a monorepo, it may be desirable to specify the specific build directory to use for a given app. This can be done via the builder:set command. If a value is specified and that directory does not exist within the repository, the build will fail. dokku builder:set node-js-app build-dir app2 The default value may be set by passing an empty value for the option: dokku builder:set node-js-app build-dir The build-dir property can also be set globally. The global default is empty string, and the global value is used when no app-specific value is set. dokku builder:set --global build-dir app2 The default value may be set by passing an empty value for the option. dokku builder:set --global build-dir","title":"Changing the build directory"},{"location":"deployment/builders/builder-management/#displaying-builder-reports-for-an-app","text":"You can get a report about the app's builder status using the builder:report command: Shell Output dokku builder:report =====> node-js-app builder information Builder build dir: custom Builder computed build dir: custom Builder computed selected: herokuish Builder global build dir: Builder global selected: herokuish Builder selected: herokuish =====> python-sample builder information Builder build dir: Builder computed build dir: Builder computed selected: dockerfile Builder global build dir: Builder global selected: herokuish Builder selected: dockerfile =====> ruby-sample builder information Builder build dir: Builder computed build dir: Builder computed selected: herokuish Builder global build dir: Builder global selected: herokuish Builder selected: You can run the command for a specific app also. Shell Output dokku builder:report node-js-app =====> node-js-app builder information Builder selected: herokuish You can pass flags which will output only the value of the specific information you want. For example: dokku builder:report node-js-app --builder-selected","title":"Displaying builder reports for an app"},{"location":"deployment/builders/builder-management/#custom-builders","text":"To create a custom builder, the following triggers must be implemented: builder-build : arguments: BUILDER_TYPE APP SOURCECODE_WORK_DIR description: Creates a docker image named with the output of common#get_app_image_name $APP . builder-detect : arguments: APP SOURCECODE_WORK_DIR description: Outputs the name of the builder (without the builder- prefix) to use to build the app. builder-release : arguments: BUILDER_TYPE APP IMAGE_AG description: A post-build, pre-release trigger that can be used to post-process the image. Usually simply tags and labels the image appropriately. Custom plugins names must have the prefix builder- or builder overriding via builder:set may not function as expected. Builders can use any tools available on the system to build the docker image, and may even be used to schedule building off-server. The only current requirement is that the image must exist on the server at the end of the builder-build command, though this requirement may be relaxed in a future release. For a simple example of how to implement this trigger, see builder-pack , which utilizes a cli tool - pack-cli - to generate an OCI image that is compatible with Docker and can be scheduled by the official scheduling plugins.","title":"Custom builders"},{"location":"deployment/builders/cloud-native-buildpacks/","text":"Cloud Native Buildpacks New Introduced in 0.22.0 builder-pack:report [<app>] [<flag>] # Displays a builder-pack report for one or more apps builder-pack:set <app> <key> (<value>) # Set or clear a builder-pack property for an app buildpacks:set-property [--global|<app>] <key> <value> # Set or clear a buildpacks property for an app Cloud Native Buildpacks are an evolution over the Buildpacks technology provided by the Herokuish builder. See the herokuish buildpacks documentation for more information on how to clear buildpack build cache for an application. Warning This functionality uses the pack cli from the Cloud Native Buildpacks project to build apps. As the integration is experimental in Dokku, it is likely to change over time. Usage Requirements The pack cli tool is not included by default with Dokku or as a dependency. It must also be installed as shown on this page . Builds will proceed with the pack cli for the app from then on. Caveats As this functionality is highly experimental, there are a number of caveats. Please note that not all issuesare listed below. Specifying specific buildpacks is not currently possible. A future release will add support for specifying buildpacks via the buildpacks plugin. There is currently no way to specify extra arguments for pack cli invocations. A future release will add support for injecting extra arguments during the build process. The default process type is web . Build cache is stored in Docker volumes instead of on disk. As such, repo:purge-cache currently has no effect. A future version will add integration with the repo plugin. pack is not currently included with Dokku, nor is it added as a package dependency. A future version will include it as a package dependency. Detection This builder will be auto-detected in either the following cases: The DOKKU_CNB_EXPERIMENTAL app environment variable is set to 1 . dokku config:set --no-restart node-js-app DOKKU_CNB_EXPERIMENTAL = 1 A project.toml file exists in the root of the app repository. This file is consumed by pack-cli and used to describe how the app is built. The builder can also be specified via the builder:set command: dokku builder:set node-js-app selected pack Info Dokku will only select the dockerfile builder if both the herokuish and pack builders are not detected and a Dockerfile exists. See the dockerfile builder documentation for more information on how that builder functions. Changing the project.toml location When deploying a monorepo, it may be desirable to specify the specific path of the project.toml file to use for a given app. This can be done via the builder-pack:set command. If a value other than project.toml is specified and that file does not exist in the app's build directory, Dokku will continue the build process as if the repository has no project.toml . dokku builder-pack:set node-js-app projecttoml-path project2.toml The default value may be set by passing an empty value for the option: dokku builder-pack:set node-js-app projecttoml-path The projecttoml-path property can also be set globally. The global default is project.toml , and the global value is used when no app-specific value is set. dokku builder-pack:set --global projecttoml-path project2.toml The default value may be set by passing an empty value for the option. dokku builder-pack:set --global projecttoml-path Displaying builder-pack reports for an app New Introduced in 0.25.0 You can get a report about the app's storage status using the builder-pack:report command: Shell Output dokku builder-pack:report =====> node-js-app builder-pack information Builder pack computed projecttoml path: project2.toml Builder pack global projecttoml path: project.toml Builder pack projecttoml path: project2.toml =====> python-sample builder-pack information Builder pack computed projecttoml path: project.toml Builder pack global projecttoml path: project.toml Builder pack projecttoml path: =====> ruby-sample builder-pack information Builder pack computed projecttoml path: project.toml Builder pack global projecttoml path: project.json Builder pack projecttoml path: You can run the command for a specific app also. Shell Output dokku builder-pack:report node-js-app =====> node-js-app builder-pack information Builder pack computed projecttoml path: project2.toml Builder pack global projecttoml path: project.toml Builder pack projecttoml path: project2.toml You can pass flags which will output only the value of the specific information you want. For example: Shell Output dokku builder-pack:report node-js-app --builder-pack-projecttoml-path project2.toml Customizing the Buildpack stack builder New Introduced in 0.23.0 The default stack builder in use by CNB buildpacks in Dokku is based on heroku/buildpacks . Users may desire to switch the stack builder to a custom version, either to update the operating system or to customize packages included with the stack builder. This can be performed via the buildpacks:set-property command. dokku buildpacks:set-property node-js-app stack paketobuildpacks/build:base-cnb The specified stack builder can also be unset by omitting the name of the stack builder when calling buildpacks:set-property . dokku buildpacks:set-property node-js-app stack A change in the stack builder value will execute the post-stack-set trigger. Finally, stack builders can be set or unset globally as a fallback. This will take precedence over a globally set DOKKU_CNB_BUILDER environment variable ( heroku/buildpacks by default). # set globally dokku buildpacks:set-property --global stack paketobuildpacks/build:base-cnb # unset globally dokku buildpacks:set-property --global stack","title":"Cloud Native Buildpacks"},{"location":"deployment/builders/cloud-native-buildpacks/#cloud-native-buildpacks","text":"New Introduced in 0.22.0 builder-pack:report [<app>] [<flag>] # Displays a builder-pack report for one or more apps builder-pack:set <app> <key> (<value>) # Set or clear a builder-pack property for an app buildpacks:set-property [--global|<app>] <key> <value> # Set or clear a buildpacks property for an app Cloud Native Buildpacks are an evolution over the Buildpacks technology provided by the Herokuish builder. See the herokuish buildpacks documentation for more information on how to clear buildpack build cache for an application. Warning This functionality uses the pack cli from the Cloud Native Buildpacks project to build apps. As the integration is experimental in Dokku, it is likely to change over time.","title":"Cloud Native Buildpacks"},{"location":"deployment/builders/cloud-native-buildpacks/#usage","text":"","title":"Usage"},{"location":"deployment/builders/cloud-native-buildpacks/#requirements","text":"The pack cli tool is not included by default with Dokku or as a dependency. It must also be installed as shown on this page . Builds will proceed with the pack cli for the app from then on.","title":"Requirements"},{"location":"deployment/builders/cloud-native-buildpacks/#caveats","text":"As this functionality is highly experimental, there are a number of caveats. Please note that not all issuesare listed below. Specifying specific buildpacks is not currently possible. A future release will add support for specifying buildpacks via the buildpacks plugin. There is currently no way to specify extra arguments for pack cli invocations. A future release will add support for injecting extra arguments during the build process. The default process type is web . Build cache is stored in Docker volumes instead of on disk. As such, repo:purge-cache currently has no effect. A future version will add integration with the repo plugin. pack is not currently included with Dokku, nor is it added as a package dependency. A future version will include it as a package dependency.","title":"Caveats"},{"location":"deployment/builders/cloud-native-buildpacks/#detection","text":"This builder will be auto-detected in either the following cases: The DOKKU_CNB_EXPERIMENTAL app environment variable is set to 1 . dokku config:set --no-restart node-js-app DOKKU_CNB_EXPERIMENTAL = 1 A project.toml file exists in the root of the app repository. This file is consumed by pack-cli and used to describe how the app is built. The builder can also be specified via the builder:set command: dokku builder:set node-js-app selected pack Info Dokku will only select the dockerfile builder if both the herokuish and pack builders are not detected and a Dockerfile exists. See the dockerfile builder documentation for more information on how that builder functions.","title":"Detection"},{"location":"deployment/builders/cloud-native-buildpacks/#changing-the-projecttoml-location","text":"When deploying a monorepo, it may be desirable to specify the specific path of the project.toml file to use for a given app. This can be done via the builder-pack:set command. If a value other than project.toml is specified and that file does not exist in the app's build directory, Dokku will continue the build process as if the repository has no project.toml . dokku builder-pack:set node-js-app projecttoml-path project2.toml The default value may be set by passing an empty value for the option: dokku builder-pack:set node-js-app projecttoml-path The projecttoml-path property can also be set globally. The global default is project.toml , and the global value is used when no app-specific value is set. dokku builder-pack:set --global projecttoml-path project2.toml The default value may be set by passing an empty value for the option. dokku builder-pack:set --global projecttoml-path","title":"Changing the project.toml location"},{"location":"deployment/builders/cloud-native-buildpacks/#displaying-builder-pack-reports-for-an-app","text":"New Introduced in 0.25.0 You can get a report about the app's storage status using the builder-pack:report command: Shell Output dokku builder-pack:report =====> node-js-app builder-pack information Builder pack computed projecttoml path: project2.toml Builder pack global projecttoml path: project.toml Builder pack projecttoml path: project2.toml =====> python-sample builder-pack information Builder pack computed projecttoml path: project.toml Builder pack global projecttoml path: project.toml Builder pack projecttoml path: =====> ruby-sample builder-pack information Builder pack computed projecttoml path: project.toml Builder pack global projecttoml path: project.json Builder pack projecttoml path: You can run the command for a specific app also. Shell Output dokku builder-pack:report node-js-app =====> node-js-app builder-pack information Builder pack computed projecttoml path: project2.toml Builder pack global projecttoml path: project.toml Builder pack projecttoml path: project2.toml You can pass flags which will output only the value of the specific information you want. For example: Shell Output dokku builder-pack:report node-js-app --builder-pack-projecttoml-path project2.toml","title":"Displaying builder-pack reports for an app"},{"location":"deployment/builders/cloud-native-buildpacks/#customizing-the-buildpack-stack-builder","text":"New Introduced in 0.23.0 The default stack builder in use by CNB buildpacks in Dokku is based on heroku/buildpacks . Users may desire to switch the stack builder to a custom version, either to update the operating system or to customize packages included with the stack builder. This can be performed via the buildpacks:set-property command. dokku buildpacks:set-property node-js-app stack paketobuildpacks/build:base-cnb The specified stack builder can also be unset by omitting the name of the stack builder when calling buildpacks:set-property . dokku buildpacks:set-property node-js-app stack A change in the stack builder value will execute the post-stack-set trigger. Finally, stack builders can be set or unset globally as a fallback. This will take precedence over a globally set DOKKU_CNB_BUILDER environment variable ( heroku/buildpacks by default). # set globally dokku buildpacks:set-property --global stack paketobuildpacks/build:base-cnb # unset globally dokku buildpacks:set-property --global stack","title":"Customizing the Buildpack stack builder"},{"location":"deployment/builders/dockerfiles/","text":"Dockerfile Deployment New Introduced in 0.3.15 builder-dockerfile:report [<app>] [<flag>] # Displays a builder-dockerfile report for one or more apps builder-dockerfile:set <app> <key> (<value>) # Set or clear a builder-dockerfile property for an app While Dokku normally defaults to using Heroku buildpacks for deployment, you can also use Docker's native Dockerfile system to define a container. Info Dockerfile support is considered a power user feature. By using Dockerfile-based deployment, you agree that you will not have the same comfort as that enjoyed by buildpack users, and Dokku features may work differently. Differences between the two systems will be documented here. Usage Detection This builder will be auto-detected in the following case: A Dockerfile exists in the root of the app repository. Dokku will only select the dockerfile builder if both the herokuish and pack builders are not detected and a Dockerfile exists. For more information on how those are detected, see the following links: Cloud Native Buildpacks documentation Herokuish documentation Switching from buildpack deployments If an application was previously deployed via buildpacks, the following commands should be run before a Dockerfile deploy will succeed: dokku config:unset --no-restart node-js-app DOKKU_PROXY_PORT_MAP Changing the Dockerfile location Info The previous method to perform this - via docker-options:add - should be removed in favor of the builder-dockerfile:set command outlined here. When deploying a monorepo, it may be desirable to specify the specific path of the Dockerfile file to use for a given app. This can be done via the builder-dockerfile:set command. If a value is specified and that file does not exist in the app's build directory, then the build will fail. dokku builder-dockerfile:set node-js-app dockerfile-path Dockerfile2 The default value may be set by passing an empty value for the option: dokku builder-dockerfile:set node-js-app dockerfile-path The dockerfile-path property can also be set globally. The global default is Dockerfile , and the global value is used when no app-specific value is set. dokku builder-dockerfile:set --global dockerfile-path Dockerfile2 The default value may be set by passing an empty value for the option. dokku builder-dockerfile:set --global dockerfile-path Displaying builder-dockerfile reports for an app New Introduced in 0.25.0 You can get a report about the app's storage status using the builder-dockerfile:report command: Shell Output dokku builder-dockerfile:report =====> node-js-app builder-dockerfile information Builder dockerfile computed dockerfile path: Dockerfile2 Builder dockerfile global dockerfile path: Dockerfile Builder dockerfile dockerfile path: Dockerfile2 =====> python-sample builder-dockerfile information Builder dockerfile computed dockerfile path: Dockerfile Builder dockerfile global dockerfile path: Dockerfile Builder dockerfile dockerfile path: =====> ruby-sample builder-dockerfile information Builder dockerfile computed dockerfile path: Dockerfile Builder dockerfile global dockerfile path: Dockerfile Builder dockerfile dockerfile path: You can run the command for a specific app also. Shell Output dokku builder-dockerfile:report node-js-app =====> node-js-app builder-dockerfile information Builder dockerfile computed dockerfile path: Dockerfile2 Builder dockerfile global dockerfile path: Dockerfile Builder dockerfile dockerfile path: Dockerfile2 You can pass flags which will output only the value of the specific information you want. For example: Shell Output dokku builder-dockerfile:report node-js-app --builder-dockerfile-dockerfile-path Dockerfile2 Build-time configuration variables For security reasons - and as per Docker recommendations - Dockerfile-based deploys have variables available only during runtime. For users that require customization in the build phase, you may use build arguments via the docker-options plugin : dokku docker-options:add node-js-app build '--build-arg NODE_ENV=production' Once set, the Dockerfile usage would be as follows: FROM ubuntu:18.04 # set the argument default ARG NODE_ENV = production # use the argument RUN echo $NODE_ENV You may also set the argument as an environment variable FROM ubuntu:18.04 # set the argument default ARG NODE_ENV = production # assign it to an environment variable # we can wrap the variable in brackets ENV NODE_ENV ${ NODE_ENV } # or omit them completely # use the argument RUN echo $NODE_ENV Building images with Docker Buildkit If your Dockerfile is using Docker engine's buildkit (not to be confused with buildpacks), then the DOCKER_BUILDKIT=1 environment variable needs to be set. Additionally, complete build log output can be forced via BUILDKIT_PROGRESS=plain . Both of these environment variables can be set as follows: echo \"export DOCKER_BUILDKIT=1\" | sudo tee -a /etc/default/dokku echo \"export BUILDKIT_PROGRESS=plain\" | sudo tee -a /etc/default/dokku Buildkit directory caching Buildkit implements the RUN --mount option, enabling mount directory caches for RUN directives. The following is an example that mounts debian packaging related directories, which can speed up fetching of remote package data. FROM debian:latest RUN --mount = target = /var/lib/apt/lists,type = cache \\ --mount = target = /var/cache/apt,type = cache \\ apt-get update \\ && DEBIAN_FRONTEND = noninteractive apt-get install -y --no-install-recommends \\ git Mount cache targets may vary depending on the tool in use, and users are encouraged to investigate the directories that apply for their language and framework. You would adjust the cache directory for whatever application cache you have, e.g. /root/.pnpm-store/v3 for pnpm, $HOME/.m2 for maven, or /root/.cache for golang. Customizing the run command By default no arguments are passed to docker run when deploying the container and the CMD or ENTRYPOINT defined in the Dockerfile are executed. You can take advantage of docker ability of overriding the CMD or passing parameters to your ENTRYPOINT setting $DOKKU_DOCKERFILE_START_CMD . Let's say for example you are deploying a base Node.js image, with the following ENTRYPOINT : ENTRYPOINT [ \"node\" ] You can do: dokku config:set node-js-app DOKKU_DOCKERFILE_START_CMD = \"--harmony server.js\" To tell Docker what to run. Setting $DOKKU_DOCKERFILE_CACHE_BUILD to true or false will enable or disable Docker's image layer cache. Lastly, for more granular build control, you may also pass any docker build option to docker , by setting $DOKKU_DOCKER_BUILD_OPTS . Procfiles and multiple processes New Introduced in 0.5.0 You can also customize the run command using a Procfile , much like you would on Heroku or with a buildpack deployed app. The Procfile should contain one or more lines defining process types and associated commands . When you deploy your app, a Docker image will be built. The Procfile will be extracted from the image (it must be in the folder defined in your Dockerfile as WORKDIR or /app ) and the commands in it will be passed to docker run to start your process(es). Here's an example Procfile : web : bin/run-prod.sh worker : bin/run-worker.sh And Dockerfile : FROM ubuntu:18.04 WORKDIR /app COPY . ./ CMD [ \"bin/run-dev.sh\" ] When you deploy this app the web process will automatically be scaled to 1 and your Docker container will be started basically using the command docker run bin/run-prod.sh . If you want to also run a worker container for this app, you can run dokku ps:scale worker=1 and a new container will be started by running docker run bin/run-worker.sh (the actual docker run commands are a bit more complex, but this is the basic idea). If you use an ENTRYPOINT in your Dockerfile , the lines in your Procfile will be passed as arguments to the ENTRYPOINT script instead of being executed. Exposed ports See the port management documentation for more information on how Dokku exposes ports for applications and how you can configure these for your app.","title":"Dockerfile Deployment"},{"location":"deployment/builders/dockerfiles/#dockerfile-deployment","text":"New Introduced in 0.3.15 builder-dockerfile:report [<app>] [<flag>] # Displays a builder-dockerfile report for one or more apps builder-dockerfile:set <app> <key> (<value>) # Set or clear a builder-dockerfile property for an app While Dokku normally defaults to using Heroku buildpacks for deployment, you can also use Docker's native Dockerfile system to define a container. Info Dockerfile support is considered a power user feature. By using Dockerfile-based deployment, you agree that you will not have the same comfort as that enjoyed by buildpack users, and Dokku features may work differently. Differences between the two systems will be documented here.","title":"Dockerfile Deployment"},{"location":"deployment/builders/dockerfiles/#usage","text":"","title":"Usage"},{"location":"deployment/builders/dockerfiles/#detection","text":"This builder will be auto-detected in the following case: A Dockerfile exists in the root of the app repository. Dokku will only select the dockerfile builder if both the herokuish and pack builders are not detected and a Dockerfile exists. For more information on how those are detected, see the following links: Cloud Native Buildpacks documentation Herokuish documentation","title":"Detection"},{"location":"deployment/builders/dockerfiles/#switching-from-buildpack-deployments","text":"If an application was previously deployed via buildpacks, the following commands should be run before a Dockerfile deploy will succeed: dokku config:unset --no-restart node-js-app DOKKU_PROXY_PORT_MAP","title":"Switching from buildpack deployments"},{"location":"deployment/builders/dockerfiles/#changing-the-dockerfile-location","text":"Info The previous method to perform this - via docker-options:add - should be removed in favor of the builder-dockerfile:set command outlined here. When deploying a monorepo, it may be desirable to specify the specific path of the Dockerfile file to use for a given app. This can be done via the builder-dockerfile:set command. If a value is specified and that file does not exist in the app's build directory, then the build will fail. dokku builder-dockerfile:set node-js-app dockerfile-path Dockerfile2 The default value may be set by passing an empty value for the option: dokku builder-dockerfile:set node-js-app dockerfile-path The dockerfile-path property can also be set globally. The global default is Dockerfile , and the global value is used when no app-specific value is set. dokku builder-dockerfile:set --global dockerfile-path Dockerfile2 The default value may be set by passing an empty value for the option. dokku builder-dockerfile:set --global dockerfile-path","title":"Changing the Dockerfile location"},{"location":"deployment/builders/dockerfiles/#displaying-builder-dockerfile-reports-for-an-app","text":"New Introduced in 0.25.0 You can get a report about the app's storage status using the builder-dockerfile:report command: Shell Output dokku builder-dockerfile:report =====> node-js-app builder-dockerfile information Builder dockerfile computed dockerfile path: Dockerfile2 Builder dockerfile global dockerfile path: Dockerfile Builder dockerfile dockerfile path: Dockerfile2 =====> python-sample builder-dockerfile information Builder dockerfile computed dockerfile path: Dockerfile Builder dockerfile global dockerfile path: Dockerfile Builder dockerfile dockerfile path: =====> ruby-sample builder-dockerfile information Builder dockerfile computed dockerfile path: Dockerfile Builder dockerfile global dockerfile path: Dockerfile Builder dockerfile dockerfile path: You can run the command for a specific app also. Shell Output dokku builder-dockerfile:report node-js-app =====> node-js-app builder-dockerfile information Builder dockerfile computed dockerfile path: Dockerfile2 Builder dockerfile global dockerfile path: Dockerfile Builder dockerfile dockerfile path: Dockerfile2 You can pass flags which will output only the value of the specific information you want. For example: Shell Output dokku builder-dockerfile:report node-js-app --builder-dockerfile-dockerfile-path Dockerfile2","title":"Displaying builder-dockerfile reports for an app"},{"location":"deployment/builders/dockerfiles/#build-time-configuration-variables","text":"For security reasons - and as per Docker recommendations - Dockerfile-based deploys have variables available only during runtime. For users that require customization in the build phase, you may use build arguments via the docker-options plugin : dokku docker-options:add node-js-app build '--build-arg NODE_ENV=production' Once set, the Dockerfile usage would be as follows: FROM ubuntu:18.04 # set the argument default ARG NODE_ENV = production # use the argument RUN echo $NODE_ENV You may also set the argument as an environment variable FROM ubuntu:18.04 # set the argument default ARG NODE_ENV = production # assign it to an environment variable # we can wrap the variable in brackets ENV NODE_ENV ${ NODE_ENV } # or omit them completely # use the argument RUN echo $NODE_ENV","title":"Build-time configuration variables"},{"location":"deployment/builders/dockerfiles/#building-images-with-docker-buildkit","text":"If your Dockerfile is using Docker engine's buildkit (not to be confused with buildpacks), then the DOCKER_BUILDKIT=1 environment variable needs to be set. Additionally, complete build log output can be forced via BUILDKIT_PROGRESS=plain . Both of these environment variables can be set as follows: echo \"export DOCKER_BUILDKIT=1\" | sudo tee -a /etc/default/dokku echo \"export BUILDKIT_PROGRESS=plain\" | sudo tee -a /etc/default/dokku","title":"Building images with Docker Buildkit"},{"location":"deployment/builders/dockerfiles/#buildkit-directory-caching","text":"Buildkit implements the RUN --mount option, enabling mount directory caches for RUN directives. The following is an example that mounts debian packaging related directories, which can speed up fetching of remote package data. FROM debian:latest RUN --mount = target = /var/lib/apt/lists,type = cache \\ --mount = target = /var/cache/apt,type = cache \\ apt-get update \\ && DEBIAN_FRONTEND = noninteractive apt-get install -y --no-install-recommends \\ git Mount cache targets may vary depending on the tool in use, and users are encouraged to investigate the directories that apply for their language and framework. You would adjust the cache directory for whatever application cache you have, e.g. /root/.pnpm-store/v3 for pnpm, $HOME/.m2 for maven, or /root/.cache for golang.","title":"Buildkit directory caching"},{"location":"deployment/builders/dockerfiles/#customizing-the-run-command","text":"By default no arguments are passed to docker run when deploying the container and the CMD or ENTRYPOINT defined in the Dockerfile are executed. You can take advantage of docker ability of overriding the CMD or passing parameters to your ENTRYPOINT setting $DOKKU_DOCKERFILE_START_CMD . Let's say for example you are deploying a base Node.js image, with the following ENTRYPOINT : ENTRYPOINT [ \"node\" ] You can do: dokku config:set node-js-app DOKKU_DOCKERFILE_START_CMD = \"--harmony server.js\" To tell Docker what to run. Setting $DOKKU_DOCKERFILE_CACHE_BUILD to true or false will enable or disable Docker's image layer cache. Lastly, for more granular build control, you may also pass any docker build option to docker , by setting $DOKKU_DOCKER_BUILD_OPTS .","title":"Customizing the run command"},{"location":"deployment/builders/dockerfiles/#procfiles-and-multiple-processes","text":"New Introduced in 0.5.0 You can also customize the run command using a Procfile , much like you would on Heroku or with a buildpack deployed app. The Procfile should contain one or more lines defining process types and associated commands . When you deploy your app, a Docker image will be built. The Procfile will be extracted from the image (it must be in the folder defined in your Dockerfile as WORKDIR or /app ) and the commands in it will be passed to docker run to start your process(es). Here's an example Procfile : web : bin/run-prod.sh worker : bin/run-worker.sh And Dockerfile : FROM ubuntu:18.04 WORKDIR /app COPY . ./ CMD [ \"bin/run-dev.sh\" ] When you deploy this app the web process will automatically be scaled to 1 and your Docker container will be started basically using the command docker run bin/run-prod.sh . If you want to also run a worker container for this app, you can run dokku ps:scale worker=1 and a new container will be started by running docker run bin/run-worker.sh (the actual docker run commands are a bit more complex, but this is the basic idea). If you use an ENTRYPOINT in your Dockerfile , the lines in your Procfile will be passed as arguments to the ENTRYPOINT script instead of being executed.","title":"Procfiles and multiple processes"},{"location":"deployment/builders/dockerfiles/#exposed-ports","text":"See the port management documentation for more information on how Dokku exposes ports for applications and how you can configure these for your app.","title":"Exposed ports"},{"location":"deployment/builders/herokuish-buildpacks/","text":"Herokuish Buildpacks New Subcommands introduced in 0.15.0 buildpacks:add [--index 1] <app> <buildpack> # Add new app buildpack while inserting into list of buildpacks if necessary buildpacks:clear <app> # Clear all buildpacks set on the app buildpacks:list <app> # List all buildpacks for an app buildpacks:remove <app> <buildpack> # Remove a buildpack set on the app buildpacks:report [<app>] [<flag>] # Displays a buildpack report for one or more apps buildpacks:set [--index 1] <app> <buildpack> # Set new app buildpack at a given position defaulting to the first buildpack if no index is specified buildpacks:set-property [--global|<app>] <key> <value> # Set or clear a buildpacks property for an app builder-herokuish:report [<app>] [<flag>] # Displays a builder-herokuish report for one or more apps builder-herokuish:set <app> <key> (<value>) # Set or clear a builder-herokuish property for an app Warning If using the buildpacks plugin, be sure to unset any BUILDPACK_URL and remove any such entries from a committed .env file. A specified BUILDPACK_URL will always override a .buildpacks file or the buildpacks plugin. Dokku normally defaults to using Heroku buildpacks for deployment, though this may be overridden by committing a valid Dockerfile to the root of your repository and pushing the repository to your Dokku installation. To avoid this automatic Dockerfile deployment detection, you may do one of the following: Set a BUILDPACK_URL environment variable This can be done via dokku config:set or via a committed .env file in the root of the repository. See the environment variable documentation for more details. Create a .buildpacks file in the root of your repository. This can be via a committed .buildpacks file or managed via the buildpacks plugin commands. This page will cover usage of the buildpacks plugin. Usage Detection This builder will be auto-detected in either the following cases: The BUILDPACK_URL app environment variable is set. This can be done via dokku config:set or via a committed .env file in the root of the repository. See the environment variable documentation for more details. A .buildpacks file exists in the root of the app repository. This can be via a committed .buildpacks file or managed via the buildpacks plugin commands. The builder can also be specified via the builder:set command: dokku builder:set node-js-app selected herokuish Info Dokku will only select the dockerfile builder if both the herokuish and pack builders are not detected and a Dockerfile exists. See the dockerfile builder documentation for more information on how that builder functions. Listing Buildpacks in Use The buildpacks:list command can be used to show buildpacks that have been set for an app. This will omit any auto-detected buildpacks. Shell Output Shell Output # running for an app with no buildpacks specified dokku buildpacks:list node-js-app -----> test buildpack urls # running for an app with two buildpacks specified dokku buildpacks:list node-js-app -----> test buildpack urls https://github.com/heroku/heroku-buildpack-python.git https://github.com/heroku/heroku-buildpack-nodejs.git Adding custom buildpacks Info Please check the documentation for your particular buildpack as you may need to include configuration files (such as a Procfile) in your project root. To add a custom buildpack, use the buildpacks:add command: dokku buildpacks:add node-js-app https://github.com/heroku/heroku-buildpack-nodejs.git When no buildpacks are currently specified, the specified buildpack will be the only one executed for detection and compilation. Multiple buildpacks may be specified by using the buildpacks:add command multiple times. dokku buildpacks:add node-js-app https://github.com/heroku/heroku-buildpack-ruby.git dokku buildpacks:add node-js-app https://github.com/heroku/heroku-buildpack-nodejs.git Buildpacks are executed in order, may be inserted at a specified index via the --index flag. This flag is specified starting at a 1-index value. # will add the golang buildpack at the second position, bumping all proceeding ones by 1 position dokku buildpacks:add --index 2 node-js-app https://github.com/heroku/heroku-buildpack-golang.git Overwriting a buildpack position In some cases, it may be necessary to swap out a given buildpack. Rather than needing to re-specify each buildpack, the buildpacks:set command can be used to overwrite a buildpack at a given position. dokku buildpacks:set node-js-app https://github.com/heroku/heroku-buildpack-ruby.git By default, this will overwrite the first buildpack specified. To specify an index, the --index flag may be used. This flag is specified starting at a 1-index value, and defaults to 1 . # the following are equivalent commands dokku buildpacks:set node-js-app https://github.com/heroku/heroku-buildpack-ruby.git dokku buildpacks:set --index 1 node-js-app https://github.com/heroku/heroku-buildpack-ruby.git If the index specified is larger than the number of buildpacks currently configured, the buildpack will be appended to the end of the list. dokku buildpacks:set --index 99 node-js-app https://github.com/heroku/heroku-buildpack-ruby.git Removing a buildpack Info At least one of a buildpack or index must be specified A single buildpack can be removed by name via the buildpacks:remove command. dokku buildpacks:remove node-js-app https://github.com/heroku/heroku-buildpack-ruby.git Buildpacks can also be removed by index via the --index flag. This flag is specified starting at a 1-index value. dokku buildpacks:remove node-js-app --index 1 Clearing all buildpacks Info This does not affect automatically detected buildpacks, nor does it impact any specified BUILDPACK_URL environment variable. The buildpacks:clear command can be used to clear all configured buildpacks for a specified app. dokku buildpacks:clear node-js-app Customizing the Buildpack stack builder New Introduced in 0.23.0 The default stack builder in use by Herokuish buildpacks in Dokku is based on gliderlabs/herokuish:latest . Typically, this is installed via an OS package which pulls the requisite Docker image. Users may desire to switch the stack builder to a custom version, either to update the operating system or to customize packages included with the stack builder. This can be performed via the buildpacks:set-property command. dokku buildpacks:set-property node-js-app stack gliderlabs/herokuish:latest The specified stack builder can also be unset by omitting the name of the stack builder when calling buildpacks:set-property . dokku buildpacks:set-property node-js-app stack A change in the stack builder value will execute the post-stack-set trigger. Finally, stack builders can be set or unset globally as a fallback. This will take precedence over a globally set DOKKU_IMAGE environment variable ( gliderlabs/herokuish:latest-20 by default). # set globally dokku buildpacks:set-property --global stack gliderlabs/herokuish:latest # unset globally dokku buildpacks:set-property --global stack Allowing herokuish for non-amd64 platforms New Introduced in 0.29.0 By default, the builder-herokuish plugin is not enabled for non-amd64 platforms, and attempting to use it is blocked. This is because the majority of buildpacks are not cross-platform compatible, and thus building apps will either be considerably slower - due to emulating the amd64 platform - or won't work - due to building amd64 packages on arm/arm64 platforms. To force-enable herokuish on non-amd64 platforms, the allowed property can be set via builder-herokuish:set . The default value depends on the host platform architecture ( true on amd64, false otherwise). dokku builder-herokuish:set node-js-app allowed true The default value may be set by passing an empty value for the option: dokku builder-herokuish:set node-js-app allowed The allowed property can also be set globally. The global default is platform-dependent, and the global value is used when no app-specific value is set. dokku builder-herokuish:set --global allowed true The default value may be set by passing an empty value for the option. dokku builder-herokuish:set --global allowed Displaying buildpack reports for an app You can get a report about the app's buildpacks status using the buildpacks:report command: Shell Output dokku buildpacks:report =====> node-js-app buildpacks information Buildpacks computed stack: gliderlabs/herokuish:v0.5.23-20 Buildpacks global stack: gliderlabs/herokuish:latest-20 Buildpacks list: https://github.com/heroku/heroku-buildpack-nodejs.git Buildpacks stack: gliderlabs/herokuish:v0.5.23-20 =====> python-sample buildpacks information Buildpacks computed stack: gliderlabs/herokuish:latest-20 Buildpacks global stack: gliderlabs/herokuish:latest-20 Buildpacks list: https://github.com/heroku/heroku-buildpack-nodejs.git,https://github.com/heroku/heroku-buildpack-python.git Buildpacks stack: =====> ruby-sample buildpacks information Buildpacks computed stack: gliderlabs/herokuish:latest-20 Buildpacks global stack: gliderlabs/herokuish:latest-20 Buildpacks list: Buildpacks stack: You can run the command for a specific app also. Shell Output dokku buildpacks:report node-js-app =====> node-js-app buildpacks information Buildpacks list: https://github.com/heroku/heroku-buildpack-nodejs.git You can pass flags which will output only the value of the specific information you want. For example: dokku buildpacks:report node-js-app --buildpacks-list Displaying builder-herokuish reports for an app New Introduced in 0.29.0 You can get a report about the app's storage status using the builder-herokuish:report command: Shell Output dokku builder-herokuish:report =====> node-js-app builder-herokuish information Builder herokuish computed allowed: false Builder herokuish global allowed: true Builder herokuish allowed: false =====> python-sample builder-herokuish information Builder herokuish computed allowed: true Builder herokuish global allowed: true Builder herokuish allowed: =====> ruby-sample builder-herokuish information Builder herokuish computed allowed: true Builder herokuish global allowed: true Builder herokuish allowed: You can run the command for a specific app also. Shell Output dokku builder-herokuish:report node-js-app =====> node-js-app builder-herokuish information Builder herokuish computed allowed: false Builder herokuish global allowed: true Builder herokuish allowed: false You can pass flags which will output only the value of the specific information you want. For example: Shell Output dokku builder-herokuish:report node-js-app --builder-herokuish-allowed false Errata Switching from Dockerfile deployments If an application was previously deployed via Dockerfile, the following commands should be run before a buildpack deploy will succeed: dokku config:unset --no-restart node-js-app DOKKU_PROXY_PORT_MAP Using a specific buildpack version Info Always remember to pin your buildpack versions when using the multi-buildpacks method, or you may find deploys changing your deployed environment. By default, Dokku uses the gliderlabs/herokuish project, which pins all of it's vendored buildpacks. There may be occasions where the pinned version results in a broken deploy, or does not have a particular feature that is required to build your project. To use a more recent version of a given buildpack, the buildpack may be specified without a Git commit SHA like so: # using the latest nodejs buildpack dokku buildpacks:set node-js-app https://github.com/heroku/heroku-buildpack-nodejs This will use the latest commit on the master branch of the specified buildpack. To pin to a newer version of a buildpack, a sha may also be specified by using the form REPOSITORY_URL#COMMIT_SHA , where COMMIT_SHA is any tree-ish git object - usually a git tag. # using v87 of the nodejs buildpack dokku buildpacks:set node-js-app https://github.com/heroku/heroku-buildpack-nodejs#v87 Specifying commands via Procfile While many buildpacks have a default command that is run when a detected repository is pushed, it is possible to override this command via a Procfile. A Procfile can also be used to specify multiple commands, each of which is subject to process scaling. See the process scaling documentation for more details around scaling individual processes. A Procfile is a file named Procfile . It should be named Procfile exactly, and not anything else. For example, Procfile.txt is not valid. The file should be a simple text file. The file must be placed in the root directory of your application. It will not function if placed in a subdirectory. If the file exists, it should not be empty, as doing so may result in a failed deploy. The syntax for declaring a Procfile is as follows. Note that the format is one process type per line, with no duplicate process types. <process type>: <command> If, for example, you have multiple queue workers and wish to scale them separately, the following would be a valid way to work around the requirement of not duplicating process types: worker : env QUEUE =* bundle exec rake resque : work importantworker : env QUEUE = important bundle exec rake resque : work The web process type holds some significance in that it is the only process type that is automatically scaled to 1 on the initial application deploy. See the process scaling documentation for more details around scaling individual processes. curl build timeouts Certain buildpacks may time out in retrieving dependencies via curl . This can happen when your network connection is poor or if there is significant network congestion. You may see a message similar to gzip: stdin: unexpected end of file after a curl command. If you see output similar this when deploying , you may need to override the curl timeouts to increase the length of time allotted to those tasks. You can do so via the config plugin: dokku config:set --global CURL_TIMEOUT = 1200 dokku config:set --global CURL_CONNECT_TIMEOUT = 180 Clearing buildpack cache See the repository management documentation for more information on how to clear buildpack build cache for an application.","title":"Herokuish Buildpacks"},{"location":"deployment/builders/herokuish-buildpacks/#herokuish-buildpacks","text":"New Subcommands introduced in 0.15.0 buildpacks:add [--index 1] <app> <buildpack> # Add new app buildpack while inserting into list of buildpacks if necessary buildpacks:clear <app> # Clear all buildpacks set on the app buildpacks:list <app> # List all buildpacks for an app buildpacks:remove <app> <buildpack> # Remove a buildpack set on the app buildpacks:report [<app>] [<flag>] # Displays a buildpack report for one or more apps buildpacks:set [--index 1] <app> <buildpack> # Set new app buildpack at a given position defaulting to the first buildpack if no index is specified buildpacks:set-property [--global|<app>] <key> <value> # Set or clear a buildpacks property for an app builder-herokuish:report [<app>] [<flag>] # Displays a builder-herokuish report for one or more apps builder-herokuish:set <app> <key> (<value>) # Set or clear a builder-herokuish property for an app Warning If using the buildpacks plugin, be sure to unset any BUILDPACK_URL and remove any such entries from a committed .env file. A specified BUILDPACK_URL will always override a .buildpacks file or the buildpacks plugin. Dokku normally defaults to using Heroku buildpacks for deployment, though this may be overridden by committing a valid Dockerfile to the root of your repository and pushing the repository to your Dokku installation. To avoid this automatic Dockerfile deployment detection, you may do one of the following: Set a BUILDPACK_URL environment variable This can be done via dokku config:set or via a committed .env file in the root of the repository. See the environment variable documentation for more details. Create a .buildpacks file in the root of your repository. This can be via a committed .buildpacks file or managed via the buildpacks plugin commands. This page will cover usage of the buildpacks plugin.","title":"Herokuish Buildpacks"},{"location":"deployment/builders/herokuish-buildpacks/#usage","text":"","title":"Usage"},{"location":"deployment/builders/herokuish-buildpacks/#detection","text":"This builder will be auto-detected in either the following cases: The BUILDPACK_URL app environment variable is set. This can be done via dokku config:set or via a committed .env file in the root of the repository. See the environment variable documentation for more details. A .buildpacks file exists in the root of the app repository. This can be via a committed .buildpacks file or managed via the buildpacks plugin commands. The builder can also be specified via the builder:set command: dokku builder:set node-js-app selected herokuish Info Dokku will only select the dockerfile builder if both the herokuish and pack builders are not detected and a Dockerfile exists. See the dockerfile builder documentation for more information on how that builder functions.","title":"Detection"},{"location":"deployment/builders/herokuish-buildpacks/#listing-buildpacks-in-use","text":"The buildpacks:list command can be used to show buildpacks that have been set for an app. This will omit any auto-detected buildpacks. Shell Output Shell Output # running for an app with no buildpacks specified dokku buildpacks:list node-js-app -----> test buildpack urls # running for an app with two buildpacks specified dokku buildpacks:list node-js-app -----> test buildpack urls https://github.com/heroku/heroku-buildpack-python.git https://github.com/heroku/heroku-buildpack-nodejs.git","title":"Listing Buildpacks in Use"},{"location":"deployment/builders/herokuish-buildpacks/#adding-custom-buildpacks","text":"Info Please check the documentation for your particular buildpack as you may need to include configuration files (such as a Procfile) in your project root. To add a custom buildpack, use the buildpacks:add command: dokku buildpacks:add node-js-app https://github.com/heroku/heroku-buildpack-nodejs.git When no buildpacks are currently specified, the specified buildpack will be the only one executed for detection and compilation. Multiple buildpacks may be specified by using the buildpacks:add command multiple times. dokku buildpacks:add node-js-app https://github.com/heroku/heroku-buildpack-ruby.git dokku buildpacks:add node-js-app https://github.com/heroku/heroku-buildpack-nodejs.git Buildpacks are executed in order, may be inserted at a specified index via the --index flag. This flag is specified starting at a 1-index value. # will add the golang buildpack at the second position, bumping all proceeding ones by 1 position dokku buildpacks:add --index 2 node-js-app https://github.com/heroku/heroku-buildpack-golang.git","title":"Adding custom buildpacks"},{"location":"deployment/builders/herokuish-buildpacks/#overwriting-a-buildpack-position","text":"In some cases, it may be necessary to swap out a given buildpack. Rather than needing to re-specify each buildpack, the buildpacks:set command can be used to overwrite a buildpack at a given position. dokku buildpacks:set node-js-app https://github.com/heroku/heroku-buildpack-ruby.git By default, this will overwrite the first buildpack specified. To specify an index, the --index flag may be used. This flag is specified starting at a 1-index value, and defaults to 1 . # the following are equivalent commands dokku buildpacks:set node-js-app https://github.com/heroku/heroku-buildpack-ruby.git dokku buildpacks:set --index 1 node-js-app https://github.com/heroku/heroku-buildpack-ruby.git If the index specified is larger than the number of buildpacks currently configured, the buildpack will be appended to the end of the list. dokku buildpacks:set --index 99 node-js-app https://github.com/heroku/heroku-buildpack-ruby.git","title":"Overwriting a buildpack position"},{"location":"deployment/builders/herokuish-buildpacks/#removing-a-buildpack","text":"Info At least one of a buildpack or index must be specified A single buildpack can be removed by name via the buildpacks:remove command. dokku buildpacks:remove node-js-app https://github.com/heroku/heroku-buildpack-ruby.git Buildpacks can also be removed by index via the --index flag. This flag is specified starting at a 1-index value. dokku buildpacks:remove node-js-app --index 1","title":"Removing a buildpack"},{"location":"deployment/builders/herokuish-buildpacks/#clearing-all-buildpacks","text":"Info This does not affect automatically detected buildpacks, nor does it impact any specified BUILDPACK_URL environment variable. The buildpacks:clear command can be used to clear all configured buildpacks for a specified app. dokku buildpacks:clear node-js-app","title":"Clearing all buildpacks"},{"location":"deployment/builders/herokuish-buildpacks/#customizing-the-buildpack-stack-builder","text":"New Introduced in 0.23.0 The default stack builder in use by Herokuish buildpacks in Dokku is based on gliderlabs/herokuish:latest . Typically, this is installed via an OS package which pulls the requisite Docker image. Users may desire to switch the stack builder to a custom version, either to update the operating system or to customize packages included with the stack builder. This can be performed via the buildpacks:set-property command. dokku buildpacks:set-property node-js-app stack gliderlabs/herokuish:latest The specified stack builder can also be unset by omitting the name of the stack builder when calling buildpacks:set-property . dokku buildpacks:set-property node-js-app stack A change in the stack builder value will execute the post-stack-set trigger. Finally, stack builders can be set or unset globally as a fallback. This will take precedence over a globally set DOKKU_IMAGE environment variable ( gliderlabs/herokuish:latest-20 by default). # set globally dokku buildpacks:set-property --global stack gliderlabs/herokuish:latest # unset globally dokku buildpacks:set-property --global stack","title":"Customizing the Buildpack stack builder"},{"location":"deployment/builders/herokuish-buildpacks/#allowing-herokuish-for-non-amd64-platforms","text":"New Introduced in 0.29.0 By default, the builder-herokuish plugin is not enabled for non-amd64 platforms, and attempting to use it is blocked. This is because the majority of buildpacks are not cross-platform compatible, and thus building apps will either be considerably slower - due to emulating the amd64 platform - or won't work - due to building amd64 packages on arm/arm64 platforms. To force-enable herokuish on non-amd64 platforms, the allowed property can be set via builder-herokuish:set . The default value depends on the host platform architecture ( true on amd64, false otherwise). dokku builder-herokuish:set node-js-app allowed true The default value may be set by passing an empty value for the option: dokku builder-herokuish:set node-js-app allowed The allowed property can also be set globally. The global default is platform-dependent, and the global value is used when no app-specific value is set. dokku builder-herokuish:set --global allowed true The default value may be set by passing an empty value for the option. dokku builder-herokuish:set --global allowed","title":"Allowing herokuish for non-amd64 platforms"},{"location":"deployment/builders/herokuish-buildpacks/#displaying-buildpack-reports-for-an-app","text":"You can get a report about the app's buildpacks status using the buildpacks:report command: Shell Output dokku buildpacks:report =====> node-js-app buildpacks information Buildpacks computed stack: gliderlabs/herokuish:v0.5.23-20 Buildpacks global stack: gliderlabs/herokuish:latest-20 Buildpacks list: https://github.com/heroku/heroku-buildpack-nodejs.git Buildpacks stack: gliderlabs/herokuish:v0.5.23-20 =====> python-sample buildpacks information Buildpacks computed stack: gliderlabs/herokuish:latest-20 Buildpacks global stack: gliderlabs/herokuish:latest-20 Buildpacks list: https://github.com/heroku/heroku-buildpack-nodejs.git,https://github.com/heroku/heroku-buildpack-python.git Buildpacks stack: =====> ruby-sample buildpacks information Buildpacks computed stack: gliderlabs/herokuish:latest-20 Buildpacks global stack: gliderlabs/herokuish:latest-20 Buildpacks list: Buildpacks stack: You can run the command for a specific app also. Shell Output dokku buildpacks:report node-js-app =====> node-js-app buildpacks information Buildpacks list: https://github.com/heroku/heroku-buildpack-nodejs.git You can pass flags which will output only the value of the specific information you want. For example: dokku buildpacks:report node-js-app --buildpacks-list","title":"Displaying buildpack reports for an app"},{"location":"deployment/builders/herokuish-buildpacks/#displaying-builder-herokuish-reports-for-an-app","text":"New Introduced in 0.29.0 You can get a report about the app's storage status using the builder-herokuish:report command: Shell Output dokku builder-herokuish:report =====> node-js-app builder-herokuish information Builder herokuish computed allowed: false Builder herokuish global allowed: true Builder herokuish allowed: false =====> python-sample builder-herokuish information Builder herokuish computed allowed: true Builder herokuish global allowed: true Builder herokuish allowed: =====> ruby-sample builder-herokuish information Builder herokuish computed allowed: true Builder herokuish global allowed: true Builder herokuish allowed: You can run the command for a specific app also. Shell Output dokku builder-herokuish:report node-js-app =====> node-js-app builder-herokuish information Builder herokuish computed allowed: false Builder herokuish global allowed: true Builder herokuish allowed: false You can pass flags which will output only the value of the specific information you want. For example: Shell Output dokku builder-herokuish:report node-js-app --builder-herokuish-allowed false","title":"Displaying builder-herokuish reports for an app"},{"location":"deployment/builders/herokuish-buildpacks/#errata","text":"","title":"Errata"},{"location":"deployment/builders/herokuish-buildpacks/#switching-from-dockerfile-deployments","text":"If an application was previously deployed via Dockerfile, the following commands should be run before a buildpack deploy will succeed: dokku config:unset --no-restart node-js-app DOKKU_PROXY_PORT_MAP","title":"Switching from Dockerfile deployments"},{"location":"deployment/builders/herokuish-buildpacks/#using-a-specific-buildpack-version","text":"Info Always remember to pin your buildpack versions when using the multi-buildpacks method, or you may find deploys changing your deployed environment. By default, Dokku uses the gliderlabs/herokuish project, which pins all of it's vendored buildpacks. There may be occasions where the pinned version results in a broken deploy, or does not have a particular feature that is required to build your project. To use a more recent version of a given buildpack, the buildpack may be specified without a Git commit SHA like so: # using the latest nodejs buildpack dokku buildpacks:set node-js-app https://github.com/heroku/heroku-buildpack-nodejs This will use the latest commit on the master branch of the specified buildpack. To pin to a newer version of a buildpack, a sha may also be specified by using the form REPOSITORY_URL#COMMIT_SHA , where COMMIT_SHA is any tree-ish git object - usually a git tag. # using v87 of the nodejs buildpack dokku buildpacks:set node-js-app https://github.com/heroku/heroku-buildpack-nodejs#v87","title":"Using a specific buildpack version"},{"location":"deployment/builders/herokuish-buildpacks/#specifying-commands-via-procfile","text":"While many buildpacks have a default command that is run when a detected repository is pushed, it is possible to override this command via a Procfile. A Procfile can also be used to specify multiple commands, each of which is subject to process scaling. See the process scaling documentation for more details around scaling individual processes. A Procfile is a file named Procfile . It should be named Procfile exactly, and not anything else. For example, Procfile.txt is not valid. The file should be a simple text file. The file must be placed in the root directory of your application. It will not function if placed in a subdirectory. If the file exists, it should not be empty, as doing so may result in a failed deploy. The syntax for declaring a Procfile is as follows. Note that the format is one process type per line, with no duplicate process types. <process type>: <command> If, for example, you have multiple queue workers and wish to scale them separately, the following would be a valid way to work around the requirement of not duplicating process types: worker : env QUEUE =* bundle exec rake resque : work importantworker : env QUEUE = important bundle exec rake resque : work The web process type holds some significance in that it is the only process type that is automatically scaled to 1 on the initial application deploy. See the process scaling documentation for more details around scaling individual processes.","title":"Specifying commands via Procfile"},{"location":"deployment/builders/herokuish-buildpacks/#curl-build-timeouts","text":"Certain buildpacks may time out in retrieving dependencies via curl . This can happen when your network connection is poor or if there is significant network congestion. You may see a message similar to gzip: stdin: unexpected end of file after a curl command. If you see output similar this when deploying , you may need to override the curl timeouts to increase the length of time allotted to those tasks. You can do so via the config plugin: dokku config:set --global CURL_TIMEOUT = 1200 dokku config:set --global CURL_CONNECT_TIMEOUT = 180","title":"curl build timeouts"},{"location":"deployment/builders/herokuish-buildpacks/#clearing-buildpack-cache","text":"See the repository management documentation for more information on how to clear buildpack build cache for an application.","title":"Clearing buildpack cache"},{"location":"deployment/builders/lambda/","text":"Lambda Builder New Introduced in 0.28.0 builder-lambda:report [<app>] [<flag>] # Displays a builder-lambda report for one or more apps builder-lambda:set <app> <key> (<value>) # Set or clear a builder-lambda property for an app The lambda builder builds AWS Lambda functions in an environment simulating AWS Lambda runtimes via lambda-builder . Apps built via this builder can run natively in Dokku and may also have their artifacts scheduled to Lambda via an appropriate scheduler. Usage Detection This builder will be auto-detected in the following case: A lambda.yml exists in the root of the app repository. The builder may also be selected via the builder:set command dokku builder:set node-js-app selected lambda Supported languages The lambda builder plugin supports the following AWS runtime languages on Amazon Linux 2: dotnet go (builder is based on AL1) nodejs python ruby See the lambda-builder documentation for more information on how specific languages are detected. Customizing the build environment The lambda builder plugin delegates all build logic to lambda-builder , including language detection and build/runtime environment specification. The lambda-builder tool supports a lambda.yml file format for customizing how apps are built. Please see the readme for lambda-builder for more information on different options. Changing the lambda.yml location When deploying a monorepo, it may be desirable to specify the specific path of the lambda.yml file to use for a given app. This can be done via the builder-lambda:set command. If a value is specified and that file does not exist in the app's build directory, then the build will fail. dokku builder-lambda:set node-js-app lambdayml-path lambda2.yml The default value may be set by passing an empty value for the option: dokku builder-lambda:set node-js-app lambdayml-path The lambdayml-path property can also be set globally. The global default is lambda.yml , and the global value is used when no app-specific value is set. dokku builder-lambda:set --global lambdayml-path lambda2.yml The default value may be set by passing an empty value for the option. dokku builder-lambda:set --global lambdayml-path Displaying builder-lambda reports for an app You can get a report about the app's storage status using the builder-lambda:report command: Shell Output dokku builder-lambda:report =====> node-js-app builder-lambda information Builder lambda computed lambdayml path: lambda2.yml Builder lambda global lambdayml path: lambda.yml Builder lambda lambdayml path: lambda2.yml =====> python-sample builder-lambda information Builder lambda computed lambdayml path: lambda.yml Builder lambda global lambdayml path: lambda.yml Builder lambda lambdayml path: =====> ruby-sample builder-lambda information Builder lambda computed lambdayml path: lambda.yml Builder lambda global lambdayml path: lambda.yml Builder lambda lambdayml path: You can run the command for a specific app also. Shell Output dokku builder-lambda:report node-js-app =====> node-js-app builder-lambda information Builder lambda computed lambdayml path: lambda2.yml Builder lambda global lambdayml path: lambda.yml Builder lambda lambdayml path: lambda2.yml You can pass flags which will output only the value of the specific information you want. For example: Shell Output dokku builder-lambda:report node-js-app --builder-lambda-lambdayml-path lambda2.yml","title":"Lambda Builder"},{"location":"deployment/builders/lambda/#lambda-builder","text":"New Introduced in 0.28.0 builder-lambda:report [<app>] [<flag>] # Displays a builder-lambda report for one or more apps builder-lambda:set <app> <key> (<value>) # Set or clear a builder-lambda property for an app The lambda builder builds AWS Lambda functions in an environment simulating AWS Lambda runtimes via lambda-builder . Apps built via this builder can run natively in Dokku and may also have their artifacts scheduled to Lambda via an appropriate scheduler.","title":"Lambda Builder"},{"location":"deployment/builders/lambda/#usage","text":"","title":"Usage"},{"location":"deployment/builders/lambda/#detection","text":"This builder will be auto-detected in the following case: A lambda.yml exists in the root of the app repository. The builder may also be selected via the builder:set command dokku builder:set node-js-app selected lambda","title":"Detection"},{"location":"deployment/builders/lambda/#supported-languages","text":"The lambda builder plugin supports the following AWS runtime languages on Amazon Linux 2: dotnet go (builder is based on AL1) nodejs python ruby See the lambda-builder documentation for more information on how specific languages are detected.","title":"Supported languages"},{"location":"deployment/builders/lambda/#customizing-the-build-environment","text":"The lambda builder plugin delegates all build logic to lambda-builder , including language detection and build/runtime environment specification. The lambda-builder tool supports a lambda.yml file format for customizing how apps are built. Please see the readme for lambda-builder for more information on different options.","title":"Customizing the build environment"},{"location":"deployment/builders/lambda/#changing-the-lambdayml-location","text":"When deploying a monorepo, it may be desirable to specify the specific path of the lambda.yml file to use for a given app. This can be done via the builder-lambda:set command. If a value is specified and that file does not exist in the app's build directory, then the build will fail. dokku builder-lambda:set node-js-app lambdayml-path lambda2.yml The default value may be set by passing an empty value for the option: dokku builder-lambda:set node-js-app lambdayml-path The lambdayml-path property can also be set globally. The global default is lambda.yml , and the global value is used when no app-specific value is set. dokku builder-lambda:set --global lambdayml-path lambda2.yml The default value may be set by passing an empty value for the option. dokku builder-lambda:set --global lambdayml-path","title":"Changing the lambda.yml location"},{"location":"deployment/builders/lambda/#displaying-builder-lambda-reports-for-an-app","text":"You can get a report about the app's storage status using the builder-lambda:report command: Shell Output dokku builder-lambda:report =====> node-js-app builder-lambda information Builder lambda computed lambdayml path: lambda2.yml Builder lambda global lambdayml path: lambda.yml Builder lambda lambdayml path: lambda2.yml =====> python-sample builder-lambda information Builder lambda computed lambdayml path: lambda.yml Builder lambda global lambdayml path: lambda.yml Builder lambda lambdayml path: =====> ruby-sample builder-lambda information Builder lambda computed lambdayml path: lambda.yml Builder lambda global lambdayml path: lambda.yml Builder lambda lambdayml path: You can run the command for a specific app also. Shell Output dokku builder-lambda:report node-js-app =====> node-js-app builder-lambda information Builder lambda computed lambdayml path: lambda2.yml Builder lambda global lambdayml path: lambda.yml Builder lambda lambdayml path: lambda2.yml You can pass flags which will output only the value of the specific information you want. For example: Shell Output dokku builder-lambda:report node-js-app --builder-lambda-lambdayml-path lambda2.yml","title":"Displaying builder-lambda reports for an app"},{"location":"deployment/builders/null/","text":"Null Builder New Introduced in 0.25.0 The null builder does nothing, and is useful for routing to services not managed by Dokku. It should not be used in normal operation. Please see the network documentation for more information on the aforementioned use case. Usage Detection This builder is never auto-detected. The builder must be specified via the builder:set command: dokku builder:set node-js-app selected null","title":"Null Builder"},{"location":"deployment/builders/null/#null-builder","text":"New Introduced in 0.25.0 The null builder does nothing, and is useful for routing to services not managed by Dokku. It should not be used in normal operation. Please see the network documentation for more information on the aforementioned use case.","title":"Null Builder"},{"location":"deployment/builders/null/#usage","text":"","title":"Usage"},{"location":"deployment/builders/null/#detection","text":"This builder is never auto-detected. The builder must be specified via the builder:set command: dokku builder:set node-js-app selected null","title":"Detection"},{"location":"deployment/continuous-integration/generic/","text":"Generic CI/CD Integration In cases where there is no direct or documented integration available, the Dokku project provides an Official Docker Image for use in Continuous Integration/Continuous Deployment (CI/CD) systems. Assuming a Docker image can be run as a CI task with environment variables injected, the following CI systems will have their variables automatically detected: circleci cloudbees drone github actions gitlab-ci semaphoreci travisci Simple Usage The simplest usage of the image is as follows. # where the `.env` file contains `GIT_REMOTE_URL` and `SSH_PRIVATE_KEY` docker run --rm -v = \" $PWD :/app\" --env-file = .env dokku/ci-docker-image dokku-deploy For more configuration examples and further documentation, see the ci-docker-image readme.","title":"Generic CI/CD Integration"},{"location":"deployment/continuous-integration/generic/#generic-cicd-integration","text":"In cases where there is no direct or documented integration available, the Dokku project provides an Official Docker Image for use in Continuous Integration/Continuous Deployment (CI/CD) systems. Assuming a Docker image can be run as a CI task with environment variables injected, the following CI systems will have their variables automatically detected: circleci cloudbees drone github actions gitlab-ci semaphoreci travisci","title":"Generic CI/CD Integration"},{"location":"deployment/continuous-integration/generic/#simple-usage","text":"The simplest usage of the image is as follows. # where the `.env` file contains `GIT_REMOTE_URL` and `SSH_PRIVATE_KEY` docker run --rm -v = \" $PWD :/app\" --env-file = .env dokku/ci-docker-image dokku-deploy For more configuration examples and further documentation, see the ci-docker-image readme.","title":"Simple Usage"},{"location":"deployment/continuous-integration/github-actions/","text":"GitHub Actions The Dokku project has an official GitHub Action available on the GitHub Marketplace . The simplest usage example is as follows: --- name : 'deploy' on : push : branches : - master jobs : deploy : runs-on : ubuntu-latest steps : - name : Cloning repo uses : actions/checkout@v2 with : fetch-depth : 0 - name : Push to dokku uses : dokku/github-action@master with : git_remote_url : 'ssh://dokku@dokku.me:22/appname' ssh_private_key : ${{ secrets.SSH_PRIVATE_KEY }} For further usage documentation and other advanced examples, see the entry on the GitHub Marketplace .","title":"GitHub Actions"},{"location":"deployment/continuous-integration/github-actions/#github-actions","text":"The Dokku project has an official GitHub Action available on the GitHub Marketplace . The simplest usage example is as follows: --- name : 'deploy' on : push : branches : - master jobs : deploy : runs-on : ubuntu-latest steps : - name : Cloning repo uses : actions/checkout@v2 with : fetch-depth : 0 - name : Push to dokku uses : dokku/github-action@master with : git_remote_url : 'ssh://dokku@dokku.me:22/appname' ssh_private_key : ${{ secrets.SSH_PRIVATE_KEY }} For further usage documentation and other advanced examples, see the entry on the GitHub Marketplace .","title":"GitHub Actions"},{"location":"deployment/continuous-integration/gitlab-ci/","text":"GitLab CI GitLab CI can be used to automatically deploy a Dokku application via the official the dokku/ci-docker-image . The simplest example is as follows: --- image: dokku/ci-docker-image stages: - deploy variables: GIT_DEPTH: 0 deploy: stage: deploy only: - master variables: GIT_REMOTE_URL: ssh://dokku@dokku.me:22/appname script: - dokku-deploy after_script: - dokku-unlock For further usage documentation and other advanced examples, see Dokku's gitlab-ci repository.","title":"GitLab CI"},{"location":"deployment/continuous-integration/gitlab-ci/#gitlab-ci","text":"GitLab CI can be used to automatically deploy a Dokku application via the official the dokku/ci-docker-image . The simplest example is as follows: --- image: dokku/ci-docker-image stages: - deploy variables: GIT_DEPTH: 0 deploy: stage: deploy only: - master variables: GIT_REMOTE_URL: ssh://dokku@dokku.me:22/appname script: - dokku-deploy after_script: - dokku-unlock For further usage documentation and other advanced examples, see Dokku's gitlab-ci repository.","title":"GitLab CI"},{"location":"deployment/methods/git/","text":"Git Deployment New Subcommands introduced in 0.12.0 git:allow-host <host> # Adds a host to known_hosts git:auth <host> [<username> <password>] # Configures netrc authentication for a given git server git:from-archive [--archive-type ARCHIVE_TYPE] <app> <archive-url> [<git-username> <git-email>] # Updates an app's git repository with a given archive file git:from-image [--build-dir DIRECTORY] <app> <docker-image> [<git-username> <git-email>] # Updates an app's git repository with a given docker image git:sync [--build] <app> <repository> [<git-ref>] # Clone or fetch an app from remote git repo git:initialize <app> # Initialize a git repository for an app git:public-key # Outputs the dokku public deploy key git:report [<app>] [<flag>] # Displays a git report for one or more apps git:set <app> <key> (<value>) # Set or clear a git property for an app git:status <app> # Show the working tree status for an app git:unlock <app> [--force] # Removes previous git clone folder for new deployment Git-based deployment has been the traditional method of deploying applications in Dokku. As of v0.12.0, Dokku introduces a few ways to customize the experience of deploying via git push . A Git-based deployment currently supports building applications via: Cloud Native Buildpacks Herokuish Buildpack Dockerfiles Usage Warning Pushing from a shallow clone is not currently supported and may have undefined behavior. Please unshallow your local repository before pushing to a Dokku app to avoid potential errors in the deployment process. Initializing an application When an application is created via git push , Dokku will create the proper pre-receive hook in order to execute the build pipeline. In certain cases - such as when fronting deploys with the git-http-backend - this may not be correctly created. As an alternative, the git:initialize command can be used to trigger this creation: # on the Dokku host # overrides any existing pre-receive hook dokku git:initialize node-js-app In order for the above command to succeed, the application must already exist. Warning If the pre-receive hook was customized in any way, this will overwrite that hook with the current defaults for Dokku. Changing the deploy branch By default, Dokku will deploy code pushed to the master branch. In order to quickly deploy a different local branch, the following Git command can be used: # on the local machine # where `SOME_BRANCH_NAME` is the name of the branch git push dokku SOME_BRANCH_NAME:master In 0.12.0 , the correct way to change the deploy branch is to use the git:set Dokku command. # on the Dokku host # override for all applications dokku git:set --global deploy-branch SOME_BRANCH_NAME # override for a specific app # where `SOME_BRANCH_NAME` is the name of the branch dokku git:set node-js-app deploy-branch SOME_BRANCH_NAME As of 0.22.1, Dokku will also respect the first pushed branch as the primary branch, and automatically set the deploy-branch value at that time. Pushing multiple branches can also be supported by creating a receive-branch plugin trigger in a custom plugin. Configuring the GIT_REV environment variable New Introduced in 0.12.0 Application deployments will include a special GIT_REV environment variable containing the current deployment sha being deployed. For rebuilds, this SHA will remain the same. To configure the name of the GIT_REV environment variable, run the git:set command as follows: # on the Dokku host # override for a specific app dokku git:set node-js-app rev-env-var DOKKU_GIT_REV This behavior can be disabled entirely on a per-app basis by setting the rev-env-var value to an empty string: # on the Dokku host # override for a specific app dokku git:set node-js-app rev-env-var \"\" Keeping the .git directory By default, Dokku will remove the contents of the .git before triggering a build for a given app. This is generally a safe default as shipping the entire source code history of your app in the deployed image artifact is unnecessary as it increases bloat and potentially can leak information if there are any security issues with your app code. To enable the .git directory, run the git:set command as follows: # on the Dokku host # keep the .git directory during builds dokku git:set node-js-app keep-git-dir true The default behavior is to delete this directory and it's contents. To revert to the default behavior, the keep-git-dir value can be set to either an empty string or false . # on the Dokku host # delete the .git directory during builds (default) dokku git:set node-js-app keep-git-dir false # delete the .git directory during builds (default) dokku git:set node-js-app keep-git-dir \"\" Please keep in mind that setting keep-git-dir to true may result in unstaged changes shown within the built container due to the build process generating application changes within the built app directory. Initializing an app repository from a docker image New Introduced in 0.24.0 A Dokku app repository can be initialized or updated from a Docker image via the git:from-image command. This command will either initialize the app repository or update it to include the specified Docker image via a FROM stanza. This is an excellent way of tracking changes when deploying only a given docker image, especially if deploying an image from a remote CI/CD pipeline. dokku git:from-image node-js-app dokku/node-js-getting-started:latest In the above example, Dokku will build the app as if the repository contained only a Dockerfile with the following content: FROM dokku/node-js-getting-started:latest Triggering a build with the same arguments multiple times will result in Dokku exiting 0 early as there will be no changes detected. If the image tag is reused but the underlying image is different, it is recommended to use the image digest instead of the tag. This can be retrieved via the following command: docker inspect --format = '{{index .RepoDigests 0}}' $IMAGE_NAME The resulting git:from-image call would then be: # where the image sha is: sha256:9d187c3025d03c033dcc71e3a284fee53be88cc4c0356a19242758bc80cab673 dokku git:from-image node-js-app dokku/node-js-getting-started@sha256:9d187c3025d03c033dcc71e3a284fee53be88cc4c0356a19242758bc80cab673 The git:from-image command can optionally take a git user.name and user.email argument (in that order) to customize the author. If the arguments are left empty, they will fallback to Dokku and automated@dokku.sh , respectively. dokku git:from-image node-js-app dokku/node-js-getting-started:latest \"Camila\" \"camila@example.com\" If the image is a private image that requires a docker login to access, the registry:login command should be used to log into the registry. See the registry documentation for more details on this process. Finally, certain images may require a custom build context in order for ONBUILD ADD and ONBUILD COPY statements to succeed. A custom build context can be specified via the --build-dir flag. All files in the specified build-dir will be copied into the repository for use within the docker build process. The build context must be specified on each deploy, and is not otherwise persisted between builds. dokku git:from-image --build-dir path/to/build node-js-app dokku/node-js-getting-started:latest \"Camila\" \"camila@example.com\" See the dockerfile documentation to learn about the different ways to configure Dockerfile-based deploys. Initializing an app repository from an archive file New Introduced in 0.24.0 A Dokku app repository can be initialized or updated from the contents of an archive file via the git:from-archive command. This is an excellent way of tracking changes when deploying pre-built binary archives, such as java jars or go binaries. This can also be useful when deploying directly from a GitHub repository at a specific commit. dokku git:from-archive node-js-app https://github.com/dokku/smoke-test-app/releases/download/2.0.0/smoke-test-app.tar In the above example, Dokku will build the app as if the repository contained the extracted contents of the specified archive file. Triggering a build with the same archive file multiple times will result in Dokku exiting 0 early as there will be no changes detected. The git:from-archive command can optionally take a git user.name and user.email argument (in that order) to customize the author. If the arguments are left empty, they will fallback to Dokku and automated@dokku.sh , respectively. dokku git:from-archive node-js-app https://github.com/dokku/smoke-test-app/releases/download/2.0.0/smoke-test-app.tar \"Camila\" \"camila@example.com\" The default archive type is always set to .tar . To use a different archive type, specify the --archive-type flag. Failure to do so will result in a failure to extract the archive. dokku git:from-archive --archive-type zip node-js-app https://github.com/dokku/smoke-test-app/archive/2.0.0.zip \"Camila\" \"camila@example.com\" Finally, if the archive url is specified as -- , the archive will be fetched from stdin. curl -sSL https://github.com/dokku/smoke-test-app/releases/download/2.0.0/smoke-test-app.tar | dokku git:from-archive node-js-app -- Initializing an app repository from a remote repository New Introduced in 0.23.0 A Dokku app repository can be initialized or updated from a remote git repository via the git:sync command. This command will either clone or fetch updates from a remote repository and has undefined behavior if the history cannot be fast-fowarded to the referenced repository reference. Any repository that can be cloned by the dokku user can be specified. Info The application must exist before the repository can be initialized dokku git:sync node-js-app https://github.com/heroku/node-js-getting-started.git The git:sync command optionally takes an optional third parameter containing a git reference, which may be a branch, tag, or specific commit. # specify a branch dokku git:sync node-js-app https://github.com/heroku/node-js-getting-started.git main # specify a tag dokku git:sync node-js-app https://github.com/heroku/node-js-getting-started.git 1 # specify a commit dokku git:sync node-js-app https://github.com/heroku/node-js-getting-started.git 97e6c72491c7531507bfc5413903e0e00e31e1b0 By default, this command does not trigger an application build. To do so during a git:sync , specify the --build flag. dokku git:sync --build node-js-app https://github.com/heroku/node-js-getting-started.git Initializing from private repositories New Introduced in 0.24.0 Initializing from a private repository requires one of the following: A Public SSH Key ( id_rsa.pub file) configured on the remote server, with the associated private key ( id_rsa ) in the Dokku server's /home/dokku/.ssh/ directory. A configured .netrc entry. Dokku provides the git:auth command which can be used to configure a netrc entry for the remote server. This command can be used to add or remove configuration for any remote server. # add credentials for github.com dokku git:auth github.com username personal-access-token # remove credentials for github.com dokku git:auth github.com For syncing to a private repository stored on a remote Git product such as GitHub or GitLab, Dokku's recommendation is to use a personal access token on a bot user where possible. Please see your service's documentation for information regarding the recommended best practices. Allowing remote repository hosts By default, the Dokku host may not have access to a server containing the remote repository. This can be initialized via the git:allow-host command. dokku git:allow-host github.com Note that this command is currently not idempotent and may add duplicate entries to the ~dokku/.ssh/known_hosts file. Verifying the cloning public key In order to clone a remote repository, the remote server should have the Dokku host's public key configured. This plugin does not currently create this key, but if there is one available, it can be shown via the git:public-key command. dokku git:public-key If there is no key, an error message is shown that displays the command that can be run on the Dokku server to generate a new public/private ssh key pair.","title":"Git Deployment"},{"location":"deployment/methods/git/#git-deployment","text":"New Subcommands introduced in 0.12.0 git:allow-host <host> # Adds a host to known_hosts git:auth <host> [<username> <password>] # Configures netrc authentication for a given git server git:from-archive [--archive-type ARCHIVE_TYPE] <app> <archive-url> [<git-username> <git-email>] # Updates an app's git repository with a given archive file git:from-image [--build-dir DIRECTORY] <app> <docker-image> [<git-username> <git-email>] # Updates an app's git repository with a given docker image git:sync [--build] <app> <repository> [<git-ref>] # Clone or fetch an app from remote git repo git:initialize <app> # Initialize a git repository for an app git:public-key # Outputs the dokku public deploy key git:report [<app>] [<flag>] # Displays a git report for one or more apps git:set <app> <key> (<value>) # Set or clear a git property for an app git:status <app> # Show the working tree status for an app git:unlock <app> [--force] # Removes previous git clone folder for new deployment Git-based deployment has been the traditional method of deploying applications in Dokku. As of v0.12.0, Dokku introduces a few ways to customize the experience of deploying via git push . A Git-based deployment currently supports building applications via: Cloud Native Buildpacks Herokuish Buildpack Dockerfiles","title":"Git Deployment"},{"location":"deployment/methods/git/#usage","text":"Warning Pushing from a shallow clone is not currently supported and may have undefined behavior. Please unshallow your local repository before pushing to a Dokku app to avoid potential errors in the deployment process.","title":"Usage"},{"location":"deployment/methods/git/#initializing-an-application","text":"When an application is created via git push , Dokku will create the proper pre-receive hook in order to execute the build pipeline. In certain cases - such as when fronting deploys with the git-http-backend - this may not be correctly created. As an alternative, the git:initialize command can be used to trigger this creation: # on the Dokku host # overrides any existing pre-receive hook dokku git:initialize node-js-app In order for the above command to succeed, the application must already exist. Warning If the pre-receive hook was customized in any way, this will overwrite that hook with the current defaults for Dokku.","title":"Initializing an application"},{"location":"deployment/methods/git/#changing-the-deploy-branch","text":"By default, Dokku will deploy code pushed to the master branch. In order to quickly deploy a different local branch, the following Git command can be used: # on the local machine # where `SOME_BRANCH_NAME` is the name of the branch git push dokku SOME_BRANCH_NAME:master In 0.12.0 , the correct way to change the deploy branch is to use the git:set Dokku command. # on the Dokku host # override for all applications dokku git:set --global deploy-branch SOME_BRANCH_NAME # override for a specific app # where `SOME_BRANCH_NAME` is the name of the branch dokku git:set node-js-app deploy-branch SOME_BRANCH_NAME As of 0.22.1, Dokku will also respect the first pushed branch as the primary branch, and automatically set the deploy-branch value at that time. Pushing multiple branches can also be supported by creating a receive-branch plugin trigger in a custom plugin.","title":"Changing the deploy branch"},{"location":"deployment/methods/git/#configuring-the-git_rev-environment-variable","text":"New Introduced in 0.12.0 Application deployments will include a special GIT_REV environment variable containing the current deployment sha being deployed. For rebuilds, this SHA will remain the same. To configure the name of the GIT_REV environment variable, run the git:set command as follows: # on the Dokku host # override for a specific app dokku git:set node-js-app rev-env-var DOKKU_GIT_REV This behavior can be disabled entirely on a per-app basis by setting the rev-env-var value to an empty string: # on the Dokku host # override for a specific app dokku git:set node-js-app rev-env-var \"\"","title":"Configuring the GIT_REV environment variable"},{"location":"deployment/methods/git/#keeping-the-git-directory","text":"By default, Dokku will remove the contents of the .git before triggering a build for a given app. This is generally a safe default as shipping the entire source code history of your app in the deployed image artifact is unnecessary as it increases bloat and potentially can leak information if there are any security issues with your app code. To enable the .git directory, run the git:set command as follows: # on the Dokku host # keep the .git directory during builds dokku git:set node-js-app keep-git-dir true The default behavior is to delete this directory and it's contents. To revert to the default behavior, the keep-git-dir value can be set to either an empty string or false . # on the Dokku host # delete the .git directory during builds (default) dokku git:set node-js-app keep-git-dir false # delete the .git directory during builds (default) dokku git:set node-js-app keep-git-dir \"\" Please keep in mind that setting keep-git-dir to true may result in unstaged changes shown within the built container due to the build process generating application changes within the built app directory.","title":"Keeping the .git directory"},{"location":"deployment/methods/git/#initializing-an-app-repository-from-a-docker-image","text":"New Introduced in 0.24.0 A Dokku app repository can be initialized or updated from a Docker image via the git:from-image command. This command will either initialize the app repository or update it to include the specified Docker image via a FROM stanza. This is an excellent way of tracking changes when deploying only a given docker image, especially if deploying an image from a remote CI/CD pipeline. dokku git:from-image node-js-app dokku/node-js-getting-started:latest In the above example, Dokku will build the app as if the repository contained only a Dockerfile with the following content: FROM dokku/node-js-getting-started:latest Triggering a build with the same arguments multiple times will result in Dokku exiting 0 early as there will be no changes detected. If the image tag is reused but the underlying image is different, it is recommended to use the image digest instead of the tag. This can be retrieved via the following command: docker inspect --format = '{{index .RepoDigests 0}}' $IMAGE_NAME The resulting git:from-image call would then be: # where the image sha is: sha256:9d187c3025d03c033dcc71e3a284fee53be88cc4c0356a19242758bc80cab673 dokku git:from-image node-js-app dokku/node-js-getting-started@sha256:9d187c3025d03c033dcc71e3a284fee53be88cc4c0356a19242758bc80cab673 The git:from-image command can optionally take a git user.name and user.email argument (in that order) to customize the author. If the arguments are left empty, they will fallback to Dokku and automated@dokku.sh , respectively. dokku git:from-image node-js-app dokku/node-js-getting-started:latest \"Camila\" \"camila@example.com\" If the image is a private image that requires a docker login to access, the registry:login command should be used to log into the registry. See the registry documentation for more details on this process. Finally, certain images may require a custom build context in order for ONBUILD ADD and ONBUILD COPY statements to succeed. A custom build context can be specified via the --build-dir flag. All files in the specified build-dir will be copied into the repository for use within the docker build process. The build context must be specified on each deploy, and is not otherwise persisted between builds. dokku git:from-image --build-dir path/to/build node-js-app dokku/node-js-getting-started:latest \"Camila\" \"camila@example.com\" See the dockerfile documentation to learn about the different ways to configure Dockerfile-based deploys.","title":"Initializing an app repository from a docker image"},{"location":"deployment/methods/git/#initializing-an-app-repository-from-an-archive-file","text":"New Introduced in 0.24.0 A Dokku app repository can be initialized or updated from the contents of an archive file via the git:from-archive command. This is an excellent way of tracking changes when deploying pre-built binary archives, such as java jars or go binaries. This can also be useful when deploying directly from a GitHub repository at a specific commit. dokku git:from-archive node-js-app https://github.com/dokku/smoke-test-app/releases/download/2.0.0/smoke-test-app.tar In the above example, Dokku will build the app as if the repository contained the extracted contents of the specified archive file. Triggering a build with the same archive file multiple times will result in Dokku exiting 0 early as there will be no changes detected. The git:from-archive command can optionally take a git user.name and user.email argument (in that order) to customize the author. If the arguments are left empty, they will fallback to Dokku and automated@dokku.sh , respectively. dokku git:from-archive node-js-app https://github.com/dokku/smoke-test-app/releases/download/2.0.0/smoke-test-app.tar \"Camila\" \"camila@example.com\" The default archive type is always set to .tar . To use a different archive type, specify the --archive-type flag. Failure to do so will result in a failure to extract the archive. dokku git:from-archive --archive-type zip node-js-app https://github.com/dokku/smoke-test-app/archive/2.0.0.zip \"Camila\" \"camila@example.com\" Finally, if the archive url is specified as -- , the archive will be fetched from stdin. curl -sSL https://github.com/dokku/smoke-test-app/releases/download/2.0.0/smoke-test-app.tar | dokku git:from-archive node-js-app --","title":"Initializing an app repository from an archive file"},{"location":"deployment/methods/git/#initializing-an-app-repository-from-a-remote-repository","text":"New Introduced in 0.23.0 A Dokku app repository can be initialized or updated from a remote git repository via the git:sync command. This command will either clone or fetch updates from a remote repository and has undefined behavior if the history cannot be fast-fowarded to the referenced repository reference. Any repository that can be cloned by the dokku user can be specified. Info The application must exist before the repository can be initialized dokku git:sync node-js-app https://github.com/heroku/node-js-getting-started.git The git:sync command optionally takes an optional third parameter containing a git reference, which may be a branch, tag, or specific commit. # specify a branch dokku git:sync node-js-app https://github.com/heroku/node-js-getting-started.git main # specify a tag dokku git:sync node-js-app https://github.com/heroku/node-js-getting-started.git 1 # specify a commit dokku git:sync node-js-app https://github.com/heroku/node-js-getting-started.git 97e6c72491c7531507bfc5413903e0e00e31e1b0 By default, this command does not trigger an application build. To do so during a git:sync , specify the --build flag. dokku git:sync --build node-js-app https://github.com/heroku/node-js-getting-started.git","title":"Initializing an app repository from a remote repository"},{"location":"deployment/methods/git/#initializing-from-private-repositories","text":"New Introduced in 0.24.0 Initializing from a private repository requires one of the following: A Public SSH Key ( id_rsa.pub file) configured on the remote server, with the associated private key ( id_rsa ) in the Dokku server's /home/dokku/.ssh/ directory. A configured .netrc entry. Dokku provides the git:auth command which can be used to configure a netrc entry for the remote server. This command can be used to add or remove configuration for any remote server. # add credentials for github.com dokku git:auth github.com username personal-access-token # remove credentials for github.com dokku git:auth github.com For syncing to a private repository stored on a remote Git product such as GitHub or GitLab, Dokku's recommendation is to use a personal access token on a bot user where possible. Please see your service's documentation for information regarding the recommended best practices.","title":"Initializing from private repositories"},{"location":"deployment/methods/git/#allowing-remote-repository-hosts","text":"By default, the Dokku host may not have access to a server containing the remote repository. This can be initialized via the git:allow-host command. dokku git:allow-host github.com Note that this command is currently not idempotent and may add duplicate entries to the ~dokku/.ssh/known_hosts file.","title":"Allowing remote repository hosts"},{"location":"deployment/methods/git/#verifying-the-cloning-public-key","text":"In order to clone a remote repository, the remote server should have the Dokku host's public key configured. This plugin does not currently create this key, but if there is one available, it can be shown via the git:public-key command. dokku git:public-key If there is no key, an error message is shown that displays the command that can be run on the Dokku server to generate a new public/private ssh key pair.","title":"Verifying the cloning public key"},{"location":"deployment/schedulers/docker-local/","text":"Docker Local Scheduler New Subcommands introduced in 0.12.12 scheduler-docker-local:report [<app>] [<flag>] # Displays a scheduler-docker-local report for one or more apps scheduler-docker-local:set <app> <key> (<value>) # Set or clear a scheduler-docker-local property for an app New Introduced in 0.12.0 Dokku natively includes functionality to manage application lifecycles for a single server using the scheduler-docker-local plugin. It is the default scheduler, but as with all schedulers, it is set on a per-application basis. The scheduler can currently be overridden by running the following command: dokku config:set node-js-app DOCKER_SCHEDULER = docker-local As it is the default, unsetting the DOCKER_SCHEDULER config variable is also a valid way to reset the scheduler. dokku config:unset node-js-app DOCKER_SCHEDULER Usage Disabling chown of persistent storage The scheduler-docker-local plugin will ensure your storage mounts are owned by either herokuishuser or the overridden value you have set in DOKKU_APP_USER . You may disable this by running the following scheduler-docker-local:set command for your application: dokku scheduler-docker-local:set node-js-app disable-chown true Once set, you may re-enable it by setting a blank value for disable-chown : dokku scheduler-docker-local:set node-js-app disable-chown Disabling the init process The scheduler-docker-local injects an init process by default via the --init . For some apps - such as those where the built docker image uses S6 as the init - this may be undesirable and cause issues with process starts. You may disable this by running the following scheduler-docker-local:set command for your application: dokku scheduler-docker-local:set node-js-app init-process false Once set, you may re-enable it by setting a blank value for init-process : dokku scheduler-docker-local:set node-js-app init-process All image containers with the label org.opencontainers.image.vendor=linuxserver.io will have the automatic init process injection force-disabled without further intervention. Deploying Process Types in Parallel New Introduced in 0.25.5 By default, Dokku deploys an app's processes one-by-one in order, with the web process being deployed first. Deployment parallelism may be achieved by setting the parallel-schedule-count property, which defaults to 1 . Increasing this number increases the number of process types that may be deployed in parallel (with the web process being the exception). # Increase parallelism from 1 process type at a time to 4 process types at a time. dokku scheduler-docker-local:set node-js-app parallel-schedule-count 4 Once set, you may reset it by setting a blank value for parallel-schedule-count : dokku scheduler-docker-local:set node-js-app parallel-schedule-count If the value of parallel-schedule-count is increased and a given process type fails to schedule successfully, then any in-flight process types will continue to be processed, while all process types that have not been scheduled will be skipped before the deployment finally fails. Container scheduling output is shown in the order it is received, and thus may be out of order in case of output to stderr. Note that increasing the value of parallel-schedule-count may significantly impact CPU utilization on your host as your app containers - and their respective processes - start up. Setting a value higher than the number of available CPUs is discouraged. It is recommended that users carefully set this value so as not to overburden their server. Increasing parallelism within a process deploy New Introduced in 0.26.0 By default, Dokku will deploy one instance of a given process type at a time. This can be increased by customizing the app.json formation key to include a max_parallel key for the given process type. An app.json file can be committed to the root of the pushed app repository, and must be within the built image artifact in the image's working directory as shown below. Buildpacks: /app/app.json Dockerfile: WORKDIR/app.json or /app.json (if no working directory specified) Docker Image: WORKDIR/app.json or /app.json (if no working directory specified) The formation key should be specified as follows in the app.json file: { \"formation\" : { \"web\" : { \"max_parallel\" : 1 }, \"worker\" : { \"max_parallel\" : 4 } } } Omitting or removing the entry will result in parallelism for that process type to return to 1 entry at a time. This can be combined with the parallel-schedule-count property to speed up deployments. Note that increasing the value of max_parallel may significantly impact CPU utilization on your host as your app containers - and their respective processes - start up. Setting a value higher than the number of available CPUs is discouraged. It is recommended that users carefully set this value so as not to overburden their server. Scheduler Interface The following sections describe implemented scheduler functionality for the docker-local scheduler. Implemented Commands and Triggers This plugin implements various functionality through plugn triggers to integrate with Docker for running apps on a single server. The following functionality is supported by the scheduler-docker-local plugin. apps:clone apps:destroy apps:rename deploy enter logs ps:inspect ps:stop run Logging support App logs for the logs command are fetched from running containers via the docker cli. To persist logs across deployments, consider using Dokku's vector integration to ship logs to another service or a third-party platform. Supported Resource Management Properties The docker-local scheduler supports a minimal list of resource limits and reservations . The following properties are supported: Resource Limits cpu: (docker option: --cpus ), is specified in number of CPUs a process can access. See the \"CPU\" section of the Docker Runtime Options documentation for more information. memory: (docker option: --memory ) should be specified with a suffix of b (bytes), k (kilobytes), m (megabytes), g (gigabytes). Default unit is m (megabytes). See the \"Memory\" section of the Docker Runtime Options documentation for more information. memory-swap: (docker option: --memory-swap ) should be specified with a suffix of b (bytes), k (kilobytes), m (megabytes), g (gigabytes) See the \"Memory\" section of the Docker Runtime Options documentation for more information. nvidia-gpus: (docker option: --gpus ), is specified in number of Nvidia GPUs a process can access. See the \"GPU\" section of the Docker Runtime Options documentation for more information. Resource Reservations memory: (docker option: --memory-reservation ) should be specified with a suffix of b (bytes), k (kilobytes), m (megabytes), g (gigabytes). Default unit is m (megabytes). See the \"Memory\" section of the Docker Runtime Options documentation for more information.","title":"Docker Local Scheduler"},{"location":"deployment/schedulers/docker-local/#docker-local-scheduler","text":"New Subcommands introduced in 0.12.12 scheduler-docker-local:report [<app>] [<flag>] # Displays a scheduler-docker-local report for one or more apps scheduler-docker-local:set <app> <key> (<value>) # Set or clear a scheduler-docker-local property for an app New Introduced in 0.12.0 Dokku natively includes functionality to manage application lifecycles for a single server using the scheduler-docker-local plugin. It is the default scheduler, but as with all schedulers, it is set on a per-application basis. The scheduler can currently be overridden by running the following command: dokku config:set node-js-app DOCKER_SCHEDULER = docker-local As it is the default, unsetting the DOCKER_SCHEDULER config variable is also a valid way to reset the scheduler. dokku config:unset node-js-app DOCKER_SCHEDULER","title":"Docker Local Scheduler"},{"location":"deployment/schedulers/docker-local/#usage","text":"","title":"Usage"},{"location":"deployment/schedulers/docker-local/#disabling-chown-of-persistent-storage","text":"The scheduler-docker-local plugin will ensure your storage mounts are owned by either herokuishuser or the overridden value you have set in DOKKU_APP_USER . You may disable this by running the following scheduler-docker-local:set command for your application: dokku scheduler-docker-local:set node-js-app disable-chown true Once set, you may re-enable it by setting a blank value for disable-chown : dokku scheduler-docker-local:set node-js-app disable-chown","title":"Disabling chown of persistent storage"},{"location":"deployment/schedulers/docker-local/#disabling-the-init-process","text":"The scheduler-docker-local injects an init process by default via the --init . For some apps - such as those where the built docker image uses S6 as the init - this may be undesirable and cause issues with process starts. You may disable this by running the following scheduler-docker-local:set command for your application: dokku scheduler-docker-local:set node-js-app init-process false Once set, you may re-enable it by setting a blank value for init-process : dokku scheduler-docker-local:set node-js-app init-process All image containers with the label org.opencontainers.image.vendor=linuxserver.io will have the automatic init process injection force-disabled without further intervention.","title":"Disabling the init process"},{"location":"deployment/schedulers/docker-local/#deploying-process-types-in-parallel","text":"New Introduced in 0.25.5 By default, Dokku deploys an app's processes one-by-one in order, with the web process being deployed first. Deployment parallelism may be achieved by setting the parallel-schedule-count property, which defaults to 1 . Increasing this number increases the number of process types that may be deployed in parallel (with the web process being the exception). # Increase parallelism from 1 process type at a time to 4 process types at a time. dokku scheduler-docker-local:set node-js-app parallel-schedule-count 4 Once set, you may reset it by setting a blank value for parallel-schedule-count : dokku scheduler-docker-local:set node-js-app parallel-schedule-count If the value of parallel-schedule-count is increased and a given process type fails to schedule successfully, then any in-flight process types will continue to be processed, while all process types that have not been scheduled will be skipped before the deployment finally fails. Container scheduling output is shown in the order it is received, and thus may be out of order in case of output to stderr. Note that increasing the value of parallel-schedule-count may significantly impact CPU utilization on your host as your app containers - and their respective processes - start up. Setting a value higher than the number of available CPUs is discouraged. It is recommended that users carefully set this value so as not to overburden their server.","title":"Deploying Process Types in Parallel"},{"location":"deployment/schedulers/docker-local/#increasing-parallelism-within-a-process-deploy","text":"New Introduced in 0.26.0 By default, Dokku will deploy one instance of a given process type at a time. This can be increased by customizing the app.json formation key to include a max_parallel key for the given process type. An app.json file can be committed to the root of the pushed app repository, and must be within the built image artifact in the image's working directory as shown below. Buildpacks: /app/app.json Dockerfile: WORKDIR/app.json or /app.json (if no working directory specified) Docker Image: WORKDIR/app.json or /app.json (if no working directory specified) The formation key should be specified as follows in the app.json file: { \"formation\" : { \"web\" : { \"max_parallel\" : 1 }, \"worker\" : { \"max_parallel\" : 4 } } } Omitting or removing the entry will result in parallelism for that process type to return to 1 entry at a time. This can be combined with the parallel-schedule-count property to speed up deployments. Note that increasing the value of max_parallel may significantly impact CPU utilization on your host as your app containers - and their respective processes - start up. Setting a value higher than the number of available CPUs is discouraged. It is recommended that users carefully set this value so as not to overburden their server.","title":"Increasing parallelism within a process deploy"},{"location":"deployment/schedulers/docker-local/#scheduler-interface","text":"The following sections describe implemented scheduler functionality for the docker-local scheduler.","title":"Scheduler Interface"},{"location":"deployment/schedulers/docker-local/#implemented-commands-and-triggers","text":"This plugin implements various functionality through plugn triggers to integrate with Docker for running apps on a single server. The following functionality is supported by the scheduler-docker-local plugin. apps:clone apps:destroy apps:rename deploy enter logs ps:inspect ps:stop run","title":"Implemented Commands and Triggers"},{"location":"deployment/schedulers/docker-local/#logging-support","text":"App logs for the logs command are fetched from running containers via the docker cli. To persist logs across deployments, consider using Dokku's vector integration to ship logs to another service or a third-party platform.","title":"Logging support"},{"location":"deployment/schedulers/docker-local/#supported-resource-management-properties","text":"The docker-local scheduler supports a minimal list of resource limits and reservations . The following properties are supported:","title":"Supported Resource Management Properties"},{"location":"deployment/schedulers/docker-local/#resource-limits","text":"cpu: (docker option: --cpus ), is specified in number of CPUs a process can access. See the \"CPU\" section of the Docker Runtime Options documentation for more information. memory: (docker option: --memory ) should be specified with a suffix of b (bytes), k (kilobytes), m (megabytes), g (gigabytes). Default unit is m (megabytes). See the \"Memory\" section of the Docker Runtime Options documentation for more information. memory-swap: (docker option: --memory-swap ) should be specified with a suffix of b (bytes), k (kilobytes), m (megabytes), g (gigabytes) See the \"Memory\" section of the Docker Runtime Options documentation for more information. nvidia-gpus: (docker option: --gpus ), is specified in number of Nvidia GPUs a process can access. See the \"GPU\" section of the Docker Runtime Options documentation for more information.","title":"Resource Limits"},{"location":"deployment/schedulers/docker-local/#resource-reservations","text":"memory: (docker option: --memory-reservation ) should be specified with a suffix of b (bytes), k (kilobytes), m (megabytes), g (gigabytes). Default unit is m (megabytes). See the \"Memory\" section of the Docker Runtime Options documentation for more information.","title":"Resource Reservations"},{"location":"deployment/schedulers/kubernetes/","text":"Kubernetes Scheduler Warning: This scheduler is not in Dokku core and thus functionality may change over time as the API stabilizes. The Kubernetes Scheduler Plugin is available free as an external plugin. Please see the plugin's issue tracker for more information on the status of the plugin. For users that require additional functionality, please refer to the Sponsoring Documentation . Scheduler Interface The following sections describe implemented scheduler functionality for the docker-local scheduler. Implemented Commands and Triggers This plugin implements various functionality through plugn triggers to integrate with kubectl for running apps on a Kubernetes cluster. The following functionality is supported by the scheduler-kubernetes plugin. apps:destroy deploy : partial, does not implement failed deploy log capture logs : partial, does not implement failure logs ps:stop Logging support App logs for the logs command are fetched from running pods via the kubectl cli. To persist logs across deployments, consider using Vector or a similar tool to ship logs to another service or a third-party platform.","title":"Kubernetes Scheduler"},{"location":"deployment/schedulers/kubernetes/#kubernetes-scheduler","text":"Warning: This scheduler is not in Dokku core and thus functionality may change over time as the API stabilizes. The Kubernetes Scheduler Plugin is available free as an external plugin. Please see the plugin's issue tracker for more information on the status of the plugin. For users that require additional functionality, please refer to the Sponsoring Documentation .","title":"Kubernetes Scheduler"},{"location":"deployment/schedulers/kubernetes/#scheduler-interface","text":"The following sections describe implemented scheduler functionality for the docker-local scheduler.","title":"Scheduler Interface"},{"location":"deployment/schedulers/kubernetes/#implemented-commands-and-triggers","text":"This plugin implements various functionality through plugn triggers to integrate with kubectl for running apps on a Kubernetes cluster. The following functionality is supported by the scheduler-kubernetes plugin. apps:destroy deploy : partial, does not implement failed deploy log capture logs : partial, does not implement failure logs ps:stop","title":"Implemented Commands and Triggers"},{"location":"deployment/schedulers/kubernetes/#logging-support","text":"App logs for the logs command are fetched from running pods via the kubectl cli. To persist logs across deployments, consider using Vector or a similar tool to ship logs to another service or a third-party platform.","title":"Logging support"},{"location":"deployment/schedulers/nomad/","text":"Nomad Scheduler Warning: This scheduler is not in Dokku core and thus functionality may change over time as the API stabilizes. The Nomad Scheduler Plugin is available free as an external plugin. Please see the plugin's issue tracker for more information on the status of the plugin. For users that require additional functionality, please refer to the Sponsoring Documentation . Scheduler Interface The following sections describe implemented scheduler functionality for the docker-local scheduler. Implemented Commands and Triggers This plugin implements various functionality through plugn triggers to integrate with the nomad cli for running apps on a Nomad cluster. The following functionality is supported by the scheduler-nomad plugin. apps:destroy deploy ps:stop Logging support Warning: Fetching app logs for the logs command is currently not implemented. Please consider using Vector or a similar tool to ship logs to another service or a third-party platform.","title":"Nomad Scheduler"},{"location":"deployment/schedulers/nomad/#nomad-scheduler","text":"Warning: This scheduler is not in Dokku core and thus functionality may change over time as the API stabilizes. The Nomad Scheduler Plugin is available free as an external plugin. Please see the plugin's issue tracker for more information on the status of the plugin. For users that require additional functionality, please refer to the Sponsoring Documentation .","title":"Nomad Scheduler"},{"location":"deployment/schedulers/nomad/#scheduler-interface","text":"The following sections describe implemented scheduler functionality for the docker-local scheduler.","title":"Scheduler Interface"},{"location":"deployment/schedulers/nomad/#implemented-commands-and-triggers","text":"This plugin implements various functionality through plugn triggers to integrate with the nomad cli for running apps on a Nomad cluster. The following functionality is supported by the scheduler-nomad plugin. apps:destroy deploy ps:stop","title":"Implemented Commands and Triggers"},{"location":"deployment/schedulers/nomad/#logging-support","text":"Warning: Fetching app logs for the logs command is currently not implemented. Please consider using Vector or a similar tool to ship logs to another service or a third-party platform.","title":"Logging support"},{"location":"deployment/schedulers/null/","text":"Null Scheduler New Introduced in 0.25.0 The null scheduler does nothing, and is useful for routing to services not managed by Dokku. It should not be used in normal operation. Please see the network documentation for more information on the aforementioned use case. Usage Detection This scheduler is never auto-detected. The scheduler must be specified via the scheduler:set command: dokku scheduler:set node-js-app selected null","title":"Null Scheduler"},{"location":"deployment/schedulers/null/#null-scheduler","text":"New Introduced in 0.25.0 The null scheduler does nothing, and is useful for routing to services not managed by Dokku. It should not be used in normal operation. Please see the network documentation for more information on the aforementioned use case.","title":"Null Scheduler"},{"location":"deployment/schedulers/null/#usage","text":"","title":"Usage"},{"location":"deployment/schedulers/null/#detection","text":"This scheduler is never auto-detected. The scheduler must be specified via the scheduler:set command: dokku scheduler:set node-js-app selected null","title":"Detection"},{"location":"deployment/schedulers/scheduler-management/","text":"Scheduler Management New Introduced in 0.26.0 scheduler:report [<app>] [<flag>] # Displays a scheduler report for one or more apps scheduler:set <app> <key> (<value>) # Set or clear a scheduler property for an app Schedulers are a way of customizing how an app image is deployed, and can be used to interact with non-local systems such as Kubernetes and Nomad. Usage Scheduler selection Dokku supports the following built-in schedulers: scheduler-docker-local : Schedules apps against the local docker socket and runs containers directly on the Dokku host. See the docker-local scheduler documentation for more information on how this scheduler functions. scheduler-null : Does nothing during the scheduler phase. See the null scheduler documentation for more information on how this scheduler functions. Overriding the auto-selected scheduler If desired, the scheduler can be specified via the scheduler:set command by speifying a value for selected . The selected scheduler will always be used. dokku scheduler:set node-js-app selected docker-local The default value may be set by passing an empty value for the option: dokku scheduler:set node-js-app selected The selected property can also be set globally. The global default is an empty string, and auto-detection will be performed when no value is set per-app or globally. dokku scheduler:set --global selected docker-local The default value may be set by passing an empty value for the option. dokku scheduler:set --global selected Displaying scheduler reports for an app You can get a report about the app's scheduler status using the scheduler:report command: Shell Output dokku scheduler:report =====> node-js-app scheduler information Scheduler computed selected: herokuish Scheduler global selected: herokuish Scheduler selected: herokuish =====> python-sample scheduler information Scheduler computed selected: dockerfile Scheduler global selected: herokuish Scheduler selected: dockerfile =====> ruby-sample scheduler information Scheduler computed selected: herokuish Scheduler global selected: herokuish Scheduler selected: You can run the command for a specific app also. Shell Output dokku scheduler:report node-js-app =====> node-js-app scheduler information Scheduler selected: herokuish You can pass flags which will output only the value of the specific information you want. For example: dokku scheduler:report node-js-app --scheduler-selected Implementing a Scheduler Custom plugins names must have the prefix scheduler- or scheduler overriding via scheduler:set may not function as expected. At this time, the following dokku commands are used to implement a complete scheduler. apps:destroy : stops the app processes on the scheduler triggers: post-delete, scheduler-register-retired, scheduler-retire apps:rename : handles app renaming triggers: post-app-rename-setup apps:clone : handles app cloning triggers: post-app-clone-setup deploy : deploys app proceses and checks the status of a deploy triggers: scheduler-app-status, scheduler-deploy, scheduler-is-deployed, scheduler-logs-failed enter : enters a running container triggers: scheduler-enter logs : fetches app logs triggers: scheduler-logs run : starts one-off run containers (detached and non-detached) as well as listing run processes triggers: scheduler-run, scheduler-run-list ps:stop : stops app processes triggers: scheduler-stop ps:inspect : outputs inspect output for processes in an app triggers: scheduler-inspect Schedulers may decide to omit some functionality here, or use plugin triggers to supplement config with information from other plugins. Additionally, a scheduler may implement other triggers in order handle any extra processes needed during a deploy. Schedulers can use any tools available on the system to build the docker image, and may even be used to interact with off-server systems. The only current requirement is that the scheduler must have access to the image built in the build phase. If this is not the case, the registry plugin can be used to push the image to a registry that the scheduler software can access. Deployment tasks are currently executed directly on the primary Dokku server.","title":"Scheduler Management"},{"location":"deployment/schedulers/scheduler-management/#scheduler-management","text":"New Introduced in 0.26.0 scheduler:report [<app>] [<flag>] # Displays a scheduler report for one or more apps scheduler:set <app> <key> (<value>) # Set or clear a scheduler property for an app Schedulers are a way of customizing how an app image is deployed, and can be used to interact with non-local systems such as Kubernetes and Nomad.","title":"Scheduler Management"},{"location":"deployment/schedulers/scheduler-management/#usage","text":"","title":"Usage"},{"location":"deployment/schedulers/scheduler-management/#scheduler-selection","text":"Dokku supports the following built-in schedulers: scheduler-docker-local : Schedules apps against the local docker socket and runs containers directly on the Dokku host. See the docker-local scheduler documentation for more information on how this scheduler functions. scheduler-null : Does nothing during the scheduler phase. See the null scheduler documentation for more information on how this scheduler functions.","title":"Scheduler selection"},{"location":"deployment/schedulers/scheduler-management/#overriding-the-auto-selected-scheduler","text":"If desired, the scheduler can be specified via the scheduler:set command by speifying a value for selected . The selected scheduler will always be used. dokku scheduler:set node-js-app selected docker-local The default value may be set by passing an empty value for the option: dokku scheduler:set node-js-app selected The selected property can also be set globally. The global default is an empty string, and auto-detection will be performed when no value is set per-app or globally. dokku scheduler:set --global selected docker-local The default value may be set by passing an empty value for the option. dokku scheduler:set --global selected","title":"Overriding the auto-selected scheduler"},{"location":"deployment/schedulers/scheduler-management/#displaying-scheduler-reports-for-an-app","text":"You can get a report about the app's scheduler status using the scheduler:report command: Shell Output dokku scheduler:report =====> node-js-app scheduler information Scheduler computed selected: herokuish Scheduler global selected: herokuish Scheduler selected: herokuish =====> python-sample scheduler information Scheduler computed selected: dockerfile Scheduler global selected: herokuish Scheduler selected: dockerfile =====> ruby-sample scheduler information Scheduler computed selected: herokuish Scheduler global selected: herokuish Scheduler selected: You can run the command for a specific app also. Shell Output dokku scheduler:report node-js-app =====> node-js-app scheduler information Scheduler selected: herokuish You can pass flags which will output only the value of the specific information you want. For example: dokku scheduler:report node-js-app --scheduler-selected","title":"Displaying scheduler reports for an app"},{"location":"deployment/schedulers/scheduler-management/#implementing-a-scheduler","text":"Custom plugins names must have the prefix scheduler- or scheduler overriding via scheduler:set may not function as expected. At this time, the following dokku commands are used to implement a complete scheduler. apps:destroy : stops the app processes on the scheduler triggers: post-delete, scheduler-register-retired, scheduler-retire apps:rename : handles app renaming triggers: post-app-rename-setup apps:clone : handles app cloning triggers: post-app-clone-setup deploy : deploys app proceses and checks the status of a deploy triggers: scheduler-app-status, scheduler-deploy, scheduler-is-deployed, scheduler-logs-failed enter : enters a running container triggers: scheduler-enter logs : fetches app logs triggers: scheduler-logs run : starts one-off run containers (detached and non-detached) as well as listing run processes triggers: scheduler-run, scheduler-run-list ps:stop : stops app processes triggers: scheduler-stop ps:inspect : outputs inspect output for processes in an app triggers: scheduler-inspect Schedulers may decide to omit some functionality here, or use plugin triggers to supplement config with information from other plugins. Additionally, a scheduler may implement other triggers in order handle any extra processes needed during a deploy. Schedulers can use any tools available on the system to build the docker image, and may even be used to interact with off-server systems. The only current requirement is that the scheduler must have access to the image built in the build phase. If this is not the case, the registry plugin can be used to push the image to a registry that the scheduler software can access. Deployment tasks are currently executed directly on the primary Dokku server.","title":"Implementing a Scheduler"},{"location":"development/plugin-creation/","text":"Plugin creation A plugin can be a simple implementation of triggers or can implement a command structure of its own. Dokku has no restrictions on the language in which a plugin is implemented; it only cares that the plugin implements the appropriate commands or triggers for the API. NOTE: any file that implements triggers or uses the command API must be executable. Plugin Overview When creating custom plugins: Take a look at the plugins shipped with Dokku and hack away! Check out the list of triggers the plugin can implement Upload the plugin to GitHub with a repository name following the dokku-<name> convention (e.g. dokku-mariadb ) Edit this page and add a link to the plugin Subscribe to the dokku development blog to be notified about API changes and releases Compilable plugins (Golang, Java(?), C, etc.) When developing a plugin, the install trigger must be implemented such that it outputs the built executable(s) using a directory structure that implements the plugin's desired command and/or triggers the API. See the smoke-test-plugin for an example. Command API There are 3 main integration points: commands , subcommands/default , and subcommands/<command-name> . commands Primarily used to supply the plugin's usage/help output. (i.e. plugin help ). subcommands/default Implements the plugin's default command behavior. (i.e. dokku plugin ). subcommands/<command-name> Implements the additional command interface and will translate to dokku plugin:cmd on the command line. (i.e. dokku plugin:install ). Plugin Building Tips Always create a plugin.toml The plugin.toml file is used to describe the plugin in help output, and helps users understand the purpose of the plugin. This must have a description and a version. The version should be bumped at every plugin release. [plugin] description = \"dokku example plugin\" version = \"0.1.0\" [plugin.config] Files should be executable Commands, subcommands, triggers and source shell scripts should all be executable. On a Unix-like machine, the following command can be used to make them executable: chmod +x path/to/file Non-executable commands, subcommands, and triggers will be ignored. Use the pipefail bash option Consider whether to include the set -eo pipefail option. Look at the following example: IMAGE = $( docker images | grep \"user/repo\" | awk '{print $3}' ) if [[ -z $IMAGE ]] ; then dokku_log_fail \"user/repo image not found... Did you run 'dokku plugin:install'?\" fi If user/repo doesn't exist, Dokku exits just before the awk command and the dokku_log_fail message will never go to STDOUT . printed with echo. The set -e option should be used in this case. Here is the help entry for set : help set Options: -e Exit immediately if a command exits with a non-zero status. -o option-name pipefail the return value of a pipeline is the status of the last command to exit with a non-zero status, or zero if no command exited with a non-zero status Support trace mode Trace mode is useful for getting debugging output from plugins when the --trace flag is specified or dokku trace:on is triggered. This should be done at the top of each shell script: #!/usr/bin/env bash set -eo pipefail [[ $DOKKU_TRACE ]] && set -x In the above example, the third line enables bash's debug mode, which prints command traces before executing command. Verify the existence of dependencies If a plugin depends on a specific command-line tool, check whether that tool exists before utilizing it. Either command -v or which may be used to do so: # `command -v` example if ! command -v \"nginx\" & >/dev/null ; then dokku_log_fail \"Missing nginx, install it\" fi # `which` example if ! which nginx >/dev/null 2 > & 1 ; then dokku_log_fail \"Missing nginx, install it\" fi In cases where a dependency should be installed before the plugin can be used at all, use the dependencies plugin trigger to install the dependency. Implement a help command For plugins which expose commands, implement a help command. This may be empty, but should contain a listing of all available commands. Commas - , - are used in the help output for columnizing output. Verify that the plugin conforms to the spec by running dokku help --all and manually verifying the output. See the sample plugin below for an example. Namespace commands All commands should be namespaced. In cases where a core plugin is overriden, the plugin may utilize the a namespace in use by the core, but generally this should be avoided to reduce confusion as to where the command is implemented. Implement a proper catch-all command As of 0.3.3, a catch-all should be implemented that exits with a DOKKU_NOT_IMPLEMENTED_EXIT code. This allows Dokku to output a command not found message. See the sample plugin below for an example. Set app config without restarting In the case that a plugin needs to set app configuration settings and a restart should be avoided (default Heroku-style behavior) these \"internal\" commands provide this functionality: config_set --no-restart node-js-app KEY1 = VALUE1 [ KEY2 = VALUE2 ... ] config_unset --no-restart node-js-app KEY1 [ KEY2 ... ] Expose functionality in a functions file To allow other plugins access to (some of) a plugin's functionality, functions can expose by including a functions file in the plugin for others to source. All functions in that file should be considered publicly accessible by other plugins. Any functions that must be kept private should reside in the plugin's trigger/ or commands/ directories. Other files may also be used to hide private functions; the official convention for hiding private functions is to place them an internal-functions file. Use helper functions to fetch app images New Introduced in 0.4.0 Dokku allows image tagging and deployment of tagged images. This means hard-coding the $IMAGE as dokku/$APP is no longer sufficient. Plugins should use get_running_image_tag() and get_app_image_name() as sourced from common/functions . See the plugin triggers doc for examples. Info Note: This is only for plugins that are not pre/post-build-* plugins Use $DOCKER_BIN instead of docker directly New Introduced in 0.17.5 Certain systems may require a wrapper function around the docker binary for proper execution. Utilizing the $DOCKER_BIN environment variable when calling docker for those functions is preferred. # good \" $DOCKER_BIN \" container run -d $IMAGE /bin/bash -e -c \" $COMMAND \" # bad docker run -d $IMAGE /bin/bash -e -c \" $COMMAND \" Include labels for all temporary containers and images New Introduced in 0.5.0 As of 0.5.0, labels are used to help cleanup intermediate containers with dokku cleanup . Plugins that create containers and images should add the correct labels to the build , commit , and run docker commands. Note that where possible, a label com.dokku.app-name=$APP - where $APP is the name of the app - should also be included. This enables dokku cleanup APP to cleanup the specific containers for a given app. # `docker build` example \" $DOCKER_BIN \" image build \"--label=com.dokku.app-name= ${ APP } \" $DOKKU_GLOBAL_BUILD_ARGS ... # `docker commit` example # Note that the arguments must be set as a local array # as arrays cannot be exported in shell local DOKKU_COMMIT_ARGS =( \"--change\" \"LABEL org.label-schema.schema-version=1.0\" \"--change\" \"LABEL org.label-schema.vendor=dokku\" \"--change\" \"LABEL $DOKKU_CONTAINER_LABEL =\" ) \" $DOCKER_BIN \" container commit --change \"LABEL com.dokku.app-name= $APP \" \" ${ DOKKU_COMMIT_ARGS [@] } \" ... # `docker run` example \" $DOCKER_BIN \" container run \"--label=com.dokku.app-name= ${ APP } \" $DOKKU_GLOBAL_RUN_ARGS ... Copy files from the built image using copy_from_image Avoid copying files from running containers as these files may change over time. Instead copy files from the image built during the deploy process. This can be done via the copy_from_image helper function. This will correctly handle various corner cases in copying files from an image. source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" local TMP_FILE = $( mktemp \"/tmp/dokku- ${ DOKKU_PID } - ${ FUNCNAME [0] } .XXXXXX\" ) trap \"rm -rf ' $TMP_FILE ' >/dev/null\" RETURN INT TERM local IMAGE_TAG = \" $( get_running_image_tag \" $APP \" ) \" local IMAGE = $( get_deploying_app_image_name \" $APP \" \" $IMAGE_TAG \" ) copy_from_image \" $IMAGE \" \"file-being-copied\" \" $TMP_FILE \" 2 >/dev/null Files are copied from the /app directory - for images built via buildpacks - or WORKDIR - for images built via Dockerfile. Avoid calling the dokku binary directly New Introduced in 0.6.0 Plugins should not call the dokku binary directly from within plugins because clients using the --app argument are potentially broken when doing so. Plugins should instead source the functions file for a given plugin when attempting to call Dokku internal functions. In cases where plugin functions cannot be sourced (eg if a plugin is implemented in Golang), then call the relevant plugin triggers instead. Sample plugin The below plugin is a dummy dokku hello plugin. Each plugin requires a plugin.toml descriptor file with the following required fields: [plugin] description = \"dokku hello plugin\" version = \"0.1.0\" [plugin.config] hello/subcommands/default #!/usr/bin/env bash set -eo pipefail [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" cmd-hello-default () { declare desc = \"prints Hello \\$APP\" declare cmd = \"hello\" [[ \" $1 \" == \" $cmd \" ]] && shift 1 # Support --app/$DOKKU_APP_NAME flag # Use the following lines to reorder args into \"$cmd $DOKKU_APP_NAME $@\"\" [[ -n $DOKKU_APP_NAME ]] && set -- $DOKKU_APP_NAME $@ set -- $cmd $@ # declare APP = \" $1 \" [[ -z \" $APP \" ]] && dokku_log_fail \"Please specify an app to run the command on\" verify_app_name \" $APP \" echo \"Hello $APP \" } cmd-hello-default \" $@ \" hello/subcommands/world #!/usr/bin/env bash set -eo pipefail [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" cmd-hello-world () { declare desc = \"prints Hello world\" declare cmd = \"hello:world\" [[ \" $1 \" == \" $cmd \" ]] && shift 1 echo \"Hello world\" } cmd-hello-world \" $@ \" hello/commands #!/usr/bin/env bash set -eo pipefail [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | hello:help ) help_content_func () { declare desc = \"return help_content string\" cat <<help_content hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" help_content } if [[ $1 = \"hello:help\" ]] ; then echo -e 'Usage: dokku hello[:world] [<app>]' echo '' echo 'Say Hello World.' echo '' echo 'Example:' echo '' echo '$ dokku hello:world' echo 'Hello world' echo '' echo 'Additional commands:' help_content_func | sort | column -c2 -t -s, else help_content_func fi ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac","title":"Plugin creation"},{"location":"development/plugin-creation/#plugin-creation","text":"A plugin can be a simple implementation of triggers or can implement a command structure of its own. Dokku has no restrictions on the language in which a plugin is implemented; it only cares that the plugin implements the appropriate commands or triggers for the API. NOTE: any file that implements triggers or uses the command API must be executable.","title":"Plugin creation"},{"location":"development/plugin-creation/#plugin-overview","text":"When creating custom plugins: Take a look at the plugins shipped with Dokku and hack away! Check out the list of triggers the plugin can implement Upload the plugin to GitHub with a repository name following the dokku-<name> convention (e.g. dokku-mariadb ) Edit this page and add a link to the plugin Subscribe to the dokku development blog to be notified about API changes and releases","title":"Plugin Overview"},{"location":"development/plugin-creation/#compilable-plugins-golang-java-c-etc","text":"When developing a plugin, the install trigger must be implemented such that it outputs the built executable(s) using a directory structure that implements the plugin's desired command and/or triggers the API. See the smoke-test-plugin for an example.","title":"Compilable plugins (Golang, Java(?), C, etc.)"},{"location":"development/plugin-creation/#command-api","text":"There are 3 main integration points: commands , subcommands/default , and subcommands/<command-name> .","title":"Command API"},{"location":"development/plugin-creation/#commands","text":"Primarily used to supply the plugin's usage/help output. (i.e. plugin help ).","title":"commands"},{"location":"development/plugin-creation/#subcommandsdefault","text":"Implements the plugin's default command behavior. (i.e. dokku plugin ).","title":"subcommands/default"},{"location":"development/plugin-creation/#subcommandscommand-name","text":"Implements the additional command interface and will translate to dokku plugin:cmd on the command line. (i.e. dokku plugin:install ).","title":"subcommands/&lt;command-name&gt;"},{"location":"development/plugin-creation/#plugin-building-tips","text":"","title":"Plugin Building Tips"},{"location":"development/plugin-creation/#always-create-a-plugintoml","text":"The plugin.toml file is used to describe the plugin in help output, and helps users understand the purpose of the plugin. This must have a description and a version. The version should be bumped at every plugin release. [plugin] description = \"dokku example plugin\" version = \"0.1.0\" [plugin.config]","title":"Always create a plugin.toml"},{"location":"development/plugin-creation/#files-should-be-executable","text":"Commands, subcommands, triggers and source shell scripts should all be executable. On a Unix-like machine, the following command can be used to make them executable: chmod +x path/to/file Non-executable commands, subcommands, and triggers will be ignored.","title":"Files should be executable"},{"location":"development/plugin-creation/#use-the-pipefail-bash-option","text":"Consider whether to include the set -eo pipefail option. Look at the following example: IMAGE = $( docker images | grep \"user/repo\" | awk '{print $3}' ) if [[ -z $IMAGE ]] ; then dokku_log_fail \"user/repo image not found... Did you run 'dokku plugin:install'?\" fi If user/repo doesn't exist, Dokku exits just before the awk command and the dokku_log_fail message will never go to STDOUT . printed with echo. The set -e option should be used in this case. Here is the help entry for set : help set Options: -e Exit immediately if a command exits with a non-zero status. -o option-name pipefail the return value of a pipeline is the status of the last command to exit with a non-zero status, or zero if no command exited with a non-zero status","title":"Use the pipefail bash option"},{"location":"development/plugin-creation/#support-trace-mode","text":"Trace mode is useful for getting debugging output from plugins when the --trace flag is specified or dokku trace:on is triggered. This should be done at the top of each shell script: #!/usr/bin/env bash set -eo pipefail [[ $DOKKU_TRACE ]] && set -x In the above example, the third line enables bash's debug mode, which prints command traces before executing command.","title":"Support trace mode"},{"location":"development/plugin-creation/#verify-the-existence-of-dependencies","text":"If a plugin depends on a specific command-line tool, check whether that tool exists before utilizing it. Either command -v or which may be used to do so: # `command -v` example if ! command -v \"nginx\" & >/dev/null ; then dokku_log_fail \"Missing nginx, install it\" fi # `which` example if ! which nginx >/dev/null 2 > & 1 ; then dokku_log_fail \"Missing nginx, install it\" fi In cases where a dependency should be installed before the plugin can be used at all, use the dependencies plugin trigger to install the dependency.","title":"Verify the existence of dependencies"},{"location":"development/plugin-creation/#implement-a-help-command","text":"For plugins which expose commands, implement a help command. This may be empty, but should contain a listing of all available commands. Commas - , - are used in the help output for columnizing output. Verify that the plugin conforms to the spec by running dokku help --all and manually verifying the output. See the sample plugin below for an example.","title":"Implement a help command"},{"location":"development/plugin-creation/#namespace-commands","text":"All commands should be namespaced. In cases where a core plugin is overriden, the plugin may utilize the a namespace in use by the core, but generally this should be avoided to reduce confusion as to where the command is implemented.","title":"Namespace commands"},{"location":"development/plugin-creation/#implement-a-proper-catch-all-command","text":"As of 0.3.3, a catch-all should be implemented that exits with a DOKKU_NOT_IMPLEMENTED_EXIT code. This allows Dokku to output a command not found message. See the sample plugin below for an example.","title":"Implement a proper catch-all command"},{"location":"development/plugin-creation/#set-app-config-without-restarting","text":"In the case that a plugin needs to set app configuration settings and a restart should be avoided (default Heroku-style behavior) these \"internal\" commands provide this functionality: config_set --no-restart node-js-app KEY1 = VALUE1 [ KEY2 = VALUE2 ... ] config_unset --no-restart node-js-app KEY1 [ KEY2 ... ]","title":"Set app config without restarting"},{"location":"development/plugin-creation/#expose-functionality-in-a-functions-file","text":"To allow other plugins access to (some of) a plugin's functionality, functions can expose by including a functions file in the plugin for others to source. All functions in that file should be considered publicly accessible by other plugins. Any functions that must be kept private should reside in the plugin's trigger/ or commands/ directories. Other files may also be used to hide private functions; the official convention for hiding private functions is to place them an internal-functions file.","title":"Expose functionality in a functions file"},{"location":"development/plugin-creation/#use-helper-functions-to-fetch-app-images","text":"New Introduced in 0.4.0 Dokku allows image tagging and deployment of tagged images. This means hard-coding the $IMAGE as dokku/$APP is no longer sufficient. Plugins should use get_running_image_tag() and get_app_image_name() as sourced from common/functions . See the plugin triggers doc for examples. Info Note: This is only for plugins that are not pre/post-build-* plugins","title":"Use helper functions to fetch app images"},{"location":"development/plugin-creation/#use-docker_bin-instead-of-docker-directly","text":"New Introduced in 0.17.5 Certain systems may require a wrapper function around the docker binary for proper execution. Utilizing the $DOCKER_BIN environment variable when calling docker for those functions is preferred. # good \" $DOCKER_BIN \" container run -d $IMAGE /bin/bash -e -c \" $COMMAND \" # bad docker run -d $IMAGE /bin/bash -e -c \" $COMMAND \"","title":"Use $DOCKER_BIN instead of docker directly"},{"location":"development/plugin-creation/#include-labels-for-all-temporary-containers-and-images","text":"New Introduced in 0.5.0 As of 0.5.0, labels are used to help cleanup intermediate containers with dokku cleanup . Plugins that create containers and images should add the correct labels to the build , commit , and run docker commands. Note that where possible, a label com.dokku.app-name=$APP - where $APP is the name of the app - should also be included. This enables dokku cleanup APP to cleanup the specific containers for a given app. # `docker build` example \" $DOCKER_BIN \" image build \"--label=com.dokku.app-name= ${ APP } \" $DOKKU_GLOBAL_BUILD_ARGS ... # `docker commit` example # Note that the arguments must be set as a local array # as arrays cannot be exported in shell local DOKKU_COMMIT_ARGS =( \"--change\" \"LABEL org.label-schema.schema-version=1.0\" \"--change\" \"LABEL org.label-schema.vendor=dokku\" \"--change\" \"LABEL $DOKKU_CONTAINER_LABEL =\" ) \" $DOCKER_BIN \" container commit --change \"LABEL com.dokku.app-name= $APP \" \" ${ DOKKU_COMMIT_ARGS [@] } \" ... # `docker run` example \" $DOCKER_BIN \" container run \"--label=com.dokku.app-name= ${ APP } \" $DOKKU_GLOBAL_RUN_ARGS ...","title":"Include labels for all temporary containers and images"},{"location":"development/plugin-creation/#copy-files-from-the-built-image-using-copy_from_image","text":"Avoid copying files from running containers as these files may change over time. Instead copy files from the image built during the deploy process. This can be done via the copy_from_image helper function. This will correctly handle various corner cases in copying files from an image. source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" local TMP_FILE = $( mktemp \"/tmp/dokku- ${ DOKKU_PID } - ${ FUNCNAME [0] } .XXXXXX\" ) trap \"rm -rf ' $TMP_FILE ' >/dev/null\" RETURN INT TERM local IMAGE_TAG = \" $( get_running_image_tag \" $APP \" ) \" local IMAGE = $( get_deploying_app_image_name \" $APP \" \" $IMAGE_TAG \" ) copy_from_image \" $IMAGE \" \"file-being-copied\" \" $TMP_FILE \" 2 >/dev/null Files are copied from the /app directory - for images built via buildpacks - or WORKDIR - for images built via Dockerfile.","title":"Copy files from the built image using copy_from_image"},{"location":"development/plugin-creation/#avoid-calling-the-dokku-binary-directly","text":"New Introduced in 0.6.0 Plugins should not call the dokku binary directly from within plugins because clients using the --app argument are potentially broken when doing so. Plugins should instead source the functions file for a given plugin when attempting to call Dokku internal functions. In cases where plugin functions cannot be sourced (eg if a plugin is implemented in Golang), then call the relevant plugin triggers instead.","title":"Avoid calling the dokku binary directly"},{"location":"development/plugin-creation/#sample-plugin","text":"The below plugin is a dummy dokku hello plugin. Each plugin requires a plugin.toml descriptor file with the following required fields: [plugin] description = \"dokku hello plugin\" version = \"0.1.0\" [plugin.config] hello/subcommands/default #!/usr/bin/env bash set -eo pipefail [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" cmd-hello-default () { declare desc = \"prints Hello \\$APP\" declare cmd = \"hello\" [[ \" $1 \" == \" $cmd \" ]] && shift 1 # Support --app/$DOKKU_APP_NAME flag # Use the following lines to reorder args into \"$cmd $DOKKU_APP_NAME $@\"\" [[ -n $DOKKU_APP_NAME ]] && set -- $DOKKU_APP_NAME $@ set -- $cmd $@ # declare APP = \" $1 \" [[ -z \" $APP \" ]] && dokku_log_fail \"Please specify an app to run the command on\" verify_app_name \" $APP \" echo \"Hello $APP \" } cmd-hello-default \" $@ \" hello/subcommands/world #!/usr/bin/env bash set -eo pipefail [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" cmd-hello-world () { declare desc = \"prints Hello world\" declare cmd = \"hello:world\" [[ \" $1 \" == \" $cmd \" ]] && shift 1 echo \"Hello world\" } cmd-hello-world \" $@ \" hello/commands #!/usr/bin/env bash set -eo pipefail [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | hello:help ) help_content_func () { declare desc = \"return help_content string\" cat <<help_content hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" help_content } if [[ $1 = \"hello:help\" ]] ; then echo -e 'Usage: dokku hello[:world] [<app>]' echo '' echo 'Say Hello World.' echo '' echo 'Example:' echo '' echo '$ dokku hello:world' echo 'Hello world' echo '' echo 'Additional commands:' help_content_func | sort | column -c2 -t -s, else help_content_func fi ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac","title":"Sample plugin"},{"location":"development/plugin-triggers/","text":"Plugin triggers Plugin triggers (formerly pluginhooks ) are a good way to jack into existing Dokku infrastructure. You can use them to modify the output of various Dokku commands or override internal configuration. Plugin triggers are simply scripts that are executed by the system. You can use any language you want, so long as the script: Is executable Has the proper language requirements installed For instance, if you wanted to write a plugin trigger in PHP, you would need to have php installed and available on the CLI prior to plugin trigger invocation. The following is an example for the nginx-hostname plugin trigger. It reverses the hostname that is provided to nginx during deploys. If you created an executable file named nginx-hostname with the following code in your plugin trigger, it would be invoked by Dokku during the normal app deployment process: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" Available plugin triggers There are a number of plugin-related triggers. These can be optionally implemented by plugins and allow integration into the standard Dokku setup/teardown process. The following plugin triggers describe those available to a Dokku installation. As well, there is an example for each trigger that you can use as templates for your own plugin development. Info The example plugin trigger code is not guaranteed to be implemented as in within dokku, and are merely simplified examples. Please look at the Dokku source for larger, more in-depth examples. app-create Description: Creates an app Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO app-destroy Description: Destroys an app (with confirmation if force isn't specified) Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO app-exists Description: Creates an app Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO app-list Description: Lists all apps in available to the currently logged in user. Optionally disables filtering by user if the first argument is false . Invoked by: Arguments: $FILTER Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO app-json-process-deploy-parallelism Description: Decides the parallelism to use when deploying a given process type. The default is 1 process entry at a type. Invoked by: dokku deploy Arguments: $APP $PROCESS_TYPE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO app-maybe-create Description: Creates an app (gated by whether this is globally enabled or not) Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO app-restart Description: Triggers an app restart Invoked by: dokku config:clear , dokku config:set , dokku config:unset Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO app-urls Description: Allows you to change the urls Dokku reports for an application. Will override any auto-detected urls. Invoked by: dokku deploy , dokku url , and dokku urls Arguments: $APP $URL_TYPE Example: #!/usr/bin/env bash # Sets the domain to `internal.tld` set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; URL_TYPE = \" $2 \" case \" $URL_TYPE \" in url ) echo \"https://internal.tld/ ${ APP } /\" ;; urls ) echo \"https://internal.tld/ ${ APP } /\" echo \"http://internal.tld/ ${ APP } /\" ;; esac builder-build Description: Triggers the artifact build process Invoked by: dokku deploy Arguments: $BUILDER_TYPE $APP $SOURCECODE_WORK_DIR Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO builder-detect Description: Allows overriding the auto-detected herokuish builder in favor of a custom one. Dockerfile gets lowest builder precedence. Invoked by: dokku deploy Arguments: $APP $SOURCECODE_WORK_DIR Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SOURCECODE_WORK_DIR = \" $2 \" if [[ -f \" $SOURCECODE_WORK_DIR /project.toml\" ]] ; then echo -n \"pack\" fi builder-create-dokku-image Description: Allows modification of the configured dokku-image Invoked by: dokku deploy Arguments: $BUILDER_TYPE $APP $SOURCECODE_WORK_DIR $DOKKU_IMAGE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO builder-dokku-image Description: Allows modification of the used dokku-image. Invoked by: dokku deploy Arguments: $BUILDER_TYPE $APP $SOURCECODE_WORK_DIR $DOKKU_IMAGE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO builder-release Description: Triggers the artifact release process Invoked by: dokku deploy Arguments: $BUILDER_TYPE $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO check-deploy Description: Allows you to run checks on a deploy before Dokku allows the container to handle requests. Invoked by: dokku deploy Arguments: $APP $CONTAINER_ID $PROC_TYPE $PORT $IP Example: #!/usr/bin/env bash # Disables deploys of containers based on whether the # `DOKKU_DISABLE_DEPLOY` env var is set to `true` for an app set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_AVAILABLE_PATH /config/functions\" APP = \" $1 \" ; CONTAINER_ID = \" $2 \" ; PROC_TYPE = \" $3 \" ; PORT = \" $4 \" ; IP = \" $5 \" eval \" $( config_export app $APP ) \" DOKKU_DISABLE_DEPLOY = \" ${ DOKKU_DISABLE_DEPLOY :- false } \" if [[ \" $DOKKU_DISABLE_DEPLOY \" = \"true\" ]] ; then echo -e \"\\033[31m\\033[1mDeploys disabled, sorry.\\033[0m\" exit 1 fi checks-get-property Description: Return the value for an app's checks property Invoked by: Arguments: $APP $KEY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; PROPERTY = \" $2 \" # TODO commands help and commands <PLUGIN_NAME>:help Description: Your plugin should implement a help command in your commands file to take advantage of this plugin trigger. commands help is used by dokku help to aggregate all plugins abbreviated help output. Implementing <PLUGIN_NAME>:help in your commands file gives users looking for help, a more detailed output. 'commands help' must be implemented inside the commands plugin file. It's recommended that PLUGIN_NAME:help be added to the commands file to ensure consistency among community plugins and give you a new avenue to share rich help content with your user. Invoked by: dokku help and commands <PLUGIN_NAME>:help Arguments: None Example: #!/usr/bin/env bash # Outputs help for the derp plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | hello:help ) help_content_func () { declare desc = \"return help_content string\" cat <<help_content hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" help_content } if [[ $1 = \"hello:help\" ]] ; then echo -e 'Usage: dokku hello[:world] [<app>]' echo '' echo 'Say Hello World.' echo '' echo 'Example:' echo '' echo '$ dokku hello:world' echo 'Hello world' echo '' echo 'Additional commands:' help_content_func | sort | column -c2 -t -s, else help_content_func fi ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac config-export Description: Returns the environment variables in a specified format Invoked by: app-json plugin Arguments: $APP $GLOBAL $MERGED $FORMAT Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO config-get Description: Fetches the app config value for a key Invoked by: Arguments: $APP $KEY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO config-get-global Description: Fetches the global config value for a key Invoked by: Arguments: $KEY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO core-post-deploy Info To avoid issues with community plugins, this plugin trigger should be used only for core plugins. Please avoid using this trigger in your own plugins. Description: Allows running of commands after an app's processes have been scaled up, but before old containers are torn down. Dokku core currently uses this to switch traffic on nginx. Invoked by: dokku deploy Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS $IMAGE_TAG Example: #!/usr/bin/env bash # Notify an external service that a successful deploy has occurred. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x curl \"http://httpstat.us/200\" core-post-extract Info To avoid issues with community plugins, this plugin trigger should be used only for core plugins. Please avoid using this trigger in your own plugins. Description: Allows you to modify the contents of an app after it has been extracted from git but before the image source type is detected. Invoked by: The receive-app plugin trigger Arguments: $APP $TMP_WORK_DIR $REV Example: #!/usr/bin/env bash # Adds a clock process to an app's Procfile set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" TMP_WORK_DIR = \" $2 \" REV = \" $3 \" # optional, may not be sent for tar-based builds pushd \" $TMP_WORK_DIR \" >/dev/null touch Procfile echo \"clock: some-command\" >> Procfile popd & >/dev/null cron-write Description: Force triggers writing out cron entries Invoked by: Arguments: Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" # TODO cron-entries Description: Allows injecting cron entries into the written out scheduled cron task list. Each entry is newline delimited, and individual entries come in the form $SCHEDULE;$FULL_COMMAND;$ARBITRARY_DATA . Individual implementations of cron writing can decide whether and how to include these cron entries. The ARBITRARY_DATA includes the log file path for the basic docker-local cron implementation. Invoked by: Arguments: $DOKKU_SCHEDULER Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" DOKKU_SCHEDULER = \" $1 \" # TODO dependencies Description: Used to install system-level dependencies. Invoked by: dokku plugin:install-dependencies Arguments: None Example: #!/usr/bin/env bash # Installs nginx for the current plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x export DEBIAN_FRONTEND = noninteractive case \" $DOKKU_DISTRO \" in debian | raspbian | ubuntu ) apt-get -qq -y --no-install-recommends install nginx ;; * ) echo \"Installation on $DOKKU_DISTRO not supported\" 1 > & 2 ;; esac deploy Description: Triggers a deploy for the given app. Can override the image tag to deploy, as well as specify a single process type to deploy. Invoked by: dokku deploy Arguments: $APP [$IMAGE_TAG] [$PROC_TYPE] Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" IMAGE_TAG = \" $2 \" PROC_TYPE = \" $3 \" # TODO deployed-app-image-repo Description: Used to manage the full repo of the image being deployed. Useful for deploying from an external registry where the repository name is not dokku/$APP Invoked by: internal function dokku_deploy_cmd() (deploy phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" # change the repo from dokku/APP to dokkupaas/APP echo \"dokkupaas/ $APP \" deployed-app-image-tag Description: Used to manage the tag of the image being deployed. Useful for deploying a specific version of an image, or when deploying from an external registry Invoked by: internal function dokku_deploy_cmd() (deploy phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # customize the tag version echo 'not-latest' deployed-app-repository Description: Used to manage the remote repository of the image being deployed. Invoked by: internal function dokku_deploy_cmd() (deploy phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x echo 'derp.dkr.ecr.us-east-1.amazonaws.com' docker-args-build Warning Deprecated, please use docker-args-process-build instead Description: Invoked by: internal function dokku_build() (build phase) Arguments: $APP $IMAGE_SOURCE_TYPE Example: #!/usr/bin/env bash # Sets a docker build-arg called CACHEBUST which can be used # to bust cache at any arbitrary point in a Dockerfile build set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x STDIN = $( cat ) APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $2 \" output = \"\" if [[ \" $IMAGE_SOURCE_TYPE \" == \"dockerfile\" ]] ; then output = \" --build-arg CACHEBUST= $( date +%s ) \" fi echo -n \" $STDIN$output \" docker-args-deploy Warning Deprecated, please use docker-args-process-deploy instead Description: Invoked by: dokku deploy Arguments: $APP $IMAGE_TAG [$PROC_TYPE $CONTAINER_INDEX] Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO docker-args-process-build Description: $PROC_TYPE may be set to magic _all_ process type to signify global docker deploy options. Invoked by: dokku ps:rebuild Arguments: $APP $IMAGE_SOURCE_TYPE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $2 \" # TODO docker-args-process-deploy Description: $PROC_TYPE may be set to magic _all_ process type to signify global docker deploy options. Invoked by: dokku deploy Arguments: $APP $IMAGE_SOURCE_TYPE $IMAGE_TAG [$PROC_TYPE $CONTAINER_INDEX] Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; $IMAGE_SOURCE_TYPE = \" $2 \" IMAGE_TAG = \" $3 \" ; PROC_TYPE = \" $4 \" ; CONTAINER_INDEX = \" $5 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO docker-args-process-run Description: $PROC_TYPE may be set to magic _all_ process type to signify global docker run options. Invoked by: dokku run Arguments: $APP $IMAGE_SOURCE_TYPE $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $3 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO docker-args-run Warning Deprecated, please use docker-args-process-run instead Description: Invoked by: dokku run Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO domains-add Description: Adds a domain to an app Invoked by: Arguments: $APP $DOMAIN Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO domains-disable Description: Disables domains for an app Invoked by: Arguments: $APP $RESTART_APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO domains-enable Description: Enables domains for an app Invoked by: Arguments: $APP $RESTART_APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO domains-list Description: Lists all domains for an app Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO domains-setup Description: Initializes domains for an app if enabled Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO domains-vhost-enabled Description: Checks if a virtual hosts are enabled for an app Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO git-deploy-branch Description: Outputs the deploy branch for an app, inherited or not Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO git-from-archive Description: Updates an app's git repository from an archive and then triggers a build Invoked by: git:from-archive Arguments: $APP $ARCHIVE_URL $ARCHIVE_TYPE $USER_NAME $USER_EMAIL Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO git-from-directory Description: Updates an app's git repository from a source directory and then triggers a build Invoked by: git:from-image and git:from-archive Arguments: $APP $SOURCECODE_WORK_DIR $USER_NAME $USER_EMAIL Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO git-from-image Description: Updates an app's git repository from a docker image and then triggers a build as necessary Invoked by: git:from-image Arguments: $APP $DOCKER_IMAGE $BUILD_DIR $USER_NAME $USER_EMAIL Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO git-has-code Description: Checks to see if there is code at the specified branch Arguments: $APP $BRANCH_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO git-post-pull Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO git-pre-pull Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO Warning The git-pre-pull trigger should not be used for authentication since it does not get called for commands that use git-upload-archive such as git archive . Instead, use the user-auth trigger. git-revision Description: Allows you to fetch the current git revision for a given application Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO install Description: Used to setup any files/configuration for a plugin. Invoked by: dokku plugin:install . Arguments: None Example: #!/usr/bin/env bash # Sets the hostname of the Dokku server # based on the output of `hostname -f` set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x if [[ ! -f \" $DOKKU_ROOT /VHOST\" ]] ; then hostname -f > $DOKKU_ROOT /VHOST fi logs-get-property Description: Return the value for an app's log property Invoked by: Arguments: $APP $KEY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; PROPERTY = \" $2 \" # TODO network-build-config Description: Rebuilds network configuration Invoked by: internally triggered by proxy-build-config within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-clear-config Description: Clears network configuration Invoked by: internally triggered within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-compute-ports Description: Computes the ports for a given app container Invoked by: internally triggered by proxy-build-config within proxy implementations Arguments: $APP $PROC_TYPE $IS_HEROKUISH_CONTAINER $CONTAINER_INDEX Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-config-exists Description: Returns whether the network configuration for a given app exists Invoked by: internally triggered by core-post-deploy within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-get-ipaddr Description: Return the ipaddr for a given app container Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_ID Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-get-listeners Description: Return the listeners (host:port combinations) for a given app container Invoked by: internally triggered by a deploy Arguments: $APP $PROCESS_TYPE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-get-port Description: Return the port for a given app container Invoked by: internally triggered by a deploy Arguments: $APP $PROCESS_TYPE $CONTAINER_ID $IS_HEROKUISH_CONTAINER Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-get-property Description: Return the value for an app's network property Invoked by: internally triggered by a deploy Arguments: $APP $KEY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-get-static-listeners Description: Return the network value for an app's property Invoked by: internally triggered by proxy-build-config Arguments: $APP $PROCESS_TYPE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-write-ipaddr Description: Write the ipaddr for a given app index Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_INDEX $IP_ADDRESS Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-write-port Description: Write the port for a given app index Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_INDEX $PORT Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO nginx-app-template-source Description: Return the path to a sigil template that should be used to generate a given nginx configuration file. Invoked by: nginx-vhosts#build-config Arguments: $APP $TEMPLATE_TYPE The TEMPLATE_TYPE argument can be one of: [app-config, hsts-config, validate-config] Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" TEMPLATE_TYPE = \" $2 \" case \" $TEMPLATE_TYPE \" in app-config ) echo \" $( cd \" $( dirname \" ${ BASH_SOURCE [0] } \" ) \" && pwd ) /app.conf.sigil\" ;; hsts-config ) echo \" $( cd \" $( dirname \" ${ BASH_SOURCE [0] } \" ) \" && pwd ) /hsts.conf.sigil\" ;; validate-config ) echo \" $( cd \" $( dirname \" ${ BASH_SOURCE [0] } \" ) \" && pwd ) /validate.conf.sigil\" ;; * ) dokku_log_fail \"Invalid template type: ${ TEMPLATE_TYPE } \" esac The default templates are viewable here: plugins/nginx-vhosts/templates/ nginx-dokku-template-source Description: Return the path to a sigil template that should be used to generate the dokku.conf nginx configuration file. Invoked by: nginx-vhosts#install Arguments: None, however the sigil template can make use of the following variables: $.DOKKU_ROOT $.NGINX_ROOT Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x echo \" $( cd \" $( dirname \" ${ BASH_SOURCE [0] } \" ) \" && pwd ) /dokku.conf.sigil\" The default template is viewable here: plugins/nginx-vhosts/templates/dokku.conf.sigil nginx-hostname Description: Allows you to customize the hostname for a given app Invoked by: dokku domains:setup Arguments: $APP $SUBDOMAIN $VHOST Example: #!/usr/bin/env bash # Reverses the hostname for the app set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" nginx-pre-reload Warning The arguments INTERNAL_PORT and INTERNAL_IP_ADDRESS are no longer sufficient to retrieve all app listeners. Please run plugn trigger network-get-listeners APP within any implementation of nginx-pre-reload in order to retrieve all application listeners. Description: Run before nginx reloads hosts Invoked by: dokku nginx:build-config Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Runs a check against all nginx conf files # to ensure they are valid set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x nginx -t post-app-clone Description: Allows you to run commands after an app was cloned. Invoked by: dokku apps:clone Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-app-clone-setup Description: Allows you to run commands after an app is setup, and before it is rebuild. This is useful for cleaning up tasks, or ensuring configuration from an old app is copied to the new app Invoked by: dokku apps:clone Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-app-rename Description: Allows you to run commands after an app was renamed. Invoked by: dokku apps:rename Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-app-rename-setup Description: Allows you to run commands after an app is setup, and before it is rebuild. This is useful for cleaning up tasks, or ensuring configuration from an old app is copied to the new app Invoked by: dokku apps:rename Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-build-buildpack Description: Allows you to run commands after the build image is create for a given app. Only applies to apps using buildpacks. Invoked by: internal function dokku_build() (build phase) Arguments: $APP $SOURCECODE_WORK_DIR Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-build-pack Warning The pack plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run commands after the build image is create for a given app. Only applies to apps using pack. Invoked by: internal function dokku_build() (build phase) Arguments: $APP $SOURCECODE_WORK_DIR Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-build-dockerfile Description: Allows you to run commands after the build image is create for a given app. Only applies to apps using a dockerfile. Invoked by: internal function dokku_build() (build phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-certs-remove Description: Allows you to run commands after a cert is removed Invoked by: dokku certs:remove Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" # TODO post-certs-update Description: Allows you to run commands after a cert is added/updated Invoked by: dokku certs:add , dokku certs:update Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" # TODO post-config-update Description: Allows you to get notified when one or more configs is added or removed. Action can be set or unset . Invoked by: dokku config:set , dokku config:unset Arguments: $APP set|unset key1=VALUE1 key2=VALUE2 Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-container-create Description: This trigger should be used to do stuff to containers after they are created but before they are started. They are explicitely for commands that may involve network traffic, and not for commands that are self-contained, such as chown or tar. Invoked by: dokku run , dokku ps:rebuild , dokku deploy Arguments \"app|service\" \"$CONTAINER_ID\" \"$APP|$SERVICE\" \"$PHASE\" #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-create Description: Can be used to run commands after an app is created. Invoked by: dokku apps:create Arguments: $APP Example: #!/usr/bin/env bash # Runs a command to ensure that an app # has a postgres database when it is starting set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; POSTGRES = \" $1 \" dokku postgres:create $POSTGRES dokku postgres:link $POSTGRES $APP post-delete Description: Can be used to run commands after an app is deleted. Invoked by: dokku apps:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Runs a command to ensure that an app's # postgres installation is removed set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku postgres:destroy $APP post-deploy Info Please see core-post-deploy if contributing a core plugin with the post-deploy hook. Description: Allows running of commands after an app's processes have been scaled up, but before old containers are torn down. Dokku calls this after core-post-deploy . Deployment Tasks are also invoked by this plugin trigger. Invoked by: dokku deploy Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS $IMAGE_TAG Example: #!/usr/bin/env bash # Notify an external service that a successful deploy has occurred. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x curl \"http://httpstat.us/200\" post-domains-update Description: Allows you to run commands once the domain for an app has been updated. It also sends in the command that has been used. This can be \"add\", \"clear\" or \"remove\". The third argument will be the optional list of domains Invoked by: dokku domains:add , dokku domains:clear , dokku domains:remove , dokku domains:set Arguments: $APP action name domains Example: #!/usr/bin/env bash # Reloads haproxy for our imaginary haproxy plugin # that replaces the nginx-vhosts plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x sudo service haproxy reload post-extract Description: Allows you to modify the contents of an app after it has been extracted from git but before the image source type is detected. Invoked by: The receive-app plugin trigger Arguments: $APP $TMP_WORK_DIR $REV Example: #!/usr/bin/env bash # Adds a clock process to an app's Procfile set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" TMP_WORK_DIR = \" $2 \" REV = \" $3 \" # optional, may not be sent for tar-based builds pushd \" $TMP_WORK_DIR \" >/dev/null touch Procfile echo \"clock: some-command\" >> Procfile popd & >/dev/null post-proxy-ports-update Description: Allows you to run commands once the proxy port mappings for an app have been updated. It also sends the invoking command. This can be \"add\", \"clear\" or \"remove\". Invoked by: dokku proxy:ports-add , dokku proxy:ports-clear , dokku proxy:ports-remove Arguments: $APP action name Example: #!/usr/bin/env bash # Rebuilds haproxy config for our imaginary haproxy plugin # that replaces the nginx-vhosts plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" source \" $PLUGIN_AVAILABLE_PATH /haproxy/functions\" APP = \" $1 \" haproxy-build-config \" $APP \" post-release-builder Warning Image mutation in this trigger may result in an invalid run state, and is heavily discouraged. Description: Invokes a command after the build process is complete. Invoked by: builder plugins Arguments: $BUILDER_TYPE $APP $IMAGE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" BUILDER_TYPE = \" $1 \" ; APP = \" $2 \" ; IMAGE = $3 # TODO post-release-buildpack Warning Deprecated, please use post-release-builder instead Warning Image mutation in this trigger may result in an invalid run state, and is heavily discouraged. Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to apps using buildpacks. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO post-release-pack Warning Deprecated, please use post-release-builder instead Warning The pack plugin trigger apis are under development and may change between minor releases until the 1.0 release. Warning Image mutation in this trigger may result in an invalid run state, and is heavily discouraged. Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to apps using pack. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO post-release-dockerfile Warning Deprecated, please use post-release-builder instead Warning Image mutation in this trigger may result in an invalid run state, and is heavily discouraged. Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to apps using a dockerfile. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO post-stop Description: Can be used to run commands after an app is manually stopped Invoked by: dokku ps:stop Arguments: $APP Example: #!/usr/bin/env bash # Marks an app as manually stopped set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku config:set --no-restart $APP MANUALLY_STOPPED = 1 pre-build-buildpack Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to apps using buildpacks. Invoked by: internal function dokku_build() (build phase) Arguments: $APP $SOURCECODE_WORK_DIR Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO pre-build-pack Warning The pack plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to apps using pack. Invoked by: internal function dokku_build() (build phase) Arguments: $APP $SOURCECODE_WORK_DIR Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO pre-build-dockerfile Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to apps using a dockerfile. Invoked by: internal function dokku_build() (build phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO pre-delete Description: Can be used to run commands before an app is deleted. Invoked by: dokku apps:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Clears out the gulp asset build cache for apps set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; GULP_CACHE_DIR = \" $DOKKU_ROOT / $APP /gulp\" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) if [[ -d $GULP_CACHE_DIR ]] ; then docker run \" ${ DOCKER_COMMIT_LABEL_ARGS [@] } \" --rm -v \" $GULP_CACHE_DIR :/gulp\" \" $IMAGE \" find /gulp -depth -mindepth 1 -maxdepth 1 -exec rm -Rf {} \\; || true fi pre-deploy Description: Allows the running of code before the app's processes are scaled up and after the docker images are prepared. Invoked by: dokku deploy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Runs gulp in our container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) dokku_log_info1 \"Running gulp\" CID = $( docker run \" ${ DOCKER_COMMIT_LABEL_ARGS [@] } \" -d $IMAGE /bin/bash -c \"cd /app && gulp default\" ) test $( docker wait $CID ) -eq 0 DOCKER_COMMIT_LABEL_ARGS =( \"--change\" \"LABEL org.label-schema.schema-version=1.0\" \"--change\" \"LABEL org.label-schema.vendor=dokku\" \"--change\" \"LABEL com.dokku.app-name= $APP \" ) docker commit \" ${ DOCKER_COMMIT_LABEL_ARGS [@] } \" $CID $IMAGE >/dev/null pre-disable-vhost Description: Allows you to run commands before the VHOST feature is disabled Invoked by: dokku domains:disable Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" # TODO pre-enable-vhost Description: Allows you to run commands before the VHOST feature is enabled Invoked by: dokku domains:enable Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" # TODO pre-receive-app Description: Allows you to customize the contents of an app directory before they are processed for deployment. The IMAGE_SOURCE_TYPE can be any of [herokuish, dockerfile] Invoked by: dokku git-hook , dokku tar-build-locked Arguments: $APP $IMAGE_SOURCE_TYPE $TMP_WORK_DIR $REV Example: #!/usr/bin/env bash # Adds a file called `dokku-is-awesome` to the repository # the contents will be the app name set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $2 \" ; TMP_WORK_DIR = \" $3 \" ; REV = \" $4 \" echo \" $APP \" > \" $TMP_WORK_DIR /dokku-is-awesome\" pre-release-buildpack Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to apps using buildpacks. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Installs the graphicsmagick package into the container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) dokku_log_info1 \"Installing GraphicsMagick...\" CMD = \"cat > gm && \\ dpkg -s graphicsmagick >/dev/null 2>&1 || \\ (apt-get update -qq && apt-get -qq -y --no-install-recommends install graphicsmagick && apt-get clean)\" CID = $( docker run $DOKKU_GLOBAL_RUN_ARGS -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $CID ) -eq 0 DOCKER_COMMIT_LABEL_ARGS =( \"--change\" \"LABEL org.label-schema.schema-version=1.0\" \"--change\" \"LABEL org.label-schema.vendor=dokku\" \"--change\" \"LABEL com.dokku.app-name= $APP \" ) docker commit \" ${ DOCKER_COMMIT_LABEL_ARGS [@] } \" $CID $IMAGE >/dev/null pre-release-pack Warning The pack plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to apps using pack. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; # TODO pre-release-dockerfile Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to apps using a dockerfile. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO pre-restore Description: Allows you to run commands before all containers are restored Invoked by: dokku ps:restore Arguments: Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" # TODO pre-start Description: Can be used to run commands before an app is started Invoked by: dokku ps:start Arguments: $APP Example: #!/usr/bin/env bash # Notifies an example url that an app is starting set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; curl \"https://dokku.me/starting/ ${ APP } \" || true procfile-get-command Description: Fetches the command for a specific process type Invoked by: internally Arguments: $APP $PROCESS_TYPE $PORT Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO proxy-build-config Description: Builds the proxy implementation configuration for a given app Invoked by: internally triggered by ps:restore Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO proxy-clear-config Description: Clears the proxy implementation configuration for a given app Invoked by: internally triggered by apps:rename Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO proxy-configure-ports Description: Configures the proxy port mapping Invoked by: internally triggered by proxy plugins Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO proxy-disable Description: Disables the configured proxy implementation for an app Invoked by: internally triggered by ps:restore Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO proxy-enable Description: Enables the configured proxy implementation for an app Invoked by: internally triggered by ps:restore Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO proxy-is-enabled Description: Checks if there is a proxy enabled for the app Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO proxy-type Description: Returns the proxy type for an app Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO ps-can-scale Description: Sets whether or not a user can scale an app with ps:scale Invoked by: Arguments: $APP Example: ps-current-scale #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO Description: Prints out the current scale contents (process-type=quantity) delimited by newlines. Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO ps-set-scale Description: Sets the scale for an app based on a specified formation (process-type=quantity). Any unspecified process types will be left as is. Invoked by: Arguments: $APP $SKIP_DEPLOY $CLEAR_EXISTING [$PROCESS_TUPLE...] Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO receive-app Description: Allows you to customize what occurs when an app is received. Normally just triggers an app build. Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV ( $REV may not be included in cases where a repository is not pushed) Example: #!/usr/bin/env bash # For our imaginary mercurial plugin, triggers a rebuild set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; REV = \" $2 \" dokku hg-build $APP $REV receive-branch Description: Allows you to customize what occurs when a specific branch is received. Can be used to add support for specific branch names Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV $REFNAME Example: #!/bin/bash # Gives Dokku the ability to support multiple branches for a given service # Allowing you to have multiple staging environments on a per-branch basis reference_app = $1 refname = $3 newrev = $2 APP = ${ refname /* \\/ / } . $reference_app if [[ ! -d \" $DOKKU_ROOT / $APP \" ]] ; then REFERENCE_REPO = \" $DOKKU_ROOT / $reference_app \" git clone --bare --shared --reference \" $REFERENCE_REPO \" \" $REFERENCE_REPO \" \" $DOKKU_ROOT / $APP \" >/dev/null fi plugn trigger receive-app $APP $newrev release-and-deploy Description: Triggers a release of the image tag and a subsequent deploy Invoked by: Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; # TODO report Description: Allows you to report on any custom configuration in use by your application Invoked by: dokku report Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; # TODO resource-get-property Description: Fetches a given resource property value Invoked by: Arguments: $APP $PROC_TYPE $RESOURCE_TYPE $PROPERTY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; PROC_TYPE = \" $2 \" RESOURCE_TYPE = \" $3 \" PROPERTY = \" $4 \" # TODO retire-container-failed Description: Allows you to run commands if/when retiring old containers has failed Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash # Send an email when a container failed to retire set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; HOSTNAME = $( hostname -s ) mail -s \" $APP containers on $HOSTNAME failed to retire\" ops@dokku.me scheduler-app-status Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Fetch the status of an app Invoked by: dokku ps:report Arguments: $DOKKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; # TODO scheduler-deploy Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when an app is deployed Invoked by: dokku deploy Arguments: $DOKKU_SCHEDULER $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; IMAGE_TAG = \" $3 \" ; # TODO scheduler-detect Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to check which scheduler is in use for an app Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" # TODO scheduler-enter Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to enter a running container for a given app Invoked by: dokku enter Arguments: $DOKKU_SCHEDULER $APP $@ Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; ARGS = \" $@ \" # TODO scheduler-inspect Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run inspect commands for all containers for a given app Invoked by: dokku ps:inspect Arguments: $DOKKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; # TODO scheduler-logs Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when retrieving container logs Invoked by: dokku logs:failed Arguments: $DOKKU_SCHEDULER $APP $PROCESS_TYPE $TAIL $PRETTY_PRINT $NUM Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; PROCESS_TYPE = \" $3 \" ; TAIL = \" $4 \" ; PRETTY_PRINT = \" $5 \" ; NUM = \" $6 \" # TODO scheduler-logs-failed Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when retrieving failed container logs Invoked by: dokku logs:failed Arguments: $DOKKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; # TODO scheduler-pre-restore Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run commands before an app is restored Invoked by: dokku ps:restore Arguments: $DOKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; # TODO scheduler-post-delete Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when an app is deleted Invoked by: dokku apps:destroy Arguments: $DOKKU_SCHEDULER $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; IMAGE_TAG = \" $3 \" ; # TODO scheduler-post-run Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands after a dokku run invocation is called Invoked by: dokku run Arguments: $DOKKU_SCHEDULER $APP $CONTAINER_ID Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; CONTAINER_ID = \" $3 \" ; # TODO scheduler-register-retired Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows scheduling retiring a local container and any related images Invoked by: internally Arguments: $APP $CONTAINER_ID Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; CONTAINER_ID = \" $2 \" ; # TODO scheduler-retire Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when containers should be force retired from the system Invoked by: dokku run Arguments: $DOKKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; # TODO scheduler-run Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when a command is executed for your app Invoked by: dokku run Arguments: $DOKKU_SCHEDULER $APP ...ARGS Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; ARGS = \" ${ @: 3 } \" ; # TODO scheduler-run-list Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Lists all run containers for a given app Invoked by: dokku run Arguments: $DOKKU_SCHEDULER $APP $FORMAT Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; FORMAT = \" $3 \" ; # TODO scheduler-run-logs Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when retrieving one-off container logs Invoked by: dokku run Arguments: $DOKKU_SCHEDULER $APP $CONTAINER $TAIL $PRETTY_PRINT $NUM Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; CONTAINER = \" $3 \" ; TAIL = \" $4 \" ; PRETTY_PRINT = \" $5 \" ; NUM = \" $6 \" # TODO scheduler-stop Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when a tag is destroyed Invoked by: dokku apps:destroy, dokku ps:stop Arguments: $DOKKU_SCHEDULER $APP $REMOVE_CONTAINERS Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; REMOVE_CONTAINERS = \" $3 \" ; # TODO storage-list Description: Returns a list of storage mounts Invoked by: dokku storage:list and dokku deploy Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" # TODO uninstall Description: Used to cleanup after itself. Invoked by: dokku plugin:uninstall Arguments: $PLUGIN Example: #!/usr/bin/env bash # Cleanup up extra containers created set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x PLUGIN = \" $1 \" [[ \" $PLUGIN \" = \"my-plugin\" ]] && docker rmi -f \" ${ PLUGIN_IMAGE_DEPENDENCY } \" To avoid uninstalling other plugins make sure to check the plugin name like shown in the example. update Description: Can be used to run plugin updates on a regular interval. You can schedule the invoker in a cron-task to ensure your system gets regular updates. Invoked by: dokku plugin:update . Arguments: None Example: #!/usr/bin/env bash # Update the herokuish image from git source set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x cd /root/dokku sudo BUILD_STACK = true make install user-auth This is a special plugin trigger that is executed on every command run. As Dokku sometimes internally invokes the dokku command, special care should be taken to properly handle internal command redirects. Note that the trigger should exit as follows: 0 to continue running as normal 1 to halt execution of the command The SSH_USER is the original ssh user. If you are running remote commands, this user will typically be dokku , and as such should not be trusted when checking permissions. If you are connected via ssh as a different user who then invokes dokku , the value of this variable will be that user's name ( root , myuser , etc.). The SSH_NAME is the NAME variable set via the sshcommand acl-add command. For reference, the following command can be run as the root user to specify a specific NAME for a given ssh key: sshcommand acl-add dokku NAME < $PATH_TO_SSH_KEY Note that the NAME value is set at the first ssh key match. If an ssh key is set in the /home/dokku/.ssh/authorized_keys multiple times, the first match will decide the value. Description: Allows you to deny access to a Dokku command by either ssh user or associated ssh-command NAME user. Invoked by: dokku Arguments: $SSH_USER $SSH_NAME $DOKKU_COMMAND Example: #!/usr/bin/env bash # Allow root/admin users to do everything # Deny plugin access to default users # Allow access to all other commands set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x SSH_USER = $1 SSH_NAME = $2 shift 2 [[ \" $SSH_USER \" == \"root\" ]] && exit 0 [[ \" $SSH_NAME \" == \"admin\" ]] && exit 0 [[ \" $SSH_NAME \" == \"default\" && $1 == plugin:* ]] && exit 1 exit 0 user-auth-app This is a special plugin trigger that is executed when listing apps or checking if an app exists. All Dokku commands should check if an app exists at least once before interacting with them so as not to circumvent the check. Note that the trigger should exit 0 , and each non-empty line on stdout is captured as a valid app name. The SSH_USER is the original ssh user. If you are running remote commands, this user will typically be dokku , and as such should not be trusted when checking permissions. If you are connected via ssh as a different user who then invokes dokku , the value of this variable will be that user's name ( root , myuser , etc.). The SSH_NAME is the NAME variable set via the sshcommand acl-add command. For reference, the following command can be run as the root user to specify a specific NAME for a given ssh key: sshcommand acl-add dokku NAME < $PATH_TO_SSH_KEY Note that the NAME value is set at the first ssh key match. If an ssh key is set in the /home/dokku/.ssh/authorized_keys multiple times, the first match will decide the value. Description: Allows you to deny access to a Dokku app by either ssh user or associated ssh-command NAME user. Invoked by: dokku Arguments: $SSH_USER $SSH_NAME $DOKKU_COMMAND Example: #!/usr/bin/env bash # hide any apps with the prefix \"admin\" # if the logged in user (SSH_USER) or SSH_NAME is not `root` main () { declare SSH_USER = \" $1 \" SSH_NAME = \" $2 \" ARGS =( \" ${ @: 3 } \" ) for arg in \" ${ ARGS [@] } \" ; do if [[ \" $arg \" == admin-* ]] && [[ \" $SSH_USER \" ! = \"root\" ]] && [[ \" $SSH_NAME \" ! = \"root\" ]] ; then continue fi echo \" ${ arg } \" done } main \" $@ \"","title":"Plugin triggers"},{"location":"development/plugin-triggers/#plugin-triggers","text":"Plugin triggers (formerly pluginhooks ) are a good way to jack into existing Dokku infrastructure. You can use them to modify the output of various Dokku commands or override internal configuration. Plugin triggers are simply scripts that are executed by the system. You can use any language you want, so long as the script: Is executable Has the proper language requirements installed For instance, if you wanted to write a plugin trigger in PHP, you would need to have php installed and available on the CLI prior to plugin trigger invocation. The following is an example for the nginx-hostname plugin trigger. It reverses the hostname that is provided to nginx during deploys. If you created an executable file named nginx-hostname with the following code in your plugin trigger, it would be invoked by Dokku during the normal app deployment process: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \"","title":"Plugin triggers"},{"location":"development/plugin-triggers/#available-plugin-triggers","text":"There are a number of plugin-related triggers. These can be optionally implemented by plugins and allow integration into the standard Dokku setup/teardown process. The following plugin triggers describe those available to a Dokku installation. As well, there is an example for each trigger that you can use as templates for your own plugin development. Info The example plugin trigger code is not guaranteed to be implemented as in within dokku, and are merely simplified examples. Please look at the Dokku source for larger, more in-depth examples.","title":"Available plugin triggers"},{"location":"development/plugin-triggers/#app-create","text":"Description: Creates an app Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"app-create"},{"location":"development/plugin-triggers/#app-destroy","text":"Description: Destroys an app (with confirmation if force isn't specified) Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"app-destroy"},{"location":"development/plugin-triggers/#app-exists","text":"Description: Creates an app Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"app-exists"},{"location":"development/plugin-triggers/#app-list","text":"Description: Lists all apps in available to the currently logged in user. Optionally disables filtering by user if the first argument is false . Invoked by: Arguments: $FILTER Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"app-list"},{"location":"development/plugin-triggers/#app-json-process-deploy-parallelism","text":"Description: Decides the parallelism to use when deploying a given process type. The default is 1 process entry at a type. Invoked by: dokku deploy Arguments: $APP $PROCESS_TYPE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"app-json-process-deploy-parallelism"},{"location":"development/plugin-triggers/#app-maybe-create","text":"Description: Creates an app (gated by whether this is globally enabled or not) Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"app-maybe-create"},{"location":"development/plugin-triggers/#app-restart","text":"Description: Triggers an app restart Invoked by: dokku config:clear , dokku config:set , dokku config:unset Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"app-restart"},{"location":"development/plugin-triggers/#app-urls","text":"Description: Allows you to change the urls Dokku reports for an application. Will override any auto-detected urls. Invoked by: dokku deploy , dokku url , and dokku urls Arguments: $APP $URL_TYPE Example: #!/usr/bin/env bash # Sets the domain to `internal.tld` set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; URL_TYPE = \" $2 \" case \" $URL_TYPE \" in url ) echo \"https://internal.tld/ ${ APP } /\" ;; urls ) echo \"https://internal.tld/ ${ APP } /\" echo \"http://internal.tld/ ${ APP } /\" ;; esac","title":"app-urls"},{"location":"development/plugin-triggers/#builder-build","text":"Description: Triggers the artifact build process Invoked by: dokku deploy Arguments: $BUILDER_TYPE $APP $SOURCECODE_WORK_DIR Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"builder-build"},{"location":"development/plugin-triggers/#builder-detect","text":"Description: Allows overriding the auto-detected herokuish builder in favor of a custom one. Dockerfile gets lowest builder precedence. Invoked by: dokku deploy Arguments: $APP $SOURCECODE_WORK_DIR Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SOURCECODE_WORK_DIR = \" $2 \" if [[ -f \" $SOURCECODE_WORK_DIR /project.toml\" ]] ; then echo -n \"pack\" fi","title":"builder-detect"},{"location":"development/plugin-triggers/#builder-create-dokku-image","text":"Description: Allows modification of the configured dokku-image Invoked by: dokku deploy Arguments: $BUILDER_TYPE $APP $SOURCECODE_WORK_DIR $DOKKU_IMAGE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"builder-create-dokku-image"},{"location":"development/plugin-triggers/#builder-dokku-image","text":"Description: Allows modification of the used dokku-image. Invoked by: dokku deploy Arguments: $BUILDER_TYPE $APP $SOURCECODE_WORK_DIR $DOKKU_IMAGE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"builder-dokku-image"},{"location":"development/plugin-triggers/#builder-release","text":"Description: Triggers the artifact release process Invoked by: dokku deploy Arguments: $BUILDER_TYPE $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"builder-release"},{"location":"development/plugin-triggers/#check-deploy","text":"Description: Allows you to run checks on a deploy before Dokku allows the container to handle requests. Invoked by: dokku deploy Arguments: $APP $CONTAINER_ID $PROC_TYPE $PORT $IP Example: #!/usr/bin/env bash # Disables deploys of containers based on whether the # `DOKKU_DISABLE_DEPLOY` env var is set to `true` for an app set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_AVAILABLE_PATH /config/functions\" APP = \" $1 \" ; CONTAINER_ID = \" $2 \" ; PROC_TYPE = \" $3 \" ; PORT = \" $4 \" ; IP = \" $5 \" eval \" $( config_export app $APP ) \" DOKKU_DISABLE_DEPLOY = \" ${ DOKKU_DISABLE_DEPLOY :- false } \" if [[ \" $DOKKU_DISABLE_DEPLOY \" = \"true\" ]] ; then echo -e \"\\033[31m\\033[1mDeploys disabled, sorry.\\033[0m\" exit 1 fi","title":"check-deploy"},{"location":"development/plugin-triggers/#checks-get-property","text":"Description: Return the value for an app's checks property Invoked by: Arguments: $APP $KEY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; PROPERTY = \" $2 \" # TODO","title":"checks-get-property"},{"location":"development/plugin-triggers/#commands-help-and-commands-plugin_namehelp","text":"Description: Your plugin should implement a help command in your commands file to take advantage of this plugin trigger. commands help is used by dokku help to aggregate all plugins abbreviated help output. Implementing <PLUGIN_NAME>:help in your commands file gives users looking for help, a more detailed output. 'commands help' must be implemented inside the commands plugin file. It's recommended that PLUGIN_NAME:help be added to the commands file to ensure consistency among community plugins and give you a new avenue to share rich help content with your user. Invoked by: dokku help and commands <PLUGIN_NAME>:help Arguments: None Example: #!/usr/bin/env bash # Outputs help for the derp plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | hello:help ) help_content_func () { declare desc = \"return help_content string\" cat <<help_content hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" help_content } if [[ $1 = \"hello:help\" ]] ; then echo -e 'Usage: dokku hello[:world] [<app>]' echo '' echo 'Say Hello World.' echo '' echo 'Example:' echo '' echo '$ dokku hello:world' echo 'Hello world' echo '' echo 'Additional commands:' help_content_func | sort | column -c2 -t -s, else help_content_func fi ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac","title":"commands help and commands &lt;PLUGIN_NAME&gt;:help"},{"location":"development/plugin-triggers/#config-export","text":"Description: Returns the environment variables in a specified format Invoked by: app-json plugin Arguments: $APP $GLOBAL $MERGED $FORMAT Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"config-export"},{"location":"development/plugin-triggers/#config-get","text":"Description: Fetches the app config value for a key Invoked by: Arguments: $APP $KEY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"config-get"},{"location":"development/plugin-triggers/#config-get-global","text":"Description: Fetches the global config value for a key Invoked by: Arguments: $KEY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"config-get-global"},{"location":"development/plugin-triggers/#core-post-deploy","text":"Info To avoid issues with community plugins, this plugin trigger should be used only for core plugins. Please avoid using this trigger in your own plugins. Description: Allows running of commands after an app's processes have been scaled up, but before old containers are torn down. Dokku core currently uses this to switch traffic on nginx. Invoked by: dokku deploy Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS $IMAGE_TAG Example: #!/usr/bin/env bash # Notify an external service that a successful deploy has occurred. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x curl \"http://httpstat.us/200\"","title":"core-post-deploy"},{"location":"development/plugin-triggers/#core-post-extract","text":"Info To avoid issues with community plugins, this plugin trigger should be used only for core plugins. Please avoid using this trigger in your own plugins. Description: Allows you to modify the contents of an app after it has been extracted from git but before the image source type is detected. Invoked by: The receive-app plugin trigger Arguments: $APP $TMP_WORK_DIR $REV Example: #!/usr/bin/env bash # Adds a clock process to an app's Procfile set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" TMP_WORK_DIR = \" $2 \" REV = \" $3 \" # optional, may not be sent for tar-based builds pushd \" $TMP_WORK_DIR \" >/dev/null touch Procfile echo \"clock: some-command\" >> Procfile popd & >/dev/null","title":"core-post-extract"},{"location":"development/plugin-triggers/#cron-write","text":"Description: Force triggers writing out cron entries Invoked by: Arguments: Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" # TODO","title":"cron-write"},{"location":"development/plugin-triggers/#cron-entries","text":"Description: Allows injecting cron entries into the written out scheduled cron task list. Each entry is newline delimited, and individual entries come in the form $SCHEDULE;$FULL_COMMAND;$ARBITRARY_DATA . Individual implementations of cron writing can decide whether and how to include these cron entries. The ARBITRARY_DATA includes the log file path for the basic docker-local cron implementation. Invoked by: Arguments: $DOKKU_SCHEDULER Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" DOKKU_SCHEDULER = \" $1 \" # TODO","title":"cron-entries"},{"location":"development/plugin-triggers/#dependencies","text":"Description: Used to install system-level dependencies. Invoked by: dokku plugin:install-dependencies Arguments: None Example: #!/usr/bin/env bash # Installs nginx for the current plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x export DEBIAN_FRONTEND = noninteractive case \" $DOKKU_DISTRO \" in debian | raspbian | ubuntu ) apt-get -qq -y --no-install-recommends install nginx ;; * ) echo \"Installation on $DOKKU_DISTRO not supported\" 1 > & 2 ;; esac","title":"dependencies"},{"location":"development/plugin-triggers/#deploy","text":"Description: Triggers a deploy for the given app. Can override the image tag to deploy, as well as specify a single process type to deploy. Invoked by: dokku deploy Arguments: $APP [$IMAGE_TAG] [$PROC_TYPE] Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" IMAGE_TAG = \" $2 \" PROC_TYPE = \" $3 \" # TODO","title":"deploy"},{"location":"development/plugin-triggers/#deployed-app-image-repo","text":"Description: Used to manage the full repo of the image being deployed. Useful for deploying from an external registry where the repository name is not dokku/$APP Invoked by: internal function dokku_deploy_cmd() (deploy phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" # change the repo from dokku/APP to dokkupaas/APP echo \"dokkupaas/ $APP \"","title":"deployed-app-image-repo"},{"location":"development/plugin-triggers/#deployed-app-image-tag","text":"Description: Used to manage the tag of the image being deployed. Useful for deploying a specific version of an image, or when deploying from an external registry Invoked by: internal function dokku_deploy_cmd() (deploy phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # customize the tag version echo 'not-latest'","title":"deployed-app-image-tag"},{"location":"development/plugin-triggers/#deployed-app-repository","text":"Description: Used to manage the remote repository of the image being deployed. Invoked by: internal function dokku_deploy_cmd() (deploy phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x echo 'derp.dkr.ecr.us-east-1.amazonaws.com'","title":"deployed-app-repository"},{"location":"development/plugin-triggers/#docker-args-build","text":"Warning Deprecated, please use docker-args-process-build instead Description: Invoked by: internal function dokku_build() (build phase) Arguments: $APP $IMAGE_SOURCE_TYPE Example: #!/usr/bin/env bash # Sets a docker build-arg called CACHEBUST which can be used # to bust cache at any arbitrary point in a Dockerfile build set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x STDIN = $( cat ) APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $2 \" output = \"\" if [[ \" $IMAGE_SOURCE_TYPE \" == \"dockerfile\" ]] ; then output = \" --build-arg CACHEBUST= $( date +%s ) \" fi echo -n \" $STDIN$output \"","title":"docker-args-build"},{"location":"development/plugin-triggers/#docker-args-deploy","text":"Warning Deprecated, please use docker-args-process-deploy instead Description: Invoked by: dokku deploy Arguments: $APP $IMAGE_TAG [$PROC_TYPE $CONTAINER_INDEX] Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO","title":"docker-args-deploy"},{"location":"development/plugin-triggers/#docker-args-process-build","text":"Description: $PROC_TYPE may be set to magic _all_ process type to signify global docker deploy options. Invoked by: dokku ps:rebuild Arguments: $APP $IMAGE_SOURCE_TYPE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $2 \" # TODO","title":"docker-args-process-build"},{"location":"development/plugin-triggers/#docker-args-process-deploy","text":"Description: $PROC_TYPE may be set to magic _all_ process type to signify global docker deploy options. Invoked by: dokku deploy Arguments: $APP $IMAGE_SOURCE_TYPE $IMAGE_TAG [$PROC_TYPE $CONTAINER_INDEX] Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; $IMAGE_SOURCE_TYPE = \" $2 \" IMAGE_TAG = \" $3 \" ; PROC_TYPE = \" $4 \" ; CONTAINER_INDEX = \" $5 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO","title":"docker-args-process-deploy"},{"location":"development/plugin-triggers/#docker-args-process-run","text":"Description: $PROC_TYPE may be set to magic _all_ process type to signify global docker run options. Invoked by: dokku run Arguments: $APP $IMAGE_SOURCE_TYPE $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $3 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO","title":"docker-args-process-run"},{"location":"development/plugin-triggers/#docker-args-run","text":"Warning Deprecated, please use docker-args-process-run instead Description: Invoked by: dokku run Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO","title":"docker-args-run"},{"location":"development/plugin-triggers/#domains-add","text":"Description: Adds a domain to an app Invoked by: Arguments: $APP $DOMAIN Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"domains-add"},{"location":"development/plugin-triggers/#domains-disable","text":"Description: Disables domains for an app Invoked by: Arguments: $APP $RESTART_APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"domains-disable"},{"location":"development/plugin-triggers/#domains-enable","text":"Description: Enables domains for an app Invoked by: Arguments: $APP $RESTART_APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"domains-enable"},{"location":"development/plugin-triggers/#domains-list","text":"Description: Lists all domains for an app Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"domains-list"},{"location":"development/plugin-triggers/#domains-setup","text":"Description: Initializes domains for an app if enabled Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"domains-setup"},{"location":"development/plugin-triggers/#domains-vhost-enabled","text":"Description: Checks if a virtual hosts are enabled for an app Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"domains-vhost-enabled"},{"location":"development/plugin-triggers/#git-deploy-branch","text":"Description: Outputs the deploy branch for an app, inherited or not Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"git-deploy-branch"},{"location":"development/plugin-triggers/#git-from-archive","text":"Description: Updates an app's git repository from an archive and then triggers a build Invoked by: git:from-archive Arguments: $APP $ARCHIVE_URL $ARCHIVE_TYPE $USER_NAME $USER_EMAIL Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"git-from-archive"},{"location":"development/plugin-triggers/#git-from-directory","text":"Description: Updates an app's git repository from a source directory and then triggers a build Invoked by: git:from-image and git:from-archive Arguments: $APP $SOURCECODE_WORK_DIR $USER_NAME $USER_EMAIL Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"git-from-directory"},{"location":"development/plugin-triggers/#git-from-image","text":"Description: Updates an app's git repository from a docker image and then triggers a build as necessary Invoked by: git:from-image Arguments: $APP $DOCKER_IMAGE $BUILD_DIR $USER_NAME $USER_EMAIL Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"git-from-image"},{"location":"development/plugin-triggers/#git-has-code","text":"Description: Checks to see if there is code at the specified branch Arguments: $APP $BRANCH_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"git-has-code"},{"location":"development/plugin-triggers/#git-post-pull","text":"Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"git-post-pull"},{"location":"development/plugin-triggers/#git-pre-pull","text":"Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO Warning The git-pre-pull trigger should not be used for authentication since it does not get called for commands that use git-upload-archive such as git archive . Instead, use the user-auth trigger.","title":"git-pre-pull"},{"location":"development/plugin-triggers/#git-revision","text":"Description: Allows you to fetch the current git revision for a given application Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"git-revision"},{"location":"development/plugin-triggers/#install","text":"Description: Used to setup any files/configuration for a plugin. Invoked by: dokku plugin:install . Arguments: None Example: #!/usr/bin/env bash # Sets the hostname of the Dokku server # based on the output of `hostname -f` set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x if [[ ! -f \" $DOKKU_ROOT /VHOST\" ]] ; then hostname -f > $DOKKU_ROOT /VHOST fi","title":"install"},{"location":"development/plugin-triggers/#logs-get-property","text":"Description: Return the value for an app's log property Invoked by: Arguments: $APP $KEY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; PROPERTY = \" $2 \" # TODO","title":"logs-get-property"},{"location":"development/plugin-triggers/#network-build-config","text":"Description: Rebuilds network configuration Invoked by: internally triggered by proxy-build-config within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-build-config"},{"location":"development/plugin-triggers/#network-clear-config","text":"Description: Clears network configuration Invoked by: internally triggered within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-clear-config"},{"location":"development/plugin-triggers/#network-compute-ports","text":"Description: Computes the ports for a given app container Invoked by: internally triggered by proxy-build-config within proxy implementations Arguments: $APP $PROC_TYPE $IS_HEROKUISH_CONTAINER $CONTAINER_INDEX Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-compute-ports"},{"location":"development/plugin-triggers/#network-config-exists","text":"Description: Returns whether the network configuration for a given app exists Invoked by: internally triggered by core-post-deploy within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-config-exists"},{"location":"development/plugin-triggers/#network-get-ipaddr","text":"Description: Return the ipaddr for a given app container Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_ID Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-get-ipaddr"},{"location":"development/plugin-triggers/#network-get-listeners","text":"Description: Return the listeners (host:port combinations) for a given app container Invoked by: internally triggered by a deploy Arguments: $APP $PROCESS_TYPE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-get-listeners"},{"location":"development/plugin-triggers/#network-get-port","text":"Description: Return the port for a given app container Invoked by: internally triggered by a deploy Arguments: $APP $PROCESS_TYPE $CONTAINER_ID $IS_HEROKUISH_CONTAINER Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-get-port"},{"location":"development/plugin-triggers/#network-get-property","text":"Description: Return the value for an app's network property Invoked by: internally triggered by a deploy Arguments: $APP $KEY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-get-property"},{"location":"development/plugin-triggers/#network-get-static-listeners","text":"Description: Return the network value for an app's property Invoked by: internally triggered by proxy-build-config Arguments: $APP $PROCESS_TYPE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-get-static-listeners"},{"location":"development/plugin-triggers/#network-write-ipaddr","text":"Description: Write the ipaddr for a given app index Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_INDEX $IP_ADDRESS Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-write-ipaddr"},{"location":"development/plugin-triggers/#network-write-port","text":"Description: Write the port for a given app index Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_INDEX $PORT Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-write-port"},{"location":"development/plugin-triggers/#nginx-app-template-source","text":"Description: Return the path to a sigil template that should be used to generate a given nginx configuration file. Invoked by: nginx-vhosts#build-config Arguments: $APP $TEMPLATE_TYPE The TEMPLATE_TYPE argument can be one of: [app-config, hsts-config, validate-config] Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" TEMPLATE_TYPE = \" $2 \" case \" $TEMPLATE_TYPE \" in app-config ) echo \" $( cd \" $( dirname \" ${ BASH_SOURCE [0] } \" ) \" && pwd ) /app.conf.sigil\" ;; hsts-config ) echo \" $( cd \" $( dirname \" ${ BASH_SOURCE [0] } \" ) \" && pwd ) /hsts.conf.sigil\" ;; validate-config ) echo \" $( cd \" $( dirname \" ${ BASH_SOURCE [0] } \" ) \" && pwd ) /validate.conf.sigil\" ;; * ) dokku_log_fail \"Invalid template type: ${ TEMPLATE_TYPE } \" esac The default templates are viewable here: plugins/nginx-vhosts/templates/","title":"nginx-app-template-source"},{"location":"development/plugin-triggers/#nginx-dokku-template-source","text":"Description: Return the path to a sigil template that should be used to generate the dokku.conf nginx configuration file. Invoked by: nginx-vhosts#install Arguments: None, however the sigil template can make use of the following variables: $.DOKKU_ROOT $.NGINX_ROOT Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x echo \" $( cd \" $( dirname \" ${ BASH_SOURCE [0] } \" ) \" && pwd ) /dokku.conf.sigil\" The default template is viewable here: plugins/nginx-vhosts/templates/dokku.conf.sigil","title":"nginx-dokku-template-source"},{"location":"development/plugin-triggers/#nginx-hostname","text":"Description: Allows you to customize the hostname for a given app Invoked by: dokku domains:setup Arguments: $APP $SUBDOMAIN $VHOST Example: #!/usr/bin/env bash # Reverses the hostname for the app set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \"","title":"nginx-hostname"},{"location":"development/plugin-triggers/#nginx-pre-reload","text":"Warning The arguments INTERNAL_PORT and INTERNAL_IP_ADDRESS are no longer sufficient to retrieve all app listeners. Please run plugn trigger network-get-listeners APP within any implementation of nginx-pre-reload in order to retrieve all application listeners. Description: Run before nginx reloads hosts Invoked by: dokku nginx:build-config Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Runs a check against all nginx conf files # to ensure they are valid set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x nginx -t","title":"nginx-pre-reload"},{"location":"development/plugin-triggers/#post-app-clone","text":"Description: Allows you to run commands after an app was cloned. Invoked by: dokku apps:clone Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-app-clone"},{"location":"development/plugin-triggers/#post-app-clone-setup","text":"Description: Allows you to run commands after an app is setup, and before it is rebuild. This is useful for cleaning up tasks, or ensuring configuration from an old app is copied to the new app Invoked by: dokku apps:clone Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-app-clone-setup"},{"location":"development/plugin-triggers/#post-app-rename","text":"Description: Allows you to run commands after an app was renamed. Invoked by: dokku apps:rename Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-app-rename"},{"location":"development/plugin-triggers/#post-app-rename-setup","text":"Description: Allows you to run commands after an app is setup, and before it is rebuild. This is useful for cleaning up tasks, or ensuring configuration from an old app is copied to the new app Invoked by: dokku apps:rename Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-app-rename-setup"},{"location":"development/plugin-triggers/#post-build-buildpack","text":"Description: Allows you to run commands after the build image is create for a given app. Only applies to apps using buildpacks. Invoked by: internal function dokku_build() (build phase) Arguments: $APP $SOURCECODE_WORK_DIR Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-build-buildpack"},{"location":"development/plugin-triggers/#post-build-pack","text":"Warning The pack plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run commands after the build image is create for a given app. Only applies to apps using pack. Invoked by: internal function dokku_build() (build phase) Arguments: $APP $SOURCECODE_WORK_DIR Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-build-pack"},{"location":"development/plugin-triggers/#post-build-dockerfile","text":"Description: Allows you to run commands after the build image is create for a given app. Only applies to apps using a dockerfile. Invoked by: internal function dokku_build() (build phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-build-dockerfile"},{"location":"development/plugin-triggers/#post-certs-remove","text":"Description: Allows you to run commands after a cert is removed Invoked by: dokku certs:remove Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" # TODO","title":"post-certs-remove"},{"location":"development/plugin-triggers/#post-certs-update","text":"Description: Allows you to run commands after a cert is added/updated Invoked by: dokku certs:add , dokku certs:update Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" # TODO","title":"post-certs-update"},{"location":"development/plugin-triggers/#post-config-update","text":"Description: Allows you to get notified when one or more configs is added or removed. Action can be set or unset . Invoked by: dokku config:set , dokku config:unset Arguments: $APP set|unset key1=VALUE1 key2=VALUE2 Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-config-update"},{"location":"development/plugin-triggers/#post-container-create","text":"Description: This trigger should be used to do stuff to containers after they are created but before they are started. They are explicitely for commands that may involve network traffic, and not for commands that are self-contained, such as chown or tar. Invoked by: dokku run , dokku ps:rebuild , dokku deploy Arguments \"app|service\" \"$CONTAINER_ID\" \"$APP|$SERVICE\" \"$PHASE\" #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-container-create"},{"location":"development/plugin-triggers/#post-create","text":"Description: Can be used to run commands after an app is created. Invoked by: dokku apps:create Arguments: $APP Example: #!/usr/bin/env bash # Runs a command to ensure that an app # has a postgres database when it is starting set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; POSTGRES = \" $1 \" dokku postgres:create $POSTGRES dokku postgres:link $POSTGRES $APP","title":"post-create"},{"location":"development/plugin-triggers/#post-delete","text":"Description: Can be used to run commands after an app is deleted. Invoked by: dokku apps:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Runs a command to ensure that an app's # postgres installation is removed set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku postgres:destroy $APP","title":"post-delete"},{"location":"development/plugin-triggers/#post-deploy","text":"Info Please see core-post-deploy if contributing a core plugin with the post-deploy hook. Description: Allows running of commands after an app's processes have been scaled up, but before old containers are torn down. Dokku calls this after core-post-deploy . Deployment Tasks are also invoked by this plugin trigger. Invoked by: dokku deploy Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS $IMAGE_TAG Example: #!/usr/bin/env bash # Notify an external service that a successful deploy has occurred. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x curl \"http://httpstat.us/200\"","title":"post-deploy"},{"location":"development/plugin-triggers/#post-domains-update","text":"Description: Allows you to run commands once the domain for an app has been updated. It also sends in the command that has been used. This can be \"add\", \"clear\" or \"remove\". The third argument will be the optional list of domains Invoked by: dokku domains:add , dokku domains:clear , dokku domains:remove , dokku domains:set Arguments: $APP action name domains Example: #!/usr/bin/env bash # Reloads haproxy for our imaginary haproxy plugin # that replaces the nginx-vhosts plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x sudo service haproxy reload","title":"post-domains-update"},{"location":"development/plugin-triggers/#post-extract","text":"Description: Allows you to modify the contents of an app after it has been extracted from git but before the image source type is detected. Invoked by: The receive-app plugin trigger Arguments: $APP $TMP_WORK_DIR $REV Example: #!/usr/bin/env bash # Adds a clock process to an app's Procfile set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" TMP_WORK_DIR = \" $2 \" REV = \" $3 \" # optional, may not be sent for tar-based builds pushd \" $TMP_WORK_DIR \" >/dev/null touch Procfile echo \"clock: some-command\" >> Procfile popd & >/dev/null","title":"post-extract"},{"location":"development/plugin-triggers/#post-proxy-ports-update","text":"Description: Allows you to run commands once the proxy port mappings for an app have been updated. It also sends the invoking command. This can be \"add\", \"clear\" or \"remove\". Invoked by: dokku proxy:ports-add , dokku proxy:ports-clear , dokku proxy:ports-remove Arguments: $APP action name Example: #!/usr/bin/env bash # Rebuilds haproxy config for our imaginary haproxy plugin # that replaces the nginx-vhosts plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" source \" $PLUGIN_AVAILABLE_PATH /haproxy/functions\" APP = \" $1 \" haproxy-build-config \" $APP \"","title":"post-proxy-ports-update"},{"location":"development/plugin-triggers/#post-release-builder","text":"Warning Image mutation in this trigger may result in an invalid run state, and is heavily discouraged. Description: Invokes a command after the build process is complete. Invoked by: builder plugins Arguments: $BUILDER_TYPE $APP $IMAGE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" BUILDER_TYPE = \" $1 \" ; APP = \" $2 \" ; IMAGE = $3 # TODO","title":"post-release-builder"},{"location":"development/plugin-triggers/#post-release-buildpack","text":"Warning Deprecated, please use post-release-builder instead Warning Image mutation in this trigger may result in an invalid run state, and is heavily discouraged. Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to apps using buildpacks. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO","title":"post-release-buildpack"},{"location":"development/plugin-triggers/#post-release-pack","text":"Warning Deprecated, please use post-release-builder instead Warning The pack plugin trigger apis are under development and may change between minor releases until the 1.0 release. Warning Image mutation in this trigger may result in an invalid run state, and is heavily discouraged. Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to apps using pack. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO","title":"post-release-pack"},{"location":"development/plugin-triggers/#post-release-dockerfile","text":"Warning Deprecated, please use post-release-builder instead Warning Image mutation in this trigger may result in an invalid run state, and is heavily discouraged. Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to apps using a dockerfile. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO","title":"post-release-dockerfile"},{"location":"development/plugin-triggers/#post-stop","text":"Description: Can be used to run commands after an app is manually stopped Invoked by: dokku ps:stop Arguments: $APP Example: #!/usr/bin/env bash # Marks an app as manually stopped set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku config:set --no-restart $APP MANUALLY_STOPPED = 1","title":"post-stop"},{"location":"development/plugin-triggers/#pre-build-buildpack","text":"Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to apps using buildpacks. Invoked by: internal function dokku_build() (build phase) Arguments: $APP $SOURCECODE_WORK_DIR Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"pre-build-buildpack"},{"location":"development/plugin-triggers/#pre-build-pack","text":"Warning The pack plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to apps using pack. Invoked by: internal function dokku_build() (build phase) Arguments: $APP $SOURCECODE_WORK_DIR Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"pre-build-pack"},{"location":"development/plugin-triggers/#pre-build-dockerfile","text":"Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to apps using a dockerfile. Invoked by: internal function dokku_build() (build phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"pre-build-dockerfile"},{"location":"development/plugin-triggers/#pre-delete","text":"Description: Can be used to run commands before an app is deleted. Invoked by: dokku apps:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Clears out the gulp asset build cache for apps set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; GULP_CACHE_DIR = \" $DOKKU_ROOT / $APP /gulp\" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) if [[ -d $GULP_CACHE_DIR ]] ; then docker run \" ${ DOCKER_COMMIT_LABEL_ARGS [@] } \" --rm -v \" $GULP_CACHE_DIR :/gulp\" \" $IMAGE \" find /gulp -depth -mindepth 1 -maxdepth 1 -exec rm -Rf {} \\; || true fi","title":"pre-delete"},{"location":"development/plugin-triggers/#pre-deploy","text":"Description: Allows the running of code before the app's processes are scaled up and after the docker images are prepared. Invoked by: dokku deploy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Runs gulp in our container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) dokku_log_info1 \"Running gulp\" CID = $( docker run \" ${ DOCKER_COMMIT_LABEL_ARGS [@] } \" -d $IMAGE /bin/bash -c \"cd /app && gulp default\" ) test $( docker wait $CID ) -eq 0 DOCKER_COMMIT_LABEL_ARGS =( \"--change\" \"LABEL org.label-schema.schema-version=1.0\" \"--change\" \"LABEL org.label-schema.vendor=dokku\" \"--change\" \"LABEL com.dokku.app-name= $APP \" ) docker commit \" ${ DOCKER_COMMIT_LABEL_ARGS [@] } \" $CID $IMAGE >/dev/null","title":"pre-deploy"},{"location":"development/plugin-triggers/#pre-disable-vhost","text":"Description: Allows you to run commands before the VHOST feature is disabled Invoked by: dokku domains:disable Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" # TODO","title":"pre-disable-vhost"},{"location":"development/plugin-triggers/#pre-enable-vhost","text":"Description: Allows you to run commands before the VHOST feature is enabled Invoked by: dokku domains:enable Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" # TODO","title":"pre-enable-vhost"},{"location":"development/plugin-triggers/#pre-receive-app","text":"Description: Allows you to customize the contents of an app directory before they are processed for deployment. The IMAGE_SOURCE_TYPE can be any of [herokuish, dockerfile] Invoked by: dokku git-hook , dokku tar-build-locked Arguments: $APP $IMAGE_SOURCE_TYPE $TMP_WORK_DIR $REV Example: #!/usr/bin/env bash # Adds a file called `dokku-is-awesome` to the repository # the contents will be the app name set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $2 \" ; TMP_WORK_DIR = \" $3 \" ; REV = \" $4 \" echo \" $APP \" > \" $TMP_WORK_DIR /dokku-is-awesome\"","title":"pre-receive-app"},{"location":"development/plugin-triggers/#pre-release-buildpack","text":"Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to apps using buildpacks. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Installs the graphicsmagick package into the container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) dokku_log_info1 \"Installing GraphicsMagick...\" CMD = \"cat > gm && \\ dpkg -s graphicsmagick >/dev/null 2>&1 || \\ (apt-get update -qq && apt-get -qq -y --no-install-recommends install graphicsmagick && apt-get clean)\" CID = $( docker run $DOKKU_GLOBAL_RUN_ARGS -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $CID ) -eq 0 DOCKER_COMMIT_LABEL_ARGS =( \"--change\" \"LABEL org.label-schema.schema-version=1.0\" \"--change\" \"LABEL org.label-schema.vendor=dokku\" \"--change\" \"LABEL com.dokku.app-name= $APP \" ) docker commit \" ${ DOCKER_COMMIT_LABEL_ARGS [@] } \" $CID $IMAGE >/dev/null","title":"pre-release-buildpack"},{"location":"development/plugin-triggers/#pre-release-pack","text":"Warning The pack plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to apps using pack. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; # TODO","title":"pre-release-pack"},{"location":"development/plugin-triggers/#pre-release-dockerfile","text":"Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to apps using a dockerfile. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) # TODO","title":"pre-release-dockerfile"},{"location":"development/plugin-triggers/#pre-restore","text":"Description: Allows you to run commands before all containers are restored Invoked by: dokku ps:restore Arguments: Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" # TODO","title":"pre-restore"},{"location":"development/plugin-triggers/#pre-start","text":"Description: Can be used to run commands before an app is started Invoked by: dokku ps:start Arguments: $APP Example: #!/usr/bin/env bash # Notifies an example url that an app is starting set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; curl \"https://dokku.me/starting/ ${ APP } \" || true","title":"pre-start"},{"location":"development/plugin-triggers/#procfile-get-command","text":"Description: Fetches the command for a specific process type Invoked by: internally Arguments: $APP $PROCESS_TYPE $PORT Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"procfile-get-command"},{"location":"development/plugin-triggers/#proxy-build-config","text":"Description: Builds the proxy implementation configuration for a given app Invoked by: internally triggered by ps:restore Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"proxy-build-config"},{"location":"development/plugin-triggers/#proxy-clear-config","text":"Description: Clears the proxy implementation configuration for a given app Invoked by: internally triggered by apps:rename Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"proxy-clear-config"},{"location":"development/plugin-triggers/#proxy-configure-ports","text":"Description: Configures the proxy port mapping Invoked by: internally triggered by proxy plugins Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"proxy-configure-ports"},{"location":"development/plugin-triggers/#proxy-disable","text":"Description: Disables the configured proxy implementation for an app Invoked by: internally triggered by ps:restore Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"proxy-disable"},{"location":"development/plugin-triggers/#proxy-enable","text":"Description: Enables the configured proxy implementation for an app Invoked by: internally triggered by ps:restore Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"proxy-enable"},{"location":"development/plugin-triggers/#proxy-is-enabled","text":"Description: Checks if there is a proxy enabled for the app Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"proxy-is-enabled"},{"location":"development/plugin-triggers/#proxy-type","text":"Description: Returns the proxy type for an app Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"proxy-type"},{"location":"development/plugin-triggers/#ps-can-scale","text":"Description: Sets whether or not a user can scale an app with ps:scale Invoked by: Arguments: $APP Example:","title":"ps-can-scale"},{"location":"development/plugin-triggers/#ps-current-scale","text":"#!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO Description: Prints out the current scale contents (process-type=quantity) delimited by newlines. Invoked by: Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"ps-current-scale"},{"location":"development/plugin-triggers/#ps-set-scale","text":"Description: Sets the scale for an app based on a specified formation (process-type=quantity). Any unspecified process types will be left as is. Invoked by: Arguments: $APP $SKIP_DEPLOY $CLEAR_EXISTING [$PROCESS_TUPLE...] Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"ps-set-scale"},{"location":"development/plugin-triggers/#receive-app","text":"Description: Allows you to customize what occurs when an app is received. Normally just triggers an app build. Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV ( $REV may not be included in cases where a repository is not pushed) Example: #!/usr/bin/env bash # For our imaginary mercurial plugin, triggers a rebuild set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; REV = \" $2 \" dokku hg-build $APP $REV","title":"receive-app"},{"location":"development/plugin-triggers/#receive-branch","text":"Description: Allows you to customize what occurs when a specific branch is received. Can be used to add support for specific branch names Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV $REFNAME Example: #!/bin/bash # Gives Dokku the ability to support multiple branches for a given service # Allowing you to have multiple staging environments on a per-branch basis reference_app = $1 refname = $3 newrev = $2 APP = ${ refname /* \\/ / } . $reference_app if [[ ! -d \" $DOKKU_ROOT / $APP \" ]] ; then REFERENCE_REPO = \" $DOKKU_ROOT / $reference_app \" git clone --bare --shared --reference \" $REFERENCE_REPO \" \" $REFERENCE_REPO \" \" $DOKKU_ROOT / $APP \" >/dev/null fi plugn trigger receive-app $APP $newrev","title":"receive-branch"},{"location":"development/plugin-triggers/#release-and-deploy","text":"Description: Triggers a release of the image tag and a subsequent deploy Invoked by: Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; # TODO","title":"release-and-deploy"},{"location":"development/plugin-triggers/#report","text":"Description: Allows you to report on any custom configuration in use by your application Invoked by: dokku report Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; # TODO","title":"report"},{"location":"development/plugin-triggers/#resource-get-property","text":"Description: Fetches a given resource property value Invoked by: Arguments: $APP $PROC_TYPE $RESOURCE_TYPE $PROPERTY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; PROC_TYPE = \" $2 \" RESOURCE_TYPE = \" $3 \" PROPERTY = \" $4 \" # TODO","title":"resource-get-property"},{"location":"development/plugin-triggers/#retire-container-failed","text":"Description: Allows you to run commands if/when retiring old containers has failed Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash # Send an email when a container failed to retire set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; HOSTNAME = $( hostname -s ) mail -s \" $APP containers on $HOSTNAME failed to retire\" ops@dokku.me","title":"retire-container-failed"},{"location":"development/plugin-triggers/#scheduler-app-status","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Fetch the status of an app Invoked by: dokku ps:report Arguments: $DOKKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; # TODO","title":"scheduler-app-status"},{"location":"development/plugin-triggers/#scheduler-deploy","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when an app is deployed Invoked by: dokku deploy Arguments: $DOKKU_SCHEDULER $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; IMAGE_TAG = \" $3 \" ; # TODO","title":"scheduler-deploy"},{"location":"development/plugin-triggers/#scheduler-detect","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to check which scheduler is in use for an app Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" # TODO","title":"scheduler-detect"},{"location":"development/plugin-triggers/#scheduler-enter","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to enter a running container for a given app Invoked by: dokku enter Arguments: $DOKKU_SCHEDULER $APP $@ Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; ARGS = \" $@ \" # TODO","title":"scheduler-enter"},{"location":"development/plugin-triggers/#scheduler-inspect","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run inspect commands for all containers for a given app Invoked by: dokku ps:inspect Arguments: $DOKKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; # TODO","title":"scheduler-inspect"},{"location":"development/plugin-triggers/#scheduler-logs","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when retrieving container logs Invoked by: dokku logs:failed Arguments: $DOKKU_SCHEDULER $APP $PROCESS_TYPE $TAIL $PRETTY_PRINT $NUM Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; PROCESS_TYPE = \" $3 \" ; TAIL = \" $4 \" ; PRETTY_PRINT = \" $5 \" ; NUM = \" $6 \" # TODO","title":"scheduler-logs"},{"location":"development/plugin-triggers/#scheduler-logs-failed","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when retrieving failed container logs Invoked by: dokku logs:failed Arguments: $DOKKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; # TODO","title":"scheduler-logs-failed"},{"location":"development/plugin-triggers/#scheduler-pre-restore","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run commands before an app is restored Invoked by: dokku ps:restore Arguments: $DOKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; # TODO","title":"scheduler-pre-restore"},{"location":"development/plugin-triggers/#scheduler-post-delete","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when an app is deleted Invoked by: dokku apps:destroy Arguments: $DOKKU_SCHEDULER $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; IMAGE_TAG = \" $3 \" ; # TODO","title":"scheduler-post-delete"},{"location":"development/plugin-triggers/#scheduler-post-run","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands after a dokku run invocation is called Invoked by: dokku run Arguments: $DOKKU_SCHEDULER $APP $CONTAINER_ID Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; CONTAINER_ID = \" $3 \" ; # TODO","title":"scheduler-post-run"},{"location":"development/plugin-triggers/#scheduler-register-retired","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows scheduling retiring a local container and any related images Invoked by: internally Arguments: $APP $CONTAINER_ID Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; CONTAINER_ID = \" $2 \" ; # TODO","title":"scheduler-register-retired"},{"location":"development/plugin-triggers/#scheduler-retire","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when containers should be force retired from the system Invoked by: dokku run Arguments: $DOKKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; # TODO","title":"scheduler-retire"},{"location":"development/plugin-triggers/#scheduler-run","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when a command is executed for your app Invoked by: dokku run Arguments: $DOKKU_SCHEDULER $APP ...ARGS Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; ARGS = \" ${ @: 3 } \" ; # TODO","title":"scheduler-run"},{"location":"development/plugin-triggers/#scheduler-run-list","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Lists all run containers for a given app Invoked by: dokku run Arguments: $DOKKU_SCHEDULER $APP $FORMAT Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; FORMAT = \" $3 \" ; # TODO","title":"scheduler-run-list"},{"location":"development/plugin-triggers/#scheduler-run-logs","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when retrieving one-off container logs Invoked by: dokku run Arguments: $DOKKU_SCHEDULER $APP $CONTAINER $TAIL $PRETTY_PRINT $NUM Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; CONTAINER = \" $3 \" ; TAIL = \" $4 \" ; PRETTY_PRINT = \" $5 \" ; NUM = \" $6 \" # TODO","title":"scheduler-run-logs"},{"location":"development/plugin-triggers/#scheduler-stop","text":"Warning The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when a tag is destroyed Invoked by: dokku apps:destroy, dokku ps:stop Arguments: $DOKKU_SCHEDULER $APP $REMOVE_CONTAINERS Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; REMOVE_CONTAINERS = \" $3 \" ; # TODO","title":"scheduler-stop"},{"location":"development/plugin-triggers/#storage-list","text":"Description: Returns a list of storage mounts Invoked by: dokku storage:list and dokku deploy Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" # TODO","title":"storage-list"},{"location":"development/plugin-triggers/#uninstall","text":"Description: Used to cleanup after itself. Invoked by: dokku plugin:uninstall Arguments: $PLUGIN Example: #!/usr/bin/env bash # Cleanup up extra containers created set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x PLUGIN = \" $1 \" [[ \" $PLUGIN \" = \"my-plugin\" ]] && docker rmi -f \" ${ PLUGIN_IMAGE_DEPENDENCY } \" To avoid uninstalling other plugins make sure to check the plugin name like shown in the example.","title":"uninstall"},{"location":"development/plugin-triggers/#update","text":"Description: Can be used to run plugin updates on a regular interval. You can schedule the invoker in a cron-task to ensure your system gets regular updates. Invoked by: dokku plugin:update . Arguments: None Example: #!/usr/bin/env bash # Update the herokuish image from git source set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x cd /root/dokku sudo BUILD_STACK = true make install","title":"update"},{"location":"development/plugin-triggers/#user-auth","text":"This is a special plugin trigger that is executed on every command run. As Dokku sometimes internally invokes the dokku command, special care should be taken to properly handle internal command redirects. Note that the trigger should exit as follows: 0 to continue running as normal 1 to halt execution of the command The SSH_USER is the original ssh user. If you are running remote commands, this user will typically be dokku , and as such should not be trusted when checking permissions. If you are connected via ssh as a different user who then invokes dokku , the value of this variable will be that user's name ( root , myuser , etc.). The SSH_NAME is the NAME variable set via the sshcommand acl-add command. For reference, the following command can be run as the root user to specify a specific NAME for a given ssh key: sshcommand acl-add dokku NAME < $PATH_TO_SSH_KEY Note that the NAME value is set at the first ssh key match. If an ssh key is set in the /home/dokku/.ssh/authorized_keys multiple times, the first match will decide the value. Description: Allows you to deny access to a Dokku command by either ssh user or associated ssh-command NAME user. Invoked by: dokku Arguments: $SSH_USER $SSH_NAME $DOKKU_COMMAND Example: #!/usr/bin/env bash # Allow root/admin users to do everything # Deny plugin access to default users # Allow access to all other commands set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x SSH_USER = $1 SSH_NAME = $2 shift 2 [[ \" $SSH_USER \" == \"root\" ]] && exit 0 [[ \" $SSH_NAME \" == \"admin\" ]] && exit 0 [[ \" $SSH_NAME \" == \"default\" && $1 == plugin:* ]] && exit 1 exit 0","title":"user-auth"},{"location":"development/plugin-triggers/#user-auth-app","text":"This is a special plugin trigger that is executed when listing apps or checking if an app exists. All Dokku commands should check if an app exists at least once before interacting with them so as not to circumvent the check. Note that the trigger should exit 0 , and each non-empty line on stdout is captured as a valid app name. The SSH_USER is the original ssh user. If you are running remote commands, this user will typically be dokku , and as such should not be trusted when checking permissions. If you are connected via ssh as a different user who then invokes dokku , the value of this variable will be that user's name ( root , myuser , etc.). The SSH_NAME is the NAME variable set via the sshcommand acl-add command. For reference, the following command can be run as the root user to specify a specific NAME for a given ssh key: sshcommand acl-add dokku NAME < $PATH_TO_SSH_KEY Note that the NAME value is set at the first ssh key match. If an ssh key is set in the /home/dokku/.ssh/authorized_keys multiple times, the first match will decide the value. Description: Allows you to deny access to a Dokku app by either ssh user or associated ssh-command NAME user. Invoked by: dokku Arguments: $SSH_USER $SSH_NAME $DOKKU_COMMAND Example: #!/usr/bin/env bash # hide any apps with the prefix \"admin\" # if the logged in user (SSH_USER) or SSH_NAME is not `root` main () { declare SSH_USER = \" $1 \" SSH_NAME = \" $2 \" ARGS =( \" ${ @: 3 } \" ) for arg in \" ${ ARGS [@] } \" ; do if [[ \" $arg \" == admin-* ]] && [[ \" $SSH_USER \" ! = \"root\" ]] && [[ \" $SSH_NAME \" ! = \"root\" ]] ; then continue fi echo \" ${ arg } \" done } main \" $@ \"","title":"user-auth-app"},{"location":"development/release-process/","text":"Release Process Dokku is released in intervals at most three weeks apart, though may be released much quicker. To propose a release, the following tasks need to be performed: export PACKAGECLOUD_TOKEN = SOME_TOKEN # supports major/minor/patch/betafish contrib/release-dokku Info If you are a maintainer and need the PACKAGECLOUD_TOKEN in order to make a release, please contact @josegonzalez to get this information. As well, the Arch Linux package description must be updated via vagrant up build-arch (needs to be done after the tag is pushed to GitHub, because it is based on that) Versioning Dokku follows semver standards. As we are not yet at a stable release, breaking changes will require only a minor release, while all other changes only require a patch release. Once we hit stable, breaking changes will require a major release. At the moment, tags need not be signed, though that may change in the future. Arch Linux Packages Arch Linux packages are not really build, because all that is needed for an Arch User Repo (AUR) package is the description of how to build the package. To make this process as easy as possible there is a vagrant box called build-arch that updates the version of this build description (a file called PKGBUILD ), then runs some helper scripts to fill all additional information and does test if the package could be build. Then only those changes need to be pushed to the AUR repo and an updated version of the package is ready for usage for our Arch Linux users. For detailed information see the section below. The workflow looks like this: # having dokku-arch in ../dokku-arch vagrant up build-arch # wait for \"==> build-arch: ==> Finished making: dokku 0.28.4-2 (Mon Feb 22 23:20:37 CET 2016)\" cd ../dokku-arch git add PKGBUILD .SRCINFO git commit -m 'Update to dokku 0.9.9' git push aur master Info If you are a maintainer and need access to the AUR repositories in order to make a release, please contact @morrisjobke or @josegonzalez to get this co-maintainership. Detailed information for Arch Linux packages All of the information to build the Arch Linux package is in the AUR git repository (see dokku AUR page ). The release of a AUR package only consists of pushing the package information into the AUR git repo. Then users could use that information to build the package on their machines. To update the package clone the repository and adjust the files in the repository. Then a helper script - updpkgsums - to update the SHA sum could be called (check against the original SHA sum). Another helper script - mksrcinfo - needs to be called to update the meta information of the package in a file called .SRCINFO . The next step builds the package locally for verification - makepkg . As last step commit your changes and push the commit. dependencies are defined in the depends attribute in PKGBUILD build steps during package build time are defined in the package() method in PKGBUILD steps that should be executed during install/update/remove time are defined in the file dokku.install detailed information about all attributes in PKGBUILD could be found in the Arch Linux wiki detailed information about the AUR workflow could be found in the AUR article in the Arch Linux wiki That is the usual workflow: updpkgsums # update sha sums - compare them with the original ones mksrcinfo # update package metadata for AUR makepkg # test package builds git add PKGBUILD .SRCINFO git commit -m 'Update to dokku 0.9.9' git push","title":"Release Process"},{"location":"development/release-process/#release-process","text":"Dokku is released in intervals at most three weeks apart, though may be released much quicker. To propose a release, the following tasks need to be performed: export PACKAGECLOUD_TOKEN = SOME_TOKEN # supports major/minor/patch/betafish contrib/release-dokku Info If you are a maintainer and need the PACKAGECLOUD_TOKEN in order to make a release, please contact @josegonzalez to get this information. As well, the Arch Linux package description must be updated via vagrant up build-arch (needs to be done after the tag is pushed to GitHub, because it is based on that)","title":"Release Process"},{"location":"development/release-process/#versioning","text":"Dokku follows semver standards. As we are not yet at a stable release, breaking changes will require only a minor release, while all other changes only require a patch release. Once we hit stable, breaking changes will require a major release. At the moment, tags need not be signed, though that may change in the future.","title":"Versioning"},{"location":"development/release-process/#arch-linux-packages","text":"Arch Linux packages are not really build, because all that is needed for an Arch User Repo (AUR) package is the description of how to build the package. To make this process as easy as possible there is a vagrant box called build-arch that updates the version of this build description (a file called PKGBUILD ), then runs some helper scripts to fill all additional information and does test if the package could be build. Then only those changes need to be pushed to the AUR repo and an updated version of the package is ready for usage for our Arch Linux users. For detailed information see the section below. The workflow looks like this: # having dokku-arch in ../dokku-arch vagrant up build-arch # wait for \"==> build-arch: ==> Finished making: dokku 0.28.4-2 (Mon Feb 22 23:20:37 CET 2016)\" cd ../dokku-arch git add PKGBUILD .SRCINFO git commit -m 'Update to dokku 0.9.9' git push aur master Info If you are a maintainer and need access to the AUR repositories in order to make a release, please contact @morrisjobke or @josegonzalez to get this co-maintainership.","title":"Arch Linux Packages"},{"location":"development/release-process/#detailed-information-for-arch-linux-packages","text":"All of the information to build the Arch Linux package is in the AUR git repository (see dokku AUR page ). The release of a AUR package only consists of pushing the package information into the AUR git repo. Then users could use that information to build the package on their machines. To update the package clone the repository and adjust the files in the repository. Then a helper script - updpkgsums - to update the SHA sum could be called (check against the original SHA sum). Another helper script - mksrcinfo - needs to be called to update the meta information of the package in a file called .SRCINFO . The next step builds the package locally for verification - makepkg . As last step commit your changes and push the commit. dependencies are defined in the depends attribute in PKGBUILD build steps during package build time are defined in the package() method in PKGBUILD steps that should be executed during install/update/remove time are defined in the file dokku.install detailed information about all attributes in PKGBUILD could be found in the Arch Linux wiki detailed information about the AUR workflow could be found in the AUR article in the Arch Linux wiki That is the usual workflow: updpkgsums # update sha sums - compare them with the original ones mksrcinfo # update package metadata for AUR makepkg # test package builds git add PKGBUILD .SRCINFO git commit -m 'Update to dokku 0.9.9' git push","title":"Detailed information for Arch Linux packages"},{"location":"development/testing/","text":"Running Tests Dokku has a full test suite to assist in quick iterating development. These tests include a linter using shellcheck , functional unit tests using the Bats testing framework , and a deployment suite of example apps that use the most popular languages and frameworks. We maintain the Dokku test harness within the tests directory: tests/unit/*.bats : Bats tests tests/apps/ : Example applications that can be used for tests Continuous Integration All pull requests have tests run against them on GitHub Actions , a continuous integration platform that provides Docker support for Ubuntu Trusty 18.04. If you wish to skip tests for a particular commit, e.g. documentation changes, you may add the [ci skip] designator to your commit message. Commits that should be tested but have the above designator will not be merged. While we do provide official packages for a variety of platforms, as our test suite currently runs on Ubuntu Trusty 18.04, we only provide official installation support for that platform and the latest LTS release of Ubuntu (currently 20.04). Local Test Execution Vagrant VM Setup Dokku in a Vagrant VM . Run the following to setup tests and execute them: vagrant ssh sudo su - cd ~/dokku make ci-dependencies setup-deploy-tests After making changes to your local Dokku clone, don't forget to update the Vagrant Dokku install. # update vagrant dokku install from local git clone make copyfiles # build a specific plugin make go-build-plugin copyplugin PLUGIN_NAME = apps VSCode Dev Container Open Dokku in a VSCode DevContainer Run the following in the VSCode terminal to setup tests and execute them: make ci-dependencies setup-deploy-tests After making changes to your local Dokku clone, don't forget to update the Vagrant Dokku install. # update vagrant dokku install from local git clone make copyfiles # build a specific plugin make go-build-plugin copyplugin PLUGIN_NAME = apps Executing tests Execute the entire test suite (linter, bats tests, and app deployment tests): make test Run the linter make lint Execute all bats tests make unit-tests Execute all app deployment tests make deploy-tests Executing App Tests You may run a specific app deployment tests with a target similar to: make deploy-test-nodejs-express For a full list of test make targets check out tests.mk in the root of the Dokku repository. Executing a single test suite When working on a particular plugin, it may be useful to run only a particular test suite. This can be done by specifying the test suite path: bats tests/unit/apps_1.bats It is also possible to target multiple test suites at a time. bats tests/unit/apps_1.bats tests/unit/certs.bats Executing a single test In order to increase testing velocity, a wrapper script around Bats is available that can be used to run a single test case within a suite. Tests within a suite may be listed by specifying the suite as a parameter to bats . bats tests/unit/apps_1.bats A single test can be specified via the --filter argument. The tests are selected via regex match, and all matches are executed. bats --filter list tests/unit/apps_1.bats","title":"Running Tests"},{"location":"development/testing/#running-tests","text":"Dokku has a full test suite to assist in quick iterating development. These tests include a linter using shellcheck , functional unit tests using the Bats testing framework , and a deployment suite of example apps that use the most popular languages and frameworks. We maintain the Dokku test harness within the tests directory: tests/unit/*.bats : Bats tests tests/apps/ : Example applications that can be used for tests","title":"Running Tests"},{"location":"development/testing/#continuous-integration","text":"All pull requests have tests run against them on GitHub Actions , a continuous integration platform that provides Docker support for Ubuntu Trusty 18.04. If you wish to skip tests for a particular commit, e.g. documentation changes, you may add the [ci skip] designator to your commit message. Commits that should be tested but have the above designator will not be merged. While we do provide official packages for a variety of platforms, as our test suite currently runs on Ubuntu Trusty 18.04, we only provide official installation support for that platform and the latest LTS release of Ubuntu (currently 20.04).","title":"Continuous Integration"},{"location":"development/testing/#local-test-execution","text":"","title":"Local Test Execution"},{"location":"development/testing/#vagrant-vm","text":"Setup Dokku in a Vagrant VM . Run the following to setup tests and execute them: vagrant ssh sudo su - cd ~/dokku make ci-dependencies setup-deploy-tests After making changes to your local Dokku clone, don't forget to update the Vagrant Dokku install. # update vagrant dokku install from local git clone make copyfiles # build a specific plugin make go-build-plugin copyplugin PLUGIN_NAME = apps","title":"Vagrant VM"},{"location":"development/testing/#vscode-dev-container","text":"Open Dokku in a VSCode DevContainer Run the following in the VSCode terminal to setup tests and execute them: make ci-dependencies setup-deploy-tests After making changes to your local Dokku clone, don't forget to update the Vagrant Dokku install. # update vagrant dokku install from local git clone make copyfiles # build a specific plugin make go-build-plugin copyplugin PLUGIN_NAME = apps","title":"VSCode Dev Container"},{"location":"development/testing/#executing-tests","text":"Execute the entire test suite (linter, bats tests, and app deployment tests): make test Run the linter make lint Execute all bats tests make unit-tests Execute all app deployment tests make deploy-tests","title":"Executing tests"},{"location":"development/testing/#executing-app-tests","text":"You may run a specific app deployment tests with a target similar to: make deploy-test-nodejs-express For a full list of test make targets check out tests.mk in the root of the Dokku repository.","title":"Executing App Tests"},{"location":"development/testing/#executing-a-single-test-suite","text":"When working on a particular plugin, it may be useful to run only a particular test suite. This can be done by specifying the test suite path: bats tests/unit/apps_1.bats It is also possible to target multiple test suites at a time. bats tests/unit/apps_1.bats tests/unit/certs.bats","title":"Executing a single test suite"},{"location":"development/testing/#executing-a-single-test","text":"In order to increase testing velocity, a wrapper script around Bats is available that can be used to run a single test case within a suite. Tests within a suite may be listed by specifying the suite as a parameter to bats . bats tests/unit/apps_1.bats A single test can be specified via the --filter argument. The tests are selected via regex match, and all matches are executed. bats --filter list tests/unit/apps_1.bats","title":"Executing a single test"},{"location":"enterprise/pro/","text":"Dokku Pro Dokku Pro is a commercial offering that provides a familiar Web UI for all common tasks performed by developers. End users can expect an interface that provides various complex cli commands in an intuitive, app-centric manner, quickly speeding up tasks that might otherwise be difficult for new and old users to perform. Additionally, it provides a way to perform these tasks remotely via a json api, enabling easier, audited remote management of servers. Finally, Dokku Pro provides an alternative, https-based method for deploying code which can be used in environments that lockdown ssh access to servers. Purchasing Dokku Pro may be purchased online by clicking the following purchase link: Dokku Pro Purchase Link Currently, the server must be able to contact the public internet to validate the license, or it will fail to start. For offline support, inquire for enterprise offline licensing. Installation Dokku Pro is shipped as Debian and RPM packages, and depends on the following files: /etc/default/dokku-pro : Configures certain environment variables for usage by the dokku-pro binary /etc/dokku-pro/license.key : Contains the downloaded license key /var/lib/dokku/data/pro/db : Contains the local dokku-pro database Please refer to the purchase email for details on configuring Dokku Pro. Features and Development Dokku Pro has the following functionality: Shipped as a single binary for ease of use JSON-API-compatible API with JWT authentication Authenticated HTTP(S) endpoints for git push functionality Single Page App (SPA) Web UI exposing app, datastore, and ssh key management While each release is fairly feature complete, individual features and documentation will expand over time. Feature development follows a monthly release cadence, with individual bug fixes released on an as needed basis.","title":"Dokku Pro"},{"location":"enterprise/pro/#dokku-pro","text":"Dokku Pro is a commercial offering that provides a familiar Web UI for all common tasks performed by developers. End users can expect an interface that provides various complex cli commands in an intuitive, app-centric manner, quickly speeding up tasks that might otherwise be difficult for new and old users to perform. Additionally, it provides a way to perform these tasks remotely via a json api, enabling easier, audited remote management of servers. Finally, Dokku Pro provides an alternative, https-based method for deploying code which can be used in environments that lockdown ssh access to servers.","title":"Dokku Pro"},{"location":"enterprise/pro/#purchasing","text":"Dokku Pro may be purchased online by clicking the following purchase link: Dokku Pro Purchase Link Currently, the server must be able to contact the public internet to validate the license, or it will fail to start. For offline support, inquire for enterprise offline licensing.","title":"Purchasing"},{"location":"enterprise/pro/#installation","text":"Dokku Pro is shipped as Debian and RPM packages, and depends on the following files: /etc/default/dokku-pro : Configures certain environment variables for usage by the dokku-pro binary /etc/dokku-pro/license.key : Contains the downloaded license key /var/lib/dokku/data/pro/db : Contains the local dokku-pro database Please refer to the purchase email for details on configuring Dokku Pro.","title":"Installation"},{"location":"enterprise/pro/#features-and-development","text":"Dokku Pro has the following functionality: Shipped as a single binary for ease of use JSON-API-compatible API with JWT authentication Authenticated HTTP(S) endpoints for git push functionality Single Page App (SPA) Web UI exposing app, datastore, and ssh key management While each release is fairly feature complete, individual features and documentation will expand over time. Feature development follows a monthly release cadence, with individual bug fixes released on an as needed basis.","title":"Features and Development"},{"location":"getting-started/advanced-installation/","text":"Advanced installation Installing via other methods For various reasons, certain hosting providers may have other steps that should be preferred to the above. If hosted on any of the following popular hosts, please follow the linked to instructions: DigitalOcean Installation Notes DreamHost Cloud Installation Notes Microsoft Azure Installation Notes As well, you may wish to customize your installation in some other fashion. or experiment with Vagrant. The guides below should get you started: Debian Package Installation Notes Docker-based Installation Notes Vagrant Installation Notes Advanced Install Customization Automated deployment via ansible Installing from Source You can always install Dokku straight from the latest - potentially unstable - master branch via the following Bash command: # using a branch results in installing from source wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh ; sudo DOKKU_BRANCH = master bash bootstrap.sh Development If you plan on developing Dokku, the easiest way to install from your own repository is cloning the repository and calling the install script. Example: git clone https://github.com/yourusername/dokku.git cd dokku sudo make install The Makefile allows source URLs to be overridden to include customizations from your own repositories. The DOCKER_URL , PLUGN_URL , SSHCOMMAND_URL and STACK_URL environment variables may be set to override the defaults (see the Makefile for how these apply). Example: sudo SSHCOMMAND_URL = https://raw.githubusercontent.com/yourusername/sshcommand/master/sshcommand make install Bootstrap a server from your own repository The bootstrap script allows the Dokku repository URL to be overridden to bootstrap a host from your own clone of Dokku using the DOKKU_REPO environment variable. Example: wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh ; chmod +x bootstrap.sh sudo DOKKU_REPO = https://github.com/yourusername/dokku.git DOKKU_BRANCH = master ./bootstrap.sh Custom Herokuish build Dokku ships with a pre-built version of version of the Herokuish component by default. If you want to build your own version you can specify that with an environment variable. git clone https://github.com/dokku/dokku.git cd dokku sudo BUILD_STACK = true STACK_URL = https://github.com/gliderlabs/herokuish.git make install Skipping Herokuish installation The Herokuish package is recommended but not required if not using Heroku buildpacks for deployment. Debian-based OS users can run the bootstrap installer via sudo DOKKU_NO_INSTALL_RECOMMENDS=\" --no-install-recommends \" bash bootstrap.sh to skip the dependency. Please note that this will also skip installation of other recommended dependencies. Configuring an unattended installation Once Dokku is installed, you'll want to configure the virtualhost setup as well as the push user. If you do not, your installation will be considered incomplete and you will not be able to deploy applications. For Debian, unattended installation is described Debian installation guide . Set up a domain using your preferred vendor and a wildcard domain pointing to the host running Dokku. You can manage this global domain using the domains plugin . Follow the user management documentation in order to add SSH keys for users to Dokku, or to give other Unix accounts access to Dokku. VMs with less than 1 GB of memory Having less than 1 GB of system memory available for Dokku and its containers may result in unexpected errors, such as ! [remote rejected] master -> master (pre-receive hook declined) during installation of NPM dependencies (https://github.com/npm/npm/issues/3867). To work around this issue, it might suffice to augment the Linux swap file size to a maximum of twice the physical memory size. To resize the swap file of a 512 MB machine to 1 GB, follow these steps while in SSH within your machine: cd /var touch swap.img chmod 600 swap.img dd if = /dev/zero of = /var/swap.img bs = 1024k count = 1000 mkswap /var/swap.img swapon /var/swap.img free echo \"/var/swap.img none swap sw 0 0\" >> /etc/fstab Reference","title":"Advanced installation"},{"location":"getting-started/advanced-installation/#advanced-installation","text":"","title":"Advanced installation"},{"location":"getting-started/advanced-installation/#installing-via-other-methods","text":"For various reasons, certain hosting providers may have other steps that should be preferred to the above. If hosted on any of the following popular hosts, please follow the linked to instructions: DigitalOcean Installation Notes DreamHost Cloud Installation Notes Microsoft Azure Installation Notes As well, you may wish to customize your installation in some other fashion. or experiment with Vagrant. The guides below should get you started: Debian Package Installation Notes Docker-based Installation Notes Vagrant Installation Notes Advanced Install Customization Automated deployment via ansible","title":"Installing via other methods"},{"location":"getting-started/advanced-installation/#installing-from-source","text":"You can always install Dokku straight from the latest - potentially unstable - master branch via the following Bash command: # using a branch results in installing from source wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh ; sudo DOKKU_BRANCH = master bash bootstrap.sh","title":"Installing from Source"},{"location":"getting-started/advanced-installation/#development","text":"If you plan on developing Dokku, the easiest way to install from your own repository is cloning the repository and calling the install script. Example: git clone https://github.com/yourusername/dokku.git cd dokku sudo make install The Makefile allows source URLs to be overridden to include customizations from your own repositories. The DOCKER_URL , PLUGN_URL , SSHCOMMAND_URL and STACK_URL environment variables may be set to override the defaults (see the Makefile for how these apply). Example: sudo SSHCOMMAND_URL = https://raw.githubusercontent.com/yourusername/sshcommand/master/sshcommand make install","title":"Development"},{"location":"getting-started/advanced-installation/#bootstrap-a-server-from-your-own-repository","text":"The bootstrap script allows the Dokku repository URL to be overridden to bootstrap a host from your own clone of Dokku using the DOKKU_REPO environment variable. Example: wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh ; chmod +x bootstrap.sh sudo DOKKU_REPO = https://github.com/yourusername/dokku.git DOKKU_BRANCH = master ./bootstrap.sh","title":"Bootstrap a server from your own repository"},{"location":"getting-started/advanced-installation/#custom-herokuish-build","text":"Dokku ships with a pre-built version of version of the Herokuish component by default. If you want to build your own version you can specify that with an environment variable. git clone https://github.com/dokku/dokku.git cd dokku sudo BUILD_STACK = true STACK_URL = https://github.com/gliderlabs/herokuish.git make install","title":"Custom Herokuish build"},{"location":"getting-started/advanced-installation/#skipping-herokuish-installation","text":"The Herokuish package is recommended but not required if not using Heroku buildpacks for deployment. Debian-based OS users can run the bootstrap installer via sudo DOKKU_NO_INSTALL_RECOMMENDS=\" --no-install-recommends \" bash bootstrap.sh to skip the dependency. Please note that this will also skip installation of other recommended dependencies.","title":"Skipping Herokuish installation"},{"location":"getting-started/advanced-installation/#configuring-an-unattended-installation","text":"Once Dokku is installed, you'll want to configure the virtualhost setup as well as the push user. If you do not, your installation will be considered incomplete and you will not be able to deploy applications. For Debian, unattended installation is described Debian installation guide . Set up a domain using your preferred vendor and a wildcard domain pointing to the host running Dokku. You can manage this global domain using the domains plugin . Follow the user management documentation in order to add SSH keys for users to Dokku, or to give other Unix accounts access to Dokku.","title":"Configuring an unattended installation"},{"location":"getting-started/advanced-installation/#vms-with-less-than-1-gb-of-memory","text":"Having less than 1 GB of system memory available for Dokku and its containers may result in unexpected errors, such as ! [remote rejected] master -> master (pre-receive hook declined) during installation of NPM dependencies (https://github.com/npm/npm/issues/3867). To work around this issue, it might suffice to augment the Linux swap file size to a maximum of twice the physical memory size. To resize the swap file of a 512 MB machine to 1 GB, follow these steps while in SSH within your machine: cd /var touch swap.img chmod 600 swap.img dd if = /dev/zero of = /var/swap.img bs = 1024k count = 1000 mkswap /var/swap.img swapon /var/swap.img free echo \"/var/swap.img none swap sw 0 0\" >> /etc/fstab Reference","title":"VMs with less than 1 GB of memory"},{"location":"getting-started/troubleshooting/","text":"Troubleshooting New Introduced in 0.17.0 trace:on # Enables trace mode trace:off # Disables trace mode Trace Mode By default, Dokku will constrain the amount of output displayed for any given command run. The verbosity of output can be increased by enabling trace mode. Trace mode will turn on the set -x flag for bash plugins, while other plugins are free to respect the environment variable DOKKU_TRACE and log differently as approprate. Trace mode can be useful to see where plugins are running commands that would otherwise be unexpected. To enable trace mode, run trace:on Shell Output dokku trace:on -----> Enabling trace mode Trace mode can be disabled with trace:off Shell Output dokku trace:off -----> Disabling trace mode Common Problems I deployed my app but I am getting the default nginx page. Most of the time it's caused by some defaults newer versions of nginx set. To make sure that's the issue you're having run the following: nginx -t ## nginx: [emerg] could not build the server_names_hash, you should increase server_names_hash_bucket_size: 32 If you get a similar error just edit /etc/nginx/nginx.conf and add the following line to your http section: http { (... existing content ...) server_names_hash_bucket_size 64 ; (...) } Note that the server_names_hash_bucket_size setting defines the maximum domain name length. A value of 64 would allow domains with up to 64 characters. Set it to 128 if you need longer ones. Save the file and try stopping nginx and starting it again: /etc/init.d/nginx stop ## * Stopping nginx nginx [ OK ] /etc/init.d/nginx start ## * Starting nginx nginx [ OK ] Using the EXPOSE directive in a Dockerfile may be another reason why you might see the default site. When the EXPOSE directive is in use and a proxy plugin is enabled (the default), the proxy plugin will listen to requests on the ports specified in the EXPOSE stanza. For example, if you have an EXPOSE directive like so: EXPOSE 8000 The proxy port mapping will be http:8000:8000 . To avoid this issue, either of the following can be done: Remove EXPOSE directive: This will require respecting the $PORT environment variable (automatically set by Dokku). Once that change is deployed, the port mapping should be cleared via the dokku proxy:ports-clear $APP command (where $APP is your app name). Update the port mapping: Updating the port mapping to redirect port 80 to your app's exposed port via dokku proxy:ports-set $APP http:80:$EXPOSED_PORT can also fix the issue. This will also allow certificate management and the letsencrypt plugin to work correctly. See the port management documentation for more information on how Dokku exposes ports for applications and how you can configure these for your app. I want to deploy my app, but while pushing I get the following error The following error may be emitted from a deploy: ! [remote rejected] master -> master (pre-receive hook declined) The remote rejected error does not give enough information. Anything could have failed. Enable trace mode and begin debugging. If this does not help you, create a gist containing the full log, and create an issue. One the reasons why you may get this error is because the command that is run in the container exited (without errors). For example, (in Procfile) when you define a new worker container to run Delayed Job and use the bin/delayed_job start command. This command deamonizes the process and exists. The container thinks it's done so it closes itself. The error you get is the one above. To fix the above problem for Delayed Job, you must define the worker to user rake jobs:work, which doesn't deamonize the process. I get the aforementioned error in the build phase (after turning on Dokku tracing) Most errors that happen in this phase are due to transient network issues (either locally or remotely) buildpack bugs. Find the failed phase's container image ( 077581956a92 in this example). docker ps -a | grep build ## 94d9515e6d93 077581956a92 \"/build\" 29 minutes ago Exited (0) 25 minutes ago cocky_bell Start a new container with the failed image and poke around (i.e. ensure you can access the internet from within the container or attempt the failed command, if known). docker run -ti 077581956a92 /bin/bash curl -s -S icanhazip.com ## 192.168.0.1 curl http://s3pository.heroku.com/node/v0.10.30/node-v0.10.30-linux-x64.tar.gz -o node-v0.10.30-linux-x64.tar.gz tar tzf node-v0.10.30-linux-x64.tar.gz ## ... Sometimes (especially on DigitalOcean) deploying again seems to get past these seemingly transient issues. Additionally we've seen issues if changing networks that have different DNS resolvers. In this case, you can run the following to update your resolv.conf . resolvconf -u Please see https://github.com/dokku/dokku/issues/841 and https://github.com/dokku/dokku/issues/649. After adding an SSH key, I am told I cannot read from the remote repository on push Connection closed by <host> port 22 fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. Certain systems may have access to the dokku user via SSH disabled. Please check that the dokku user is allowed access to the system in the file /etc/security/access.conf . As Dokku does not manage this file, please consult your Operating System's documentation for more information. I want to deploy my app but I am getting asked for the password of the Git user Sometimes the following error message may be shown on push fatal: 'NAME' does not appear to be a git repository fatal: Could not read from remote repository. You get asked for a password because your SSH secret key can't be found. This may happen if the private key corresponding to the public key you added with sshcommand acl-add is not located in the default location ~/.ssh/id_rsa . You have to point SSH to the correct secret key for your domain name. Add the following to your ~/.ssh/config : Host DOKKU_HOSTNAME IdentityFile \"~/.ssh/KEYNAME\" Also see issue #116 . I successfully deployed my application with no deployment errors and receiving Bad Gateway when attempting to access the application. In many cases the application will require the a process.env.PORT port opposed to a specified port. When specifying your port you may want to use something similar to: var port = process . env . PORT || 3000 Please see https://github.com/dokku/dokku/issues/282. Deployment fails because of slow internet connection, messages shows gzip: stdin: unexpected end of file . If you see output similar this when deploying: Command: 'set -o pipefail; curl --fail --retry 3 --retry-delay 1 --connect-timeout 3 --max-time 30 https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/ruby-2.0.0-p451-default-cache.tgz -s -o - | tar zxf -' failed unexpectedly: ! ! gzip: stdin: unexpected end of file ! tar: Unexpected EOF in archive ! tar: Unexpected EOF in archive ! tar: Error is not recoverable: exiting now it might that the cURL command that is supposed to fetch the buildpack (anything in the low megabyte file size range) takes too long to finish, due to slowish connection. To overwrite the default values (connection timeout: 90 seconds, total maximum time for operation: 600 seconds), set the following environment variables: dokku config:set --global CURL_TIMEOUT = 1200 dokku config:set --global CURL_CONNECT_TIMEOUT = 180 Please see https://github.com/dokku/dokku/issues/509. Another reason for this error (although it may respond immediately ruling out a timeout issue) may be because you've set the config setting SSL_CERT_FILE . Using a config setting with this key interferes with the buildpack's ability to download its dependencies, so you must rename the config setting to something else, e.g. MY_APP_SSL_CERT_FILE . Build fails with Killed message. This generally occurs when the server runs out of memory. You can either add more RAM to your server or setup swap space. The follow script will create 2 GB of swap space. sudo install -o root -g root -m 0600 /dev/null /swapfile dd if = /dev/zero of = /swapfile bs = 1k count = 2048k mkswap /swapfile swapon /swapfile echo \"/swapfile swap swap auto 0 0\" | sudo tee -a /etc/fstab sudo sysctl -w vm.swappiness = 10 echo vm.swappiness = 10 | sudo tee -a /etc/sysctl.conf I successfully deployed my application with no deployment errors but I'm receiving Connection Timeout when attempting to access the application. This can occur if Dokku is running on a system with a firewall like UFW enabled (some OS versions like Ubuntu have this enabled by default). You can check if this is your case by running the following script: sudo ufw status If the previous script returned Status: active and a list of ports, UFW is enabled and is probably the cause of the symptom described above. To disable it, run: sudo ufw disable I can't connect to my application because the server is sending an invalid response, or can't provide a secure connection. This isn't usually an issue with Dokku, but rather an app config problem. This can happen when your application is configured to enforce secure connections/HSTS, but you don't have SSL set up for the app. In Rails at least, if your application.rb or environmnents/production.rb include the line configure.force_ssl = true which includes HSTS, try commenting that out and redeploying. If this solves the issue temporarily, longer term you should consider configuring SSL . My application deploys properly, but won't load in browser \"connection refused\" This could be a result of a bad proxy configuration ( http:5000:5000 may be incorrect). Run dokku proxy:report myapp to check if your app has the correct proxy configuration. It should show something like the following. =====> myapp proxy information Proxy enabled: true Proxy port map: http:80:5000 https:443:5000 Proxy type: nginx Set dokku proxy:ports-set front http:80:5000 to get proxy correctly configured for http endpoint.","title":"Troubleshooting"},{"location":"getting-started/troubleshooting/#troubleshooting","text":"New Introduced in 0.17.0 trace:on # Enables trace mode trace:off # Disables trace mode","title":"Troubleshooting"},{"location":"getting-started/troubleshooting/#trace-mode","text":"By default, Dokku will constrain the amount of output displayed for any given command run. The verbosity of output can be increased by enabling trace mode. Trace mode will turn on the set -x flag for bash plugins, while other plugins are free to respect the environment variable DOKKU_TRACE and log differently as approprate. Trace mode can be useful to see where plugins are running commands that would otherwise be unexpected. To enable trace mode, run trace:on Shell Output dokku trace:on -----> Enabling trace mode Trace mode can be disabled with trace:off Shell Output dokku trace:off -----> Disabling trace mode","title":"Trace Mode"},{"location":"getting-started/troubleshooting/#common-problems","text":"","title":"Common Problems"},{"location":"getting-started/troubleshooting/#i-deployed-my-app-but-i-am-getting-the-default-nginx-page","text":"Most of the time it's caused by some defaults newer versions of nginx set. To make sure that's the issue you're having run the following: nginx -t ## nginx: [emerg] could not build the server_names_hash, you should increase server_names_hash_bucket_size: 32 If you get a similar error just edit /etc/nginx/nginx.conf and add the following line to your http section: http { (... existing content ...) server_names_hash_bucket_size 64 ; (...) } Note that the server_names_hash_bucket_size setting defines the maximum domain name length. A value of 64 would allow domains with up to 64 characters. Set it to 128 if you need longer ones. Save the file and try stopping nginx and starting it again: /etc/init.d/nginx stop ## * Stopping nginx nginx [ OK ] /etc/init.d/nginx start ## * Starting nginx nginx [ OK ] Using the EXPOSE directive in a Dockerfile may be another reason why you might see the default site. When the EXPOSE directive is in use and a proxy plugin is enabled (the default), the proxy plugin will listen to requests on the ports specified in the EXPOSE stanza. For example, if you have an EXPOSE directive like so: EXPOSE 8000 The proxy port mapping will be http:8000:8000 . To avoid this issue, either of the following can be done: Remove EXPOSE directive: This will require respecting the $PORT environment variable (automatically set by Dokku). Once that change is deployed, the port mapping should be cleared via the dokku proxy:ports-clear $APP command (where $APP is your app name). Update the port mapping: Updating the port mapping to redirect port 80 to your app's exposed port via dokku proxy:ports-set $APP http:80:$EXPOSED_PORT can also fix the issue. This will also allow certificate management and the letsencrypt plugin to work correctly. See the port management documentation for more information on how Dokku exposes ports for applications and how you can configure these for your app.","title":"I deployed my app but I am getting the default nginx page."},{"location":"getting-started/troubleshooting/#i-want-to-deploy-my-app-but-while-pushing-i-get-the-following-error","text":"The following error may be emitted from a deploy: ! [remote rejected] master -> master (pre-receive hook declined) The remote rejected error does not give enough information. Anything could have failed. Enable trace mode and begin debugging. If this does not help you, create a gist containing the full log, and create an issue. One the reasons why you may get this error is because the command that is run in the container exited (without errors). For example, (in Procfile) when you define a new worker container to run Delayed Job and use the bin/delayed_job start command. This command deamonizes the process and exists. The container thinks it's done so it closes itself. The error you get is the one above. To fix the above problem for Delayed Job, you must define the worker to user rake jobs:work, which doesn't deamonize the process.","title":"I want to deploy my app, but while pushing I get the following error"},{"location":"getting-started/troubleshooting/#i-get-the-aforementioned-error-in-the-build-phase-after-turning-on-dokku-tracing","text":"Most errors that happen in this phase are due to transient network issues (either locally or remotely) buildpack bugs. Find the failed phase's container image ( 077581956a92 in this example). docker ps -a | grep build ## 94d9515e6d93 077581956a92 \"/build\" 29 minutes ago Exited (0) 25 minutes ago cocky_bell Start a new container with the failed image and poke around (i.e. ensure you can access the internet from within the container or attempt the failed command, if known). docker run -ti 077581956a92 /bin/bash curl -s -S icanhazip.com ## 192.168.0.1 curl http://s3pository.heroku.com/node/v0.10.30/node-v0.10.30-linux-x64.tar.gz -o node-v0.10.30-linux-x64.tar.gz tar tzf node-v0.10.30-linux-x64.tar.gz ## ... Sometimes (especially on DigitalOcean) deploying again seems to get past these seemingly transient issues. Additionally we've seen issues if changing networks that have different DNS resolvers. In this case, you can run the following to update your resolv.conf . resolvconf -u Please see https://github.com/dokku/dokku/issues/841 and https://github.com/dokku/dokku/issues/649.","title":"I get the aforementioned error in the build phase (after turning on Dokku tracing)"},{"location":"getting-started/troubleshooting/#after-adding-an-ssh-key-i-am-told-i-cannot-read-from-the-remote-repository-on-push","text":"Connection closed by <host> port 22 fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. Certain systems may have access to the dokku user via SSH disabled. Please check that the dokku user is allowed access to the system in the file /etc/security/access.conf . As Dokku does not manage this file, please consult your Operating System's documentation for more information.","title":"After adding an SSH key, I am told I cannot read from the remote repository on push"},{"location":"getting-started/troubleshooting/#i-want-to-deploy-my-app-but-i-am-getting-asked-for-the-password-of-the-git-user","text":"Sometimes the following error message may be shown on push fatal: 'NAME' does not appear to be a git repository fatal: Could not read from remote repository. You get asked for a password because your SSH secret key can't be found. This may happen if the private key corresponding to the public key you added with sshcommand acl-add is not located in the default location ~/.ssh/id_rsa . You have to point SSH to the correct secret key for your domain name. Add the following to your ~/.ssh/config : Host DOKKU_HOSTNAME IdentityFile \"~/.ssh/KEYNAME\" Also see issue #116 .","title":"I want to deploy my app but I am getting asked for the password of the Git user"},{"location":"getting-started/troubleshooting/#i-successfully-deployed-my-application-with-no-deployment-errors-and-receiving-bad-gateway-when-attempting-to-access-the-application","text":"In many cases the application will require the a process.env.PORT port opposed to a specified port. When specifying your port you may want to use something similar to: var port = process . env . PORT || 3000 Please see https://github.com/dokku/dokku/issues/282.","title":"I successfully deployed my application with no deployment errors and receiving Bad Gateway when attempting to access the application."},{"location":"getting-started/troubleshooting/#deployment-fails-because-of-slow-internet-connection-messages-shows-gzip-stdin-unexpected-end-of-file","text":"If you see output similar this when deploying: Command: 'set -o pipefail; curl --fail --retry 3 --retry-delay 1 --connect-timeout 3 --max-time 30 https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/ruby-2.0.0-p451-default-cache.tgz -s -o - | tar zxf -' failed unexpectedly: ! ! gzip: stdin: unexpected end of file ! tar: Unexpected EOF in archive ! tar: Unexpected EOF in archive ! tar: Error is not recoverable: exiting now it might that the cURL command that is supposed to fetch the buildpack (anything in the low megabyte file size range) takes too long to finish, due to slowish connection. To overwrite the default values (connection timeout: 90 seconds, total maximum time for operation: 600 seconds), set the following environment variables: dokku config:set --global CURL_TIMEOUT = 1200 dokku config:set --global CURL_CONNECT_TIMEOUT = 180 Please see https://github.com/dokku/dokku/issues/509. Another reason for this error (although it may respond immediately ruling out a timeout issue) may be because you've set the config setting SSL_CERT_FILE . Using a config setting with this key interferes with the buildpack's ability to download its dependencies, so you must rename the config setting to something else, e.g. MY_APP_SSL_CERT_FILE .","title":"Deployment fails because of slow internet connection, messages shows gzip: stdin: unexpected end of file."},{"location":"getting-started/troubleshooting/#build-fails-with-killed-message","text":"This generally occurs when the server runs out of memory. You can either add more RAM to your server or setup swap space. The follow script will create 2 GB of swap space. sudo install -o root -g root -m 0600 /dev/null /swapfile dd if = /dev/zero of = /swapfile bs = 1k count = 2048k mkswap /swapfile swapon /swapfile echo \"/swapfile swap swap auto 0 0\" | sudo tee -a /etc/fstab sudo sysctl -w vm.swappiness = 10 echo vm.swappiness = 10 | sudo tee -a /etc/sysctl.conf","title":"Build fails with Killed message."},{"location":"getting-started/troubleshooting/#i-successfully-deployed-my-application-with-no-deployment-errors-but-im-receiving-connection-timeout-when-attempting-to-access-the-application","text":"This can occur if Dokku is running on a system with a firewall like UFW enabled (some OS versions like Ubuntu have this enabled by default). You can check if this is your case by running the following script: sudo ufw status If the previous script returned Status: active and a list of ports, UFW is enabled and is probably the cause of the symptom described above. To disable it, run: sudo ufw disable","title":"I successfully deployed my application with no deployment errors but I'm receiving Connection Timeout when attempting to access the application."},{"location":"getting-started/troubleshooting/#i-cant-connect-to-my-application-because-the-server-is-sending-an-invalid-response-or-cant-provide-a-secure-connection","text":"This isn't usually an issue with Dokku, but rather an app config problem. This can happen when your application is configured to enforce secure connections/HSTS, but you don't have SSL set up for the app. In Rails at least, if your application.rb or environmnents/production.rb include the line configure.force_ssl = true which includes HSTS, try commenting that out and redeploying. If this solves the issue temporarily, longer term you should consider configuring SSL .","title":"I can't connect to my application because the server is sending an invalid response, or can't provide a secure connection."},{"location":"getting-started/troubleshooting/#my-application-deploys-properly-but-wont-load-in-browser-connection-refused","text":"This could be a result of a bad proxy configuration ( http:5000:5000 may be incorrect). Run dokku proxy:report myapp to check if your app has the correct proxy configuration. It should show something like the following. =====> myapp proxy information Proxy enabled: true Proxy port map: http:80:5000 https:443:5000 Proxy type: nginx Set dokku proxy:ports-set front http:80:5000 to get proxy correctly configured for http endpoint.","title":"My application deploys properly, but won't load in browser \"connection refused\""},{"location":"getting-started/uninstalling/","text":"Uninstalling While we hate to see you go, if you need to uninstall Dokku, the following may help you out: Arch Uninstallation # purge dokku from your system yay -Rsn dokku Debian Uninstallation # purge dokku from your system apt-get purge dokku herokuish # remove any dependencies that are no longer necessary apt-get autoremove Makefile Uninstallation This is a manual deletion process, and as it is not a recommended installation method, there is currently no automated uninstallation. All service plugins should be unlinked from applications, stopped, and destroyed. All applications should be stopped, and all docker containers and images deleted: # stop all applications dokku ps:stop --all # cleanup containers and images dokku cleanup The following user/group must be deleted: user: dokku group: dokku The following directories must be deleted: ~dokku /var/lib/dokku /var/log/dokku","title":"Uninstalling"},{"location":"getting-started/uninstalling/#uninstalling","text":"While we hate to see you go, if you need to uninstall Dokku, the following may help you out:","title":"Uninstalling"},{"location":"getting-started/uninstalling/#arch-uninstallation","text":"# purge dokku from your system yay -Rsn dokku","title":"Arch Uninstallation"},{"location":"getting-started/uninstalling/#debian-uninstallation","text":"# purge dokku from your system apt-get purge dokku herokuish # remove any dependencies that are no longer necessary apt-get autoremove","title":"Debian Uninstallation"},{"location":"getting-started/uninstalling/#makefile-uninstallation","text":"This is a manual deletion process, and as it is not a recommended installation method, there is currently no automated uninstallation. All service plugins should be unlinked from applications, stopped, and destroyed. All applications should be stopped, and all docker containers and images deleted: # stop all applications dokku ps:stop --all # cleanup containers and images dokku cleanup The following user/group must be deleted: user: dokku group: dokku The following directories must be deleted: ~dokku /var/lib/dokku /var/log/dokku","title":"Makefile Uninstallation"},{"location":"getting-started/where-to-get-help/","text":"Where to Get Help If you\u2019re stuck, there are a number of places you can get help: The Official Dokku Website https://dokku.com/docs/ The Official Dokku website is always a great place to visit. It features links to oft-used developer tools, community plugins, and guides on using Dokku. Monitored Locations The Code Of Conduct applies to all actively monitored Dokku discussion areas. Please be mindful of your neighbors on the internet. Forums GitHub Discussions GitHub Discussions is a new way for the Dokku community to interact with each other! This is a place to ask questions to the community or discuss potential feature requests before filing issues. The Slack Channel Gliderlabs Slack (Join the #dokku channel) If you\u2019re stumped, give us a holler in the Dokku Slack channel. Someone from the development team is usually there, especially during the daylight hours for North and South American users. We\u2019d love to hear from you, whether you need some help, want to find users in your area, or would like to donate our brand new sports car. Chat is synced to Discord and IRC. Discord Dokku Discord We provide a Dokku Discord that folks can use to ask questions or comments about the project. Someone from the development team is usually there, especially during the daylight hours for North and South American users. Feel free to join us online! Chat is synced to IRC and Slack. Unmonitored Locations You may find help on these locations, but they are not actively monitored by the development team. The Code of Conduct still applies. Stack Overflow The Dokku tag on Stack Overflow Tag your questions with dokku to enable existing users of Stack Overflow to find your questions. IRC (on libera.chat) irc.libera.chat/#dokku This location isn't as well monitored as Slack, and loses history. Chat is synced to Discord and Slack","title":"Where to Get Help"},{"location":"getting-started/where-to-get-help/#where-to-get-help","text":"If you\u2019re stuck, there are a number of places you can get help:","title":"Where to Get Help"},{"location":"getting-started/where-to-get-help/#the-official-dokku-website","text":"https://dokku.com/docs/ The Official Dokku website is always a great place to visit. It features links to oft-used developer tools, community plugins, and guides on using Dokku.","title":"The Official Dokku Website"},{"location":"getting-started/where-to-get-help/#monitored-locations","text":"The Code Of Conduct applies to all actively monitored Dokku discussion areas. Please be mindful of your neighbors on the internet.","title":"Monitored Locations"},{"location":"getting-started/where-to-get-help/#forums","text":"GitHub Discussions GitHub Discussions is a new way for the Dokku community to interact with each other! This is a place to ask questions to the community or discuss potential feature requests before filing issues.","title":"Forums"},{"location":"getting-started/where-to-get-help/#the-slack-channel","text":"Gliderlabs Slack (Join the #dokku channel) If you\u2019re stumped, give us a holler in the Dokku Slack channel. Someone from the development team is usually there, especially during the daylight hours for North and South American users. We\u2019d love to hear from you, whether you need some help, want to find users in your area, or would like to donate our brand new sports car. Chat is synced to Discord and IRC.","title":"The Slack Channel"},{"location":"getting-started/where-to-get-help/#discord","text":"Dokku Discord We provide a Dokku Discord that folks can use to ask questions or comments about the project. Someone from the development team is usually there, especially during the daylight hours for North and South American users. Feel free to join us online! Chat is synced to IRC and Slack.","title":"Discord"},{"location":"getting-started/where-to-get-help/#unmonitored-locations","text":"You may find help on these locations, but they are not actively monitored by the development team. The Code of Conduct still applies.","title":"Unmonitored Locations"},{"location":"getting-started/where-to-get-help/#stack-overflow","text":"The Dokku tag on Stack Overflow Tag your questions with dokku to enable existing users of Stack Overflow to find your questions.","title":"Stack Overflow"},{"location":"getting-started/where-to-get-help/#irc-on-liberachat","text":"irc.libera.chat/#dokku This location isn't as well monitored as Slack, and loses history. Chat is synced to Discord and Slack","title":"IRC (on libera.chat)"},{"location":"getting-started/install/azure/","text":"Microsoft Azure Installation Notes If you don't already have one generate an SSH key pair . Go to the Dokku on Azure deployment page and click Deploy to Azure . You'll be prompted to enter a few parameters, including a unique storage account name and a unique name for the subdomain used for your public IP address. For the sshKeyData parameter, copy and paste the contents of the public key file you just created. After a few minutes the Dokku instance will be deployed. Once the installation is complete, you should configure an ssh key and set your global domain. # usually your key is already available under the current user's `~/.ssh/authorized_keys` file cat ~/.ssh/authorized_keys | dokku ssh-keys:add admin # you can use any domain you already have access to # this domain should have an A record or CNAME pointing at your server's IP dokku domains:set-global dokku.me # you can also use the ip of your server dokku domains:set-global 10 .0.0.2 # finally, you can use sslip.io to get subdomain support # as you would with a regular domain name # this would be done by appending `.sslip.io` to your ip address dokku domains:set-global 10 .0.0.2.sslip.io See the user management and domains documentation for more information.","title":"Microsoft Azure Installation Notes"},{"location":"getting-started/install/azure/#microsoft-azure-installation-notes","text":"If you don't already have one generate an SSH key pair . Go to the Dokku on Azure deployment page and click Deploy to Azure . You'll be prompted to enter a few parameters, including a unique storage account name and a unique name for the subdomain used for your public IP address. For the sshKeyData parameter, copy and paste the contents of the public key file you just created. After a few minutes the Dokku instance will be deployed. Once the installation is complete, you should configure an ssh key and set your global domain. # usually your key is already available under the current user's `~/.ssh/authorized_keys` file cat ~/.ssh/authorized_keys | dokku ssh-keys:add admin # you can use any domain you already have access to # this domain should have an A record or CNAME pointing at your server's IP dokku domains:set-global dokku.me # you can also use the ip of your server dokku domains:set-global 10 .0.0.2 # finally, you can use sslip.io to get subdomain support # as you would with a regular domain name # this would be done by appending `.sslip.io` to your ip address dokku domains:set-global 10 .0.0.2.sslip.io See the user management and domains documentation for more information.","title":"Microsoft Azure Installation Notes"},{"location":"getting-started/install/debian/","text":"Debian Package Installation Notes As of 0.3.18, Dokku defaults to being installed via Debian package. While certain hosts may require extra work to get running, you may optionally wish to automate the installation of Dokku without the use of our bootstrap.sh Bash script. The following are the steps run by said script: # install prerequisites sudo apt-get update -qq >/dev/null sudo apt-get -qq -y --no-install-recommends install apt-transport-https # install docker wget -nv -O - https://get.docker.com/ | sh # install dokku wget -qO- https://packagecloud.io/dokku/dokku/gpgkey | sudo tee /etc/apt/trusted.gpg.d/dokku.asc OS_ID = \" $( lsb_release -cs 2 >/dev/null || echo \"bionic\" ) \" echo \"bionic focal jammy\" | grep -q \" $OS_ID \" || OS_ID = \"bionic\" echo \"deb https://packagecloud.io/dokku/dokku/ubuntu/ ${ OS_ID } main\" | sudo tee /etc/apt/sources.list.d/dokku.list sudo apt-get update -qq >/dev/null sudo apt-get -qq -y install dokku sudo dokku plugin:install-dependencies --core Unattended installation In case you want to perform an unattended installation of Dokku, this is made possible through debconf , which allows you to configure a package before installing it. You can set any of the below options through the debconf-set-selections command, for example to enable vhost-based deployments: echo \"dokku dokku/vhost_enable boolean true\" | sudo debconf-set-selections After setting the desired options, proceed with the installation as described above. debconf options Name Type Default Description dokku/vhost_enable boolean false Use vhost-based deployments (e.g. [yourapp].dokku.me ) dokku/hostname string dokku.me Hostname, used as vhost domain and for showing app URL after deploy dokku/skip_key_file boolean false Don't check for the existence of the dokku/key_file. Warning: Setting this to true, will require you to manually add an SSH key later on. dokku/key_file string /root/.ssh/id_rsa.pub Path on disk to an SSH key to add to the Dokku user (Will be ignored on dpkg-reconfigure ) dokku/nginx_enable boolean true Enable nginx-vhosts plugin","title":"Debian Package Installation Notes"},{"location":"getting-started/install/debian/#debian-package-installation-notes","text":"As of 0.3.18, Dokku defaults to being installed via Debian package. While certain hosts may require extra work to get running, you may optionally wish to automate the installation of Dokku without the use of our bootstrap.sh Bash script. The following are the steps run by said script: # install prerequisites sudo apt-get update -qq >/dev/null sudo apt-get -qq -y --no-install-recommends install apt-transport-https # install docker wget -nv -O - https://get.docker.com/ | sh # install dokku wget -qO- https://packagecloud.io/dokku/dokku/gpgkey | sudo tee /etc/apt/trusted.gpg.d/dokku.asc OS_ID = \" $( lsb_release -cs 2 >/dev/null || echo \"bionic\" ) \" echo \"bionic focal jammy\" | grep -q \" $OS_ID \" || OS_ID = \"bionic\" echo \"deb https://packagecloud.io/dokku/dokku/ubuntu/ ${ OS_ID } main\" | sudo tee /etc/apt/sources.list.d/dokku.list sudo apt-get update -qq >/dev/null sudo apt-get -qq -y install dokku sudo dokku plugin:install-dependencies --core","title":"Debian Package Installation Notes"},{"location":"getting-started/install/debian/#unattended-installation","text":"In case you want to perform an unattended installation of Dokku, this is made possible through debconf , which allows you to configure a package before installing it. You can set any of the below options through the debconf-set-selections command, for example to enable vhost-based deployments: echo \"dokku dokku/vhost_enable boolean true\" | sudo debconf-set-selections After setting the desired options, proceed with the installation as described above.","title":"Unattended installation"},{"location":"getting-started/install/debian/#debconf-options","text":"Name Type Default Description dokku/vhost_enable boolean false Use vhost-based deployments (e.g. [yourapp].dokku.me ) dokku/hostname string dokku.me Hostname, used as vhost domain and for showing app URL after deploy dokku/skip_key_file boolean false Don't check for the existence of the dokku/key_file. Warning: Setting this to true, will require you to manually add an SSH key later on. dokku/key_file string /root/.ssh/id_rsa.pub Path on disk to an SSH key to add to the Dokku user (Will be ignored on dpkg-reconfigure ) dokku/nginx_enable boolean true Enable nginx-vhosts plugin","title":"debconf options"},{"location":"getting-started/install/digitalocean/","text":"DigitalOcean Droplet Installation Notes DigitalOcean offers a pre-installed Dokku image. You can run this image on any sized Droplet, although larger Droplets will allow you to run larger applications. Info Please disable IPv6 . There are known issues with IPv6 on DigitalOcean and Docker. If you would like to run Dokku on an IPv6 DigitalOcean Droplet, please consult this guide . Login to your DigitalOcean account. Click Create a Droplet . Under Choose an image > Marketplace , search latest Dokku release for Ubuntu 20.04 (version numbers may vary) . Under Choose a size , select your machine spec. Under Choose a datacenter region , select your region. Add an SSH Key. New Keys Under Add your SSH keys click New SSH Key (this opens a dialog) . From your terminal, execute cat $HOME/.ssh/id_rsa.pub . Copy the output and paste it into the New SSH Key dialog, provide a name and click Add SSH Key . Existing Keys Simply add a checkmark next to the existing keys you'd like to add. Under Finalize and create , give your Droplet a hostname (not required) and click Create . Once created, copy the IP address to your clipboard. In a browser, go to the IP address you copied above and fill out the presented form to complete configuration. Failure to do so may allow others to reconfigure SSH access on your server. Once the web UI has been submitted, you will be redirected to our application deployment tutorial , which will guide you through deploying a sample application to your Dokku server.","title":"DigitalOcean Droplet Installation Notes"},{"location":"getting-started/install/digitalocean/#digitalocean-droplet-installation-notes","text":"DigitalOcean offers a pre-installed Dokku image. You can run this image on any sized Droplet, although larger Droplets will allow you to run larger applications. Info Please disable IPv6 . There are known issues with IPv6 on DigitalOcean and Docker. If you would like to run Dokku on an IPv6 DigitalOcean Droplet, please consult this guide . Login to your DigitalOcean account. Click Create a Droplet . Under Choose an image > Marketplace , search latest Dokku release for Ubuntu 20.04 (version numbers may vary) . Under Choose a size , select your machine spec. Under Choose a datacenter region , select your region. Add an SSH Key. New Keys Under Add your SSH keys click New SSH Key (this opens a dialog) . From your terminal, execute cat $HOME/.ssh/id_rsa.pub . Copy the output and paste it into the New SSH Key dialog, provide a name and click Add SSH Key . Existing Keys Simply add a checkmark next to the existing keys you'd like to add. Under Finalize and create , give your Droplet a hostname (not required) and click Create . Once created, copy the IP address to your clipboard. In a browser, go to the IP address you copied above and fill out the presented form to complete configuration. Failure to do so may allow others to reconfigure SSH access on your server. Once the web UI has been submitted, you will be redirected to our application deployment tutorial , which will guide you through deploying a sample application to your Dokku server.","title":"DigitalOcean Droplet Installation Notes"},{"location":"getting-started/install/docker/","text":"Docker Installation Notes Pull the dokku/dokku image: docker pull dokku/dokku:0.28.4 Next, run the image. docker container run \\ --env DOKKU_HOSTNAME = dokku.me \\ --env DOKKU_HOST_ROOT = /var/lib/dokku/home/dokku \\ --name dokku \\ --publish 3022 :22 \\ --publish 8080 :80 \\ --publish 8443 :443 \\ --volume /var/lib/dokku:/mnt/dokku \\ --volume /var/run/docker.sock:/var/run/docker.sock \\ dokku/dokku:0.28.4 The above command will start a new docker container that is ready when a message similar to Runit started as PID 12345 appears. Dokku is run in the following configuration: The global hostname is set to dokku.me on boot. The container name is dokku. Container SSH port 22 is exposed on the host as 3022. Container HTTP port 80 is exposed on the host as 8080. Container HTTPS port 443 is exposed on the host as 8443. Data within the container is stored on the host within the /var/lib/dokku directory. Image build cache is set to the data dir + /home/dokku . The docker socket is mounted into container. Application repositories, plugin config, as well as plugin data are persisted to disk within the specified host directory for /var/lib/dokku . Other docker container options can also be used when running Dokku, though the specific outcome will depend upon the specified options. For example, the Dokku container's nginx port can be bound to a specific host ip by specifying --publish $HOST_IP:8080:80 , where $HOST_IP is the IP desired. Please see the docker container run documentation for further explanation for various docker arguments. Plugin Installation To install custom plugins, create a plugin-list file in the host's /var/lib/dokku directory. The plugins listed herein will be automatically installed by Dokku on container boot. This file should be the following format: plugin_name : repository_url An example for installing the postgres and redis plugins follows: postgres : https://github.com/dokku/dokku-postgres.git redis : https://github.com/dokku/dokku-redis.git SSH Key Management To initialize ssh-keys within the container, use docker exec to enter the container and run the appropriate ssh-keys commands. docker exec -it dokku bash Please see the user management documentation for more information. Pushing Applications When exposing the Dokku container's SSH port (22) on 3022, something similar to the following will need to be setup within the user's ~/.ssh/config : Host dokku.docker HostName 127.0.0.1 Port 3022 In the above example, the hostname 127.0.0.1 is being aliased to dokku.docker , while the port is being overriden to 3022 . All SSH commands - including git pushes - for the hostname dokku.docker will be transparently sent to 127.0.0.1:3022 .","title":"Docker Installation Notes"},{"location":"getting-started/install/docker/#docker-installation-notes","text":"Pull the dokku/dokku image: docker pull dokku/dokku:0.28.4 Next, run the image. docker container run \\ --env DOKKU_HOSTNAME = dokku.me \\ --env DOKKU_HOST_ROOT = /var/lib/dokku/home/dokku \\ --name dokku \\ --publish 3022 :22 \\ --publish 8080 :80 \\ --publish 8443 :443 \\ --volume /var/lib/dokku:/mnt/dokku \\ --volume /var/run/docker.sock:/var/run/docker.sock \\ dokku/dokku:0.28.4 The above command will start a new docker container that is ready when a message similar to Runit started as PID 12345 appears. Dokku is run in the following configuration: The global hostname is set to dokku.me on boot. The container name is dokku. Container SSH port 22 is exposed on the host as 3022. Container HTTP port 80 is exposed on the host as 8080. Container HTTPS port 443 is exposed on the host as 8443. Data within the container is stored on the host within the /var/lib/dokku directory. Image build cache is set to the data dir + /home/dokku . The docker socket is mounted into container. Application repositories, plugin config, as well as plugin data are persisted to disk within the specified host directory for /var/lib/dokku . Other docker container options can also be used when running Dokku, though the specific outcome will depend upon the specified options. For example, the Dokku container's nginx port can be bound to a specific host ip by specifying --publish $HOST_IP:8080:80 , where $HOST_IP is the IP desired. Please see the docker container run documentation for further explanation for various docker arguments.","title":"Docker Installation Notes"},{"location":"getting-started/install/docker/#plugin-installation","text":"To install custom plugins, create a plugin-list file in the host's /var/lib/dokku directory. The plugins listed herein will be automatically installed by Dokku on container boot. This file should be the following format: plugin_name : repository_url An example for installing the postgres and redis plugins follows: postgres : https://github.com/dokku/dokku-postgres.git redis : https://github.com/dokku/dokku-redis.git","title":"Plugin Installation"},{"location":"getting-started/install/docker/#ssh-key-management","text":"To initialize ssh-keys within the container, use docker exec to enter the container and run the appropriate ssh-keys commands. docker exec -it dokku bash Please see the user management documentation for more information.","title":"SSH Key Management"},{"location":"getting-started/install/docker/#pushing-applications","text":"When exposing the Dokku container's SSH port (22) on 3022, something similar to the following will need to be setup within the user's ~/.ssh/config : Host dokku.docker HostName 127.0.0.1 Port 3022 In the above example, the hostname 127.0.0.1 is being aliased to dokku.docker , while the port is being overriden to 3022 . All SSH commands - including git pushes - for the hostname dokku.docker will be transparently sent to 127.0.0.1:3022 .","title":"Pushing Applications"},{"location":"getting-started/install/dreamhost/","text":"DreamHost Cloud Server Installation Notes Cloud-init script can be used to automate installation of Dokku on Dreamhost (or any other OpenStack-compatible cloud with minimal changes). A new server instance can be created on DreamHost Cloud from the command line using OpenStack client or from the web UI and with the same command use a cloud-init script to install Dokku. Install the OpenStack CLI , download the DreamHost Cloud credentials file before proceeding and make sure your public SSH key is added to the cloud. source openrc.sh # Set the environment variables for DreamHost Cloud This allows OpenStack client to connect to DreamHost API endpoints. The command below creates a new server instance named my-dokku-instance based on Ubuntu 18.04, with 2 GB RAM and 1 CPU (the flavor called supersonic ), opening network port access to HTTP and SSH (the default security group), and the name of the chosen SSH key. This key will be automatically added to the new server in the authorized_keys for the default SSH user ( ubuntu ), and it will be reused by Dokku. openstack server create \\ --image Ubuntu-18.04 \\ --flavor gp1.supersonic \\ --security-group default \\ --key-name $YOUR_SSH_KEYNAME \\ --user-data dokku-cloudinit.sh \\ my-dokku-instance The content of dokku-cloudinit.sh script contains instructions to add Docker and Dokku's apt repositories and install Dokku with the proper debconf options set. Don't forget to add the FQDN for your application server: #cloud-config apt : sources : source_dokku : source : 'deb https://packagecloud.io/dokku/dokku/ubuntu/ $RELEASE main' key : | -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.11 (GNU/Linux) mQINBFu7hksBEADJfS1wB4JJmVcJ3FYoY/F3DmEsg2/NSj/TleB7hkdFPGTaOEef c6SrK6bkQas8CzCZXskg3FFUFyxJwP0yQFosJ7nQCXbuaCzkGyOaob/2D4lqniKu lyFvZuN0Evh2SoJYB6Idiy3rG58/KMQxJ/73HjcrOPxwpcfIE+rfey0fo6HOcSz7 AS3pXMbe0VoVOt8107i9qg6PizpaPugbSOP98aq2o0sPkjvKVzPsBvXWe9lDTreI X+00Z6WXjcDxmKTGvCkcJ6jk0L5r66Y6TNlJeYwFb0o7PbY7YeJSEJxw9eNozZpY EYvHCzHvsv7c8s+s5MeHDvvF5qsvt5qPPfw3zwLT01g1YTQpZdSDKn72YhrQUGJM j/W8ro8Ij9BYhYQMIdy+RPNQrBdKjj75kW1NLCGLlE89+6PYzlQwDFLdl9eZlUdM rvxbDPM99MRBBq30xfIS6YctHr40mEqZEi6OUoImaj5bbA1H3XHVH2JsWo1ttQYo 5qOGGhNi7/nyI9zxVo9r97lgGLztyl6ILZt8kxnWIx1QnPmSMuUNqYfuUuKAPs1q +bisBLvylnFvQSqnpEuPwUS1UDby4CzVBzshTsuykCQRiwdU9tcjzZUlKKKTRLhj CZCNxv1Ovgl+3m/4R5L7YOBYGCmVW0/GvlrxPLGCjZa1O8/3nih5+cv5TwARAQAB tGhodHRwczovL3BhY2thZ2VjbG91ZC5pby9kb2trdS9kb2trdSAoaHR0cHM6Ly9w YWNrYWdlY2xvdWQuaW8vZG9jcyNncGdfc2lnbmluZykgPHN1cHBvcnRAcGFja2Fn ZWNsb3VkLmlvPokCOAQTAQIAIgUCW7uGSwIbLwYLCQgHAwIGFQgCCQoLBBYCAwEC HgECF4AACgkQ8f9oUSiLMxUN3Q/+LeoFr8p3zSp9tRcCuMXfbc7rnJ/UgJiO53jW 8LsXH1h5dWeh2H5VqzGjDJ3SORisAWdOMu1SWkw4mvBZQQL12iwAMZmIDmbWU73c PplwGUQ4sltNxtiAVdntWC1vwSceY6/AQZwE2k60RYzg5bR2KAyZR9yGssGsekFO zOuMiTswzEYoZaJla+cduAXZzGf8NZgbzhXKhyfjVodRTyNR0dhoeMwNBlH0WWzW owwNOaJQ1LwDUkjrfRpkT53RJ5olRYa5ONDxuZEvmFy57bqXJh5U13m9FNWEtmF2 NySFltZYEL6BZQn5qehF4kqqJ0JSVsHEyEC7sU9yr93khTGjWQfcGaITZXPNyXTC py/J1TeOEOz2VyvglPx/JL4dTfPg5uZCTWRXzLJDAbW26BcyFI4OyPjFly6FLj0o nMUuEzdCmNpHCKWkeyXajxtYd4EMo+UHGYC7jrpsAxRib0pdHUwnOG0MeNIUtPm/ yW8i5St9PnX2y2qSaAoVURAI3irApn4Wc+hgRjo22l/B6ZudMAtASD5Ie8pXHNS0 dlsgiv3sTZachMKU+usoIgejIb0MuBhBwVJ93A4YguEqNgZg0Cz4MUpWNma6zLIN Ko+3khp3z2Y/jWfNTKs41sz++png1iqjnvXjGIjKtgcFJyH+AwZzkh5LjRiahM/I OO/xTaO5Ag0EW7uGSwEQAL39qC95IFVNobRvecddeL26kHPgd0JS4fjB5r01pMFR 3fojnEwGTLzRJVR4iTfzOiAG1XKGYmEb15NkEgEcvaLaojSsaaAHv++BqL2qXHJa sfsgjKqxCAKyJps5wCEIzF1xfxHB/5BIyKenXZw9K/zlZzsfqzyehLAarZ4oMQEN u/dG3TlXCf/oSBHDttLTcRTGs1I8FEaA9O0ZeV+2S/WuT0kFa6s1tRUMMWHWzMmR 2a+vLCE3OMWtlRk6sfhfccf4rIzjj3xyieEGKznkOycu8JOqTBRmGMl3wRS2XI7c PFiV1MGRV5uhJ6a0D6DDAddL13TaXMfsZB0KkFHh8bKvAxJA9opHhl+X2NrdwsLz crCWF+QdoPX494j2aWnwSOXXtW9c2b6cpDfUoGVD79IYEzL0n6dgBPwCKLcmxotF Tv+H3Yy0DBn8BaQ0ZHbEgudwr73vxMgbYStGfu/bQEulcLA0vfTRGBRhzlZLE8k6 +fXK23R4T/3kdyJovHdnK6aIN6oFTnVM5pyLrxmUkLCaPEbnoxVtA9zOeiGhqjYT pLgZMG95HgoscBlOh8BpuM2E3MSPV6XYjEKtvDpWy/i/oCPhd/PcY/qVxzj6dANU gQE/8hdf6Q//SvUxZaVrVwnmWkIZshGDJj/EM8VGhKzEoZF8Xmr/aibyN3CLoSMl ABEBAAGJBD4EGAECAAkFAlu7hksCGy4CKQkQ8f9oUSiLMxXBXSAEGQECAAYFAlu7 hksACgkQ+ytqpCHNGT+1Vg//Z0ZiIoQQCLXmbAPdA79HVLCzsvkKQ3/RlqIR7Nq1 JzgqPxg8drRo5+Ri+VrsIJt3AYH/lGm1UuSeycM6NrNWBpqL5FLjrMmbILQp9GMf bCZLXocOwDvrfpdBuEK+AS8SuLeiZtl8DcOe9Xtv3LSxXre0hsiIZpTRIjP+qkj8 W7oZqUxwo1Wcnff+0snf6hPiTps/IB1utzSjxXVe86/89BWvLt/mT1o81h5mclgk l1eit6BvZsO/iicLB5KbyA7DVjAnxngze0+cCUAIVbqQbZhAVw5oZbKeXedbGuxr eRLWx+h5IBbtn+JwWngzueHyc3fY5b6ann06f6y6BF5+XmPRIXakYh4moJxSRQCA GVKGEubH/Y1Vyq8QIX7V6PGpS39mQkoYXEztvEtyZiV3J+SyObYZVTs9d5/rhoE2 wXQIFTOdyHi52K2VfT3JU7rWOw5/SWuOQyyDdWgxEJuU6bUeOViOwHVkZDzwBX3Y 1to5cgY6dNQARplEgZZjRja4uc06u2d7Bk2CfqO4LvjV5UlPm838Ga+kGzBpp86X 5JBbZz9lPGf+GY7ZcROQp6ONui8P08+7EaTVtILTE0rd5g8umOnWBo1zteMv50As jyIPW20kUuJMdz3V+TNag5aCMW7qnO4zwildlQZmL54+xQDuRXK8P5JlKml6gnK+ 4SLvUA/8CALEMqxNlb06ZJc1GCU/mcQYXfkNosHaNYpORjziDnH1LBQ7AnhIhhMy FwcuxpG9bABwQfoQE84Kx3zVU0xEoCGr549Kf5p7ZcqGwn3WzSql+qR/NcPRV9Dp tb4iSXoTUeutR1SeVn/TI2aOWez3UyIztnam+p32e4BNuyByFRmo2e8dP1RqCg6b 0KwuxDDE0k3zJCpjsWROrtBVQ9Zt9rsfG5kFxJ6Qi90uJP71f8rFDUuKmxJazDf3 g3GHEGovUrOJO5JpvCcfCyT9mfOPxUSAKGBHj8NPY84vjqGaA9qqt54D8YT57TjR 5oWd8Iwex4XFHAoj59q04KmramVgP5q8VKFrxwVOhYmK6SNmvW9dEI3Y16bu9KF7 CJnPq/mQXEI+a/G6hZgZ8eYxOV2812WcORppezALreHJeN1HogxI972G0kalKhNC p3315BKJdw/p6/j/qIob2EZOdqBsdHRKBgBVXVbaCnzgh1kKLEvJnVDio+zjEPDr lR9wQbcHRbu+ZqRSEbH0of/4rx0CdCPGKSDafviKPDXnvls85tWV/lMtNxamqYvv V0DUeTWQDmfiyWCgqXTiRA9U4ZFgFNWmirh38UmV7VtSlYaRos8fEQTfmN20fqTk 9mVAREENSiAuc4P93l8TtrN1bAqXaTX5oz+lepqWmHWvY+RiNiw= =laU4 -----END PGP PUBLIC KEY BLOCK----- source_docker : source : 'deb [arch=amd64] https://download.docker.com/linux/ubuntu $RELEASE stable' key : | -----BEGIN PGP PUBLIC KEY BLOCK----- mQINBFit2ioBEADhWpZ8/wvZ6hUTiXOwQHXMAlaFHcPH9hAtr4F1y2+OYdbtMuth lqqwp028AqyY+PRfVMtSYMbjuQuu5byyKR01BbqYhuS3jtqQmljZ/bJvXqnmiVXh 38UuLa+z077PxyxQhu5BbqntTPQMfiyqEiU+BKbq2WmANUKQf+1AmZY/IruOXbnq L4C1+gJ8vfmXQt99npCaxEjaNRVYfOS8QcixNzHUYnb6emjlANyEVlZzeqo7XKl7 UrwV5inawTSzWNvtjEjj4nJL8NsLwscpLPQUhTQ+7BbQXAwAmeHCUTQIvvWXqw0N cmhh4HgeQscQHYgOJjjDVfoY5MucvglbIgCqfzAHW9jxmRL4qbMZj+b1XoePEtht ku4bIQN1X5P07fNWzlgaRL5Z4POXDDZTlIQ/El58j9kp4bnWRCJW0lya+f8ocodo vZZ+Doi+fy4D5ZGrL4XEcIQP/Lv5uFyf+kQtl/94VFYVJOleAv8W92KdgDkhTcTD G7c0tIkVEKNUq48b3aQ64NOZQW7fVjfoKwEZdOqPE72Pa45jrZzvUFxSpdiNk2tZ XYukHjlxxEgBdC/J3cMMNRE1F4NCA3ApfV1Y7/hTeOnmDuDYwr9/obA8t016Yljj q5rdkywPf4JF8mXUW5eCN1vAFHxeg9ZWemhBtQmGxXnw9M+z6hWwc6ahmwARAQAB tCtEb2NrZXIgUmVsZWFzZSAoQ0UgZGViKSA8ZG9ja2VyQGRvY2tlci5jb20+iQI3 BBMBCgAhBQJYrefAAhsvBQsJCAcDBRUKCQgLBRYCAwEAAh4BAheAAAoJEI2BgDwO v82IsskP/iQZo68flDQmNvn8X5XTd6RRaUH33kXYXquT6NkHJciS7E2gTJmqvMqd tI4mNYHCSEYxI5qrcYV5YqX9P6+Ko+vozo4nseUQLPH/ATQ4qL0Zok+1jkag3Lgk jonyUf9bwtWxFp05HC3GMHPhhcUSexCxQLQvnFWXD2sWLKivHp2fT8QbRGeZ+d3m 6fqcd5Fu7pxsqm0EUDK5NL+nPIgYhN+auTrhgzhK1CShfGccM/wfRlei9Utz6p9P XRKIlWnXtT4qNGZNTN0tR+NLG/6Bqd8OYBaFAUcue/w1VW6JQ2VGYZHnZu9S8LMc FYBa5Ig9PxwGQOgq6RDKDbV+PqTQT5EFMeR1mrjckk4DQJjbxeMZbiNMG5kGECA8 g383P3elhn03WGbEEa4MNc3Z4+7c236QI3xWJfNPdUbXRaAwhy/6rTSFbzwKB0Jm ebwzQfwjQY6f55MiI/RqDCyuPj3r3jyVRkK86pQKBAJwFHyqj9KaKXMZjfVnowLh 9svIGfNbGHpucATqREvUHuQbNnqkCx8VVhtYkhDb9fEP2xBu5VvHbR+3nfVhMut5 G34Ct5RS7Jt6LIfFdtcn8CaSas/l1HbiGeRgc70X/9aYx/V/CEJv0lIe8gP6uDoW FPIZ7d6vH+Vro6xuWEGiuMaiznap2KhZmpkgfupyFmplh0s6knymuQINBFit2ioB EADneL9S9m4vhU3blaRjVUUyJ7b/qTjcSylvCH5XUE6R2k+ckEZjfAMZPLpO+/tF M2JIJMD4SifKuS3xck9KtZGCufGmcwiLQRzeHF7vJUKrLD5RTkNi23ydvWZgPjtx Q+DTT1Zcn7BrQFY6FgnRoUVIxwtdw1bMY/89rsFgS5wwuMESd3Q2RYgb7EOFOpnu w6da7WakWf4IhnF5nsNYGDVaIHzpiqCl+uTbf1epCjrOlIzkZ3Z3Yk5CM/TiFzPk z2lLz89cpD8U+NtCsfagWWfjd2U3jDapgH+7nQnCEWpROtzaKHG6lA3pXdix5zG8 eRc6/0IbUSWvfjKxLLPfNeCS2pCL3IeEI5nothEEYdQH6szpLog79xB9dVnJyKJb VfxXnseoYqVrRz2VVbUI5Blwm6B40E3eGVfUQWiux54DspyVMMk41Mx7QJ3iynIa 1N4ZAqVMAEruyXTRTxc9XW0tYhDMA/1GYvz0EmFpm8LzTHA6sFVtPm/ZlNCX6P1X zJwrv7DSQKD6GGlBQUX+OeEJ8tTkkf8QTJSPUdh8P8YxDFS5EOGAvhhpMBYD42kQ pqXjEC+XcycTvGI7impgv9PDY1RCC1zkBjKPa120rNhv/hkVk/YhuGoajoHyy4h7 ZQopdcMtpN2dgmhEegny9JCSwxfQmQ0zK0g7m6SHiKMwjwARAQABiQQ+BBgBCAAJ BQJYrdoqAhsCAikJEI2BgDwOv82IwV0gBBkBCAAGBQJYrdoqAAoJEH6gqcPyc/zY 1WAP/2wJ+R0gE6qsce3rjaIz58PJmc8goKrir5hnElWhPgbq7cYIsW5qiFyLhkdp YcMmhD9mRiPpQn6Ya2w3e3B8zfIVKipbMBnke/ytZ9M7qHmDCcjoiSmwEXN3wKYI mD9VHONsl/CG1rU9Isw1jtB5g1YxuBA7M/m36XN6x2u+NtNMDB9P56yc4gfsZVES KA9v+yY2/l45L8d/WUkUi0YXomn6hyBGI7JrBLq0CX37GEYP6O9rrKipfz73XfO7 JIGzOKZlljb/D9RX/g7nRbCn+3EtH7xnk+TK/50euEKw8SMUg147sJTcpQmv6UzZ cM4JgL0HbHVCojV4C/plELwMddALOFeYQzTif6sMRPf+3DSj8frbInjChC3yOLy0 6br92KFom17EIj2CAcoeq7UPhi2oouYBwPxh5ytdehJkoo+sN7RIWua6P2WSmon5 U888cSylXC0+ADFdgLX9K2zrDVYUG1vo8CX0vzxFBaHwN6Px26fhIT1/hYUHQR1z VfNDcyQmXqkOnZvvoMfz/Q0s9BhFJ/zU6AgQbIZE/hm1spsfgvtsD1frZfygXJ9f irP+MSAI80xHSf91qSRZOj4Pl3ZJNbq4yYxv0b1pkMqeGdjdCYhLU+LZ4wbQmpCk SVe2prlLureigXtmZfkqevRz7FrIZiu9ky8wnCAPwC7/zmS18rgP/17bOtL4/iIz QhxAAoAMWVrGyJivSkjhSGx1uCojsWfsTAm11P7jsruIL61ZzMUVE2aM3Pmj5G+W 9AcZ58Em+1WsVnAXdUR//bMmhyr8wL/G1YO1V3JEJTRdxsSxdYa4deGBBY/Adpsw 24jxhOJR+lsJpqIUeb999+R8euDhRHG9eFO7DRu6weatUJ6suupoDTRWtr/4yGqe dKxV3qQhNLSnaAzqW/1nA3iUB4k7kCaKZxhdhDbClf9P37qaRW467BLCVO/coL3y Vm50dwdrNtKpMBh3ZpbB1uJvgi9mXtyBOMJ3v8RZeDzFiG8HdCtg9RvIt/AIFoHR H3S+U79NT6i0KPzLImDfs8T7RlpyuMc4Ufs8ggyg9v3Ae6cN3eQyxcK3w0cbBwsh /nQNfsA6uu+9H7NhbehBMhYnpNZyrHzCmzyXkauwRAqoCbGCNykTRwsur9gS41TQ M8ssD1jFheOJf3hODnkKU+HKjvMROl1DK7zdmLdNzA1cvtZH/nCC9KPj1z8QC47S xx+dTZSx4ONAhwbS/LN3PoKtn8LPjY9NP9uDWI+TWYquS2U+KHDrBDlsgozDbs/O jCxcpDzNmXpWQHEtHU7649OXHP7UeNST1mCUCH5qdank0V1iejF6/CfTFU4MfcrG YT90qFF93M3v01BbxP+EIY2/9tiIPbrd =0YYh -----END PGP PUBLIC KEY BLOCK----- debconf_selections : vhost : dokku dokku/vhost_enable boolean true # set the domain name of the new Dokku server hostname : dokku dokku/hostname string $YOUR_FULL_QUALIFIED_DOMAIN # this copies over the public SSH key assigned to the server key : dokku dokku/key_file string /home/ubuntu/.ssh/authorized_keys packages : - dokku package_update : true package_upgrade : true package_reboot_if_required : true Shortly after running the create command you will get a confirmation that the instance has been created, and after about a minute it should be ready to login. Check the IP of the instance through the web UI or by running: nova list SSH with the ubuntu username and the public key previously added. Keep in mind that if you logged in quick enough Dokku might still be installing in the background, and not be ready. The installation takes a few minutes.","title":"DreamHost Cloud Server Installation Notes"},{"location":"getting-started/install/dreamhost/#dreamhost-cloud-server-installation-notes","text":"Cloud-init script can be used to automate installation of Dokku on Dreamhost (or any other OpenStack-compatible cloud with minimal changes). A new server instance can be created on DreamHost Cloud from the command line using OpenStack client or from the web UI and with the same command use a cloud-init script to install Dokku. Install the OpenStack CLI , download the DreamHost Cloud credentials file before proceeding and make sure your public SSH key is added to the cloud. source openrc.sh # Set the environment variables for DreamHost Cloud This allows OpenStack client to connect to DreamHost API endpoints. The command below creates a new server instance named my-dokku-instance based on Ubuntu 18.04, with 2 GB RAM and 1 CPU (the flavor called supersonic ), opening network port access to HTTP and SSH (the default security group), and the name of the chosen SSH key. This key will be automatically added to the new server in the authorized_keys for the default SSH user ( ubuntu ), and it will be reused by Dokku. openstack server create \\ --image Ubuntu-18.04 \\ --flavor gp1.supersonic \\ --security-group default \\ --key-name $YOUR_SSH_KEYNAME \\ --user-data dokku-cloudinit.sh \\ my-dokku-instance The content of dokku-cloudinit.sh script contains instructions to add Docker and Dokku's apt repositories and install Dokku with the proper debconf options set. Don't forget to add the FQDN for your application server: #cloud-config apt : sources : source_dokku : source : 'deb https://packagecloud.io/dokku/dokku/ubuntu/ $RELEASE main' key : | -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.11 (GNU/Linux) mQINBFu7hksBEADJfS1wB4JJmVcJ3FYoY/F3DmEsg2/NSj/TleB7hkdFPGTaOEef c6SrK6bkQas8CzCZXskg3FFUFyxJwP0yQFosJ7nQCXbuaCzkGyOaob/2D4lqniKu lyFvZuN0Evh2SoJYB6Idiy3rG58/KMQxJ/73HjcrOPxwpcfIE+rfey0fo6HOcSz7 AS3pXMbe0VoVOt8107i9qg6PizpaPugbSOP98aq2o0sPkjvKVzPsBvXWe9lDTreI X+00Z6WXjcDxmKTGvCkcJ6jk0L5r66Y6TNlJeYwFb0o7PbY7YeJSEJxw9eNozZpY EYvHCzHvsv7c8s+s5MeHDvvF5qsvt5qPPfw3zwLT01g1YTQpZdSDKn72YhrQUGJM j/W8ro8Ij9BYhYQMIdy+RPNQrBdKjj75kW1NLCGLlE89+6PYzlQwDFLdl9eZlUdM rvxbDPM99MRBBq30xfIS6YctHr40mEqZEi6OUoImaj5bbA1H3XHVH2JsWo1ttQYo 5qOGGhNi7/nyI9zxVo9r97lgGLztyl6ILZt8kxnWIx1QnPmSMuUNqYfuUuKAPs1q +bisBLvylnFvQSqnpEuPwUS1UDby4CzVBzshTsuykCQRiwdU9tcjzZUlKKKTRLhj CZCNxv1Ovgl+3m/4R5L7YOBYGCmVW0/GvlrxPLGCjZa1O8/3nih5+cv5TwARAQAB tGhodHRwczovL3BhY2thZ2VjbG91ZC5pby9kb2trdS9kb2trdSAoaHR0cHM6Ly9w YWNrYWdlY2xvdWQuaW8vZG9jcyNncGdfc2lnbmluZykgPHN1cHBvcnRAcGFja2Fn ZWNsb3VkLmlvPokCOAQTAQIAIgUCW7uGSwIbLwYLCQgHAwIGFQgCCQoLBBYCAwEC HgECF4AACgkQ8f9oUSiLMxUN3Q/+LeoFr8p3zSp9tRcCuMXfbc7rnJ/UgJiO53jW 8LsXH1h5dWeh2H5VqzGjDJ3SORisAWdOMu1SWkw4mvBZQQL12iwAMZmIDmbWU73c PplwGUQ4sltNxtiAVdntWC1vwSceY6/AQZwE2k60RYzg5bR2KAyZR9yGssGsekFO zOuMiTswzEYoZaJla+cduAXZzGf8NZgbzhXKhyfjVodRTyNR0dhoeMwNBlH0WWzW owwNOaJQ1LwDUkjrfRpkT53RJ5olRYa5ONDxuZEvmFy57bqXJh5U13m9FNWEtmF2 NySFltZYEL6BZQn5qehF4kqqJ0JSVsHEyEC7sU9yr93khTGjWQfcGaITZXPNyXTC py/J1TeOEOz2VyvglPx/JL4dTfPg5uZCTWRXzLJDAbW26BcyFI4OyPjFly6FLj0o nMUuEzdCmNpHCKWkeyXajxtYd4EMo+UHGYC7jrpsAxRib0pdHUwnOG0MeNIUtPm/ yW8i5St9PnX2y2qSaAoVURAI3irApn4Wc+hgRjo22l/B6ZudMAtASD5Ie8pXHNS0 dlsgiv3sTZachMKU+usoIgejIb0MuBhBwVJ93A4YguEqNgZg0Cz4MUpWNma6zLIN Ko+3khp3z2Y/jWfNTKs41sz++png1iqjnvXjGIjKtgcFJyH+AwZzkh5LjRiahM/I OO/xTaO5Ag0EW7uGSwEQAL39qC95IFVNobRvecddeL26kHPgd0JS4fjB5r01pMFR 3fojnEwGTLzRJVR4iTfzOiAG1XKGYmEb15NkEgEcvaLaojSsaaAHv++BqL2qXHJa sfsgjKqxCAKyJps5wCEIzF1xfxHB/5BIyKenXZw9K/zlZzsfqzyehLAarZ4oMQEN u/dG3TlXCf/oSBHDttLTcRTGs1I8FEaA9O0ZeV+2S/WuT0kFa6s1tRUMMWHWzMmR 2a+vLCE3OMWtlRk6sfhfccf4rIzjj3xyieEGKznkOycu8JOqTBRmGMl3wRS2XI7c PFiV1MGRV5uhJ6a0D6DDAddL13TaXMfsZB0KkFHh8bKvAxJA9opHhl+X2NrdwsLz crCWF+QdoPX494j2aWnwSOXXtW9c2b6cpDfUoGVD79IYEzL0n6dgBPwCKLcmxotF Tv+H3Yy0DBn8BaQ0ZHbEgudwr73vxMgbYStGfu/bQEulcLA0vfTRGBRhzlZLE8k6 +fXK23R4T/3kdyJovHdnK6aIN6oFTnVM5pyLrxmUkLCaPEbnoxVtA9zOeiGhqjYT pLgZMG95HgoscBlOh8BpuM2E3MSPV6XYjEKtvDpWy/i/oCPhd/PcY/qVxzj6dANU gQE/8hdf6Q//SvUxZaVrVwnmWkIZshGDJj/EM8VGhKzEoZF8Xmr/aibyN3CLoSMl ABEBAAGJBD4EGAECAAkFAlu7hksCGy4CKQkQ8f9oUSiLMxXBXSAEGQECAAYFAlu7 hksACgkQ+ytqpCHNGT+1Vg//Z0ZiIoQQCLXmbAPdA79HVLCzsvkKQ3/RlqIR7Nq1 JzgqPxg8drRo5+Ri+VrsIJt3AYH/lGm1UuSeycM6NrNWBpqL5FLjrMmbILQp9GMf bCZLXocOwDvrfpdBuEK+AS8SuLeiZtl8DcOe9Xtv3LSxXre0hsiIZpTRIjP+qkj8 W7oZqUxwo1Wcnff+0snf6hPiTps/IB1utzSjxXVe86/89BWvLt/mT1o81h5mclgk l1eit6BvZsO/iicLB5KbyA7DVjAnxngze0+cCUAIVbqQbZhAVw5oZbKeXedbGuxr eRLWx+h5IBbtn+JwWngzueHyc3fY5b6ann06f6y6BF5+XmPRIXakYh4moJxSRQCA GVKGEubH/Y1Vyq8QIX7V6PGpS39mQkoYXEztvEtyZiV3J+SyObYZVTs9d5/rhoE2 wXQIFTOdyHi52K2VfT3JU7rWOw5/SWuOQyyDdWgxEJuU6bUeOViOwHVkZDzwBX3Y 1to5cgY6dNQARplEgZZjRja4uc06u2d7Bk2CfqO4LvjV5UlPm838Ga+kGzBpp86X 5JBbZz9lPGf+GY7ZcROQp6ONui8P08+7EaTVtILTE0rd5g8umOnWBo1zteMv50As jyIPW20kUuJMdz3V+TNag5aCMW7qnO4zwildlQZmL54+xQDuRXK8P5JlKml6gnK+ 4SLvUA/8CALEMqxNlb06ZJc1GCU/mcQYXfkNosHaNYpORjziDnH1LBQ7AnhIhhMy FwcuxpG9bABwQfoQE84Kx3zVU0xEoCGr549Kf5p7ZcqGwn3WzSql+qR/NcPRV9Dp tb4iSXoTUeutR1SeVn/TI2aOWez3UyIztnam+p32e4BNuyByFRmo2e8dP1RqCg6b 0KwuxDDE0k3zJCpjsWROrtBVQ9Zt9rsfG5kFxJ6Qi90uJP71f8rFDUuKmxJazDf3 g3GHEGovUrOJO5JpvCcfCyT9mfOPxUSAKGBHj8NPY84vjqGaA9qqt54D8YT57TjR 5oWd8Iwex4XFHAoj59q04KmramVgP5q8VKFrxwVOhYmK6SNmvW9dEI3Y16bu9KF7 CJnPq/mQXEI+a/G6hZgZ8eYxOV2812WcORppezALreHJeN1HogxI972G0kalKhNC p3315BKJdw/p6/j/qIob2EZOdqBsdHRKBgBVXVbaCnzgh1kKLEvJnVDio+zjEPDr lR9wQbcHRbu+ZqRSEbH0of/4rx0CdCPGKSDafviKPDXnvls85tWV/lMtNxamqYvv V0DUeTWQDmfiyWCgqXTiRA9U4ZFgFNWmirh38UmV7VtSlYaRos8fEQTfmN20fqTk 9mVAREENSiAuc4P93l8TtrN1bAqXaTX5oz+lepqWmHWvY+RiNiw= =laU4 -----END PGP PUBLIC KEY BLOCK----- source_docker : source : 'deb [arch=amd64] https://download.docker.com/linux/ubuntu $RELEASE stable' key : | -----BEGIN PGP PUBLIC KEY BLOCK----- mQINBFit2ioBEADhWpZ8/wvZ6hUTiXOwQHXMAlaFHcPH9hAtr4F1y2+OYdbtMuth lqqwp028AqyY+PRfVMtSYMbjuQuu5byyKR01BbqYhuS3jtqQmljZ/bJvXqnmiVXh 38UuLa+z077PxyxQhu5BbqntTPQMfiyqEiU+BKbq2WmANUKQf+1AmZY/IruOXbnq L4C1+gJ8vfmXQt99npCaxEjaNRVYfOS8QcixNzHUYnb6emjlANyEVlZzeqo7XKl7 UrwV5inawTSzWNvtjEjj4nJL8NsLwscpLPQUhTQ+7BbQXAwAmeHCUTQIvvWXqw0N cmhh4HgeQscQHYgOJjjDVfoY5MucvglbIgCqfzAHW9jxmRL4qbMZj+b1XoePEtht ku4bIQN1X5P07fNWzlgaRL5Z4POXDDZTlIQ/El58j9kp4bnWRCJW0lya+f8ocodo vZZ+Doi+fy4D5ZGrL4XEcIQP/Lv5uFyf+kQtl/94VFYVJOleAv8W92KdgDkhTcTD G7c0tIkVEKNUq48b3aQ64NOZQW7fVjfoKwEZdOqPE72Pa45jrZzvUFxSpdiNk2tZ XYukHjlxxEgBdC/J3cMMNRE1F4NCA3ApfV1Y7/hTeOnmDuDYwr9/obA8t016Yljj q5rdkywPf4JF8mXUW5eCN1vAFHxeg9ZWemhBtQmGxXnw9M+z6hWwc6ahmwARAQAB tCtEb2NrZXIgUmVsZWFzZSAoQ0UgZGViKSA8ZG9ja2VyQGRvY2tlci5jb20+iQI3 BBMBCgAhBQJYrefAAhsvBQsJCAcDBRUKCQgLBRYCAwEAAh4BAheAAAoJEI2BgDwO v82IsskP/iQZo68flDQmNvn8X5XTd6RRaUH33kXYXquT6NkHJciS7E2gTJmqvMqd tI4mNYHCSEYxI5qrcYV5YqX9P6+Ko+vozo4nseUQLPH/ATQ4qL0Zok+1jkag3Lgk jonyUf9bwtWxFp05HC3GMHPhhcUSexCxQLQvnFWXD2sWLKivHp2fT8QbRGeZ+d3m 6fqcd5Fu7pxsqm0EUDK5NL+nPIgYhN+auTrhgzhK1CShfGccM/wfRlei9Utz6p9P XRKIlWnXtT4qNGZNTN0tR+NLG/6Bqd8OYBaFAUcue/w1VW6JQ2VGYZHnZu9S8LMc FYBa5Ig9PxwGQOgq6RDKDbV+PqTQT5EFMeR1mrjckk4DQJjbxeMZbiNMG5kGECA8 g383P3elhn03WGbEEa4MNc3Z4+7c236QI3xWJfNPdUbXRaAwhy/6rTSFbzwKB0Jm ebwzQfwjQY6f55MiI/RqDCyuPj3r3jyVRkK86pQKBAJwFHyqj9KaKXMZjfVnowLh 9svIGfNbGHpucATqREvUHuQbNnqkCx8VVhtYkhDb9fEP2xBu5VvHbR+3nfVhMut5 G34Ct5RS7Jt6LIfFdtcn8CaSas/l1HbiGeRgc70X/9aYx/V/CEJv0lIe8gP6uDoW FPIZ7d6vH+Vro6xuWEGiuMaiznap2KhZmpkgfupyFmplh0s6knymuQINBFit2ioB EADneL9S9m4vhU3blaRjVUUyJ7b/qTjcSylvCH5XUE6R2k+ckEZjfAMZPLpO+/tF M2JIJMD4SifKuS3xck9KtZGCufGmcwiLQRzeHF7vJUKrLD5RTkNi23ydvWZgPjtx Q+DTT1Zcn7BrQFY6FgnRoUVIxwtdw1bMY/89rsFgS5wwuMESd3Q2RYgb7EOFOpnu w6da7WakWf4IhnF5nsNYGDVaIHzpiqCl+uTbf1epCjrOlIzkZ3Z3Yk5CM/TiFzPk z2lLz89cpD8U+NtCsfagWWfjd2U3jDapgH+7nQnCEWpROtzaKHG6lA3pXdix5zG8 eRc6/0IbUSWvfjKxLLPfNeCS2pCL3IeEI5nothEEYdQH6szpLog79xB9dVnJyKJb VfxXnseoYqVrRz2VVbUI5Blwm6B40E3eGVfUQWiux54DspyVMMk41Mx7QJ3iynIa 1N4ZAqVMAEruyXTRTxc9XW0tYhDMA/1GYvz0EmFpm8LzTHA6sFVtPm/ZlNCX6P1X zJwrv7DSQKD6GGlBQUX+OeEJ8tTkkf8QTJSPUdh8P8YxDFS5EOGAvhhpMBYD42kQ pqXjEC+XcycTvGI7impgv9PDY1RCC1zkBjKPa120rNhv/hkVk/YhuGoajoHyy4h7 ZQopdcMtpN2dgmhEegny9JCSwxfQmQ0zK0g7m6SHiKMwjwARAQABiQQ+BBgBCAAJ BQJYrdoqAhsCAikJEI2BgDwOv82IwV0gBBkBCAAGBQJYrdoqAAoJEH6gqcPyc/zY 1WAP/2wJ+R0gE6qsce3rjaIz58PJmc8goKrir5hnElWhPgbq7cYIsW5qiFyLhkdp YcMmhD9mRiPpQn6Ya2w3e3B8zfIVKipbMBnke/ytZ9M7qHmDCcjoiSmwEXN3wKYI mD9VHONsl/CG1rU9Isw1jtB5g1YxuBA7M/m36XN6x2u+NtNMDB9P56yc4gfsZVES KA9v+yY2/l45L8d/WUkUi0YXomn6hyBGI7JrBLq0CX37GEYP6O9rrKipfz73XfO7 JIGzOKZlljb/D9RX/g7nRbCn+3EtH7xnk+TK/50euEKw8SMUg147sJTcpQmv6UzZ cM4JgL0HbHVCojV4C/plELwMddALOFeYQzTif6sMRPf+3DSj8frbInjChC3yOLy0 6br92KFom17EIj2CAcoeq7UPhi2oouYBwPxh5ytdehJkoo+sN7RIWua6P2WSmon5 U888cSylXC0+ADFdgLX9K2zrDVYUG1vo8CX0vzxFBaHwN6Px26fhIT1/hYUHQR1z VfNDcyQmXqkOnZvvoMfz/Q0s9BhFJ/zU6AgQbIZE/hm1spsfgvtsD1frZfygXJ9f irP+MSAI80xHSf91qSRZOj4Pl3ZJNbq4yYxv0b1pkMqeGdjdCYhLU+LZ4wbQmpCk SVe2prlLureigXtmZfkqevRz7FrIZiu9ky8wnCAPwC7/zmS18rgP/17bOtL4/iIz QhxAAoAMWVrGyJivSkjhSGx1uCojsWfsTAm11P7jsruIL61ZzMUVE2aM3Pmj5G+W 9AcZ58Em+1WsVnAXdUR//bMmhyr8wL/G1YO1V3JEJTRdxsSxdYa4deGBBY/Adpsw 24jxhOJR+lsJpqIUeb999+R8euDhRHG9eFO7DRu6weatUJ6suupoDTRWtr/4yGqe dKxV3qQhNLSnaAzqW/1nA3iUB4k7kCaKZxhdhDbClf9P37qaRW467BLCVO/coL3y Vm50dwdrNtKpMBh3ZpbB1uJvgi9mXtyBOMJ3v8RZeDzFiG8HdCtg9RvIt/AIFoHR H3S+U79NT6i0KPzLImDfs8T7RlpyuMc4Ufs8ggyg9v3Ae6cN3eQyxcK3w0cbBwsh /nQNfsA6uu+9H7NhbehBMhYnpNZyrHzCmzyXkauwRAqoCbGCNykTRwsur9gS41TQ M8ssD1jFheOJf3hODnkKU+HKjvMROl1DK7zdmLdNzA1cvtZH/nCC9KPj1z8QC47S xx+dTZSx4ONAhwbS/LN3PoKtn8LPjY9NP9uDWI+TWYquS2U+KHDrBDlsgozDbs/O jCxcpDzNmXpWQHEtHU7649OXHP7UeNST1mCUCH5qdank0V1iejF6/CfTFU4MfcrG YT90qFF93M3v01BbxP+EIY2/9tiIPbrd =0YYh -----END PGP PUBLIC KEY BLOCK----- debconf_selections : vhost : dokku dokku/vhost_enable boolean true # set the domain name of the new Dokku server hostname : dokku dokku/hostname string $YOUR_FULL_QUALIFIED_DOMAIN # this copies over the public SSH key assigned to the server key : dokku dokku/key_file string /home/ubuntu/.ssh/authorized_keys packages : - dokku package_update : true package_upgrade : true package_reboot_if_required : true Shortly after running the create command you will get a confirmation that the instance has been created, and after about a minute it should be ready to login. Check the IP of the instance through the web UI or by running: nova list SSH with the ubuntu username and the public key previously added. Keep in mind that if you logged in quick enough Dokku might still be installing in the background, and not be ready. The installation takes a few minutes.","title":"DreamHost Cloud Server Installation Notes"},{"location":"getting-started/install/vagrant/","text":"Vagrant Installation Notes Download and install VirtualBox . Download and install Vagrant . Clone Dokku. git clone https://github.com/dokku/dokku.git Create VM. # Optional ENV arguments: # - `BOX_NAME` # - `BOX_URI` # - `BOX_MEMORY` # - `DOKKU_DOMAIN` # - `DOKKU_IP` # - `FORWARDED_PORT`. cd path/to/dokku # for most users vagrant up # windows users must instead use the following in an elevated command prompt vagrant up dokku-windows Setup SSH Config in ~/.ssh/config . Host dokku.me Port 22 For users that have customized the IP address of their VM - either in a custom Vagrantfile or via the DOKKU_IP environment variable - and are not using 10.0.0.2 for the Vagrant IP, you'll need to instead use the output of vagrant ssh-config dokku for your ~/.ssh/config entry. Connect to the server and add your ssh key to the install. Additionally, set the global domain name to dokku.me . # usually your key is already available under the current user's `~/.ssh/authorized_keys` file cat ~/.ssh/authorized_keys | dokku ssh-keys:add admin # you can use any domain you already have access to dokku domains:set-global dokku.me Please note, the dokku.me domain is setup to point to 10.0.0.2 along with all subdomains (i.e. yourapp.dokku.me ). If you change the DOKKU_IP in your Vagrant setup you'll need to update your /etc/hosts file to point your reconfigured IP address. You are now ready to deploy an app or install plugins.","title":"Vagrant Installation Notes"},{"location":"getting-started/install/vagrant/#vagrant-installation-notes","text":"Download and install VirtualBox . Download and install Vagrant . Clone Dokku. git clone https://github.com/dokku/dokku.git Create VM. # Optional ENV arguments: # - `BOX_NAME` # - `BOX_URI` # - `BOX_MEMORY` # - `DOKKU_DOMAIN` # - `DOKKU_IP` # - `FORWARDED_PORT`. cd path/to/dokku # for most users vagrant up # windows users must instead use the following in an elevated command prompt vagrant up dokku-windows Setup SSH Config in ~/.ssh/config . Host dokku.me Port 22 For users that have customized the IP address of their VM - either in a custom Vagrantfile or via the DOKKU_IP environment variable - and are not using 10.0.0.2 for the Vagrant IP, you'll need to instead use the output of vagrant ssh-config dokku for your ~/.ssh/config entry. Connect to the server and add your ssh key to the install. Additionally, set the global domain name to dokku.me . # usually your key is already available under the current user's `~/.ssh/authorized_keys` file cat ~/.ssh/authorized_keys | dokku ssh-keys:add admin # you can use any domain you already have access to dokku domains:set-global dokku.me Please note, the dokku.me domain is setup to point to 10.0.0.2 along with all subdomains (i.e. yourapp.dokku.me ). If you change the DOKKU_IP in your Vagrant setup you'll need to update your /etc/hosts file to point your reconfigured IP address. You are now ready to deploy an app or install plugins.","title":"Vagrant Installation Notes"},{"location":"getting-started/installation/","text":"Getting Started with Dokku What is Dokku? Dokku is an extensible, open source Platform as a Service that runs on a single server of your choice. Dokku supports building apps on the fly from a git push via either Dockerfile or by auto-detecting the language with Buildpacks, and then starts containers based on your built image. Using technologies such as nginx and cron, Web processes are automatically routed to, while background processes and automated cron tasks are also managed by Dokku. System Requirements To start using Dokku, you'll need a system that meets the following minimum requirements: A fresh installation of any of the following operating systems: Ubuntu 18.04/20.04/22.04 Debian 10+ x64 A server with one of the following architectures AMD64 (alternatively known as x86_64 ), commonly used for Intel cloud servers ARMV7 (alternatively known as armhf ), commonly used for Raspberry PI ARMV8 (alternatively known as arm64 ), commonly used for Raspberry PI and AWS Graviton To avoid memory pressure during builds or runtime of your applications, we suggest the following: At least 1 GB of system memory If your system has less than 1GB of memory, you can use this workaround . Finally, we recommend attaching at least one domain name to your server. This is not required, but using a domain name will make app access easier. When connecting a domain, either a single domain or a wildcard may be associated to the server's IP. Wildcard domain ( *.domain.tld A Record): will allow access to apps via $APP.domain.tld . Single domain ( domain.tld A or CNAME Record): will result in apps being accessed via domain.tld:$RANDOM_PORT . Please see the dns documentation and domains documentation for more details. Installing the latest stable version This is the simple method of installing Dokku. For alternative methods of installation, see the advanced install guide . 1. Install Dokku To install the latest stable version of Dokku, you can run the following shell commands: # for debian systems, installs Dokku via apt-get wget https://raw.githubusercontent.com/dokku/dokku/v0.28.4/bootstrap.sh sudo DOKKU_TAG = v0.28.4 bash bootstrap.sh The installation process takes about 5-10 minutes, depending upon internet connection speed. 2. Setup SSH key and Virtualhost Settings Once the installation is complete, you should configure an ssh key and set your global domain. # usually your key is already available under the current user's `~/.ssh/authorized_keys` file cat ~/.ssh/authorized_keys | dokku ssh-keys:add admin # you can use any domain you already have access to # this domain should have an A record or CNAME pointing at your server's IP dokku domains:set-global dokku.me # you can also use the ip of your server dokku domains:set-global 10 .0.0.2 # finally, you can use sslip.io to get subdomain support # as you would with a regular domain name # this would be done by appending `.sslip.io` to your ip address dokku domains:set-global 10 .0.0.2.sslip.io See the user management and domains documentation for more information. 3. Deploy your first application At this point, you should be able to deploy to the Dokku installation .","title":"Getting Started with Dokku"},{"location":"getting-started/installation/#getting-started-with-dokku","text":"","title":"Getting Started with Dokku"},{"location":"getting-started/installation/#what-is-dokku","text":"Dokku is an extensible, open source Platform as a Service that runs on a single server of your choice. Dokku supports building apps on the fly from a git push via either Dockerfile or by auto-detecting the language with Buildpacks, and then starts containers based on your built image. Using technologies such as nginx and cron, Web processes are automatically routed to, while background processes and automated cron tasks are also managed by Dokku.","title":"What is Dokku?"},{"location":"getting-started/installation/#system-requirements","text":"To start using Dokku, you'll need a system that meets the following minimum requirements: A fresh installation of any of the following operating systems: Ubuntu 18.04/20.04/22.04 Debian 10+ x64 A server with one of the following architectures AMD64 (alternatively known as x86_64 ), commonly used for Intel cloud servers ARMV7 (alternatively known as armhf ), commonly used for Raspberry PI ARMV8 (alternatively known as arm64 ), commonly used for Raspberry PI and AWS Graviton To avoid memory pressure during builds or runtime of your applications, we suggest the following: At least 1 GB of system memory If your system has less than 1GB of memory, you can use this workaround . Finally, we recommend attaching at least one domain name to your server. This is not required, but using a domain name will make app access easier. When connecting a domain, either a single domain or a wildcard may be associated to the server's IP. Wildcard domain ( *.domain.tld A Record): will allow access to apps via $APP.domain.tld . Single domain ( domain.tld A or CNAME Record): will result in apps being accessed via domain.tld:$RANDOM_PORT . Please see the dns documentation and domains documentation for more details.","title":"System Requirements"},{"location":"getting-started/installation/#installing-the-latest-stable-version","text":"This is the simple method of installing Dokku. For alternative methods of installation, see the advanced install guide .","title":"Installing the latest stable version"},{"location":"getting-started/installation/#1-install-dokku","text":"To install the latest stable version of Dokku, you can run the following shell commands: # for debian systems, installs Dokku via apt-get wget https://raw.githubusercontent.com/dokku/dokku/v0.28.4/bootstrap.sh sudo DOKKU_TAG = v0.28.4 bash bootstrap.sh The installation process takes about 5-10 minutes, depending upon internet connection speed.","title":"1. Install Dokku"},{"location":"getting-started/installation/#2-setup-ssh-key-and-virtualhost-settings","text":"Once the installation is complete, you should configure an ssh key and set your global domain. # usually your key is already available under the current user's `~/.ssh/authorized_keys` file cat ~/.ssh/authorized_keys | dokku ssh-keys:add admin # you can use any domain you already have access to # this domain should have an A record or CNAME pointing at your server's IP dokku domains:set-global dokku.me # you can also use the ip of your server dokku domains:set-global 10 .0.0.2 # finally, you can use sslip.io to get subdomain support # as you would with a regular domain name # this would be done by appending `.sslip.io` to your ip address dokku domains:set-global 10 .0.0.2.sslip.io See the user management and domains documentation for more information.","title":"2. Setup SSH key and Virtualhost Settings"},{"location":"getting-started/installation/#3-deploy-your-first-application","text":"At this point, you should be able to deploy to the Dokku installation .","title":"3. Deploy your first application"},{"location":"getting-started/upgrading/","text":"Upgrading If your version of Dokku is pre 0.3.0 (check with dokku version ), we recommend a fresh install on a new server. Security Updates For any security related updates, please follow our Twitter account . As Dokku does not run any daemons, the security risk introduced by our software is minimal. Your operating system may occasionally provide security updates. We recommend setting unattended upgrades for your operating system. Here are some helpful links: Arch Linux System Maintenance Debian Unattended Upgrades Ubuntu Unattended Upgrades Docker releases updates periodically to their engine. We recommend reading their release notes and upgrading accordingly. Please see the Docker documentation for more details. Migration Guides Before upgrading, check the migration guides to get comfortable with new features and prepare your deployment to be upgraded. Upgrading to 0.29 Upgrading to 0.28 Upgrading to 0.27 Upgrading to 0.26 Upgrading to 0.25 Upgrading to 0.24 Upgrading to 0.23 Upgrading to 0.22 Upgrading to 0.21 Upgrading to 0.20 Upgrading to 0.10 Upgrading to 0.9 Upgrading to 0.8 Upgrading to 0.7 Upgrading to 0.6 Upgrading to 0.5 Before upgrading If you'll be updating docker or the herokuish package simultaneously, it's recommended that you stop all applications before upgrading and rebuild afterwards. This is not required if the upgrade only impacts the dokku package. Why do we recommend stopping all apps? docker : Containers may be randomly reset during the upgrade process, resulting in requests being sent to the wrong containers. Acknowledging and scheduling downtime thus becomes much more important. herokuish : While not required, it may be useful to take advantage of the latest base image. Herokuish changes do not cause issues unless the base OS changes, which may happen in minor or major releases. # for 0.22.0 and newer versions, use dokku ps:stop --all # for versions between 0.11.4 and 0.21.4, use dokku ps:stopall # for versions between 0.8.1 and 0.11.3, use dokku --quiet apps:list | xargs -L1 dokku ps:stop # for versions versions older than 0.8.1, use dokku --quiet apps | xargs -L1 dokku ps:stop After upgrading After upgrading, you should rebuild the applications to take advantage of any new buildpacks that were released: dokku ps:rebuild --all Upgrading using dokku-update We provide a helpful binary called dokku-update . This is a recommended package that: Can be installed separately, so upgrading Dokku will not affect the running of this package. Automates many of the upgrade instructions for you. Provides a clean way for us to further enhance the upgrade process in the future. This binary is available on Debian and RPM-based systems from our package repositories under the name dokku-update . When installing from source, this is available from a separate Github repository at dokku/dokku-update . Upgrading using apt If Dokku was installed in a Debian or Ubuntu system, via apt-get install dokku or bootstrap.sh , you can upgrade with apt-get : # update your local apt cache sudo apt-get update -qq # update dokku and its dependencies sudo apt-get -qq -y --no-install-recommends install dokku herokuish sshcommand plugn gliderlabs-sigil dokku-update dokku-event-listener # or just upgrade every package: sudo apt-get upgrade Upgrading from source If you installed Dokku from source (less common), upgrade with: cd ~/dokku git pull --tags origin master # continue to install from source sudo DOKKU_BRANCH = master make install # upgrade to debian package-based installation sudo make install To upgrade Herokuish from source, upgrade with: cd /tmp git clone https://github.com/gliderlabs/herokuish.git cd herokuish CIRCLECI = true IMAGE_NAME = gliderlabs/herokuish BUILD_TAG = latest make build/docker","title":"Upgrading"},{"location":"getting-started/upgrading/#upgrading","text":"If your version of Dokku is pre 0.3.0 (check with dokku version ), we recommend a fresh install on a new server.","title":"Upgrading"},{"location":"getting-started/upgrading/#security-updates","text":"For any security related updates, please follow our Twitter account . As Dokku does not run any daemons, the security risk introduced by our software is minimal. Your operating system may occasionally provide security updates. We recommend setting unattended upgrades for your operating system. Here are some helpful links: Arch Linux System Maintenance Debian Unattended Upgrades Ubuntu Unattended Upgrades Docker releases updates periodically to their engine. We recommend reading their release notes and upgrading accordingly. Please see the Docker documentation for more details.","title":"Security Updates"},{"location":"getting-started/upgrading/#migration-guides","text":"Before upgrading, check the migration guides to get comfortable with new features and prepare your deployment to be upgraded. Upgrading to 0.29 Upgrading to 0.28 Upgrading to 0.27 Upgrading to 0.26 Upgrading to 0.25 Upgrading to 0.24 Upgrading to 0.23 Upgrading to 0.22 Upgrading to 0.21 Upgrading to 0.20 Upgrading to 0.10 Upgrading to 0.9 Upgrading to 0.8 Upgrading to 0.7 Upgrading to 0.6 Upgrading to 0.5","title":"Migration Guides"},{"location":"getting-started/upgrading/#before-upgrading","text":"If you'll be updating docker or the herokuish package simultaneously, it's recommended that you stop all applications before upgrading and rebuild afterwards. This is not required if the upgrade only impacts the dokku package. Why do we recommend stopping all apps? docker : Containers may be randomly reset during the upgrade process, resulting in requests being sent to the wrong containers. Acknowledging and scheduling downtime thus becomes much more important. herokuish : While not required, it may be useful to take advantage of the latest base image. Herokuish changes do not cause issues unless the base OS changes, which may happen in minor or major releases. # for 0.22.0 and newer versions, use dokku ps:stop --all # for versions between 0.11.4 and 0.21.4, use dokku ps:stopall # for versions between 0.8.1 and 0.11.3, use dokku --quiet apps:list | xargs -L1 dokku ps:stop # for versions versions older than 0.8.1, use dokku --quiet apps | xargs -L1 dokku ps:stop","title":"Before upgrading"},{"location":"getting-started/upgrading/#after-upgrading","text":"After upgrading, you should rebuild the applications to take advantage of any new buildpacks that were released: dokku ps:rebuild --all","title":"After upgrading"},{"location":"getting-started/upgrading/#upgrading-using-dokku-update","text":"We provide a helpful binary called dokku-update . This is a recommended package that: Can be installed separately, so upgrading Dokku will not affect the running of this package. Automates many of the upgrade instructions for you. Provides a clean way for us to further enhance the upgrade process in the future. This binary is available on Debian and RPM-based systems from our package repositories under the name dokku-update . When installing from source, this is available from a separate Github repository at dokku/dokku-update .","title":"Upgrading using dokku-update"},{"location":"getting-started/upgrading/#upgrading-using-apt","text":"If Dokku was installed in a Debian or Ubuntu system, via apt-get install dokku or bootstrap.sh , you can upgrade with apt-get : # update your local apt cache sudo apt-get update -qq # update dokku and its dependencies sudo apt-get -qq -y --no-install-recommends install dokku herokuish sshcommand plugn gliderlabs-sigil dokku-update dokku-event-listener # or just upgrade every package: sudo apt-get upgrade","title":"Upgrading using apt"},{"location":"getting-started/upgrading/#upgrading-from-source","text":"If you installed Dokku from source (less common), upgrade with: cd ~/dokku git pull --tags origin master # continue to install from source sudo DOKKU_BRANCH = master make install # upgrade to debian package-based installation sudo make install To upgrade Herokuish from source, upgrade with: cd /tmp git clone https://github.com/gliderlabs/herokuish.git cd herokuish CIRCLECI = true IMAGE_NAME = gliderlabs/herokuish BUILD_TAG = latest make build/docker","title":"Upgrading from source"},{"location":"networking/dns/","text":"DNS Configuration Note This is a work in progress. DNS Versions There are many different DNS servers 'in the wild'. Some of the popular ones on Linux are BIND, dnsmasq, and pdns. Windows has its own built-in DNS server as well as Unbound, Posadis, and more. A full list of DNS packages can be found on Wikipedia under Comparison of DNS Server Software . In addition to the various DNS packages, there are tens of thousands of Managed DNS Providers out that all have different DNS interfaces. Focus Because there are so many different DNS server packages out there as well as a tremendous number of Managed DNS Providers, we will focus on the concepts of DNS as well as providing examples in the 'BIND' format so you can adapt the information to your own server package or managed DNS provider. Assumptions We assume you have a passing familiarity with DNS. If not, you can read an in-depth article on DNS. But basically you need to know that DNS changes names (like example.tld) into addresses (like 127.0.0.1) We assume you already have a domain name registered and pointed to your favorite Managed DNS Provider or have your own BIND DNS server running. You have a server on the internet and are about to follow the instructions in the README to get Dokku installed. Don't do the install just yet though. Caching Please remember that DNS relies heavily on caching . Changes you make to DNS could take anywhere from a few seconds to a few days to propagate. If you tried surfing to example.tld, then changed the IP address in DNS, it could be a while before your computer picks up on the changes. Getting started For the examples, we will use the domain name example.tld and the IP address 127.0.0.1 . Dokku uses DNS to differentiate between apps on your dokku-powered server. If you are using the domain example.tld , and you have two apps node-js-app1 and node-js-app2 , Dokku will make them available at node-js-app1.example.tld and node-js-app2.example.tld . To get started, you need to know the IP address of your Dokku server. Connect to it and run ifconfig or ip addr to see the IP address. Now you have to make a decision about your domain. Do you want everything and anything at example.tld to go to your Dokku server, or would you rather use a 'sub domain' for your Dokku server? In other words, do you want your applications on your Dokku server accessible via node-js-app.example.tld or via node-js-app.myserver.example.tld ? Using a sub-domain (node-js-app.myserver.example.tld) Using a sub-domain is easy. When you set up your server, you probably gave it a name like myserver.example.tld . Go in to your Managed DNS provider and create an A record named myserver and put in the IP address you got from your server a few moments ago. Hopefully your managed DNS provider also supports wildcards. Create a second A record named *.myserver along with the IP address you got from your server a few moments ago. If you are using BIND, your zone file will look similar to this: $ORIGIN example.tld $TTL 5m myserver IN A 127.0.0.1 *.myserver IN A 127.0.0.1 You can verify your changes in Linux by trying one or more of the following commands: host myserver.example.tld dig -t A myserver.example.tld nslookup myserver.example.tld Now is a good time to remind you that the answers you get MAY BE CACHED. If everything is working correctly, you should also be able to query for any other name under myserver.example.tld and get back the IP address of your server. Try: host test.myserver.example.tld host xyzzy.myserver.example.tld If they all return your IP address, you have set DNS up properly for dokku. You should also be able to ssh root@myserver.example.tld and access your server. Proceed with the setup instructions in the installation documentation Using the root of your domain (node-js-app.example.tld) This section is a work in progress. It is incomplete. Using the 'root' of your domain is nearly identical to the previous example. hostname is under example.tld , still needs A record. Update your global domain using the domains plugin .","title":"DNS Configuration"},{"location":"networking/dns/#dns-configuration","text":"Note This is a work in progress.","title":"DNS Configuration"},{"location":"networking/dns/#dns-versions","text":"There are many different DNS servers 'in the wild'. Some of the popular ones on Linux are BIND, dnsmasq, and pdns. Windows has its own built-in DNS server as well as Unbound, Posadis, and more. A full list of DNS packages can be found on Wikipedia under Comparison of DNS Server Software . In addition to the various DNS packages, there are tens of thousands of Managed DNS Providers out that all have different DNS interfaces.","title":"DNS Versions"},{"location":"networking/dns/#focus","text":"Because there are so many different DNS server packages out there as well as a tremendous number of Managed DNS Providers, we will focus on the concepts of DNS as well as providing examples in the 'BIND' format so you can adapt the information to your own server package or managed DNS provider.","title":"Focus"},{"location":"networking/dns/#assumptions","text":"We assume you have a passing familiarity with DNS. If not, you can read an in-depth article on DNS. But basically you need to know that DNS changes names (like example.tld) into addresses (like 127.0.0.1) We assume you already have a domain name registered and pointed to your favorite Managed DNS Provider or have your own BIND DNS server running. You have a server on the internet and are about to follow the instructions in the README to get Dokku installed. Don't do the install just yet though.","title":"Assumptions"},{"location":"networking/dns/#caching","text":"Please remember that DNS relies heavily on caching . Changes you make to DNS could take anywhere from a few seconds to a few days to propagate. If you tried surfing to example.tld, then changed the IP address in DNS, it could be a while before your computer picks up on the changes.","title":"Caching"},{"location":"networking/dns/#getting-started","text":"For the examples, we will use the domain name example.tld and the IP address 127.0.0.1 . Dokku uses DNS to differentiate between apps on your dokku-powered server. If you are using the domain example.tld , and you have two apps node-js-app1 and node-js-app2 , Dokku will make them available at node-js-app1.example.tld and node-js-app2.example.tld . To get started, you need to know the IP address of your Dokku server. Connect to it and run ifconfig or ip addr to see the IP address. Now you have to make a decision about your domain. Do you want everything and anything at example.tld to go to your Dokku server, or would you rather use a 'sub domain' for your Dokku server? In other words, do you want your applications on your Dokku server accessible via node-js-app.example.tld or via node-js-app.myserver.example.tld ?","title":"Getting started"},{"location":"networking/dns/#using-a-sub-domain-node-js-appmyserverexampletld","text":"Using a sub-domain is easy. When you set up your server, you probably gave it a name like myserver.example.tld . Go in to your Managed DNS provider and create an A record named myserver and put in the IP address you got from your server a few moments ago. Hopefully your managed DNS provider also supports wildcards. Create a second A record named *.myserver along with the IP address you got from your server a few moments ago. If you are using BIND, your zone file will look similar to this: $ORIGIN example.tld $TTL 5m myserver IN A 127.0.0.1 *.myserver IN A 127.0.0.1 You can verify your changes in Linux by trying one or more of the following commands: host myserver.example.tld dig -t A myserver.example.tld nslookup myserver.example.tld Now is a good time to remind you that the answers you get MAY BE CACHED. If everything is working correctly, you should also be able to query for any other name under myserver.example.tld and get back the IP address of your server. Try: host test.myserver.example.tld host xyzzy.myserver.example.tld If they all return your IP address, you have set DNS up properly for dokku. You should also be able to ssh root@myserver.example.tld and access your server. Proceed with the setup instructions in the installation documentation","title":"Using a sub-domain (node-js-app.myserver.example.tld)"},{"location":"networking/dns/#using-the-root-of-your-domain-node-js-appexampletld","text":"This section is a work in progress. It is incomplete. Using the 'root' of your domain is nearly identical to the previous example. hostname is under example.tld , still needs A record. Update your global domain using the domains plugin .","title":"Using the root of your domain (node-js-app.example.tld)"},{"location":"networking/network/","text":"Network Management New Introduced in 0.11.0, Enhanced in 0.20.0 network:create <network> # Creates an attachable docker network network:destroy <network> # Destroys a docker network network:exists <network> # Checks if a docker network exists network:info <network> # Outputs information about a docker network network:list # Lists all docker networks network:report [<app>] [<flag>] # Displays a network report for one or more apps network:rebuild <app> # Rebuilds network settings for an app network:rebuildall # Rebuild network settings for all apps network:set <app> <key> (<value>) # Set or clear a network property for an app The Network plugin allows developers to abstract the concept of container network management, allowing developers to both change what networks a given container is attached to as well as rebuild the configuration on the fly. Usage Listing networks New Introduced in 0.20.0, Requires Docker 1.21+ You can easily list all available networks using the network:list command: Shell Output dokku network:list =====> Networks bridge host none test-network Note that you can easily hide extra output from Dokku commands by using the --quiet flag, which makes it easier to parse on the command line. Shell Output dokku --quiet network:list bridge host none test-network Creating a network New Introduced in 0.20.0, Requires Docker 1.21+ Docker networks can be created via the network:create command. Executing this command will create an attachable bridge network. This can be used to route requests between containers without going through any public network. Shell Output dokku network:create test-network -----> Creating network test-network Specifying other additional flags or other types of networks can be created directly via the docker command. Destroying a network New Introduced in 0.20.0, Requires Docker 1.21+ A Docker network without any associated containers may be destroyed via the network:destroy command. Docker will refuse to destroy networks that have containers attached. Info test dokku network:destroy test-network ! WARNING: Potentially Destructive Action ! This command will destroy network test. ! To proceed, type \"test\" -----> Destroying network test As the command is destructive, it will default to asking for confirmation before executing the removal of the network. This may be avoided by providing the --force flag: dokku --force network:destroy test-network -----> Destroying network test Checking if a network exists New Introduced in 0.20.0, Requires Docker 1.21+ For CI/CD pipelines, it may be useful to see if an network exists before creating a new network. You can do so via the network:exists command: Shell Output dokku network:exists nonexistent-network Network does not exist The network:exists command will return non-zero if the network does not exist, and zero if it does. Checking network info New Introduced in 0.20.0, Requires Docker 1.21+ Network information can be retrieved via the network:info command. This is a slightly different version of the docker network command. Shell Output dokku network:info test-network // TODO Routing an app to a known ip:port combination New Introduced in 0.25.0 In some cases, it may be necessary to route an app to an existing $IP:$PORT combination. This is particularly the case for internal admin tools or services that aren't run by Dokku but have a web ui that would benefit from being exposed by Dokku. This can be done by setting a value for static-web-lister and running a few other commands when creating an app. # for a service listening on: # - ip address: 127.0.0.1 # - port: 8080 # create the app dokku apps:create local-app # set the builder to the null builder, which does nothing dokku builder:set local-app selected null # set the scheduler to the null scheduler, which does nothing dokku scheduler:set local-app selected null # set the static-web-listener network property to the ip:port combination for your app. dokku network:set local-app static-web-listener 127 .0.0.1:8080 # set the port map as desired for the port specified in your static-web-listener dokku proxy:ports-set local-app http:80:8080 # set the domains desired dokku domains:set local-app local-app.dokku.me dokku proxy:build-config local-app Only a single $IP:$PORT combination can be routed to for a given app, and that $IP:$PORT combination must be accessible to the proxy, or requests to the app may not resolve. Attaching an app to a network New Introduced in 0.20.0, Requires Docker 1.21+ Apps will default to being associated with the default bridge network or a network specified by the initial-network network property. Additionally, an app can be attached to attachable networks by changing the attach-post-create or attach-post-deploy network properties when using the docker-local scheduler . A change in these values will require an app deploy or rebuild. # associates the network after a container is created but before it is started dokku network:set node-js-app attach-post-create test-network # associates the network after the deploy is successful but before the proxy is updated dokku network:set node-js-app attach-post-deploy other-test-network # associates the network at container creation dokku network:set node-js-app initial-network global-network Setting the attach network property to an empty value will de-associate the container with the network. dokku network:set node-js-app attach-post-create dokku network:set node-js-app attach-post-deploy dokku network:set node-js-app initial-network The network properties can also be set globally. The global default value is an empty string, and the global value is used when no app-specific value is set. dokku network:set --global attach-post-create global-create-network dokku network:set --global attach-post-deploy global-deploy-network dokku network:set --global initial-network global-network The default value may be set by passing an empty value for the option. dokku network:set --global attach-post-create dokku network:set --global attach-post-deploy dokku network:set --global initial-network Network Aliases When a container created for a deployment is being attached to a network - regardless of which attach property was used - a network alias of the pattern APP.PROC_TYPE will be added to all containers. This can be used to load-balance requests between containers. For an application named node-js-app with a process type of web, the network alias - or resolvable DNS record within the network - will be: node-js-app.web The fully-qualified URL for the resource will depend upon the PORT being listened to by the application. Applications built via buildpacks will have their PORT environment variable set to 5000 , and as such internal network requests for the above example should point to the following: http://node-js-app.web:5000 Dockerfile-based applications may listen on other ports. For more information on how ports are specified for applications, please refer to the port management documentation . Specifying a custom TLD When attaching applications to networks, a custom TLD can be specified via the network:set command. This TLD is suffixed to the network alias for the application/process-type combination for all networks to which the application is attached, and cannot be customized per network. The default value is an empty string. To specify a TLD of svc.cluster.local for your application, run the following command: # replace node-js-app with your application name dokku network:set node-js-app tld svc.cluster.local With an application named node-js-app and a process-type named web , the above command will turn the network alias into: node-js-app.web.svc.cluster.local Note that this has no impact on container port handling, and users must still specify the container port when making internal network requests. The default value may be set by passing an empty value for the option: dokku network:set node-js-app tld The tld property can also be set globally. The global default is emty string, and the global value is used when no app-specific value is set. dokku network:set --global tld svc.cluster.local The default value may be set by passing an empty value for the option. dokku network:set --global tld When to attach containers to a network Containers can be attached to a network for a variety of reasons: A background process in one app needs to communicate to a webservice in another app An app needs to talk to a container not managed by Dokku in a secure manner A custom network that allows transparent access to another host exists and is necessary for an app to run Whatever the reason, the semantics of the two network hooks are important and are outlined before. attach-post-create : Phase it applies to: build : Intermediate containers created during the build process. deploy : Deployed app containers. run : Containers created by the run command. Container state on attach: created but not running Use case: When the container needs to access a resource on the network. Example: The app needs to talk to a database on the same network when it first boots. attach-post-deploy Phase it applies to: deploy : Deployed app containers. Container state on attach: running Use case: When another container on the network needs to access this container. Example: A background process needs to communicate with the web process exposed by this container. initial-network : Phase it applies to: build : Intermediate containers created during the build process. deploy : Deployed app containers. run : Containers created by the run command. Container state on attach: created Use case: When another container on the network is already running and needed by this container. Example: A key-value store exposing itself to all your apps may be on the initial-network . Warning If the attachment fails during the running container state, this may result in your application failing to respond to proxied requests once older containers are removed. Rebuilding network settings There are cases where you may need to rebuild the network configuration for an app, such as on app boot or container restart. In these cases, you can use the network:rebuild command: dokku network:rebuild node-js-app Info This command will exit a non-zero number that depends on the number of containers for which configuration could not be built Rebuilding all network settings In some cases, a docker upgrade may reset container IPs or Ports. In both cases, you can quickly rewrite those files by using the network:rebuildall command: dokku network:rebuildall Info This command will exit a non-zero number that depends on the number of containers for which configuration could not be built Container network interface binding Info This functionality does not control the --network docker flag. Please use the docker-options plugin to manage this flag. By default, an app will only bind to the internal interface. This behavior can be modified per app by changing the bind-all-interfaces network property. # bind to the default docker interface (`docker0`) with a random internal ip # this is the default behavior dokku network:set node-js-app bind-all-interfaces false # bind to all interfaces (`0.0.0.0`) on a random port for each upstream port # this will make the app container directly accessible by other hosts on your network # ports are randomized for every deploy, e.g. `0.0.0.0:32771->5000/tcp`. dokku network:set node-js-app bind-all-interfaces true By way of example, in the default case, each container is bound to the docker interface: Shell Output docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b88d8aec3d1 dokku/node-js-app:latest \"/bin/bash -c '/star About a minute ago Up About a minute node-js-app.web.1 As such, the container's IP address will be an internal IP, and thus it is only accessible on the host itself: docker inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' node-js-app.web.1 172.17.0.6 However, you can disable the internal proxying via the network:set command so that it will listen on the host's IP address: Shell Output dokku network:set node-js-app bind-all-interfaces true # container bound to all interfaces docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d6499edb0edb dokku/node-js-app:latest \"/bin/bash -c '/star About a minute ago Up About a minute 0.0.0.0:49153->5000/tcp node-js-app.web.1 The bind-all-interfaces property can also be set globally. The global default is false , and the global value is used when no app-specific value is set. dokku network:set --global bind-all-interfaces true The default value may be set by passing an empty value for the option. dokku network:set --global bind-all-interfaces Displaying network reports for an app You can get a report about the app's network status using the network:report command: Shell Output dokku network:report =====> node-js-app network information Network attach post create: Network attach post deploy: Network bind all interfaces: false Network computed attach post create: Network computed attach post deploy: Network computed bind all interfaces:false Network computed initial network: Network computed tld: Network global attach post create: Network global attach post deploy: Network global bind all interfaces:false Network global initial network: Network global tld: Network initial network: Network tld: Network web listeners: 172.17.0.1:5000 =====> python-sample network information Network attach post create: Network attach post deploy: Network bind all interfaces: false Network computed attach post create: Network computed attach post deploy: Network computed bind all interfaces:false Network computed initial network: Network computed tld: Network global attach post create: Network global attach post deploy: Network global bind all interfaces:false Network global initial network: Network global tld: Network initial network: Network tld: Network web listeners: 172.17.0.2:5000 =====> ruby-sample network information Network attach post create: Network attach post deploy: Network bind all interfaces: false Network computed attach post create: Network computed attach post deploy: Network computed bind all interfaces:false Network computed initial network: Network computed tld: Network global attach post create: Network global attach post deploy: Network global bind all interfaces:false Network global initial network: Network global tld: Network initial network: Network tld: Network web listeners: You can run the command for a specific app also. Shell Output dokku network:report node-js-app =====> node-js-app network information Network attach post create: Network attach post deploy: Network bind all interfaces: false Network computed attach post create: Network computed attach post deploy: Network computed bind all interfaces:false Network computed initial network: Network computed tld: Network global attach post create: Network global attach post deploy: Network global bind all interfaces:false Network global initial network: Network global tld: Network initial network: Network tld: Network web listeners: 172.17.0.1:5000 You can pass flags which will output only the value of the specific information you want. For example: dokku network:report node-js-app --network-bind-all-interfaces","title":"Network Management"},{"location":"networking/network/#network-management","text":"New Introduced in 0.11.0, Enhanced in 0.20.0 network:create <network> # Creates an attachable docker network network:destroy <network> # Destroys a docker network network:exists <network> # Checks if a docker network exists network:info <network> # Outputs information about a docker network network:list # Lists all docker networks network:report [<app>] [<flag>] # Displays a network report for one or more apps network:rebuild <app> # Rebuilds network settings for an app network:rebuildall # Rebuild network settings for all apps network:set <app> <key> (<value>) # Set or clear a network property for an app The Network plugin allows developers to abstract the concept of container network management, allowing developers to both change what networks a given container is attached to as well as rebuild the configuration on the fly.","title":"Network Management"},{"location":"networking/network/#usage","text":"","title":"Usage"},{"location":"networking/network/#listing-networks","text":"New Introduced in 0.20.0, Requires Docker 1.21+ You can easily list all available networks using the network:list command: Shell Output dokku network:list =====> Networks bridge host none test-network Note that you can easily hide extra output from Dokku commands by using the --quiet flag, which makes it easier to parse on the command line. Shell Output dokku --quiet network:list bridge host none test-network","title":"Listing networks"},{"location":"networking/network/#creating-a-network","text":"New Introduced in 0.20.0, Requires Docker 1.21+ Docker networks can be created via the network:create command. Executing this command will create an attachable bridge network. This can be used to route requests between containers without going through any public network. Shell Output dokku network:create test-network -----> Creating network test-network Specifying other additional flags or other types of networks can be created directly via the docker command.","title":"Creating a network"},{"location":"networking/network/#destroying-a-network","text":"New Introduced in 0.20.0, Requires Docker 1.21+ A Docker network without any associated containers may be destroyed via the network:destroy command. Docker will refuse to destroy networks that have containers attached. Info test dokku network:destroy test-network ! WARNING: Potentially Destructive Action ! This command will destroy network test. ! To proceed, type \"test\" -----> Destroying network test As the command is destructive, it will default to asking for confirmation before executing the removal of the network. This may be avoided by providing the --force flag: dokku --force network:destroy test-network -----> Destroying network test","title":"Destroying a network"},{"location":"networking/network/#checking-if-a-network-exists","text":"New Introduced in 0.20.0, Requires Docker 1.21+ For CI/CD pipelines, it may be useful to see if an network exists before creating a new network. You can do so via the network:exists command: Shell Output dokku network:exists nonexistent-network Network does not exist The network:exists command will return non-zero if the network does not exist, and zero if it does.","title":"Checking if a network exists"},{"location":"networking/network/#checking-network-info","text":"New Introduced in 0.20.0, Requires Docker 1.21+ Network information can be retrieved via the network:info command. This is a slightly different version of the docker network command. Shell Output dokku network:info test-network // TODO","title":"Checking network info"},{"location":"networking/network/#routing-an-app-to-a-known-ipport-combination","text":"New Introduced in 0.25.0 In some cases, it may be necessary to route an app to an existing $IP:$PORT combination. This is particularly the case for internal admin tools or services that aren't run by Dokku but have a web ui that would benefit from being exposed by Dokku. This can be done by setting a value for static-web-lister and running a few other commands when creating an app. # for a service listening on: # - ip address: 127.0.0.1 # - port: 8080 # create the app dokku apps:create local-app # set the builder to the null builder, which does nothing dokku builder:set local-app selected null # set the scheduler to the null scheduler, which does nothing dokku scheduler:set local-app selected null # set the static-web-listener network property to the ip:port combination for your app. dokku network:set local-app static-web-listener 127 .0.0.1:8080 # set the port map as desired for the port specified in your static-web-listener dokku proxy:ports-set local-app http:80:8080 # set the domains desired dokku domains:set local-app local-app.dokku.me dokku proxy:build-config local-app Only a single $IP:$PORT combination can be routed to for a given app, and that $IP:$PORT combination must be accessible to the proxy, or requests to the app may not resolve.","title":"Routing an app to a known ip:port combination"},{"location":"networking/network/#attaching-an-app-to-a-network","text":"New Introduced in 0.20.0, Requires Docker 1.21+ Apps will default to being associated with the default bridge network or a network specified by the initial-network network property. Additionally, an app can be attached to attachable networks by changing the attach-post-create or attach-post-deploy network properties when using the docker-local scheduler . A change in these values will require an app deploy or rebuild. # associates the network after a container is created but before it is started dokku network:set node-js-app attach-post-create test-network # associates the network after the deploy is successful but before the proxy is updated dokku network:set node-js-app attach-post-deploy other-test-network # associates the network at container creation dokku network:set node-js-app initial-network global-network Setting the attach network property to an empty value will de-associate the container with the network. dokku network:set node-js-app attach-post-create dokku network:set node-js-app attach-post-deploy dokku network:set node-js-app initial-network The network properties can also be set globally. The global default value is an empty string, and the global value is used when no app-specific value is set. dokku network:set --global attach-post-create global-create-network dokku network:set --global attach-post-deploy global-deploy-network dokku network:set --global initial-network global-network The default value may be set by passing an empty value for the option. dokku network:set --global attach-post-create dokku network:set --global attach-post-deploy dokku network:set --global initial-network","title":"Attaching an app to a network"},{"location":"networking/network/#network-aliases","text":"When a container created for a deployment is being attached to a network - regardless of which attach property was used - a network alias of the pattern APP.PROC_TYPE will be added to all containers. This can be used to load-balance requests between containers. For an application named node-js-app with a process type of web, the network alias - or resolvable DNS record within the network - will be: node-js-app.web The fully-qualified URL for the resource will depend upon the PORT being listened to by the application. Applications built via buildpacks will have their PORT environment variable set to 5000 , and as such internal network requests for the above example should point to the following: http://node-js-app.web:5000 Dockerfile-based applications may listen on other ports. For more information on how ports are specified for applications, please refer to the port management documentation .","title":"Network Aliases"},{"location":"networking/network/#specifying-a-custom-tld","text":"When attaching applications to networks, a custom TLD can be specified via the network:set command. This TLD is suffixed to the network alias for the application/process-type combination for all networks to which the application is attached, and cannot be customized per network. The default value is an empty string. To specify a TLD of svc.cluster.local for your application, run the following command: # replace node-js-app with your application name dokku network:set node-js-app tld svc.cluster.local With an application named node-js-app and a process-type named web , the above command will turn the network alias into: node-js-app.web.svc.cluster.local Note that this has no impact on container port handling, and users must still specify the container port when making internal network requests. The default value may be set by passing an empty value for the option: dokku network:set node-js-app tld The tld property can also be set globally. The global default is emty string, and the global value is used when no app-specific value is set. dokku network:set --global tld svc.cluster.local The default value may be set by passing an empty value for the option. dokku network:set --global tld","title":"Specifying a custom TLD"},{"location":"networking/network/#when-to-attach-containers-to-a-network","text":"Containers can be attached to a network for a variety of reasons: A background process in one app needs to communicate to a webservice in another app An app needs to talk to a container not managed by Dokku in a secure manner A custom network that allows transparent access to another host exists and is necessary for an app to run Whatever the reason, the semantics of the two network hooks are important and are outlined before. attach-post-create : Phase it applies to: build : Intermediate containers created during the build process. deploy : Deployed app containers. run : Containers created by the run command. Container state on attach: created but not running Use case: When the container needs to access a resource on the network. Example: The app needs to talk to a database on the same network when it first boots. attach-post-deploy Phase it applies to: deploy : Deployed app containers. Container state on attach: running Use case: When another container on the network needs to access this container. Example: A background process needs to communicate with the web process exposed by this container. initial-network : Phase it applies to: build : Intermediate containers created during the build process. deploy : Deployed app containers. run : Containers created by the run command. Container state on attach: created Use case: When another container on the network is already running and needed by this container. Example: A key-value store exposing itself to all your apps may be on the initial-network . Warning If the attachment fails during the running container state, this may result in your application failing to respond to proxied requests once older containers are removed.","title":"When to attach containers to a network"},{"location":"networking/network/#rebuilding-network-settings","text":"There are cases where you may need to rebuild the network configuration for an app, such as on app boot or container restart. In these cases, you can use the network:rebuild command: dokku network:rebuild node-js-app Info This command will exit a non-zero number that depends on the number of containers for which configuration could not be built","title":"Rebuilding network settings"},{"location":"networking/network/#rebuilding-all-network-settings","text":"In some cases, a docker upgrade may reset container IPs or Ports. In both cases, you can quickly rewrite those files by using the network:rebuildall command: dokku network:rebuildall Info This command will exit a non-zero number that depends on the number of containers for which configuration could not be built","title":"Rebuilding all network settings"},{"location":"networking/network/#container-network-interface-binding","text":"Info This functionality does not control the --network docker flag. Please use the docker-options plugin to manage this flag. By default, an app will only bind to the internal interface. This behavior can be modified per app by changing the bind-all-interfaces network property. # bind to the default docker interface (`docker0`) with a random internal ip # this is the default behavior dokku network:set node-js-app bind-all-interfaces false # bind to all interfaces (`0.0.0.0`) on a random port for each upstream port # this will make the app container directly accessible by other hosts on your network # ports are randomized for every deploy, e.g. `0.0.0.0:32771->5000/tcp`. dokku network:set node-js-app bind-all-interfaces true By way of example, in the default case, each container is bound to the docker interface: Shell Output docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b88d8aec3d1 dokku/node-js-app:latest \"/bin/bash -c '/star About a minute ago Up About a minute node-js-app.web.1 As such, the container's IP address will be an internal IP, and thus it is only accessible on the host itself: docker inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' node-js-app.web.1 172.17.0.6 However, you can disable the internal proxying via the network:set command so that it will listen on the host's IP address: Shell Output dokku network:set node-js-app bind-all-interfaces true # container bound to all interfaces docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d6499edb0edb dokku/node-js-app:latest \"/bin/bash -c '/star About a minute ago Up About a minute 0.0.0.0:49153->5000/tcp node-js-app.web.1 The bind-all-interfaces property can also be set globally. The global default is false , and the global value is used when no app-specific value is set. dokku network:set --global bind-all-interfaces true The default value may be set by passing an empty value for the option. dokku network:set --global bind-all-interfaces","title":"Container network interface binding"},{"location":"networking/network/#displaying-network-reports-for-an-app","text":"You can get a report about the app's network status using the network:report command: Shell Output dokku network:report =====> node-js-app network information Network attach post create: Network attach post deploy: Network bind all interfaces: false Network computed attach post create: Network computed attach post deploy: Network computed bind all interfaces:false Network computed initial network: Network computed tld: Network global attach post create: Network global attach post deploy: Network global bind all interfaces:false Network global initial network: Network global tld: Network initial network: Network tld: Network web listeners: 172.17.0.1:5000 =====> python-sample network information Network attach post create: Network attach post deploy: Network bind all interfaces: false Network computed attach post create: Network computed attach post deploy: Network computed bind all interfaces:false Network computed initial network: Network computed tld: Network global attach post create: Network global attach post deploy: Network global bind all interfaces:false Network global initial network: Network global tld: Network initial network: Network tld: Network web listeners: 172.17.0.2:5000 =====> ruby-sample network information Network attach post create: Network attach post deploy: Network bind all interfaces: false Network computed attach post create: Network computed attach post deploy: Network computed bind all interfaces:false Network computed initial network: Network computed tld: Network global attach post create: Network global attach post deploy: Network global bind all interfaces:false Network global initial network: Network global tld: Network initial network: Network tld: Network web listeners: You can run the command for a specific app also. Shell Output dokku network:report node-js-app =====> node-js-app network information Network attach post create: Network attach post deploy: Network bind all interfaces: false Network computed attach post create: Network computed attach post deploy: Network computed bind all interfaces:false Network computed initial network: Network computed tld: Network global attach post create: Network global attach post deploy: Network global bind all interfaces:false Network global initial network: Network global tld: Network initial network: Network tld: Network web listeners: 172.17.0.1:5000 You can pass flags which will output only the value of the specific information you want. For example: dokku network:report node-js-app --network-bind-all-interfaces","title":"Displaying network reports for an app"},{"location":"networking/port-management/","text":"Port Management New Introduced in 0.5.0, Enhanced in 0.6.0 proxy:ports <app> # List proxy port mappings for an app proxy:ports-add <app> <scheme>:<host-port>:<container-port> [<scheme>:<host-port>:<container-port>...] # Add proxy port mappings to an app proxy:ports-clear <app> # Clear all proxy port mappings for an app proxy:ports-remove <app> <host-port> [<host-port>|<scheme>:<host-port>:<container-port>...] # Remove specific proxy port mappings from an app proxy:ports-set <app> <scheme>:<host-port>:<container-port> [<scheme>:<host-port>:<container-port>...] # Set proxy port mappings for an app In Dokku 0.5.0, port proxying was decoupled from the nginx-vhosts plugin into the proxy plugin. Dokku 0.6.0 introduced the ability to map host ports to specific container ports. In the future this will allow other proxy software - such as HAProxy or Caddy - to be used in place of nginx. Usage Warning Mapping alternative ports may conflict with the active firewall installed on your server or hosting provider. Such software includes - but is not limited to - AWS Security Groups, iptables, and UFW. Please consult the documentation for those softwares as applicable. Users should also avoid setting the PORT environment variable. Dokku will use port mappings to set this value. Overriding this manually may cause issues in application routing. New Introduced in 0.6.0 You can now configure host -> container port mappings with the proxy:ports-* commands. This mapping is currently supported by the built-in nginx-vhosts plugin. By default, buildpack apps and dockerfile apps without explicitly exposed ports (i.e. using the EXPOSE directive) will be configured with a listener on port 80 (and additionally a listener on 443 if ssl is enabled) that will proxy to the application container on port 5000 . Dockerfile apps with explicitly exposed ports will be configured with a listener on each exposed port and will proxy to that same port of the deployed application container. Note This default behavior will not be automatically changed on subsequent pushes and must be manipulated with the proxy:ports-* commands detailed below. Listing port mappings To inspect the port mapping for a given application, use the proxy:ports command: Shell Output dokku proxy:ports node-js-app -----> Port mappings for node-js-app -----> scheme host port container port http 80 5000 The above application is listening on the host's port 80 , which we can test via curl: Shell Output curl http://node-js-app.dokku.me Hello World! Adding a custom port mapping There are cases where we may wish for the service to be listening on more than one port, such as port 8080. Normally, this would not be possible: Shell Output curl http://node-js-app.dokku.me:8080 curl: (7) Failed to connect to node-js-app.dokku.me port 8080: Connection refused However, we can use the proxy:ports-add command to add a second external port mapping - 8080 - to our application's port 5000 . Shell Output dokku proxy:ports-add node-js-app http:8080:5000 -----> Setting config vars DOKKU_PROXY_PORT_MAP: http:80:5000 http:8080:5000 -----> Configuring node-js-app.dokku.me...(using built-in template) -----> Creating http nginx.conf Reloading nginx We can now test that port 80 still responds properly: Shell Output curl http://node-js-app.dokku.me Hello World! And our new listening port of 8080 also works: Shell Output curl http://node-js-app.dokku.me:8080 Hello World! Setting all port mappings at once Port mappings can also be force set using the proxy:ports-set command. Shell Output dokku proxy:ports-set node-js-app http:8080:5000 -----> Setting config vars DOKKU_PROXY_PORT_MAP: http:80:5000 http:8080:5000 -----> Configuring node-js-app.dokku.me...(using built-in template) -----> Creating http nginx.conf Reloading nginx Removing a port mapping A port mapping can be removed using the proxy:ports-remove command if it no longer necessary: dokku proxy:ports-remove node-js-app http:80:5000 Ports may also be removed by specifying only the host-port value. This effectively acts as a wildcard and removes all mappings for that particular host port. dokku proxy:ports-remove node-js-app http:80 Port management by Deployment Method Warning If you set a proxy port map but do not have a global domain set , Dokku will reset that map upon first deployment. Buildpacks For buildpack deployments, your application must respect the PORT environment variable. We will typically set this to port 5000 , but this is not guaranteed. If you do not respect the PORT environment variable, your containers may start but your services will not be accessible outside of that container. Dockerfile Info Changed as of 0.5.0 Dokku's default proxy implementation - nginx - supports HTTP and GRPC request proxying. At this time, we do not support proxying plain TCP or UDP ports. UDP ports can be exposed by disabling the nginx proxy with dokku proxy:disable myapp . If you would like to investigate alternative proxy methods, please refer to our proxy management documentation . Applications using EXPOSE Dokku will extract all tcp ports exposed using the EXPOSE directive (one port per line) and setup nginx to proxy the same port numbers to listen publicly. If you would like to change the exposed port, you should do so within your Dockerfile . For example, if the Dokku installation is configured with the domain dokku.me and an application named node-js-app is deployed with following Dockerfile: FROM ubuntu:18.04 EXPOSE 1234 RUN python -m SimpleHTTPServer 1234 The application would be exposed to the user at node-js-app.dokku.me:1234 . If this is not desired, the following application configuration may be applied: # add a port mapping to port 80 dokku proxy:ports-add node-js-app http:80:1234 # remove the incorrect port mapping dokku proxy:ports-remove node-js-app http:1234:1234 Applications not using EXPOSE Any application that does not use an EXPOSE directive will result in Dokku defaulting to port 5000 . This behavior mimics the behavior of a Buildpack deploy. If your application does not support the PORT environment variable, then you will either need to: modify your application to support the PORT environment variable. switch to using an EXPOSE directive in your Dockerfile. Switching between EXPOSE usage modes When switching between EXPOSE usage modes, it is important to reset your port management. The following two commands can be used to reset your state and redeploy your application. # assuming your application is called `node-js-app` dokku config:unset --no-restart node-js-app DOKKU_DOCKERFILE_PORTS PORT dokku proxy:ports-clear node-js-app Docker Image When deploying an image, we will use docker inspect to extract the ExposedPorts configuration and if defined, use that to populate port mapping. If this behavior is not desired, you can override that configuration variable with the following commands. # assuming your application is called `node-js-app` dokku config:set node-js-app DOKKU_DOCKERFILE_PORTS = \"1234/tcp 80/tcp\" dokku proxy:ports-clear node-js-app All other port-related behavior is the same as when deploying via Dockerfile.","title":"Port Management"},{"location":"networking/port-management/#port-management","text":"New Introduced in 0.5.0, Enhanced in 0.6.0 proxy:ports <app> # List proxy port mappings for an app proxy:ports-add <app> <scheme>:<host-port>:<container-port> [<scheme>:<host-port>:<container-port>...] # Add proxy port mappings to an app proxy:ports-clear <app> # Clear all proxy port mappings for an app proxy:ports-remove <app> <host-port> [<host-port>|<scheme>:<host-port>:<container-port>...] # Remove specific proxy port mappings from an app proxy:ports-set <app> <scheme>:<host-port>:<container-port> [<scheme>:<host-port>:<container-port>...] # Set proxy port mappings for an app In Dokku 0.5.0, port proxying was decoupled from the nginx-vhosts plugin into the proxy plugin. Dokku 0.6.0 introduced the ability to map host ports to specific container ports. In the future this will allow other proxy software - such as HAProxy or Caddy - to be used in place of nginx.","title":"Port Management"},{"location":"networking/port-management/#usage","text":"Warning Mapping alternative ports may conflict with the active firewall installed on your server or hosting provider. Such software includes - but is not limited to - AWS Security Groups, iptables, and UFW. Please consult the documentation for those softwares as applicable. Users should also avoid setting the PORT environment variable. Dokku will use port mappings to set this value. Overriding this manually may cause issues in application routing. New Introduced in 0.6.0 You can now configure host -> container port mappings with the proxy:ports-* commands. This mapping is currently supported by the built-in nginx-vhosts plugin. By default, buildpack apps and dockerfile apps without explicitly exposed ports (i.e. using the EXPOSE directive) will be configured with a listener on port 80 (and additionally a listener on 443 if ssl is enabled) that will proxy to the application container on port 5000 . Dockerfile apps with explicitly exposed ports will be configured with a listener on each exposed port and will proxy to that same port of the deployed application container. Note This default behavior will not be automatically changed on subsequent pushes and must be manipulated with the proxy:ports-* commands detailed below.","title":"Usage"},{"location":"networking/port-management/#listing-port-mappings","text":"To inspect the port mapping for a given application, use the proxy:ports command: Shell Output dokku proxy:ports node-js-app -----> Port mappings for node-js-app -----> scheme host port container port http 80 5000 The above application is listening on the host's port 80 , which we can test via curl: Shell Output curl http://node-js-app.dokku.me Hello World!","title":"Listing port mappings"},{"location":"networking/port-management/#adding-a-custom-port-mapping","text":"There are cases where we may wish for the service to be listening on more than one port, such as port 8080. Normally, this would not be possible: Shell Output curl http://node-js-app.dokku.me:8080 curl: (7) Failed to connect to node-js-app.dokku.me port 8080: Connection refused However, we can use the proxy:ports-add command to add a second external port mapping - 8080 - to our application's port 5000 . Shell Output dokku proxy:ports-add node-js-app http:8080:5000 -----> Setting config vars DOKKU_PROXY_PORT_MAP: http:80:5000 http:8080:5000 -----> Configuring node-js-app.dokku.me...(using built-in template) -----> Creating http nginx.conf Reloading nginx We can now test that port 80 still responds properly: Shell Output curl http://node-js-app.dokku.me Hello World! And our new listening port of 8080 also works: Shell Output curl http://node-js-app.dokku.me:8080 Hello World!","title":"Adding a custom port mapping"},{"location":"networking/port-management/#setting-all-port-mappings-at-once","text":"Port mappings can also be force set using the proxy:ports-set command. Shell Output dokku proxy:ports-set node-js-app http:8080:5000 -----> Setting config vars DOKKU_PROXY_PORT_MAP: http:80:5000 http:8080:5000 -----> Configuring node-js-app.dokku.me...(using built-in template) -----> Creating http nginx.conf Reloading nginx","title":"Setting all port mappings at once"},{"location":"networking/port-management/#removing-a-port-mapping","text":"A port mapping can be removed using the proxy:ports-remove command if it no longer necessary: dokku proxy:ports-remove node-js-app http:80:5000 Ports may also be removed by specifying only the host-port value. This effectively acts as a wildcard and removes all mappings for that particular host port. dokku proxy:ports-remove node-js-app http:80","title":"Removing a port mapping"},{"location":"networking/port-management/#port-management-by-deployment-method","text":"Warning If you set a proxy port map but do not have a global domain set , Dokku will reset that map upon first deployment.","title":"Port management by Deployment Method"},{"location":"networking/port-management/#buildpacks","text":"For buildpack deployments, your application must respect the PORT environment variable. We will typically set this to port 5000 , but this is not guaranteed. If you do not respect the PORT environment variable, your containers may start but your services will not be accessible outside of that container.","title":"Buildpacks"},{"location":"networking/port-management/#dockerfile","text":"Info Changed as of 0.5.0 Dokku's default proxy implementation - nginx - supports HTTP and GRPC request proxying. At this time, we do not support proxying plain TCP or UDP ports. UDP ports can be exposed by disabling the nginx proxy with dokku proxy:disable myapp . If you would like to investigate alternative proxy methods, please refer to our proxy management documentation .","title":"Dockerfile"},{"location":"networking/port-management/#applications-using-expose","text":"Dokku will extract all tcp ports exposed using the EXPOSE directive (one port per line) and setup nginx to proxy the same port numbers to listen publicly. If you would like to change the exposed port, you should do so within your Dockerfile . For example, if the Dokku installation is configured with the domain dokku.me and an application named node-js-app is deployed with following Dockerfile: FROM ubuntu:18.04 EXPOSE 1234 RUN python -m SimpleHTTPServer 1234 The application would be exposed to the user at node-js-app.dokku.me:1234 . If this is not desired, the following application configuration may be applied: # add a port mapping to port 80 dokku proxy:ports-add node-js-app http:80:1234 # remove the incorrect port mapping dokku proxy:ports-remove node-js-app http:1234:1234","title":"Applications using EXPOSE"},{"location":"networking/port-management/#applications-not-using-expose","text":"Any application that does not use an EXPOSE directive will result in Dokku defaulting to port 5000 . This behavior mimics the behavior of a Buildpack deploy. If your application does not support the PORT environment variable, then you will either need to: modify your application to support the PORT environment variable. switch to using an EXPOSE directive in your Dockerfile.","title":"Applications not using EXPOSE"},{"location":"networking/port-management/#switching-between-expose-usage-modes","text":"When switching between EXPOSE usage modes, it is important to reset your port management. The following two commands can be used to reset your state and redeploy your application. # assuming your application is called `node-js-app` dokku config:unset --no-restart node-js-app DOKKU_DOCKERFILE_PORTS PORT dokku proxy:ports-clear node-js-app","title":"Switching between EXPOSE usage modes"},{"location":"networking/port-management/#docker-image","text":"When deploying an image, we will use docker inspect to extract the ExposedPorts configuration and if defined, use that to populate port mapping. If this behavior is not desired, you can override that configuration variable with the following commands. # assuming your application is called `node-js-app` dokku config:set node-js-app DOKKU_DOCKERFILE_PORTS = \"1234/tcp 80/tcp\" dokku proxy:ports-clear node-js-app All other port-related behavior is the same as when deploying via Dockerfile.","title":"Docker Image"},{"location":"networking/proxy-management/","text":"Proxy Management New Introduced in 0.5.0, Enhanced in 0.6.0 proxy:build-config [--parallel count] [--all|<app>] # (Re)builds config for given app proxy:clear-config [--all|<app>] # Clears config for given app proxy:disable [--parallel count] [--all|<app>] # Disable proxy for app proxy:enable [--parallel count] [--all|<app>] # Enable proxy for app proxy:report [<app>] [<flag>] # Displays a proxy report for one or more apps proxy:set <app> <proxy-type> # Set proxy type for app In Dokku 0.5.0, port proxying was decoupled from the nginx-vhosts plugin into the proxy plugin. Dokku 0.6.0 introduced the ability to map host ports to specific container ports. In the future this will allow other proxy software - such as HAProxy or Caddy - to be used in place of nginx. Usage Regenerating proxy config In certain cases, your app proxy configs may drift from the correct config for your app. You may regenerate the config at any point via the proxy:build-config command. This command will trigger a rebuild for the configured proxy implementation (default: nginx) for a given app. The command may fail if there are no current web listeners for your app. dokku proxy:build-config node-js-app All apps may have their proxy config rebuilt by using the --all flag. dokku proxy:build-config --all By default, rebuilding proxy configs for all apps happens serially. The parallelism may be controlled by the --parallel flag. dokku proxy:build-config --all --parallel 2 Finally, the number of parallel workers may be automatically set to the number of CPUs available by setting the --parallel flag to -1 dokku proxy:build-config --all --parallel -1 Clearing the generated proxy config New Introduced in 0.27.0 Generated proxy configurations can also be cleared using the proxy:clear-config command. dokku proxy:clear-config node-js-app All apps may have their proxy config cleared by using the --all flag. dokku proxy:clear-config --all Clearing a proxy configuration has different effects depending on the proxy plugin in use. Consul the documentation for your proxy implementation for further details. Displaying proxy reports for an app New Introduced in 0.8.1 You can get a report about the app's proxy status using the proxy:report command: Shell Output dokku proxy:report =====> node-js-app proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 https:443:5000 =====> python-sample proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 =====> ruby-sample proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 You can run the command for a specific app also. Shell Output dokku proxy:report node-js-app =====> node-js-app proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 https:443:5000 You can pass flags which will output only the value of the specific information you want. For example: dokku proxy:report node-js-app --proxy-type Proxy Port Scheme The proxy port scheme is as follows: SCHEME:HOST_PORT:CONTAINER_PORT The scheme metadata can be used by proxy implementations in order to properly handle proxying of requests. For example, the built-in nginx-vhosts proxy implementation supports the http , https , grpc and grpcs schemes. For the grpc and grpcs see nginx blog post on grpc . Developers of proxy implementations are encouraged to use whatever schemes make the most sense, and ignore configurations which they do not support. For instance, a udp proxy implementation can safely ignore http and https port mappings. To change the proxy implementation in use for an application, use the proxy:set command: # no validation will be performed against # the specified proxy implementation dokku proxy:set node-js-app nginx Proxy port mapping See the port management documentation for more information on how port mappings are managed for an application. Container network interface binding Info Changed as of 0.11.0 From Dokku versions 0.5.0 until 0.11.0 , enabling or disabling an application's proxy would also control whether or not the application was bound to all interfaces - e.g. 0.0.0.0 . As of 0.11.0 , this is now controlled by the network plugin. Please see the network documentation for more information. Implementing a Proxy Custom plugins names must have the suffix -vhosts or scheduler overriding via proxy:set may not function as expected. At this time, the following dokku commands are used to implement a complete proxy implementation. domains:add : Adds a given domain to an app. triggers: post-domains-update domains:clear : Clears out an app's associated domains. triggers: post-domains-update domains:disable : Disables domains for an app. triggers: pre-disable-vhost domains:enable : Enables domains for an app. triggers: pre-enable-vhost domains:remove : Removes a domain from an app. triggers: post-domains-update domains:set : Sets all domains for a given app. triggers: post-domains-update proxy:build-config : Builds - or rebuilds - external proxy configuration. triggers: proxy-build-config proxy:clear-config : Clears out external proxy configuration. triggers: proxy-clear-config proxy:disable : Disables the proxy configuration for an app. triggers: proxy-disable proxy:enable : Enables the proxy configuration for an app. triggers: proxy-enable proxy:ports-add : Adds one or more port mappings to an app triggers: post-proxy-ports-update proxy:ports-clear : Clears out all port mappings for an app. triggers: post-proxy-ports-update proxy:ports-remove : Removes one or more port mappings from an app. triggers: post-proxy-ports-update proxy:ports-set : Sets all port mappings for an app. triggers: post-proxy-ports-update Proxy implementations may decide to omit some functionality here, or use plugin triggers to supplement config with information from other plugins. Individual proxy implementations may trigger app rebuilds, depending on how proxy metadata is exposed for the proxy implementation. Finally, proxy implementations may install extra software needed for the proxy itself in whatever manner deemed fit. Proxy software can run on the host itself or within a running Docker container with either exposed ports or host networking.","title":"Proxy Management"},{"location":"networking/proxy-management/#proxy-management","text":"New Introduced in 0.5.0, Enhanced in 0.6.0 proxy:build-config [--parallel count] [--all|<app>] # (Re)builds config for given app proxy:clear-config [--all|<app>] # Clears config for given app proxy:disable [--parallel count] [--all|<app>] # Disable proxy for app proxy:enable [--parallel count] [--all|<app>] # Enable proxy for app proxy:report [<app>] [<flag>] # Displays a proxy report for one or more apps proxy:set <app> <proxy-type> # Set proxy type for app In Dokku 0.5.0, port proxying was decoupled from the nginx-vhosts plugin into the proxy plugin. Dokku 0.6.0 introduced the ability to map host ports to specific container ports. In the future this will allow other proxy software - such as HAProxy or Caddy - to be used in place of nginx.","title":"Proxy Management"},{"location":"networking/proxy-management/#usage","text":"","title":"Usage"},{"location":"networking/proxy-management/#regenerating-proxy-config","text":"In certain cases, your app proxy configs may drift from the correct config for your app. You may regenerate the config at any point via the proxy:build-config command. This command will trigger a rebuild for the configured proxy implementation (default: nginx) for a given app. The command may fail if there are no current web listeners for your app. dokku proxy:build-config node-js-app All apps may have their proxy config rebuilt by using the --all flag. dokku proxy:build-config --all By default, rebuilding proxy configs for all apps happens serially. The parallelism may be controlled by the --parallel flag. dokku proxy:build-config --all --parallel 2 Finally, the number of parallel workers may be automatically set to the number of CPUs available by setting the --parallel flag to -1 dokku proxy:build-config --all --parallel -1","title":"Regenerating proxy config"},{"location":"networking/proxy-management/#clearing-the-generated-proxy-config","text":"New Introduced in 0.27.0 Generated proxy configurations can also be cleared using the proxy:clear-config command. dokku proxy:clear-config node-js-app All apps may have their proxy config cleared by using the --all flag. dokku proxy:clear-config --all Clearing a proxy configuration has different effects depending on the proxy plugin in use. Consul the documentation for your proxy implementation for further details.","title":"Clearing the generated proxy config"},{"location":"networking/proxy-management/#displaying-proxy-reports-for-an-app","text":"New Introduced in 0.8.1 You can get a report about the app's proxy status using the proxy:report command: Shell Output dokku proxy:report =====> node-js-app proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 https:443:5000 =====> python-sample proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 =====> ruby-sample proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 You can run the command for a specific app also. Shell Output dokku proxy:report node-js-app =====> node-js-app proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 https:443:5000 You can pass flags which will output only the value of the specific information you want. For example: dokku proxy:report node-js-app --proxy-type","title":"Displaying proxy reports for an app"},{"location":"networking/proxy-management/#proxy-port-scheme","text":"The proxy port scheme is as follows: SCHEME:HOST_PORT:CONTAINER_PORT The scheme metadata can be used by proxy implementations in order to properly handle proxying of requests. For example, the built-in nginx-vhosts proxy implementation supports the http , https , grpc and grpcs schemes. For the grpc and grpcs see nginx blog post on grpc . Developers of proxy implementations are encouraged to use whatever schemes make the most sense, and ignore configurations which they do not support. For instance, a udp proxy implementation can safely ignore http and https port mappings. To change the proxy implementation in use for an application, use the proxy:set command: # no validation will be performed against # the specified proxy implementation dokku proxy:set node-js-app nginx","title":"Proxy Port Scheme"},{"location":"networking/proxy-management/#proxy-port-mapping","text":"See the port management documentation for more information on how port mappings are managed for an application.","title":"Proxy port mapping"},{"location":"networking/proxy-management/#container-network-interface-binding","text":"Info Changed as of 0.11.0 From Dokku versions 0.5.0 until 0.11.0 , enabling or disabling an application's proxy would also control whether or not the application was bound to all interfaces - e.g. 0.0.0.0 . As of 0.11.0 , this is now controlled by the network plugin. Please see the network documentation for more information.","title":"Container network interface binding"},{"location":"networking/proxy-management/#implementing-a-proxy","text":"Custom plugins names must have the suffix -vhosts or scheduler overriding via proxy:set may not function as expected. At this time, the following dokku commands are used to implement a complete proxy implementation. domains:add : Adds a given domain to an app. triggers: post-domains-update domains:clear : Clears out an app's associated domains. triggers: post-domains-update domains:disable : Disables domains for an app. triggers: pre-disable-vhost domains:enable : Enables domains for an app. triggers: pre-enable-vhost domains:remove : Removes a domain from an app. triggers: post-domains-update domains:set : Sets all domains for a given app. triggers: post-domains-update proxy:build-config : Builds - or rebuilds - external proxy configuration. triggers: proxy-build-config proxy:clear-config : Clears out external proxy configuration. triggers: proxy-clear-config proxy:disable : Disables the proxy configuration for an app. triggers: proxy-disable proxy:enable : Enables the proxy configuration for an app. triggers: proxy-enable proxy:ports-add : Adds one or more port mappings to an app triggers: post-proxy-ports-update proxy:ports-clear : Clears out all port mappings for an app. triggers: post-proxy-ports-update proxy:ports-remove : Removes one or more port mappings from an app. triggers: post-proxy-ports-update proxy:ports-set : Sets all port mappings for an app. triggers: post-proxy-ports-update Proxy implementations may decide to omit some functionality here, or use plugin triggers to supplement config with information from other plugins. Individual proxy implementations may trigger app rebuilds, depending on how proxy metadata is exposed for the proxy implementation. Finally, proxy implementations may install extra software needed for the proxy itself in whatever manner deemed fit. Proxy software can run on the host itself or within a running Docker container with either exposed ports or host networking.","title":"Implementing a Proxy"},{"location":"networking/proxies/caddy/","text":"Caddy Proxy New Introduced in 0.28.0 Dokku provides integration with the Caddy proxy service by utilizing the Docker label-based integration implemented by Caddy. caddy:report [<app>] [<flag>] # Displays a caddy report for one or more apps caddy:logs [--num num] [--tail] # Display caddy log output caddy:set <app> <property> (<value>) # Set or clear an caddy property for an app caddy:show-config <app> # Display caddy compose config caddy:start # Starts the caddy server caddy:stop # Stops the caddy server Requirements Using the caddy plugin integration requires the docker-compose-plugin for Docker. See this document from the Docker documentation for more information on the installation process for the docker-compose-plugin . Usage Warning As using multiple proxy plugins on a single Dokku installation can lead to issues routing requests to apps, doing so should be avoided. As the default proxy implementation is nginx, users are encouraged to stop the nginx service before switching to Caddy. The Caddy plugin has specific rules for routing requests: Caddy integration is exposed via docker labels attached to containers. Changes in labels require either app deploys or rebuilds. While Caddy will respect labels associated with other containers, only web containers have Caddy labels injected by the plugin. Only http:80 and https:443 port mappings are supported. Caddy will automatically enable SSL if the letsencrypt email property is set. SSL will be disabled otherwise. If no http:80 mapping is found, the first http port mapping is used for http requests. If no https:443 mapping is found, the first https port mapping is used for https requests. If no https mapping is found, the container port from http:80 will be used for https requests. Requests are routed as soon as the container is running and passing healthchecks. Switching to Caddy To use the Caddy plugin, use the proxy:set command for the app in question: dokku proxy:set node-js-app caddy This will enable the docker label-based Caddy integration. All future deploys will inject the correct labels for Caddy to read and route requests to containers. Due to the docker label-based integration used by Caddy, a single deploy or rebuild will be required before requests will route successfully. dokku ps:rebuild node-js-app Any changes to domains or port mappings will also require either a deploy or rebuild. Starting Caddy container Caddy can be started via the caddy:start command. This will start a Caddy container via the docker compose up command. dokku caddy:start Stopping the Caddy container Caddy may be stopped via the caddy:stop command. dokku caddy:stop The Caddy container will be stopped and removed from the system. If the container is not running, this command will do nothing. Showing the Caddy compose config For debugging purposes, it may be useful to show the Caddy compose config. This can be achieved via the caddy:show-config command. dokku caddy:show-config Customizing the Caddy container image While the default Caddy image is hardcoded, users may specify an alternative by setting the image property with the --global flag: dokku caddy:set --global image lucaslorentz/caddy-docker-proxy:2.7 Checking the Caddy container's logs It may be necessary to check the Caddy container's logs to ensure that Caddy is operating as expected. This can be performed with the caddy:logs command. dokku caddy:logs This command also supports the following modifiers: --num NUM # the number of lines to display --tail # continually stream logs You can use these modifiers as follows: dokku caddy:logs --tail --num 10 The above command will show logs continually from the vector container, with an initial history of 10 log lines Changing the Caddy log level Caddy log output is set to ERROR by default. It may be changed by setting the log-level property with the --global flag: dokku caddy:set --global log-level DEBUG After modifying, the Caddy container will need to be restarted. SSL Configuration The caddy plugin only supports automatic ssl certificates from it's letsencrypt integration. Managed certificates provided by the certs plugin are ignored. Enabling letsencrypt integration By default, letsencrypt is disabled and https port mappings are ignored. To enable, set the letsencrypt-email property with the --global flag: dokku caddy:set --global letsencrypt-email automated@dokku.sh After enabling, the Caddy container will need to be restarted and apps will need to be rebuilt. All http requests will then be redirected to https. Customizing the letsencrypt server The letsencrypt integration is set to the production letsencrypt server by default. To change this, set the letsencrypt-server property with the --global flag: dokku caddy:set --global letsencrypt-server https://acme-staging-v02.api.letsencrypt.org/directory After enabling, the Caddy container will need to be restarted and apps will need to be rebuilt to retrieve certificates from the new server. Using Caddy's Internal TLS server To switch to Caddy's internal TLS server for certificate provisioning, set the tls-internal property. This can only be set on a per-app basis. dokku caddy:set node-js-app tls-internal true Displaying Caddy reports for an app You can get a report about the app's Caddy config using the caddy:report command: Shell Output dokku caddy:report =====> node-js-app caddy information Caddy image: lucaslorentz/caddy-docker-proxy:2.7 Caddy letsencrypt email: Caddy letsencrypt server: Caddy log level: ERROR Caddy polling interval: 5s Caddy tls internal: false =====> python-app caddy information Caddy image: lucaslorentz/caddy-docker-proxy:2.7 Caddy letsencrypt email: Caddy letsencrypt server: Caddy log level: ERROR Caddy polling interval: 5s Caddy tls internal: false =====> ruby-app caddy information Caddy image: lucaslorentz/caddy-docker-proxy:2.7 Caddy letsencrypt email: Caddy letsencrypt server: Caddy log level: ERROR Caddy polling interval: 5s Caddy tls internal: false You can run the command for a specific app also. Shell Output dokku caddy:report node-js-app =====> node-js-app caddy information Caddy image: lucaslorentz/caddy-docker-proxy:2.7 Caddy letsencrypt email: Caddy letsencrypt server: Caddy log level: ERROR Caddy polling interval: 5s Caddy tls internal: false You can pass flags which will output only the value of the specific information you want. For example: dokku caddy:report node-js-app --caddy-image","title":"Caddy Proxy"},{"location":"networking/proxies/caddy/#caddy-proxy","text":"New Introduced in 0.28.0 Dokku provides integration with the Caddy proxy service by utilizing the Docker label-based integration implemented by Caddy. caddy:report [<app>] [<flag>] # Displays a caddy report for one or more apps caddy:logs [--num num] [--tail] # Display caddy log output caddy:set <app> <property> (<value>) # Set or clear an caddy property for an app caddy:show-config <app> # Display caddy compose config caddy:start # Starts the caddy server caddy:stop # Stops the caddy server","title":"Caddy Proxy"},{"location":"networking/proxies/caddy/#requirements","text":"Using the caddy plugin integration requires the docker-compose-plugin for Docker. See this document from the Docker documentation for more information on the installation process for the docker-compose-plugin .","title":"Requirements"},{"location":"networking/proxies/caddy/#usage","text":"Warning As using multiple proxy plugins on a single Dokku installation can lead to issues routing requests to apps, doing so should be avoided. As the default proxy implementation is nginx, users are encouraged to stop the nginx service before switching to Caddy. The Caddy plugin has specific rules for routing requests: Caddy integration is exposed via docker labels attached to containers. Changes in labels require either app deploys or rebuilds. While Caddy will respect labels associated with other containers, only web containers have Caddy labels injected by the plugin. Only http:80 and https:443 port mappings are supported. Caddy will automatically enable SSL if the letsencrypt email property is set. SSL will be disabled otherwise. If no http:80 mapping is found, the first http port mapping is used for http requests. If no https:443 mapping is found, the first https port mapping is used for https requests. If no https mapping is found, the container port from http:80 will be used for https requests. Requests are routed as soon as the container is running and passing healthchecks.","title":"Usage"},{"location":"networking/proxies/caddy/#switching-to-caddy","text":"To use the Caddy plugin, use the proxy:set command for the app in question: dokku proxy:set node-js-app caddy This will enable the docker label-based Caddy integration. All future deploys will inject the correct labels for Caddy to read and route requests to containers. Due to the docker label-based integration used by Caddy, a single deploy or rebuild will be required before requests will route successfully. dokku ps:rebuild node-js-app Any changes to domains or port mappings will also require either a deploy or rebuild.","title":"Switching to Caddy"},{"location":"networking/proxies/caddy/#starting-caddy-container","text":"Caddy can be started via the caddy:start command. This will start a Caddy container via the docker compose up command. dokku caddy:start","title":"Starting Caddy container"},{"location":"networking/proxies/caddy/#stopping-the-caddy-container","text":"Caddy may be stopped via the caddy:stop command. dokku caddy:stop The Caddy container will be stopped and removed from the system. If the container is not running, this command will do nothing.","title":"Stopping the Caddy container"},{"location":"networking/proxies/caddy/#showing-the-caddy-compose-config","text":"For debugging purposes, it may be useful to show the Caddy compose config. This can be achieved via the caddy:show-config command. dokku caddy:show-config","title":"Showing the Caddy compose config"},{"location":"networking/proxies/caddy/#customizing-the-caddy-container-image","text":"While the default Caddy image is hardcoded, users may specify an alternative by setting the image property with the --global flag: dokku caddy:set --global image lucaslorentz/caddy-docker-proxy:2.7","title":"Customizing the Caddy container image"},{"location":"networking/proxies/caddy/#checking-the-caddy-containers-logs","text":"It may be necessary to check the Caddy container's logs to ensure that Caddy is operating as expected. This can be performed with the caddy:logs command. dokku caddy:logs This command also supports the following modifiers: --num NUM # the number of lines to display --tail # continually stream logs You can use these modifiers as follows: dokku caddy:logs --tail --num 10 The above command will show logs continually from the vector container, with an initial history of 10 log lines","title":"Checking the Caddy container's logs"},{"location":"networking/proxies/caddy/#changing-the-caddy-log-level","text":"Caddy log output is set to ERROR by default. It may be changed by setting the log-level property with the --global flag: dokku caddy:set --global log-level DEBUG After modifying, the Caddy container will need to be restarted.","title":"Changing the Caddy log level"},{"location":"networking/proxies/caddy/#ssl-configuration","text":"The caddy plugin only supports automatic ssl certificates from it's letsencrypt integration. Managed certificates provided by the certs plugin are ignored.","title":"SSL Configuration"},{"location":"networking/proxies/caddy/#enabling-letsencrypt-integration","text":"By default, letsencrypt is disabled and https port mappings are ignored. To enable, set the letsencrypt-email property with the --global flag: dokku caddy:set --global letsencrypt-email automated@dokku.sh After enabling, the Caddy container will need to be restarted and apps will need to be rebuilt. All http requests will then be redirected to https.","title":"Enabling letsencrypt integration"},{"location":"networking/proxies/caddy/#customizing-the-letsencrypt-server","text":"The letsencrypt integration is set to the production letsencrypt server by default. To change this, set the letsencrypt-server property with the --global flag: dokku caddy:set --global letsencrypt-server https://acme-staging-v02.api.letsencrypt.org/directory After enabling, the Caddy container will need to be restarted and apps will need to be rebuilt to retrieve certificates from the new server.","title":"Customizing the letsencrypt server"},{"location":"networking/proxies/caddy/#using-caddys-internal-tls-server","text":"To switch to Caddy's internal TLS server for certificate provisioning, set the tls-internal property. This can only be set on a per-app basis. dokku caddy:set node-js-app tls-internal true","title":"Using Caddy's Internal TLS server"},{"location":"networking/proxies/caddy/#displaying-caddy-reports-for-an-app","text":"You can get a report about the app's Caddy config using the caddy:report command: Shell Output dokku caddy:report =====> node-js-app caddy information Caddy image: lucaslorentz/caddy-docker-proxy:2.7 Caddy letsencrypt email: Caddy letsencrypt server: Caddy log level: ERROR Caddy polling interval: 5s Caddy tls internal: false =====> python-app caddy information Caddy image: lucaslorentz/caddy-docker-proxy:2.7 Caddy letsencrypt email: Caddy letsencrypt server: Caddy log level: ERROR Caddy polling interval: 5s Caddy tls internal: false =====> ruby-app caddy information Caddy image: lucaslorentz/caddy-docker-proxy:2.7 Caddy letsencrypt email: Caddy letsencrypt server: Caddy log level: ERROR Caddy polling interval: 5s Caddy tls internal: false You can run the command for a specific app also. Shell Output dokku caddy:report node-js-app =====> node-js-app caddy information Caddy image: lucaslorentz/caddy-docker-proxy:2.7 Caddy letsencrypt email: Caddy letsencrypt server: Caddy log level: ERROR Caddy polling interval: 5s Caddy tls internal: false You can pass flags which will output only the value of the specific information you want. For example: dokku caddy:report node-js-app --caddy-image","title":"Displaying Caddy reports for an app"},{"location":"networking/proxies/nginx/","text":"Nginx Proxy Dokku uses nginx as its server for routing requests to specific applications. By default, access and error logs are written for each app to /var/log/nginx/${APP}-access.log and /var/log/nginx/${APP}-error.log respectively nginx:access-logs <app> [-t] # Show the nginx access logs for an application (-t follows) nginx:error-logs <app> [-t] # Show the nginx error logs for an application (-t follows) nginx:report [<app>] [<flag>] # Displays a nginx report for one or more apps nginx:set <app> <property> (<value>) # Set or clear an nginx property for an app nginx:show-config <app> # Display app nginx config nginx:start # Starts the nginx server nginx:stop # Stops the nginx server nginx:validate-config [<app>] [--clean] # Validates and optionally cleans up invalid nginx configurations Usage Warning As using multiple proxy plugins on a single Dokku installation can lead to issues routing requests to apps, doing so should be avoided. Request Proxying By default, the web process is the only process proxied by the nginx proxy implementation. Proxying to other process types may be handled by a custom nginx.conf.sigil file, as generally described below Nginx will proxy the requests in a round-robin balancing fashion to the different deployed (scaled) containers running the web proctype. This way, the host's resources can be fully leveraged for single-threaded applications (e.g. dokku ps:scale node-js-app web=4 on a 4-core machine). Starting nginx New Introduced in 0.28.0 The nginx server can be started via nginx:start . dokku nginx:start ```` ### Stopping nginx !!! tip \"New\" Introduced in 0 .28.0 The nginx server can be stopped via ` nginx:stop ` . ``` shell dokku nginx:stop ```` ### Binding to specific addresses !!! tip \"New\" Introduced in 0 .19.2 !!! note \"Note\" Changing this value globally or on a per-app basis will require rebuilding the nginx config via the ` proxy:build-config ` command. By default, nginx will listen to all interfaces ( ` [ :: ] ` for IPv6, ` 0 .0.0.0 ` for IPv4 ) when proxying requests to applications. This may be changed using the ` bind-address-ipv4 ` and ` bind-address-ipv6 ` properties. This is useful in cases where the proxying should be internal to a network or if there are multiple network interfaces that should respond with different content. ``` shell dokku nginx:set node-js-app bind-address-ipv4 127 .0.0.1 dokku nginx:set node-js-app bind-address-ipv6 ::1 This may be reverted by setting an empty bind address. dokku nginx:set node-js-app bind-address-ipv4 dokku nginx:set node-js-app bind-address-ipv6 Warning Validation is not performed on either value. Users with apps that contain a custom nginx.conf.sigil file will need to modify the files to respect the new NGINX_BIND_ADDRESS_IPV4 and NGINX_BIND_ADDRESS_IPV6 variables. HSTS Header New Introduced in 0.20.0 Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. If SSL certificates are present, HSTS will be automatically enabled. It can be toggled via nginx:set : dokku nginx:set node-js-app hsts true dokku nginx:set node-js-app hsts false The following options are also available via the nginx:set command: hsts (type: boolean, default: true ): Enables or disables HSTS for your application. hsts-include-subdomains (type: boolean, default: true ): Tells the browser that the HSTS policy also applies to all subdomains of the current domain. hsts-max-age (type: integer, default: 15724800 ): Time in seconds to cache HSTS configuration. hsts-preload (type: boolean, default: false ): Tells most major web browsers to include the domain in their HSTS preload lists. Beware that if you enable the header and a subsequent deploy of your application results in an HTTP deploy (for whatever reason), the way the header works means that a browser will not attempt to request the HTTP version of your site if the HTTPS version fails until the max-age is reached. Globally disabling the HSTS Header Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. HSTS Header can be disabled for all apps by setting the hsts property to false after passing the --global flag to nginx:set . dokku nginx:set --global hsts false Once the HSTS setting is disabled globally, it can be re-enabled on a per-app basis by setting the hsts property as normal. dokku nginx:set node-js-app hsts true Checking access logs Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. You may check nginx access logs via the nginx:access-logs command. This assumes that app access logs are being stored in /var/log/nginx/$APP-access.log , as is the default in the generated nginx.conf . dokku nginx:access-logs node-js-app You may also follow the logs by specifying the -t flag. dokku nginx:access-logs node-js-app -t Checking error logs You may check nginx error logs via the nginx:error-logs command. This assumes that app error logs are being stored in /var/log/nginx/$APP-error.log , as is the default in the generated nginx.conf . dokku nginx:error-logs node-js-app You may also follow the logs by specifying the -t flag. dokku nginx:error-logs node-js-app -t Changing log path New Introduced in 0.20.1 Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. The path to where log files are stored can be changed by calling the nginx:set command with the following options: access-log-path (type: string, default: ${NGINX_LOG_ROOT}/${APP}-access.log ): Log path for nginx access logs error-log-path (type: string, default: ${NGINX_LOG_ROOT}/${APP}-error.log ): Log path for nginx error logs The defaults should not be changed without verifying that the paths will be writeable by nginx. However, this setting is useful for enabling or disabling logging by setting the values to off . dokku nginx:set node-js-app access-log-path off dokku nginx:set node-js-app error-log-path off The default value may be set by passing an empty value for the option: dokku nginx:set node-js-app access-log-path dokku nginx:set node-js-app error-log-path In all cases, the nginx config must be regenerated after setting the above values. Changing log format New Introduced in 0.22.0 Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. The format of the access log can be changed by calling the nginx:set command as follows: dokku nginx:set node-js-app access-log-format custom-format Prior to changing the log-format, log formats should be specified at a file such as /etc/nginx/conf.d/00-log-formats.conf . This will ensure they are available within your app's nginx context. For instance, the following may be added to the above file. It only needs to be specified once to be used for all apps. # /etc/nginx/conf.d/00-log-formats.conf # escape=json was added in nginx 1.11.8 log_format json_combined escape=json ' { ' '\"time_local\":\" $time_local\",' '\"remote_addr\":\" $remote_addr\",' '\"remote_user\":\" $remote_user\",' '\"request\":\" $request\",' '\"status\":\" $status\",' '\"body_bytes_sent\":\" $body_bytes_sent\",' '\"request_time\":\" $request_time\",' '\"http_referrer\":\" $http_referer\",' '\"http_user_agent\":\" $http_user_agent\"' ' } ' ; Next, the format should be set for the given app. dokku nginx:set node-js-app access-log-format json_combined Finally, a proxy rebuild will change the format as desired. dokku proxy:build-config node-js-app Specifying a read timeout New Introduced in 0.21.0 Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. When proxying requests to your applications, it may be useful to specify a proxy read timeout. This can be done via the nginx:set command as follows: dokku nginx:set node-js-app proxy-read-timeout 120s The default value is 60s , and all numeric values must have a trailing time value specified ( s for seconds, m for minutes). The default value may be set by passing an empty value for the option: dokku nginx:set node-js-app proxy-read-timeout In all cases, the nginx config must be regenerated after setting the above value. Specifying a custom client_max_body_size New Introduced in 0.23.0 Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. Users can override the default client_max_body_size value - which limits file uploads - via nginx:set . Changing this value will only apply to every server stanza of the default nginx.conf.sigil ; users of custom nginx.conf.sigil files must update their templates to support the new value. dokku nginx:set node-js-app client-max-body-size 50m The default value is empty string, which will result in nginx falling back to any configured, higher-level defaults (or 1m if unconfigued; all numerical values must have a size unit specified ( k for kilobytes, m for megabytes). The default value may be set by passing an empty value for the option: dokku nginx:set node-js-app client-max-body-size In all cases, the nginx config must be regenerated after setting the above value. Changing this value when using the PHP buildpack (or any other buildpack that uses an intermediary server) will require changing the value in the server config shipped with that buildpack. Consult your buildpack documentation for further details. Showing the nginx config For debugging purposes, it may be useful to show the nginx config. This can be achieved via the nginx:show-config command. dokku nginx:show-config node-js-app Validating nginx configs It may be desired to validate an nginx config outside of the deployment process. To do so, run the nginx:validate-config command. With no arguments, this will validate all app nginx configs, one at a time. A minimal wrapper nginx config is generated for each app's nginx config, upon which nginx -t will be run. dokku nginx:validate-config As app nginx configs are actually executed within a shared context, it is possible for an individual config to be invalid when being validated standalone but also be valid within the global server context. As such, the exit code for the nginx:validate-config command is the exit code of nginx -t against the server's real nginx config. The nginx:validate-config command also takes an optional --clean flag. If specified, invalid nginx configs will be removed. Warning Invalid app nginx config's will be removed even if the config is valid in the global server context. dokku nginx:validate-config --clean The --clean flag may also be specified for a given app: dokku nginx:validate-config node-js-app --clean Customizing the nginx configuration New Introduced in 0.5.0 Dokku uses a templating library by the name of sigil to generate nginx configuration for each app. This may be overriden by committing the default configuration template to a file named nginx.conf.sigil in the root of the app repository. When deploying a monorepo, it may be desirable to specify the specific path of the nginx.conf.sigil file to use for a given app. This can be done via the nginx:set command. If a value is specified and that file does not exist in the app's build directory, Dokku will continue the build process as if the repository has no nginx.conf.sigil . dokku nginx:set node-js-app nginx-conf-sigil-path dokku/nginx.conf.sigil This property can also be changed globally, which will take into effect if there is no value at the app level. dokku nginx:set --global nginx-conf-sigil-path dokku/nginx.conf.sigil In either case, the value can be reset by specifying an empty value. dokku nginx:set node-js-app nginx-conf-sigil-path dokku nginx:set --global nginx-conf-sigil-path Info The default template may change with new releases of Dokku. Please refer to the appropriate template file version for your Dokku version, and make sure to look out for changes when you upgrade. Disabling custom nginx config Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. While enabled by default, using a custom nginx config can be disabled via nginx:set . This may be useful in cases where you do not want to allow users to override any higher-level customization of app nginx config. # enable fetching custom config (default) dokku nginx:set node-js-app disable-custom-config false # disable fetching custom config dokku nginx:set node-js-app disable-custom-config true Unsetting this value is the same as enabling custom nginx config usage. Available template variables {{ .APP }} Application name {{ .APP_SSL_PATH }} Path to SSL certificate and key {{ .DOKKU_ROOT }} Global Dokku root directory (ex: app dir would be `{{ .DOKKU_ROOT }}/{{ .APP }}`) {{ .PROXY_PORT }} Non-SSL nginx listener port (same as `DOKKU_PROXY_PORT` config var) {{ .PROXY_SSL_PORT }} SSL nginx listener port (same as `DOKKU_PROXY_SSL_PORT` config var) {{ .NOSSL_SERVER_NAME }} List of non-SSL VHOSTS {{ .PROXY_PORT_MAP }} List of port mappings (same as `DOKKU_PROXY_PORT_MAP` config var) {{ .PROXY_UPSTREAM_PORTS }} List of configured upstream ports (derived from `DOKKU_PROXY_PORT_MAP` config var) {{ .RAW_TCP_PORTS }} List of exposed tcp ports as defined by Dockerfile `EXPOSE` directive (**Dockerfile apps only**) {{ .SSL_INUSE }} Boolean set when an app is SSL-enabled {{ .SSL_SERVER_NAME }} List of SSL VHOSTS Finally, each process type has it's network listeners - a list of IP:PORT pairs for the respective app containers - exposed via an .DOKKU_APP_${PROCESS_TYPE}_LISTENERS variable - the PROCESS_TYPE will be upper-cased with hyphens transformed into underscores. Users can use the new variables to expose non-web processes via the nginx proxy. Note Application environment variables are available for use in custom templates. To do so, use the form of {{ var \"FOO\" }} to access a variable named FOO . Customizing via configuration files included by the default templates The default nginx.conf template will include everything from your apps nginx.conf.d/ subdirectory in the main server {} block (see above): include {{ .DOKKU_ROOT }}/{{ .APP }}/nginx.conf.d/*.conf; That means you can put additional configuration in separate files. To increase the client request header timeout, the following can be performed: mkdir /home/dokku/node-js-app/nginx.conf.d/ echo 'client_header_timeout 50s;' > /home/dokku/node-js-app/nginx.conf.d/timeout.conf chown dokku:dokku /home/dokku/node-js-app/nginx.conf.d/upload.conf service nginx reload The example above uses additional configuration files directly on the Dokku host. Unlike the nginx.conf.sigil file, these additional files will not be copied over from your application repo, and thus need to be placed in the /home/dokku/node-js-app/nginx.conf.d/ directory manually. For PHP Buildpack users, you will also need to provide a Procfile and an accompanying nginx.conf file to customize the nginx config within the container. The following are example contents for your Procfile web: vendor/bin/heroku-php-nginx -C nginx.conf -i php.ini php/ Your nginx.conf file - not to be confused with Dokku's nginx.conf.sigil - would also need to be configured as shown in this example: client_header_timeout 50s; location / { index index.php; try_files $uri $uri/ /index.php$is_args$args; } Please adjust the Procfile and nginx.conf file as appropriate. Custom Error Pages By default, Dokku provides custom error pages for the following three categories of errors: 4xx: For all non-404 errors with a 4xx response code. 404: For \"404 Not Found\" errors. 5xx: For all 5xx error responses These are provided as an alternative to the generic Nginx error page, are shared for all applications, and their contents are located on disk at /var/lib/dokku/data/nginx-vhosts/dokku-errors . To customize them for a specific app, create a custom nginx.conf.sigil as described above and change the paths to point elsewhere. Default site By default, Dokku will route any received request with an unknown HOST header value to the lexicographically first site in the nginx config stack. If this is not the desired behavior, you may want to add the following configuration to the global nginx configuration. Create the file at /etc/nginx/conf.d/00-default-vhost.conf : server { listen 80 default_server ; listen [::]:80 default_server ; server_name _ ; access_log off ; return 410 ; } # To handle HTTPS requests, you can uncomment the following section. # # Please note that in order to let this work as expected, you need a valid # SSL certificate for any domains being served. Browsers will show SSL # errors in all other cases. # # Note that the key and certificate files in the below example need to # be copied into /etc/nginx/ssl/ folder. # # server { # listen 443 ssl; # listen [::]:443 ssl; # server_name _; # ssl_certificate /etc/nginx/ssl/cert.crt; # ssl_certificate_key /etc/nginx/ssl/cert.key; # access_log off; # return 410; # } Make sure to reload nginx after creating this file by running service nginx reload . This will catch all unknown HOST header values and return a 410 Gone response. You can replace the return 410; with return 444; which will cause nginx to not respond to requests that do not match known domains (connection refused). The configuration file must be loaded before /etc/nginx/conf.d/dokku.conf , so it can not be arranged as a vhost in /etc/nginx/sites-enabled that is only processed afterwards. Alternatively, you may push an app to your Dokku host with a name like \"00-default\". As long as it lists first in ls /home/dokku/*/nginx.conf | head , it will be used as the default nginx vhost. Other Domains plugin See the domain configuration documentation for more information on how to configure domains for your app. Customizing hostnames See the customizing hostnames documentation for more information on how to configure domains for your app. Disabling VHOSTS See the disabling vhosts documentation for more information on how to disable domain usage for your app. Running behind a load balancer See the load balancer documentation for more information on how to configure your nginx config for running behind a network load balancer. SSL Configuration See the ssl documentation for more information on how to configure SSL certificates for your application. Disabling Nginx See the proxy documentation for more information on how to disable nginx as the proxy implementation for your app. Managing Proxy Port mappings See the proxy documentation for more information on how to manage ports proxied for your app. Regenerating nginx config See the proxy documentation for more information on how to rebuild the nginx proxy configuration for your app.","title":"Nginx Proxy"},{"location":"networking/proxies/nginx/#nginx-proxy","text":"Dokku uses nginx as its server for routing requests to specific applications. By default, access and error logs are written for each app to /var/log/nginx/${APP}-access.log and /var/log/nginx/${APP}-error.log respectively nginx:access-logs <app> [-t] # Show the nginx access logs for an application (-t follows) nginx:error-logs <app> [-t] # Show the nginx error logs for an application (-t follows) nginx:report [<app>] [<flag>] # Displays a nginx report for one or more apps nginx:set <app> <property> (<value>) # Set or clear an nginx property for an app nginx:show-config <app> # Display app nginx config nginx:start # Starts the nginx server nginx:stop # Stops the nginx server nginx:validate-config [<app>] [--clean] # Validates and optionally cleans up invalid nginx configurations","title":"Nginx Proxy"},{"location":"networking/proxies/nginx/#usage","text":"Warning As using multiple proxy plugins on a single Dokku installation can lead to issues routing requests to apps, doing so should be avoided.","title":"Usage"},{"location":"networking/proxies/nginx/#request-proxying","text":"By default, the web process is the only process proxied by the nginx proxy implementation. Proxying to other process types may be handled by a custom nginx.conf.sigil file, as generally described below Nginx will proxy the requests in a round-robin balancing fashion to the different deployed (scaled) containers running the web proctype. This way, the host's resources can be fully leveraged for single-threaded applications (e.g. dokku ps:scale node-js-app web=4 on a 4-core machine).","title":"Request Proxying"},{"location":"networking/proxies/nginx/#starting-nginx","text":"New Introduced in 0.28.0 The nginx server can be started via nginx:start . dokku nginx:start ```` ### Stopping nginx !!! tip \"New\" Introduced in 0 .28.0 The nginx server can be stopped via ` nginx:stop ` . ``` shell dokku nginx:stop ```` ### Binding to specific addresses !!! tip \"New\" Introduced in 0 .19.2 !!! note \"Note\" Changing this value globally or on a per-app basis will require rebuilding the nginx config via the ` proxy:build-config ` command. By default, nginx will listen to all interfaces ( ` [ :: ] ` for IPv6, ` 0 .0.0.0 ` for IPv4 ) when proxying requests to applications. This may be changed using the ` bind-address-ipv4 ` and ` bind-address-ipv6 ` properties. This is useful in cases where the proxying should be internal to a network or if there are multiple network interfaces that should respond with different content. ``` shell dokku nginx:set node-js-app bind-address-ipv4 127 .0.0.1 dokku nginx:set node-js-app bind-address-ipv6 ::1 This may be reverted by setting an empty bind address. dokku nginx:set node-js-app bind-address-ipv4 dokku nginx:set node-js-app bind-address-ipv6 Warning Validation is not performed on either value. Users with apps that contain a custom nginx.conf.sigil file will need to modify the files to respect the new NGINX_BIND_ADDRESS_IPV4 and NGINX_BIND_ADDRESS_IPV6 variables.","title":"Starting nginx"},{"location":"networking/proxies/nginx/#hsts-header","text":"New Introduced in 0.20.0 Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. If SSL certificates are present, HSTS will be automatically enabled. It can be toggled via nginx:set : dokku nginx:set node-js-app hsts true dokku nginx:set node-js-app hsts false The following options are also available via the nginx:set command: hsts (type: boolean, default: true ): Enables or disables HSTS for your application. hsts-include-subdomains (type: boolean, default: true ): Tells the browser that the HSTS policy also applies to all subdomains of the current domain. hsts-max-age (type: integer, default: 15724800 ): Time in seconds to cache HSTS configuration. hsts-preload (type: boolean, default: false ): Tells most major web browsers to include the domain in their HSTS preload lists. Beware that if you enable the header and a subsequent deploy of your application results in an HTTP deploy (for whatever reason), the way the header works means that a browser will not attempt to request the HTTP version of your site if the HTTPS version fails until the max-age is reached.","title":"HSTS Header"},{"location":"networking/proxies/nginx/#globally-disabling-the-hsts-header","text":"Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. HSTS Header can be disabled for all apps by setting the hsts property to false after passing the --global flag to nginx:set . dokku nginx:set --global hsts false Once the HSTS setting is disabled globally, it can be re-enabled on a per-app basis by setting the hsts property as normal. dokku nginx:set node-js-app hsts true","title":"Globally disabling the HSTS Header"},{"location":"networking/proxies/nginx/#checking-access-logs","text":"Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. You may check nginx access logs via the nginx:access-logs command. This assumes that app access logs are being stored in /var/log/nginx/$APP-access.log , as is the default in the generated nginx.conf . dokku nginx:access-logs node-js-app You may also follow the logs by specifying the -t flag. dokku nginx:access-logs node-js-app -t","title":"Checking access logs"},{"location":"networking/proxies/nginx/#checking-error-logs","text":"You may check nginx error logs via the nginx:error-logs command. This assumes that app error logs are being stored in /var/log/nginx/$APP-error.log , as is the default in the generated nginx.conf . dokku nginx:error-logs node-js-app You may also follow the logs by specifying the -t flag. dokku nginx:error-logs node-js-app -t","title":"Checking error logs"},{"location":"networking/proxies/nginx/#changing-log-path","text":"New Introduced in 0.20.1 Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. The path to where log files are stored can be changed by calling the nginx:set command with the following options: access-log-path (type: string, default: ${NGINX_LOG_ROOT}/${APP}-access.log ): Log path for nginx access logs error-log-path (type: string, default: ${NGINX_LOG_ROOT}/${APP}-error.log ): Log path for nginx error logs The defaults should not be changed without verifying that the paths will be writeable by nginx. However, this setting is useful for enabling or disabling logging by setting the values to off . dokku nginx:set node-js-app access-log-path off dokku nginx:set node-js-app error-log-path off The default value may be set by passing an empty value for the option: dokku nginx:set node-js-app access-log-path dokku nginx:set node-js-app error-log-path In all cases, the nginx config must be regenerated after setting the above values.","title":"Changing log path"},{"location":"networking/proxies/nginx/#changing-log-format","text":"New Introduced in 0.22.0 Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. The format of the access log can be changed by calling the nginx:set command as follows: dokku nginx:set node-js-app access-log-format custom-format Prior to changing the log-format, log formats should be specified at a file such as /etc/nginx/conf.d/00-log-formats.conf . This will ensure they are available within your app's nginx context. For instance, the following may be added to the above file. It only needs to be specified once to be used for all apps. # /etc/nginx/conf.d/00-log-formats.conf # escape=json was added in nginx 1.11.8 log_format json_combined escape=json ' { ' '\"time_local\":\" $time_local\",' '\"remote_addr\":\" $remote_addr\",' '\"remote_user\":\" $remote_user\",' '\"request\":\" $request\",' '\"status\":\" $status\",' '\"body_bytes_sent\":\" $body_bytes_sent\",' '\"request_time\":\" $request_time\",' '\"http_referrer\":\" $http_referer\",' '\"http_user_agent\":\" $http_user_agent\"' ' } ' ; Next, the format should be set for the given app. dokku nginx:set node-js-app access-log-format json_combined Finally, a proxy rebuild will change the format as desired. dokku proxy:build-config node-js-app","title":"Changing log format"},{"location":"networking/proxies/nginx/#specifying-a-read-timeout","text":"New Introduced in 0.21.0 Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. When proxying requests to your applications, it may be useful to specify a proxy read timeout. This can be done via the nginx:set command as follows: dokku nginx:set node-js-app proxy-read-timeout 120s The default value is 60s , and all numeric values must have a trailing time value specified ( s for seconds, m for minutes). The default value may be set by passing an empty value for the option: dokku nginx:set node-js-app proxy-read-timeout In all cases, the nginx config must be regenerated after setting the above value.","title":"Specifying a read timeout"},{"location":"networking/proxies/nginx/#specifying-a-custom-client_max_body_size","text":"New Introduced in 0.23.0 Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. Users can override the default client_max_body_size value - which limits file uploads - via nginx:set . Changing this value will only apply to every server stanza of the default nginx.conf.sigil ; users of custom nginx.conf.sigil files must update their templates to support the new value. dokku nginx:set node-js-app client-max-body-size 50m The default value is empty string, which will result in nginx falling back to any configured, higher-level defaults (or 1m if unconfigued; all numerical values must have a size unit specified ( k for kilobytes, m for megabytes). The default value may be set by passing an empty value for the option: dokku nginx:set node-js-app client-max-body-size In all cases, the nginx config must be regenerated after setting the above value. Changing this value when using the PHP buildpack (or any other buildpack that uses an intermediary server) will require changing the value in the server config shipped with that buildpack. Consult your buildpack documentation for further details.","title":"Specifying a custom client_max_body_size"},{"location":"networking/proxies/nginx/#showing-the-nginx-config","text":"For debugging purposes, it may be useful to show the nginx config. This can be achieved via the nginx:show-config command. dokku nginx:show-config node-js-app","title":"Showing the nginx config"},{"location":"networking/proxies/nginx/#validating-nginx-configs","text":"It may be desired to validate an nginx config outside of the deployment process. To do so, run the nginx:validate-config command. With no arguments, this will validate all app nginx configs, one at a time. A minimal wrapper nginx config is generated for each app's nginx config, upon which nginx -t will be run. dokku nginx:validate-config As app nginx configs are actually executed within a shared context, it is possible for an individual config to be invalid when being validated standalone but also be valid within the global server context. As such, the exit code for the nginx:validate-config command is the exit code of nginx -t against the server's real nginx config. The nginx:validate-config command also takes an optional --clean flag. If specified, invalid nginx configs will be removed. Warning Invalid app nginx config's will be removed even if the config is valid in the global server context. dokku nginx:validate-config --clean The --clean flag may also be specified for a given app: dokku nginx:validate-config node-js-app --clean","title":"Validating nginx configs"},{"location":"networking/proxies/nginx/#customizing-the-nginx-configuration","text":"New Introduced in 0.5.0 Dokku uses a templating library by the name of sigil to generate nginx configuration for each app. This may be overriden by committing the default configuration template to a file named nginx.conf.sigil in the root of the app repository. When deploying a monorepo, it may be desirable to specify the specific path of the nginx.conf.sigil file to use for a given app. This can be done via the nginx:set command. If a value is specified and that file does not exist in the app's build directory, Dokku will continue the build process as if the repository has no nginx.conf.sigil . dokku nginx:set node-js-app nginx-conf-sigil-path dokku/nginx.conf.sigil This property can also be changed globally, which will take into effect if there is no value at the app level. dokku nginx:set --global nginx-conf-sigil-path dokku/nginx.conf.sigil In either case, the value can be reset by specifying an empty value. dokku nginx:set node-js-app nginx-conf-sigil-path dokku nginx:set --global nginx-conf-sigil-path Info The default template may change with new releases of Dokku. Please refer to the appropriate template file version for your Dokku version, and make sure to look out for changes when you upgrade.","title":"Customizing the nginx configuration"},{"location":"networking/proxies/nginx/#disabling-custom-nginx-config","text":"Note Changing this value globally or on a per-app basis will require rebuilding the nginx config via the proxy:build-config command. While enabled by default, using a custom nginx config can be disabled via nginx:set . This may be useful in cases where you do not want to allow users to override any higher-level customization of app nginx config. # enable fetching custom config (default) dokku nginx:set node-js-app disable-custom-config false # disable fetching custom config dokku nginx:set node-js-app disable-custom-config true Unsetting this value is the same as enabling custom nginx config usage.","title":"Disabling custom nginx config"},{"location":"networking/proxies/nginx/#available-template-variables","text":"{{ .APP }} Application name {{ .APP_SSL_PATH }} Path to SSL certificate and key {{ .DOKKU_ROOT }} Global Dokku root directory (ex: app dir would be `{{ .DOKKU_ROOT }}/{{ .APP }}`) {{ .PROXY_PORT }} Non-SSL nginx listener port (same as `DOKKU_PROXY_PORT` config var) {{ .PROXY_SSL_PORT }} SSL nginx listener port (same as `DOKKU_PROXY_SSL_PORT` config var) {{ .NOSSL_SERVER_NAME }} List of non-SSL VHOSTS {{ .PROXY_PORT_MAP }} List of port mappings (same as `DOKKU_PROXY_PORT_MAP` config var) {{ .PROXY_UPSTREAM_PORTS }} List of configured upstream ports (derived from `DOKKU_PROXY_PORT_MAP` config var) {{ .RAW_TCP_PORTS }} List of exposed tcp ports as defined by Dockerfile `EXPOSE` directive (**Dockerfile apps only**) {{ .SSL_INUSE }} Boolean set when an app is SSL-enabled {{ .SSL_SERVER_NAME }} List of SSL VHOSTS Finally, each process type has it's network listeners - a list of IP:PORT pairs for the respective app containers - exposed via an .DOKKU_APP_${PROCESS_TYPE}_LISTENERS variable - the PROCESS_TYPE will be upper-cased with hyphens transformed into underscores. Users can use the new variables to expose non-web processes via the nginx proxy. Note Application environment variables are available for use in custom templates. To do so, use the form of {{ var \"FOO\" }} to access a variable named FOO .","title":"Available template variables"},{"location":"networking/proxies/nginx/#customizing-via-configuration-files-included-by-the-default-templates","text":"The default nginx.conf template will include everything from your apps nginx.conf.d/ subdirectory in the main server {} block (see above): include {{ .DOKKU_ROOT }}/{{ .APP }}/nginx.conf.d/*.conf; That means you can put additional configuration in separate files. To increase the client request header timeout, the following can be performed: mkdir /home/dokku/node-js-app/nginx.conf.d/ echo 'client_header_timeout 50s;' > /home/dokku/node-js-app/nginx.conf.d/timeout.conf chown dokku:dokku /home/dokku/node-js-app/nginx.conf.d/upload.conf service nginx reload The example above uses additional configuration files directly on the Dokku host. Unlike the nginx.conf.sigil file, these additional files will not be copied over from your application repo, and thus need to be placed in the /home/dokku/node-js-app/nginx.conf.d/ directory manually. For PHP Buildpack users, you will also need to provide a Procfile and an accompanying nginx.conf file to customize the nginx config within the container. The following are example contents for your Procfile web: vendor/bin/heroku-php-nginx -C nginx.conf -i php.ini php/ Your nginx.conf file - not to be confused with Dokku's nginx.conf.sigil - would also need to be configured as shown in this example: client_header_timeout 50s; location / { index index.php; try_files $uri $uri/ /index.php$is_args$args; } Please adjust the Procfile and nginx.conf file as appropriate.","title":"Customizing via configuration files included by the default templates"},{"location":"networking/proxies/nginx/#custom-error-pages","text":"By default, Dokku provides custom error pages for the following three categories of errors: 4xx: For all non-404 errors with a 4xx response code. 404: For \"404 Not Found\" errors. 5xx: For all 5xx error responses These are provided as an alternative to the generic Nginx error page, are shared for all applications, and their contents are located on disk at /var/lib/dokku/data/nginx-vhosts/dokku-errors . To customize them for a specific app, create a custom nginx.conf.sigil as described above and change the paths to point elsewhere.","title":"Custom Error Pages"},{"location":"networking/proxies/nginx/#default-site","text":"By default, Dokku will route any received request with an unknown HOST header value to the lexicographically first site in the nginx config stack. If this is not the desired behavior, you may want to add the following configuration to the global nginx configuration. Create the file at /etc/nginx/conf.d/00-default-vhost.conf : server { listen 80 default_server ; listen [::]:80 default_server ; server_name _ ; access_log off ; return 410 ; } # To handle HTTPS requests, you can uncomment the following section. # # Please note that in order to let this work as expected, you need a valid # SSL certificate for any domains being served. Browsers will show SSL # errors in all other cases. # # Note that the key and certificate files in the below example need to # be copied into /etc/nginx/ssl/ folder. # # server { # listen 443 ssl; # listen [::]:443 ssl; # server_name _; # ssl_certificate /etc/nginx/ssl/cert.crt; # ssl_certificate_key /etc/nginx/ssl/cert.key; # access_log off; # return 410; # } Make sure to reload nginx after creating this file by running service nginx reload . This will catch all unknown HOST header values and return a 410 Gone response. You can replace the return 410; with return 444; which will cause nginx to not respond to requests that do not match known domains (connection refused). The configuration file must be loaded before /etc/nginx/conf.d/dokku.conf , so it can not be arranged as a vhost in /etc/nginx/sites-enabled that is only processed afterwards. Alternatively, you may push an app to your Dokku host with a name like \"00-default\". As long as it lists first in ls /home/dokku/*/nginx.conf | head , it will be used as the default nginx vhost.","title":"Default site"},{"location":"networking/proxies/nginx/#other","text":"","title":"Other"},{"location":"networking/proxies/nginx/#domains-plugin","text":"See the domain configuration documentation for more information on how to configure domains for your app.","title":"Domains plugin"},{"location":"networking/proxies/nginx/#customizing-hostnames","text":"See the customizing hostnames documentation for more information on how to configure domains for your app.","title":"Customizing hostnames"},{"location":"networking/proxies/nginx/#disabling-vhosts","text":"See the disabling vhosts documentation for more information on how to disable domain usage for your app.","title":"Disabling VHOSTS"},{"location":"networking/proxies/nginx/#running-behind-a-load-balancer","text":"See the load balancer documentation for more information on how to configure your nginx config for running behind a network load balancer.","title":"Running behind a load balancer"},{"location":"networking/proxies/nginx/#ssl-configuration","text":"See the ssl documentation for more information on how to configure SSL certificates for your application.","title":"SSL Configuration"},{"location":"networking/proxies/nginx/#disabling-nginx","text":"See the proxy documentation for more information on how to disable nginx as the proxy implementation for your app.","title":"Disabling Nginx"},{"location":"networking/proxies/nginx/#managing-proxy-port-mappings","text":"See the proxy documentation for more information on how to manage ports proxied for your app.","title":"Managing Proxy Port mappings"},{"location":"networking/proxies/nginx/#regenerating-nginx-config","text":"See the proxy documentation for more information on how to rebuild the nginx proxy configuration for your app.","title":"Regenerating nginx config"},{"location":"networking/proxies/traefik/","text":"Traefik Proxy New Introduced in 0.28.0 Dokku provides integration with the Traefik proxy service by utilizing the Docker label-based integration implemented by Traefik. traefik:report [<app>] [<flag>] # Displays a traefik report for one or more apps traefik:logs [--num num] [--tail] # Display traefik log output traefik:set <app> <property> (<value>) # Set or clear an traefik property for an app traefik:show-config <app> # Display traefik compose config traefik:start # Starts the traefik server traefik:stop # Stops the traefik server Requirements Using the traefik plugin integration requires the docker-compose-plugin for Docker. See this document from the Docker documentation for more information on the installation process for the docker-compose-plugin . Usage Warning As using multiple proxy plugins on a single Dokku installation can lead to issues routing requests to apps, doing so should be avoided. As the default proxy implementation is nginx, users are encouraged to stop the nginx service before switching to Traefik. The Traefik plugin has specific rules for routing requests: Traefik integration is exposed via docker labels attached to containers. Changes in labels require either app deploys or rebuilds. While Traefik will respect labels associated with other containers, only web containers have Traefik labels injected by the plugin. Only http:80 and https:443 port mappings are supported. If no http:80 mapping is found, the first http port mapping is used for http requests. If no https:443 mapping is found, the first https port mapping is used for https requests. If no https mapping is found, the container port from http:80 will be used for https requests. Requests are routed as soon as the container is running and passing healthchecks. Switching to Traefik To use the Traefik plugin, use the proxy:set command for the app in question: dokku proxy:set node-js-app traefik This will enable the docker label-based Traefik integration. All future deploys will inject the correct labels for Traefik to read and route requests to containers. Due to the docker label-based integration used by Traefik, a single deploy or rebuild will be required before requests will route successfully. dokku ps:rebuild node-js-app Any changes to domains or port mappings will also require either a deploy or rebuild. Starting Traefik container Traefik can be started via the traefik:start command. This will start a Traefik container via the docker compose up command. dokku traefik:start Stopping the Traefik container Traefik may be stopped via the traefik:stop command. dokku traefik:stop The Traefik container will be stopped and removed from the system. If the container is not running, this command will do nothing. Showing the Traefik compose config For debugging purposes, it may be useful to show the Traefik compose config. This can be achieved via the traefik:show-config command. dokku traefik:show-config Customizing the Traefik container image While the default Traefik image is hardcoded, users may specify an alternative by setting the image property with the --global flag: dokku traefik:set --global image traefik:v2.8 Checking the Traefik container's logs It may be necessary to check the Traefik container's logs to ensure that Traefik is operating as expected. This can be performed with the traefik:logs command. dokku traefik:logs This command also supports the following modifiers: --num NUM # the number of lines to display --tail # continually stream logs You can use these modifiers as follows: dokku traefik:logs --tail --num 10 The above command will show logs continually from the vector container, with an initial history of 10 log lines Changing the Traefik log level Traefik log output is set to ERROR by default. It may be changed by setting the log-level property with the --global flag: dokku traefik:set --global log-level DEBUG After modifying, the Traefik container will need to be restarted. Setting rule priority By default, app deployments will result in the newer traefik rules using a higher priority in order to have any newer rules respected by Traefik. Rule priorities will always increase according to the current unix timestamp. The priority may be fixed by setting the app-level priority property: dokku traefik:set node-js-app priority 12345 After modifying, the app container will need to be recreated via a ps:rebuild or an app deployment. SSL Configuration The traefik plugin only supports automatic ssl certificates from it's letsencrypt integration. Managed certificates provided by the certs plugin are ignored. Enabling letsencrypt integration By default, letsencrypt is disabled and https port mappings are ignored. To enable, set the letsencrypt-email property with the --global flag: dokku traefik:set --global letsencrypt-email automated@dokku.sh After enabling, apps will need to be rebuilt and the Traefik container will need to be restarted. All http requests will then be redirected to https. Customizing the letsencrypt server The letsencrypt integration is set to the production letsencrypt server by default. To change this, set the letsencrypt-server property with the --global flag: dokku traefik:set --global letsencrypt-server https://acme-staging-v02.api.letsencrypt.org/directory After enabling, the Traefik container will need to be restarted and apps will need to be rebuilt to retrieve certificates from the new server. API Access Traefik exposes an API and Dashboard, which Dokku disables by default for security reasons. It can be exposed and customized as described below. Enabling the api Warning Users enabling the dashboard should also enable api basic auth. By default, the api is disabled. To enable, set the api property with the --global flag: dokku traefik:set --global api true After enabling, the Traefik container will need to be restarted. Enabling the dashboard Warning Users enabling the dashboard should also enable api basic auth. By default, the dashboard is disabled. To enable, set the dashboard property with the --global flag: dokku traefik:set --global dashboard true After enabling, the Traefik container will need to be restarted. Enabling api basic auth Users enabling either the api or dashboard are encouraged to enable basic auth. This will apply only to the api/dashboard, and not to apps. To enable, set the basic-auth-username and basic-auth-password properties with the --global flag:. Both must be set or basic auth will not be enabled. dokku traefik:set --global basic-auth-username username dokku traefik:set --global basic-auth-password password After enabling, the Traefik container will need to be restarted. Customizing the api hostname The hostname used for the api and dashboard is set to traefik.dokku.me by default. It can be customized by setting the api-vhost property with the --global flag: dokku traefik:set --global api-vhost lb.dokku.me After enabling, the Traefik container will need to be restarted. Displaying Traefik reports for an app You can get a report about the app's Traefik config using the traefik:report command: Shell Output dokku traefik:report =====> node-js-app traefik information Traefik api enabled: false Traefik api vhost: traefik.dokku.me Traefik basic auth password: password Traefik basic auth username: user Traefik dashboard enabled: false Traefik image: traefik:v2.8 Traefik letsencrypt email: Traefik letsencrypt server: Traefik log level: ERROR =====> python-app traefik information Traefik api enabled: false Traefik api vhost: traefik.dokku.me Traefik basic auth password: password Traefik basic auth username: user Traefik dashboard enabled: false Traefik image: traefik:v2.8 Traefik letsencrypt email: Traefik letsencrypt server: Traefik log level: ERROR =====> ruby-app traefik information Traefik api enabled: false Traefik api vhost: traefik.dokku.me Traefik basic auth password: password Traefik basic auth username: user Traefik dashboard enabled: false Traefik image: traefik:v2.8 Traefik letsencrypt email: Traefik letsencrypt server: Traefik log level: ERROR You can run the command for a specific app also. Shell Output dokku traefik:report node-js-app =====> node-js-app traefik information Traefik api enabled: false Traefik api vhost: traefik.dokku.me Traefik basic auth password: password Traefik basic auth username: user Traefik dashboard enabled: false Traefik image: traefik:v2.8 Traefik letsencrypt email: Traefik letsencrypt server: Traefik log level: ERROR You can pass flags which will output only the value of the specific information you want. For example: dokku traefik:report node-js-app --traefik-api-enabled","title":"Traefik Proxy"},{"location":"networking/proxies/traefik/#traefik-proxy","text":"New Introduced in 0.28.0 Dokku provides integration with the Traefik proxy service by utilizing the Docker label-based integration implemented by Traefik. traefik:report [<app>] [<flag>] # Displays a traefik report for one or more apps traefik:logs [--num num] [--tail] # Display traefik log output traefik:set <app> <property> (<value>) # Set or clear an traefik property for an app traefik:show-config <app> # Display traefik compose config traefik:start # Starts the traefik server traefik:stop # Stops the traefik server","title":"Traefik Proxy"},{"location":"networking/proxies/traefik/#requirements","text":"Using the traefik plugin integration requires the docker-compose-plugin for Docker. See this document from the Docker documentation for more information on the installation process for the docker-compose-plugin .","title":"Requirements"},{"location":"networking/proxies/traefik/#usage","text":"Warning As using multiple proxy plugins on a single Dokku installation can lead to issues routing requests to apps, doing so should be avoided. As the default proxy implementation is nginx, users are encouraged to stop the nginx service before switching to Traefik. The Traefik plugin has specific rules for routing requests: Traefik integration is exposed via docker labels attached to containers. Changes in labels require either app deploys or rebuilds. While Traefik will respect labels associated with other containers, only web containers have Traefik labels injected by the plugin. Only http:80 and https:443 port mappings are supported. If no http:80 mapping is found, the first http port mapping is used for http requests. If no https:443 mapping is found, the first https port mapping is used for https requests. If no https mapping is found, the container port from http:80 will be used for https requests. Requests are routed as soon as the container is running and passing healthchecks.","title":"Usage"},{"location":"networking/proxies/traefik/#switching-to-traefik","text":"To use the Traefik plugin, use the proxy:set command for the app in question: dokku proxy:set node-js-app traefik This will enable the docker label-based Traefik integration. All future deploys will inject the correct labels for Traefik to read and route requests to containers. Due to the docker label-based integration used by Traefik, a single deploy or rebuild will be required before requests will route successfully. dokku ps:rebuild node-js-app Any changes to domains or port mappings will also require either a deploy or rebuild.","title":"Switching to Traefik"},{"location":"networking/proxies/traefik/#starting-traefik-container","text":"Traefik can be started via the traefik:start command. This will start a Traefik container via the docker compose up command. dokku traefik:start","title":"Starting Traefik container"},{"location":"networking/proxies/traefik/#stopping-the-traefik-container","text":"Traefik may be stopped via the traefik:stop command. dokku traefik:stop The Traefik container will be stopped and removed from the system. If the container is not running, this command will do nothing.","title":"Stopping the Traefik container"},{"location":"networking/proxies/traefik/#showing-the-traefik-compose-config","text":"For debugging purposes, it may be useful to show the Traefik compose config. This can be achieved via the traefik:show-config command. dokku traefik:show-config","title":"Showing the Traefik compose config"},{"location":"networking/proxies/traefik/#customizing-the-traefik-container-image","text":"While the default Traefik image is hardcoded, users may specify an alternative by setting the image property with the --global flag: dokku traefik:set --global image traefik:v2.8","title":"Customizing the Traefik container image"},{"location":"networking/proxies/traefik/#checking-the-traefik-containers-logs","text":"It may be necessary to check the Traefik container's logs to ensure that Traefik is operating as expected. This can be performed with the traefik:logs command. dokku traefik:logs This command also supports the following modifiers: --num NUM # the number of lines to display --tail # continually stream logs You can use these modifiers as follows: dokku traefik:logs --tail --num 10 The above command will show logs continually from the vector container, with an initial history of 10 log lines","title":"Checking the Traefik container's logs"},{"location":"networking/proxies/traefik/#changing-the-traefik-log-level","text":"Traefik log output is set to ERROR by default. It may be changed by setting the log-level property with the --global flag: dokku traefik:set --global log-level DEBUG After modifying, the Traefik container will need to be restarted.","title":"Changing the Traefik log level"},{"location":"networking/proxies/traefik/#setting-rule-priority","text":"By default, app deployments will result in the newer traefik rules using a higher priority in order to have any newer rules respected by Traefik. Rule priorities will always increase according to the current unix timestamp. The priority may be fixed by setting the app-level priority property: dokku traefik:set node-js-app priority 12345 After modifying, the app container will need to be recreated via a ps:rebuild or an app deployment.","title":"Setting rule priority"},{"location":"networking/proxies/traefik/#ssl-configuration","text":"The traefik plugin only supports automatic ssl certificates from it's letsencrypt integration. Managed certificates provided by the certs plugin are ignored.","title":"SSL Configuration"},{"location":"networking/proxies/traefik/#enabling-letsencrypt-integration","text":"By default, letsencrypt is disabled and https port mappings are ignored. To enable, set the letsencrypt-email property with the --global flag: dokku traefik:set --global letsencrypt-email automated@dokku.sh After enabling, apps will need to be rebuilt and the Traefik container will need to be restarted. All http requests will then be redirected to https.","title":"Enabling letsencrypt integration"},{"location":"networking/proxies/traefik/#customizing-the-letsencrypt-server","text":"The letsencrypt integration is set to the production letsencrypt server by default. To change this, set the letsencrypt-server property with the --global flag: dokku traefik:set --global letsencrypt-server https://acme-staging-v02.api.letsencrypt.org/directory After enabling, the Traefik container will need to be restarted and apps will need to be rebuilt to retrieve certificates from the new server.","title":"Customizing the letsencrypt server"},{"location":"networking/proxies/traefik/#api-access","text":"Traefik exposes an API and Dashboard, which Dokku disables by default for security reasons. It can be exposed and customized as described below.","title":"API Access"},{"location":"networking/proxies/traefik/#enabling-the-api","text":"Warning Users enabling the dashboard should also enable api basic auth. By default, the api is disabled. To enable, set the api property with the --global flag: dokku traefik:set --global api true After enabling, the Traefik container will need to be restarted.","title":"Enabling the api"},{"location":"networking/proxies/traefik/#enabling-the-dashboard","text":"Warning Users enabling the dashboard should also enable api basic auth. By default, the dashboard is disabled. To enable, set the dashboard property with the --global flag: dokku traefik:set --global dashboard true After enabling, the Traefik container will need to be restarted.","title":"Enabling the dashboard"},{"location":"networking/proxies/traefik/#enabling-api-basic-auth","text":"Users enabling either the api or dashboard are encouraged to enable basic auth. This will apply only to the api/dashboard, and not to apps. To enable, set the basic-auth-username and basic-auth-password properties with the --global flag:. Both must be set or basic auth will not be enabled. dokku traefik:set --global basic-auth-username username dokku traefik:set --global basic-auth-password password After enabling, the Traefik container will need to be restarted.","title":"Enabling api basic auth"},{"location":"networking/proxies/traefik/#customizing-the-api-hostname","text":"The hostname used for the api and dashboard is set to traefik.dokku.me by default. It can be customized by setting the api-vhost property with the --global flag: dokku traefik:set --global api-vhost lb.dokku.me After enabling, the Traefik container will need to be restarted.","title":"Customizing the api hostname"},{"location":"networking/proxies/traefik/#displaying-traefik-reports-for-an-app","text":"You can get a report about the app's Traefik config using the traefik:report command: Shell Output dokku traefik:report =====> node-js-app traefik information Traefik api enabled: false Traefik api vhost: traefik.dokku.me Traefik basic auth password: password Traefik basic auth username: user Traefik dashboard enabled: false Traefik image: traefik:v2.8 Traefik letsencrypt email: Traefik letsencrypt server: Traefik log level: ERROR =====> python-app traefik information Traefik api enabled: false Traefik api vhost: traefik.dokku.me Traefik basic auth password: password Traefik basic auth username: user Traefik dashboard enabled: false Traefik image: traefik:v2.8 Traefik letsencrypt email: Traefik letsencrypt server: Traefik log level: ERROR =====> ruby-app traefik information Traefik api enabled: false Traefik api vhost: traefik.dokku.me Traefik basic auth password: password Traefik basic auth username: user Traefik dashboard enabled: false Traefik image: traefik:v2.8 Traefik letsencrypt email: Traefik letsencrypt server: Traefik log level: ERROR You can run the command for a specific app also. Shell Output dokku traefik:report node-js-app =====> node-js-app traefik information Traefik api enabled: false Traefik api vhost: traefik.dokku.me Traefik basic auth password: password Traefik basic auth username: user Traefik dashboard enabled: false Traefik image: traefik:v2.8 Traefik letsencrypt email: Traefik letsencrypt server: Traefik log level: ERROR You can pass flags which will output only the value of the specific information you want. For example: dokku traefik:report node-js-app --traefik-api-enabled","title":"Displaying Traefik reports for an app"},{"location":"processes/entering-containers/","text":"Entering containers New Introduced in 0.4.0 enter <app> [<container-type> || --container-id <container-id>] # Connect to a specific app container Usage The enter command can be used to enter a running container. The following variations of the command exist: # enter the web process dokku enter node-js-app web # enter the first web process dokku enter node-js-app web.1 # enter a process for an app by container ID dokku enter node-js-app --container-id ID The container-type argument can be one either: If your app has a Procfile , the name of a process type in your Procfile . If your app has no Procfile , the word web . If the specified process type is scaled up to more than one container, then the first container will be automatically selected. this can be overriden by specifying an integer index denoting the desired container, where the first container's index is 1 . Additionally, the enter command can be executed with no <container-type> . If only a single <container-type> is defined in the app's Procfile, executing enter will drop the terminal into the only running container. This behavior is not supported when specifying a custom command; as described below. By default, dokku enter will run a /bin/bash , but can also be used to run custom commands: # just echo hi dokku enter node-js-app web echo hi # run a long-running command, as one might for a cron task dokku enter node-js-app web python script/background-worker.py","title":"Entering containers"},{"location":"processes/entering-containers/#entering-containers","text":"New Introduced in 0.4.0 enter <app> [<container-type> || --container-id <container-id>] # Connect to a specific app container","title":"Entering containers"},{"location":"processes/entering-containers/#usage","text":"The enter command can be used to enter a running container. The following variations of the command exist: # enter the web process dokku enter node-js-app web # enter the first web process dokku enter node-js-app web.1 # enter a process for an app by container ID dokku enter node-js-app --container-id ID The container-type argument can be one either: If your app has a Procfile , the name of a process type in your Procfile . If your app has no Procfile , the word web . If the specified process type is scaled up to more than one container, then the first container will be automatically selected. this can be overriden by specifying an integer index denoting the desired container, where the first container's index is 1 . Additionally, the enter command can be executed with no <container-type> . If only a single <container-type> is defined in the app's Procfile, executing enter will drop the terminal into the only running container. This behavior is not supported when specifying a custom command; as described below. By default, dokku enter will run a /bin/bash , but can also be used to run custom commands: # just echo hi dokku enter node-js-app web echo hi # run a long-running command, as one might for a cron task dokku enter node-js-app web python script/background-worker.py","title":"Usage"},{"location":"processes/one-off-tasks/","text":"One-off Tasks run [-e|--env KEY=VALUE] [--no-tty] <app> <cmd> # Run a command in a new container using the current app image run:detached [-e|-env KEY=VALUE] [--no-tty] <app> <cmd> # Run a command in a new detached container using the current app image run:list [--format json|stdout] [<app>] # List all run containers for an app run:logs <app|--container CONTAINER> [-h] [-t] [-n num] [-q] # Display recent log output for run containers run:stop <app|--container CONTAINER> # Stops all run containers for an app or a specified run container Sometimes it is necessary to run a one-off command under an app. Dokku makes it easy to run a fresh container via the run command. Usage Running a one-off command The run command can be used to run a one-off process for a specific command. This will start a new container and run the desired command within that container. The container image will be the same container image as was used to start the currently deployed app. New Introduced in 0.25.0, this container will be removed after the process exits. # runs `ls -lah` in the `/app` directory of the app `node-js-app` dokku run node-js-app ls -lah # optionally, run can be passed custom environment variables dokku run --env \"NODE_ENV=development\" --env \"PATH=/custom/path\" node-js-app npm run mytask One off containers are removed at the end of process execution. Running Procfile commands The run command can also be used to run a command defined in the app Procfile : console: bundle exec racksh # runs `bundle exec racksh` in the `/app` directory of the app `my-app` dokku run my-app console Specifying container labels Containers may have specific labels attached. In order to avoid issues with dokku internals, do not use any labels beginning with either com.dokku or org.label-schema . dokku --label = com.example.test-label = value run node-js-app ls -lah Disabling TTY New Introduced in 0.25.0 One-off containers default to interactive mode where possible. To disable this behavior, specify the --no-tty flag: dokku run --no-tty node-js-app ls -lah Running a detached container New Introduced in 0.25.0 Finally, a container can be run in \"detached\" mode via the run:detached Dokku command. Running a process in detached mode will immediately return a CONTAINER_ID . Detached containers are run without a tty and are also removed at the end of process execution. dokku run:detached node-js-app ls -lah # returns the ID of the new container Displaying one-off container logs You can easily get logs of all one-off containers for an app using the logs command: dokku run:logs node-js-app Logs are pulled via integration with the scheduler for the specified application via \"live tailing\". As such, logs from previously running deployments are usually not available. Users that desire to see logs from previous deployments for debugging purposes should persist those logs to external services. Please see Dokku's vector integration for more information on how to persist logs across deployments to ship logs to another service or a third-party platform. Behavioral modifiers Dokku also supports certain command-line arguments that augment the run:log command's behavior. --container NAME # the name of a specific container to show logs for -n, --num NUM # the number of lines to display -t, --tail # continually stream logs -q, --quiet # display raw logs without colors, time and names You can use these modifiers as follows: dokku run:logs -t --container node-js-app.run.1234 The above command will show logs continually from the node-js-app.run.1234 one-off run process. Listing one-off containers New Introduced in 0.25.0 One-off containers for a given app can be listed via the run:list command: Shell Output dokku run:list node-js-app =====> node-js-app run containers NAMES COMMAND CREATED node-js-app.run.28689 \"/exec sleep 15\" 2 seconds ago Info The COMMAND displayed will be what Docker executes and may not exactly match the command specified by a dokku run command. The output can also be shown in json format: Shell Output dokku run:list node-js-app --format json [ { \"name\": \"node-js-app.run.28689\", \"state\": \"running\", \"command\": \"\\\"/exec 'sleep 15'\\\"\", \"created_at\": \"2022-08-03 05:47:44 +0000 UTC\" } ] Stopping a one-off cotainer New Introduced in 0.29.0 Run containers for an app can be stopped via the run:stop command. The output will be the container id. node-js-app.run.2313 Shell Output # start a container # the output will be something like: node-js-app.run.2313 dokku run node-js-app sleep 300 # stop the container dokku run:stop --container node-js-app.run.2313 ```` dokku run:stop node-js-app All containers for a given app can be stopped by specifying the app name. node-js-app.run.2313 node-js-app.run.574 ```","title":"One-off Tasks"},{"location":"processes/one-off-tasks/#one-off-tasks","text":"run [-e|--env KEY=VALUE] [--no-tty] <app> <cmd> # Run a command in a new container using the current app image run:detached [-e|-env KEY=VALUE] [--no-tty] <app> <cmd> # Run a command in a new detached container using the current app image run:list [--format json|stdout] [<app>] # List all run containers for an app run:logs <app|--container CONTAINER> [-h] [-t] [-n num] [-q] # Display recent log output for run containers run:stop <app|--container CONTAINER> # Stops all run containers for an app or a specified run container Sometimes it is necessary to run a one-off command under an app. Dokku makes it easy to run a fresh container via the run command.","title":"One-off Tasks"},{"location":"processes/one-off-tasks/#usage","text":"","title":"Usage"},{"location":"processes/one-off-tasks/#running-a-one-off-command","text":"The run command can be used to run a one-off process for a specific command. This will start a new container and run the desired command within that container. The container image will be the same container image as was used to start the currently deployed app. New Introduced in 0.25.0, this container will be removed after the process exits. # runs `ls -lah` in the `/app` directory of the app `node-js-app` dokku run node-js-app ls -lah # optionally, run can be passed custom environment variables dokku run --env \"NODE_ENV=development\" --env \"PATH=/custom/path\" node-js-app npm run mytask One off containers are removed at the end of process execution.","title":"Running a one-off command"},{"location":"processes/one-off-tasks/#running-procfile-commands","text":"The run command can also be used to run a command defined in the app Procfile : console: bundle exec racksh # runs `bundle exec racksh` in the `/app` directory of the app `my-app` dokku run my-app console","title":"Running Procfile commands"},{"location":"processes/one-off-tasks/#specifying-container-labels","text":"Containers may have specific labels attached. In order to avoid issues with dokku internals, do not use any labels beginning with either com.dokku or org.label-schema . dokku --label = com.example.test-label = value run node-js-app ls -lah","title":"Specifying container labels"},{"location":"processes/one-off-tasks/#disabling-tty","text":"New Introduced in 0.25.0 One-off containers default to interactive mode where possible. To disable this behavior, specify the --no-tty flag: dokku run --no-tty node-js-app ls -lah","title":"Disabling TTY"},{"location":"processes/one-off-tasks/#running-a-detached-container","text":"New Introduced in 0.25.0 Finally, a container can be run in \"detached\" mode via the run:detached Dokku command. Running a process in detached mode will immediately return a CONTAINER_ID . Detached containers are run without a tty and are also removed at the end of process execution. dokku run:detached node-js-app ls -lah # returns the ID of the new container","title":"Running a detached container"},{"location":"processes/one-off-tasks/#displaying-one-off-container-logs","text":"You can easily get logs of all one-off containers for an app using the logs command: dokku run:logs node-js-app Logs are pulled via integration with the scheduler for the specified application via \"live tailing\". As such, logs from previously running deployments are usually not available. Users that desire to see logs from previous deployments for debugging purposes should persist those logs to external services. Please see Dokku's vector integration for more information on how to persist logs across deployments to ship logs to another service or a third-party platform.","title":"Displaying one-off container logs"},{"location":"processes/one-off-tasks/#behavioral-modifiers","text":"Dokku also supports certain command-line arguments that augment the run:log command's behavior. --container NAME # the name of a specific container to show logs for -n, --num NUM # the number of lines to display -t, --tail # continually stream logs -q, --quiet # display raw logs without colors, time and names You can use these modifiers as follows: dokku run:logs -t --container node-js-app.run.1234 The above command will show logs continually from the node-js-app.run.1234 one-off run process.","title":"Behavioral modifiers"},{"location":"processes/one-off-tasks/#listing-one-off-containers","text":"New Introduced in 0.25.0 One-off containers for a given app can be listed via the run:list command: Shell Output dokku run:list node-js-app =====> node-js-app run containers NAMES COMMAND CREATED node-js-app.run.28689 \"/exec sleep 15\" 2 seconds ago Info The COMMAND displayed will be what Docker executes and may not exactly match the command specified by a dokku run command. The output can also be shown in json format: Shell Output dokku run:list node-js-app --format json [ { \"name\": \"node-js-app.run.28689\", \"state\": \"running\", \"command\": \"\\\"/exec 'sleep 15'\\\"\", \"created_at\": \"2022-08-03 05:47:44 +0000 UTC\" } ]","title":"Listing one-off containers"},{"location":"processes/one-off-tasks/#stopping-a-one-off-cotainer","text":"New Introduced in 0.29.0 Run containers for an app can be stopped via the run:stop command. The output will be the container id. node-js-app.run.2313 Shell Output # start a container # the output will be something like: node-js-app.run.2313 dokku run node-js-app sleep 300 # stop the container dokku run:stop --container node-js-app.run.2313 ```` dokku run:stop node-js-app All containers for a given app can be stopped by specifying the app name. node-js-app.run.2313 node-js-app.run.574 ```","title":"Stopping a one-off cotainer"},{"location":"processes/process-management/","text":"Process Management New Introduced in 0.3.14, Enhanced in 0.7.0 ps:inspect <app> # Displays a sanitized version of docker inspect for an app ps:rebuild [--parallel count] [--all|<app>] # Rebuilds an app from source ps:report [<app>] [<flag>] # Displays a process report for one or more apps ps:restart [--parallel count] [--all|<app>] [<process-name>] # Restart an app ps:restore [<app>] # Start previously running apps e.g. after reboot ps:scale [--skip-deploy] <app> <proc>=<count> [<proc>=<count>...] # Get/Set how many instances of a given process to run ps:set <app> <key> <value> # Set or clear a ps property for an app ps:start [--parallel count] [--all|<app>] # Start an app ps:stop [--parallel count] [--all|<app>] # Stop an app Usage Inspecting app containers New Introduced in 0.13.0 A common administrative task to perform is calling docker inspect on the containers that are running for an app. This can be an error-prone task to perform, and may also reveal sensitive environment variables if not done correctly. Dokku provides a wrapper around this command via the ps:inspect command: dokku ps:inspect node-js-app This command will gather all the running container IDs for your app and call docker inspect , sanitizing the output data so it can be copy-pasted elsewhere safely. Rebuilding apps It may be useful to rebuild an app at will, such as for commands that do not rebuild an app or when skipping a rebuild after setting multiple config values. For these use cases, the ps:rebuild function can be used. dokku ps:rebuild node-js-app All apps may be rebuilt by using the --all flag. dokku ps:rebuild --all By default, rebuilding all apps happens serially. The parallelism may be controlled by the --parallel flag. dokku ps:rebuild --all --parallel 2 Finally, the number of parallel workers may be automatically set to the number of CPUs available by setting the --parallel flag to -1 dokku ps:rebuild --all --parallel -1 A missing linked container will result in failure to boot apps. Services should all be started for apps being rebuilt. Restarting apps An app may be restarted using the ps:restart command. dokku ps:restart node-js-app A single process type - such as web or worker - may also be specified. This does not support specifying a given instance of a process type, and only supports restarting all instances of that process type. dokku ps:restart node-js-app web All apps may be restarted by using the --all flag. This flag is incompatible with specifying a process type. dokku ps:restart --all By default, restarting all apps happens serially. The parallelism may be controlled by the --parallel flag. dokku ps:restart --all --parallel 2 Finally, the number of parallel workers may be automatically set to the number of CPUs available by setting the --parallel flag to -1 dokku ps:restart --all --parallel -1 A missing linked container will result in failure to boot apps. Services should all be started for apps being rebuilt. Displaying existing scale properties Issuing the ps:scale command with no arguments will output the current scaling properties for an app. Shell Output dokku ps:scale node-js-app -----> Scaling for python proctype: qty --------: --- web: 1 Scaling apps Via CLI Info This functionality is disabled if the formation is managed via the formation key of app.json . Dokku can also manage scaling itself via the ps:scale command. This command can be used to scale multiple process types at the same time. dokku ps:scale node-js-app web = 1 Multiple process types can be scaled at once: dokku ps:scale node-js-app web = 1 worker = 1 If desired, the corresponding deploy will be skipped by using the --skip-deploy flag: dokku ps:scale --skip-deploy node-js-app web = 1 Manually managing process scaling Info Using a formation key in an app.json file with any quantity specified disables the ability to use ps:scale for scaling. All processes not specified in the app.json will have their process count set to zero. An app.json file can be committed to the root of the pushed app repository, and must be within the built image artifact in the image's working directory as shown below. Buildpacks: /app/app.json Dockerfile: WORKDIR/app.json or /app.json (if no working directory specified) Docker Image: WORKDIR/app.json or /app.json (if no working directory specified) The formation key should be specified as follows in the app.json file: { \"formation\" : { \"web\" : { \"quantity\" : 1 }, \"worker\" : { \"quantity\" : 4 } } } Removing the file will result in Dokku respecting the ps:scale command for setting scale values. The values set via the app.json file from a previous deploy will be respected. The web process For initial app deploys, Dokku will default to starting a single web process for each app. This process may be defined within the Procfile or as the CMD (for Dockerfile or Docker image deploys). Scaling of the web process - and all other processes - may be managed via ps:scale or the formation key in the app.json file either before or after the initial deploy. There are also a few other exceptions for the web process. Custom checks defined by a CHECKS file only apply to the web process type. By default, the built-in nginx proxy implementation only proxies the web process (others may be handled via a custom nginx.conf.sigil ). See the nginx request proxying documentation for more information on how nginx handles proxied requests. Only the web process may be bound to an external port. Changing the Procfile location When deploying a monorepo, it may be desirable to specify the specific path of the Procfile file to use for a given app. This can be done via the ps:set command. If a value is specified and that file does not exist within the repository, Dokku will continue the build process as if the repository has no Procfile . dokku ps:set node-js-app procfile-path Procfile2 The default value may be set by passing an empty value for the option: dokku ps:set node-js-app procfile-path The procfile-path property can also be set globally. The global default is Procfile , and the global value is used when no app-specific value is set. dokku ps:set --global procfile-path global-Procfile The default value may be set by passing an empty value for the option. dokku ps:set --global procfile-path Stopping apps Deployed apps can be stopped using the ps:stop command. This turns off all running containers for an app, and will result in a 502 Bad Gateway response for the default nginx proxy implementation. dokku ps:stop node-js-app All apps may be stopped by using the --all flag. dokku ps:stop --all By default, stopping all apps happens serially. The parallelism may be controlled by the --parallel flag. dokku ps:stop --all --parallel 2 Finally, the number of parallel workers may be automatically set to the number of CPUs available by setting the --parallel flag to -1 dokku ps:stop --all --parallel -1 Starting apps All stopped containers can be started using the ps:start command. This is similar to running ps:restart , except no action will be taken if the app containers are running. dokku ps:start node-js-app All apps may be started by using the --all flag. dokku ps:start --all By default, starting all apps happens serially. The parallelism may be controlled by the --parallel flag. dokku ps:start --all --parallel 2 Finally, the number of parallel workers may be automatically set to the number of CPUs available by setting the --parallel flag to -1 dokku ps:start --all --parallel -1 Restart policies New Introduced in 0.7.0, Command Changed in 0.22.0 By default, Dokku will automatically restart containers that exit with a non-zero status up to 10 times via the on-failure Docker restart policy . Setting the restart policy Info A change in the restart policy must be followed by a ps:rebuild call. You can configure this via the ps:set command: # always restart an exited container dokku ps:set node-js-app restart-policy always # never restart an exited container dokku ps:set node-js-app restart-policy no # only restart it on Docker restart if it was not manually stopped dokku ps:set node-js-app restart-policy unless-stopped # restart only on non-zero exit status dokku ps:set node-js-app restart-policy on-failure # restart only on non-zero exit status up to 20 times dokku ps:set node-js-app restart-policy on-failure:20 Restart policies have no bearing on server reboot, and Dokku will always attempt to restart your apps at that point unless they were manually stopped. Dokku also runs dokku-event-listener in the background via the system's init service. This monitors container state, performing the following actions: If a web process restarts and it's container IP address changes, the app's proxy configuration will be rebuilt. If a process within an app exceeds the restart count, the app will be rebuilt. Displaying reports for an app New Introduced in 0.12.0 You can get a report about the deployed apps using the ps:report command: Shell Output dokku ps:report =====> node-js-app ps information Deployed: false Processes: 0 Ps can scale: true Ps computed procfile path: Procfile2 Ps global procfile path: Procfile Ps restart policy: on-failure:10 Ps procfile path: Procfile2 Restore: true Running: false =====> python-sample ps information Deployed: false Processes: 0 Ps can scale: true Ps computed procfile path: Procfile Ps global procfile path: Procfile Ps restart policy: on-failure:10 Ps procfile path: Restore: true Running: false =====> ruby-sample ps information Deployed: false Processes: 0 Ps can scale: true Ps computed procfile path: Procfile Ps global procfile path: Procfile Ps restart policy: on-failure:10 Ps procfile path: Restore: true Running: false You can run the command for a specific app also. Shell Output dokku ps:report node-js-app =====> node-js-app ps information Deployed: false Processes: 0 Ps can scale: true Ps restart policy: on-failure:10 Restore: true Running: false You can pass flags which will output only the value of the specific information you want. For example: dokku ps:report node-js-app --deployed Restoring apps after a server reboot When a server reboots or Docker is restarted/upgraded, Docker may or may not start old app containers automatically, and may in some cases re-assign container IP addresses. To combat this issue, Dokku uses an init process that triggers dokku ps:restore after the Docker daemon is detected as starting. When triggered, the dokku ps:restore command will serially (one by one) run the following for each: Start all linked services. Clear generated proxy configuration files. Start the app if it has not been manually stopped. If the app containers still exist, they will be started and the generated proxy configuration files will be rebuilt. If any of the app containers are missing, the entire app will be rebuilt. During this time, requests may route to the incorrect app if the assigned IPs correspond to those for other apps. While dokku makes all efforts to avoid this, there may be a few minutes where urls may route to the wrong app. To avoid this, either use a custom proxy plugin or wait a few minutes until the restoration process is complete.","title":"Process Management"},{"location":"processes/process-management/#process-management","text":"New Introduced in 0.3.14, Enhanced in 0.7.0 ps:inspect <app> # Displays a sanitized version of docker inspect for an app ps:rebuild [--parallel count] [--all|<app>] # Rebuilds an app from source ps:report [<app>] [<flag>] # Displays a process report for one or more apps ps:restart [--parallel count] [--all|<app>] [<process-name>] # Restart an app ps:restore [<app>] # Start previously running apps e.g. after reboot ps:scale [--skip-deploy] <app> <proc>=<count> [<proc>=<count>...] # Get/Set how many instances of a given process to run ps:set <app> <key> <value> # Set or clear a ps property for an app ps:start [--parallel count] [--all|<app>] # Start an app ps:stop [--parallel count] [--all|<app>] # Stop an app","title":"Process Management"},{"location":"processes/process-management/#usage","text":"","title":"Usage"},{"location":"processes/process-management/#inspecting-app-containers","text":"New Introduced in 0.13.0 A common administrative task to perform is calling docker inspect on the containers that are running for an app. This can be an error-prone task to perform, and may also reveal sensitive environment variables if not done correctly. Dokku provides a wrapper around this command via the ps:inspect command: dokku ps:inspect node-js-app This command will gather all the running container IDs for your app and call docker inspect , sanitizing the output data so it can be copy-pasted elsewhere safely.","title":"Inspecting app containers"},{"location":"processes/process-management/#rebuilding-apps","text":"It may be useful to rebuild an app at will, such as for commands that do not rebuild an app or when skipping a rebuild after setting multiple config values. For these use cases, the ps:rebuild function can be used. dokku ps:rebuild node-js-app All apps may be rebuilt by using the --all flag. dokku ps:rebuild --all By default, rebuilding all apps happens serially. The parallelism may be controlled by the --parallel flag. dokku ps:rebuild --all --parallel 2 Finally, the number of parallel workers may be automatically set to the number of CPUs available by setting the --parallel flag to -1 dokku ps:rebuild --all --parallel -1 A missing linked container will result in failure to boot apps. Services should all be started for apps being rebuilt.","title":"Rebuilding apps"},{"location":"processes/process-management/#restarting-apps","text":"An app may be restarted using the ps:restart command. dokku ps:restart node-js-app A single process type - such as web or worker - may also be specified. This does not support specifying a given instance of a process type, and only supports restarting all instances of that process type. dokku ps:restart node-js-app web All apps may be restarted by using the --all flag. This flag is incompatible with specifying a process type. dokku ps:restart --all By default, restarting all apps happens serially. The parallelism may be controlled by the --parallel flag. dokku ps:restart --all --parallel 2 Finally, the number of parallel workers may be automatically set to the number of CPUs available by setting the --parallel flag to -1 dokku ps:restart --all --parallel -1 A missing linked container will result in failure to boot apps. Services should all be started for apps being rebuilt.","title":"Restarting apps"},{"location":"processes/process-management/#displaying-existing-scale-properties","text":"Issuing the ps:scale command with no arguments will output the current scaling properties for an app. Shell Output dokku ps:scale node-js-app -----> Scaling for python proctype: qty --------: --- web: 1","title":"Displaying existing scale properties"},{"location":"processes/process-management/#scaling-apps","text":"","title":"Scaling apps"},{"location":"processes/process-management/#via-cli","text":"Info This functionality is disabled if the formation is managed via the formation key of app.json . Dokku can also manage scaling itself via the ps:scale command. This command can be used to scale multiple process types at the same time. dokku ps:scale node-js-app web = 1 Multiple process types can be scaled at once: dokku ps:scale node-js-app web = 1 worker = 1 If desired, the corresponding deploy will be skipped by using the --skip-deploy flag: dokku ps:scale --skip-deploy node-js-app web = 1","title":"Via CLI"},{"location":"processes/process-management/#manually-managing-process-scaling","text":"Info Using a formation key in an app.json file with any quantity specified disables the ability to use ps:scale for scaling. All processes not specified in the app.json will have their process count set to zero. An app.json file can be committed to the root of the pushed app repository, and must be within the built image artifact in the image's working directory as shown below. Buildpacks: /app/app.json Dockerfile: WORKDIR/app.json or /app.json (if no working directory specified) Docker Image: WORKDIR/app.json or /app.json (if no working directory specified) The formation key should be specified as follows in the app.json file: { \"formation\" : { \"web\" : { \"quantity\" : 1 }, \"worker\" : { \"quantity\" : 4 } } } Removing the file will result in Dokku respecting the ps:scale command for setting scale values. The values set via the app.json file from a previous deploy will be respected.","title":"Manually managing process scaling"},{"location":"processes/process-management/#the-web-process","text":"For initial app deploys, Dokku will default to starting a single web process for each app. This process may be defined within the Procfile or as the CMD (for Dockerfile or Docker image deploys). Scaling of the web process - and all other processes - may be managed via ps:scale or the formation key in the app.json file either before or after the initial deploy. There are also a few other exceptions for the web process. Custom checks defined by a CHECKS file only apply to the web process type. By default, the built-in nginx proxy implementation only proxies the web process (others may be handled via a custom nginx.conf.sigil ). See the nginx request proxying documentation for more information on how nginx handles proxied requests. Only the web process may be bound to an external port.","title":"The web process"},{"location":"processes/process-management/#changing-the-procfile-location","text":"When deploying a monorepo, it may be desirable to specify the specific path of the Procfile file to use for a given app. This can be done via the ps:set command. If a value is specified and that file does not exist within the repository, Dokku will continue the build process as if the repository has no Procfile . dokku ps:set node-js-app procfile-path Procfile2 The default value may be set by passing an empty value for the option: dokku ps:set node-js-app procfile-path The procfile-path property can also be set globally. The global default is Procfile , and the global value is used when no app-specific value is set. dokku ps:set --global procfile-path global-Procfile The default value may be set by passing an empty value for the option. dokku ps:set --global procfile-path","title":"Changing the Procfile location"},{"location":"processes/process-management/#stopping-apps","text":"Deployed apps can be stopped using the ps:stop command. This turns off all running containers for an app, and will result in a 502 Bad Gateway response for the default nginx proxy implementation. dokku ps:stop node-js-app All apps may be stopped by using the --all flag. dokku ps:stop --all By default, stopping all apps happens serially. The parallelism may be controlled by the --parallel flag. dokku ps:stop --all --parallel 2 Finally, the number of parallel workers may be automatically set to the number of CPUs available by setting the --parallel flag to -1 dokku ps:stop --all --parallel -1","title":"Stopping apps"},{"location":"processes/process-management/#starting-apps","text":"All stopped containers can be started using the ps:start command. This is similar to running ps:restart , except no action will be taken if the app containers are running. dokku ps:start node-js-app All apps may be started by using the --all flag. dokku ps:start --all By default, starting all apps happens serially. The parallelism may be controlled by the --parallel flag. dokku ps:start --all --parallel 2 Finally, the number of parallel workers may be automatically set to the number of CPUs available by setting the --parallel flag to -1 dokku ps:start --all --parallel -1","title":"Starting apps"},{"location":"processes/process-management/#restart-policies","text":"New Introduced in 0.7.0, Command Changed in 0.22.0 By default, Dokku will automatically restart containers that exit with a non-zero status up to 10 times via the on-failure Docker restart policy .","title":"Restart policies"},{"location":"processes/process-management/#setting-the-restart-policy","text":"Info A change in the restart policy must be followed by a ps:rebuild call. You can configure this via the ps:set command: # always restart an exited container dokku ps:set node-js-app restart-policy always # never restart an exited container dokku ps:set node-js-app restart-policy no # only restart it on Docker restart if it was not manually stopped dokku ps:set node-js-app restart-policy unless-stopped # restart only on non-zero exit status dokku ps:set node-js-app restart-policy on-failure # restart only on non-zero exit status up to 20 times dokku ps:set node-js-app restart-policy on-failure:20 Restart policies have no bearing on server reboot, and Dokku will always attempt to restart your apps at that point unless they were manually stopped. Dokku also runs dokku-event-listener in the background via the system's init service. This monitors container state, performing the following actions: If a web process restarts and it's container IP address changes, the app's proxy configuration will be rebuilt. If a process within an app exceeds the restart count, the app will be rebuilt.","title":"Setting the restart policy"},{"location":"processes/process-management/#displaying-reports-for-an-app","text":"New Introduced in 0.12.0 You can get a report about the deployed apps using the ps:report command: Shell Output dokku ps:report =====> node-js-app ps information Deployed: false Processes: 0 Ps can scale: true Ps computed procfile path: Procfile2 Ps global procfile path: Procfile Ps restart policy: on-failure:10 Ps procfile path: Procfile2 Restore: true Running: false =====> python-sample ps information Deployed: false Processes: 0 Ps can scale: true Ps computed procfile path: Procfile Ps global procfile path: Procfile Ps restart policy: on-failure:10 Ps procfile path: Restore: true Running: false =====> ruby-sample ps information Deployed: false Processes: 0 Ps can scale: true Ps computed procfile path: Procfile Ps global procfile path: Procfile Ps restart policy: on-failure:10 Ps procfile path: Restore: true Running: false You can run the command for a specific app also. Shell Output dokku ps:report node-js-app =====> node-js-app ps information Deployed: false Processes: 0 Ps can scale: true Ps restart policy: on-failure:10 Restore: true Running: false You can pass flags which will output only the value of the specific information you want. For example: dokku ps:report node-js-app --deployed","title":"Displaying reports for an app"},{"location":"processes/process-management/#restoring-apps-after-a-server-reboot","text":"When a server reboots or Docker is restarted/upgraded, Docker may or may not start old app containers automatically, and may in some cases re-assign container IP addresses. To combat this issue, Dokku uses an init process that triggers dokku ps:restore after the Docker daemon is detected as starting. When triggered, the dokku ps:restore command will serially (one by one) run the following for each: Start all linked services. Clear generated proxy configuration files. Start the app if it has not been manually stopped. If the app containers still exist, they will be started and the generated proxy configuration files will be rebuilt. If any of the app containers are missing, the entire app will be rebuilt. During this time, requests may route to the incorrect app if the assigned IPs correspond to those for other apps. While dokku makes all efforts to avoid this, there may be a few minutes where urls may route to the wrong app. To avoid this, either use a custom proxy plugin or wait a few minutes until the restoration process is complete.","title":"Restoring apps after a server reboot"},{"location":"processes/scheduled-cron-tasks/","text":"Scheduled Cron Tasks New Introduced in 0.23.0 cron:list <app> # List scheduled cron tasks for an app cron:report [<app>] [<flag>] # Display report about an app Usage Dokku Managed Cron Dokku automates scheduled dokku run commands via it's app.json cron integration. Specifying commands The app.json file for a given app can define a special cron key that contains a list of commands to run on given schedules. The following is a simple example app.json that effectively runs the command dokku run $APP npm run send-email once a day: { \"cron\": [ { \"command\": \"npm run send-email\", \"schedule\": \"@daily\" } ] } A cron entry takes the following properties: command : A command to be run within the built app image. Specified commands can also be Procfile entries. schedule : A cron-compatible scheduling definition upon which to run the command. Seconds are generally not supported. Zero or more cron commands can be specified per app. Cron entries are validated after the build artifact is created but before the app is deployed, and the cron schedule is updated during the post-deploy phase. Task Environment When running scheduled cron tasks, there are a few items to be aware of: Scheduled cron tasks are performed within the app environment available at runtime. If the app image does not exist, the command may fail to execute. Schedules are performed on the hosting server's timezone, which is typically UTC. At this time, only the PATH and SHELL environment variables are specified in the cron template. Each scheduled task is executed within a one-off run container, and thus inherit any docker-options specified for run containers.Resources are never shared between scheduled tasks. Tasks are always executed using the --rm flag, and are never executed in detached mode. Scheduled cron tasks are supported on a per-scheduler basis, and are currently only implemented by the docker-local scheduler. Tasks for all apps managed by the docker-local scheduler are written to a single crontab file owned by the dokku user. The dokku user's crontab should be considered reserved for this purpose. Listing Cron tasks Cron tasks for an app can be listed via the cron:list command. This command takes an app argument. Shell Output dokku cron:list node-js-app ID Schedule Command cGhwPT09cGhwIHRlc3QucGhwPT09QGRhaWx5 @daily node index.js cGhwPT09dHJ1ZT09PSogKiAqICogKg== * * * * * true Displaying reports You can get a report about the cron configuration for apps using the cron:report command: Shell Output dokku cron:report =====> node-js-app cron information Cron task count: 2 =====> python-sample cron information Cron task count: 0 =====> ruby-sample cron information Cron task count: 10 You can run the command for a specific app also. Shell Output dokku cron:report node-js-app =====> node-js-app cron information Cron task count: 2 You can pass flags which will output only the value of the specific information you want. For example: dokku cron:report node-js-app --cron-task-count Self Managed Cron Warning Self-managed cron tasks should be considered advanced usage. While the instructions are available, users are highly encouraged to use the built-in scheduled cron task support unless absolutely necessary. Some installations may require more fine-grained control over cron usage. The following are advanced instructions for configuring cron. Using run for cron tasks You can always use a one-off container to run an app task: dokku --rm run node-js-app some-command dokku --rm-container run node-js-app some-command For tasks that should not be interrupted, run is the preferred method of handling cron tasks, as the container will continue running even during a deploy or scaling event. The trade-off is that there will be an increase in memory usage if there are multiple concurrent tasks running. Using enter for cron tasks Your Procfile can have the following entry: cron : sleep infinity With the cron process scaled to 1 : dokku ps:scale node-js-app cron = 1 You can now run all your commands in that container: dokku enter node-js-app cron some-command Note that you can also run multiple commands at the same time to reduce memory usage, though that may result in polluting the container environment. For tasks that will properly resume, you should use the above method, as running tasks will be interrupted during deploys and scaling events, and subsequent commands will always run with the latest container. Note that if you scale the cron container down, this may interrupt proper running of the task. General cron recommendations Regularly scheduled tasks can be a bit of a pain with Dokku. The following are general recommendations to follow to help ensure successful task runs. Use the dokku user in your cron entry. If you do not, the dokku binary will attempt to execute with sudo , and your cron run with fail with sudo: no tty present and no askpass program specified . Add a MAILTO environment variable to ship cron emails to yourself. Add a PATH environment variable or specify the full path to binaries on the host. Add a SHELL environment variable to specify Bash when running commands. Keep your cron tasks in time-sorted order. Keep your server time in UTC so you don't need to translate daylight savings time when reading the cronfile. Run tasks at the lowest traffic times if possible. Use cron to trigger jobs, not run them. Use a real queuing system such as rabbitmq to actually process jobs. Try to keep tasks quiet so that mails only send on errors. Do not silence standard error or standard out. If you silence the former, you will miss failures. Silencing the latter means you should actually make app changes to handle log levels. Use a service such as Dead Man's Snitch to verify that cron tasks completed successfully. Add lots of comments to your cronfile, including what a task is doing, so that you don't spend time deciphering the file later. Place your cronfiles in a pattern such as /etc/cron.d/APP . Do not use non-ASCII characters in your cronfile names. cron is finicky. Remember to have trailing newlines in your cronfile! cron is finicky. The following is a sample cronfile that you can use for your apps: # server cron jobs MAILTO=\"mail@dokku.me\" PATH=/usr/local/bin:/usr/bin:/bin SHELL=/bin/bash # m h dom mon dow username command # * * * * * dokku command to be executed # - - - - - # | | | | | # | | | | +----- day of week (0 - 6) (Sunday=0) # | | | +------- month (1 - 12) # | | +--------- day of month (1 - 31) # | +----------- hour (0 - 23) # +----------- min (0 - 59) ### HIGH TRAFFIC TIME IS B/W 00:00 - 04:00 AND 14:00 - 23:59 ### RUN YOUR TASKS FROM 04:00 - 14:00 ### KEEP SORTED IN TIME ORDER ### PLACE ALL CRON TASKS BELOW # removes unresponsive users from the subscriber list to decrease bounce rates 0 0 * * * dokku dokku --rm run node-js-app some-command # sends out our email alerts to users 0 1 * * * dokku dokku ps:scale node-js-app cron=1 && dokku enter node-js-app cron some-other-command && dokku ps:scale node-js-app cron=0 ### PLACE ALL CRON TASKS ABOVE, DO NOT REMOVE THE WHITESPACE AFTER THIS LINE","title":"Scheduled Cron Tasks"},{"location":"processes/scheduled-cron-tasks/#scheduled-cron-tasks","text":"New Introduced in 0.23.0 cron:list <app> # List scheduled cron tasks for an app cron:report [<app>] [<flag>] # Display report about an app","title":"Scheduled Cron Tasks"},{"location":"processes/scheduled-cron-tasks/#usage","text":"","title":"Usage"},{"location":"processes/scheduled-cron-tasks/#dokku-managed-cron","text":"Dokku automates scheduled dokku run commands via it's app.json cron integration.","title":"Dokku Managed Cron"},{"location":"processes/scheduled-cron-tasks/#specifying-commands","text":"The app.json file for a given app can define a special cron key that contains a list of commands to run on given schedules. The following is a simple example app.json that effectively runs the command dokku run $APP npm run send-email once a day: { \"cron\": [ { \"command\": \"npm run send-email\", \"schedule\": \"@daily\" } ] } A cron entry takes the following properties: command : A command to be run within the built app image. Specified commands can also be Procfile entries. schedule : A cron-compatible scheduling definition upon which to run the command. Seconds are generally not supported. Zero or more cron commands can be specified per app. Cron entries are validated after the build artifact is created but before the app is deployed, and the cron schedule is updated during the post-deploy phase.","title":"Specifying commands"},{"location":"processes/scheduled-cron-tasks/#task-environment","text":"When running scheduled cron tasks, there are a few items to be aware of: Scheduled cron tasks are performed within the app environment available at runtime. If the app image does not exist, the command may fail to execute. Schedules are performed on the hosting server's timezone, which is typically UTC. At this time, only the PATH and SHELL environment variables are specified in the cron template. Each scheduled task is executed within a one-off run container, and thus inherit any docker-options specified for run containers.Resources are never shared between scheduled tasks. Tasks are always executed using the --rm flag, and are never executed in detached mode. Scheduled cron tasks are supported on a per-scheduler basis, and are currently only implemented by the docker-local scheduler. Tasks for all apps managed by the docker-local scheduler are written to a single crontab file owned by the dokku user. The dokku user's crontab should be considered reserved for this purpose.","title":"Task Environment"},{"location":"processes/scheduled-cron-tasks/#listing-cron-tasks","text":"Cron tasks for an app can be listed via the cron:list command. This command takes an app argument. Shell Output dokku cron:list node-js-app ID Schedule Command cGhwPT09cGhwIHRlc3QucGhwPT09QGRhaWx5 @daily node index.js cGhwPT09dHJ1ZT09PSogKiAqICogKg== * * * * * true","title":"Listing Cron tasks"},{"location":"processes/scheduled-cron-tasks/#displaying-reports","text":"You can get a report about the cron configuration for apps using the cron:report command: Shell Output dokku cron:report =====> node-js-app cron information Cron task count: 2 =====> python-sample cron information Cron task count: 0 =====> ruby-sample cron information Cron task count: 10 You can run the command for a specific app also. Shell Output dokku cron:report node-js-app =====> node-js-app cron information Cron task count: 2 You can pass flags which will output only the value of the specific information you want. For example: dokku cron:report node-js-app --cron-task-count","title":"Displaying reports"},{"location":"processes/scheduled-cron-tasks/#self-managed-cron","text":"Warning Self-managed cron tasks should be considered advanced usage. While the instructions are available, users are highly encouraged to use the built-in scheduled cron task support unless absolutely necessary. Some installations may require more fine-grained control over cron usage. The following are advanced instructions for configuring cron.","title":"Self Managed Cron"},{"location":"processes/scheduled-cron-tasks/#using-run-for-cron-tasks","text":"You can always use a one-off container to run an app task: dokku --rm run node-js-app some-command dokku --rm-container run node-js-app some-command For tasks that should not be interrupted, run is the preferred method of handling cron tasks, as the container will continue running even during a deploy or scaling event. The trade-off is that there will be an increase in memory usage if there are multiple concurrent tasks running.","title":"Using run for cron tasks"},{"location":"processes/scheduled-cron-tasks/#using-enter-for-cron-tasks","text":"Your Procfile can have the following entry: cron : sleep infinity With the cron process scaled to 1 : dokku ps:scale node-js-app cron = 1 You can now run all your commands in that container: dokku enter node-js-app cron some-command Note that you can also run multiple commands at the same time to reduce memory usage, though that may result in polluting the container environment. For tasks that will properly resume, you should use the above method, as running tasks will be interrupted during deploys and scaling events, and subsequent commands will always run with the latest container. Note that if you scale the cron container down, this may interrupt proper running of the task.","title":"Using enter for cron tasks"},{"location":"processes/scheduled-cron-tasks/#general-cron-recommendations","text":"Regularly scheduled tasks can be a bit of a pain with Dokku. The following are general recommendations to follow to help ensure successful task runs. Use the dokku user in your cron entry. If you do not, the dokku binary will attempt to execute with sudo , and your cron run with fail with sudo: no tty present and no askpass program specified . Add a MAILTO environment variable to ship cron emails to yourself. Add a PATH environment variable or specify the full path to binaries on the host. Add a SHELL environment variable to specify Bash when running commands. Keep your cron tasks in time-sorted order. Keep your server time in UTC so you don't need to translate daylight savings time when reading the cronfile. Run tasks at the lowest traffic times if possible. Use cron to trigger jobs, not run them. Use a real queuing system such as rabbitmq to actually process jobs. Try to keep tasks quiet so that mails only send on errors. Do not silence standard error or standard out. If you silence the former, you will miss failures. Silencing the latter means you should actually make app changes to handle log levels. Use a service such as Dead Man's Snitch to verify that cron tasks completed successfully. Add lots of comments to your cronfile, including what a task is doing, so that you don't spend time deciphering the file later. Place your cronfiles in a pattern such as /etc/cron.d/APP . Do not use non-ASCII characters in your cronfile names. cron is finicky. Remember to have trailing newlines in your cronfile! cron is finicky. The following is a sample cronfile that you can use for your apps: # server cron jobs MAILTO=\"mail@dokku.me\" PATH=/usr/local/bin:/usr/bin:/bin SHELL=/bin/bash # m h dom mon dow username command # * * * * * dokku command to be executed # - - - - - # | | | | | # | | | | +----- day of week (0 - 6) (Sunday=0) # | | | +------- month (1 - 12) # | | +--------- day of month (1 - 31) # | +----------- hour (0 - 23) # +----------- min (0 - 59) ### HIGH TRAFFIC TIME IS B/W 00:00 - 04:00 AND 14:00 - 23:59 ### RUN YOUR TASKS FROM 04:00 - 14:00 ### KEEP SORTED IN TIME ORDER ### PLACE ALL CRON TASKS BELOW # removes unresponsive users from the subscriber list to decrease bounce rates 0 0 * * * dokku dokku --rm run node-js-app some-command # sends out our email alerts to users 0 1 * * * dokku dokku ps:scale node-js-app cron=1 && dokku enter node-js-app cron some-other-command && dokku ps:scale node-js-app cron=0 ### PLACE ALL CRON TASKS ABOVE, DO NOT REMOVE THE WHITESPACE AFTER THIS LINE","title":"General cron recommendations"}]}