{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"advanced-installation/","text":"Advanced installation You can always install dokku straight from the latest - potentially unstable - master release via the following bash command: # using a branch results in installing from source wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh sudo DOKKU_BRANCH = master bash bootstrap.sh Development If you plan on developing dokku, the easiest way to install from your own repository is cloning the repository and calling the install script. Example: git clone https://github.com/yourusername/dokku.git cd dokku sudo make install The Makefile allows source URLs to be overridden to include customizations from your own repositories. The DOCKER_URL , PLUGN_URL , SSHCOMMAND_URL and STACK_URL environment variables may be set to override the defaults (see the Makefile for how these apply). Example: sudo SSHCOMMAND_URL = https://raw.githubusercontent.com/yourusername/sshcommand/master/sshcommand make install Bootstrap a server from your own repository The bootstrap script allows the dokku repository URL to be overridden to bootstrap a host from your own clone of dokku using the DOKKU_REPO environment variable. Example: wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh chmod +x bootstrap.sh sudo DOKKU_REPO = https://github.com/yourusername/dokku.git DOKKU_BRANCH = master ./bootstrap.sh Custom herokuish build Dokku ships with a pre-built version of version of the herokuish component by default. If you want to build your own version you can specify that with an env variable. git clone https://github.com/dokku/dokku.git cd dokku sudo BUILD_STACK = true STACK_URL = https://github.com/gliderlabs/herokuish.git make install Configuring Once dokku is installed, if you are not using the web-installer, you'll want to configure a the virtualhost setup as well as the push user. If you do not, your installation will be considered incomplete and you will not be able to deploy applications. You should also stop and disable the dokku-installer service to remove public access to adding SSH keys. Set up a domain and a wildcard domain pointing to that host. Make sure /home/dokku/VHOST is set to this domain. By default it's set to whatever hostname the host has. This file is only created if the hostname can be resolved by dig ( dig +short $(hostname -f) ). Otherwise you have to create the file manually and set it to your preferred domain. If this file still is not present when you push your app, dokku will publish the app with a port number (i.e. http://example.com:49154 - note the missing subdomain). Follow the user management documentation in order to add users to dokku. That's it! VMs with less than 1GB of memory Having less than 1GB of system memory available for dokku and its containers, for example Digital Ocean's small 512MB machines, might result in unexpected errors, such as ! [remote rejected] master -> master (pre-receive hook declined) during installation of NPM dependencies (https://github.com/npm/npm/issues/3867). To work around this issue, it might suffice to augment the linux swap file size to a maximum of twice the physical memory size. To resize the swap file of a 512MB machine to 1GB, follow these steps while in SSH within your machine: cd /var touch swap.img chmod 600 swap.img dd if = /dev/zero of = /var/swap.img bs = 1024k count = 1000 mkswap /var/swap.img swapon /var/swap.img free echo \"/var/swap.img none swap sw 0 0\" >> /etc/fstab Reference: https://www.digitalocean.com/community/tutorials/how-to-configure-virtual-memory-swap-file-on-a-vps","title":"Advanced installation"},{"location":"advanced-installation/#advanced-installation","text":"You can always install dokku straight from the latest - potentially unstable - master release via the following bash command: # using a branch results in installing from source wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh sudo DOKKU_BRANCH = master bash bootstrap.sh","title":"Advanced installation"},{"location":"advanced-installation/#development","text":"If you plan on developing dokku, the easiest way to install from your own repository is cloning the repository and calling the install script. Example: git clone https://github.com/yourusername/dokku.git cd dokku sudo make install The Makefile allows source URLs to be overridden to include customizations from your own repositories. The DOCKER_URL , PLUGN_URL , SSHCOMMAND_URL and STACK_URL environment variables may be set to override the defaults (see the Makefile for how these apply). Example: sudo SSHCOMMAND_URL = https://raw.githubusercontent.com/yourusername/sshcommand/master/sshcommand make install","title":"Development"},{"location":"advanced-installation/#bootstrap-a-server-from-your-own-repository","text":"The bootstrap script allows the dokku repository URL to be overridden to bootstrap a host from your own clone of dokku using the DOKKU_REPO environment variable. Example: wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh chmod +x bootstrap.sh sudo DOKKU_REPO = https://github.com/yourusername/dokku.git DOKKU_BRANCH = master ./bootstrap.sh","title":"Bootstrap a server from your own repository"},{"location":"advanced-installation/#custom-herokuish-build","text":"Dokku ships with a pre-built version of version of the herokuish component by default. If you want to build your own version you can specify that with an env variable. git clone https://github.com/dokku/dokku.git cd dokku sudo BUILD_STACK = true STACK_URL = https://github.com/gliderlabs/herokuish.git make install","title":"Custom herokuish build"},{"location":"advanced-installation/#configuring","text":"Once dokku is installed, if you are not using the web-installer, you'll want to configure a the virtualhost setup as well as the push user. If you do not, your installation will be considered incomplete and you will not be able to deploy applications. You should also stop and disable the dokku-installer service to remove public access to adding SSH keys. Set up a domain and a wildcard domain pointing to that host. Make sure /home/dokku/VHOST is set to this domain. By default it's set to whatever hostname the host has. This file is only created if the hostname can be resolved by dig ( dig +short $(hostname -f) ). Otherwise you have to create the file manually and set it to your preferred domain. If this file still is not present when you push your app, dokku will publish the app with a port number (i.e. http://example.com:49154 - note the missing subdomain). Follow the user management documentation in order to add users to dokku. That's it!","title":"Configuring"},{"location":"advanced-installation/#vms-with-less-than-1gb-of-memory","text":"Having less than 1GB of system memory available for dokku and its containers, for example Digital Ocean's small 512MB machines, might result in unexpected errors, such as ! [remote rejected] master -> master (pre-receive hook declined) during installation of NPM dependencies (https://github.com/npm/npm/issues/3867). To work around this issue, it might suffice to augment the linux swap file size to a maximum of twice the physical memory size. To resize the swap file of a 512MB machine to 1GB, follow these steps while in SSH within your machine: cd /var touch swap.img chmod 600 swap.img dd if = /dev/zero of = /var/swap.img bs = 1024k count = 1000 mkswap /var/swap.img swapon /var/swap.img free echo \"/var/swap.img none swap sw 0 0\" >> /etc/fstab Reference: https://www.digitalocean.com/community/tutorials/how-to-configure-virtual-memory-swap-file-on-a-vps","title":"VMs with less than 1GB of memory"},{"location":"application-deployment/","text":"Deploying to Dokku Deploy tutorial Once Dokku has been configured with at least one user, applications can be deployed via a git push command. To quickly see Dokku deployment in action, you can use the Heroku Ruby on Rails example app. # from your local machine git clone git@github.com:heroku/ruby-rails-sample.git Create the app Create the application on the Dokku host. You will need to ssh onto the host to run this command. # on your dokku host dokku apps:create ruby-rails-sample Create the backing services When you create a new app, Dokku by default does not provide any datastores such as MySQL or PostgreSQL. You will need to install plugins to handle that, but fortunately Dokku has official plugins for common datastores. Our sample app requires a PostgreSQL service: # on your dokku host # install the postgres plugin # plugin installation requires root, hence the user change sudo dokku plugin:install https://github.com/dokku/dokku-postgres.git # create a postgres service with the name rails-database dokku postgres:create rails-database Each services may take a few moments to create. Linking backing services to applications Once the service creation is complete, set the POSTGRES_URL environment variable by linking the service. # on your dokku host # each official datastore offers a `link` method to link a service to any application dokku postgres:link rails-database ruby-rails-sample You can link a single service to multiple applications or use one service per application. Deploy the app Now you can deploy the ruby-rails-sample app to your Dokku server. All you have to do is add a remote to name the app. Applications are created on-the-fly on the Dokku server. # from your local machine git remote add dokku dokku@dokku.me:ruby-rails-sample git push dokku master You should see output similar to the following: Counting objects: 231, done. Delta compression using up to 8 threads. Compressing objects: 100% (162/162), done. Writing objects: 100% (231/231), 36.96 KiB | 0 bytes/s, done. Total 231 (delta 93), reused 147 (delta 53) -----> Cleaning up... -----> Building ruby-rails-sample from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.2.1 -----> Installing dependencies using 1.9.7 Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin -j4 --deployment Fetching gem metadata from https://rubygems.org/........... Fetching version metadata from https://rubygems.org/... Fetching dependency metadata from https://rubygems.org/.. Using rake 10.4.2 ... When the deploy finishes, the application's URL will be shown. ===== > Application deployed: http://ruby-rails-sample.dokku.me Dokku supports deploying applications via Heroku buildpacks with Herokuish or using a project's dockerfile . Removing a deployed app You can also remove an application from your Dokku installation. This will unlink all linked services and destroy any config related to the application. Note that linked services will retain their data for later use (or removal). # on your dokku host # replace APP with the name of your application dokku apps:destroy APP This will prompt you to verify the application's name before destroying it. You may also use the --force flag to circumvent this verification process: # on your dokku host # replace APP with the name of your application dokku --force apps:destroy APP Renaming a deployed app New as of 0.4.7 You can rename a deployed app using the apps:rename CLI tool: # on your dokku host dokku apps:rename OLD_NAME NEW_NAME This will copy all of your app's contents into a new app directory with the name of your choice, delete your old app, then rebuild the new version of the app and deploy it. All of your config variables, including database urls, will be preserved. Deploying non-master branch Dokku only supports deploying from its master branch, so if you'd like to deploy a different local branch use: git push dokku <local branch>:master You can also support pushing multiple branches using the receive-branch plugin trigger in a custom plugin. Skipping deployment If you only want to rebuild and tag a container, you can skip the deployment phase by setting $DOKKU_SKIP_DEPLOY to true by running: # on your dokku host dokku config:set ruby-rails-sample DOKKU_SKIP_DEPLOY = true Deploying with private git submodules Dokku uses git locally (i.e. not a docker image) to build its own copy of your app repo, including submodules. This is done as the dokku user. Therefore, in order to deploy private git submodules, you'll need to drop your deploy key in /home/dokku/.ssh/ and potentially add github.com (or your VCS host key) into /home/dokku/.ssh/known_hosts . The following test should help confirm you've done it correctly. # on your dokku host su - dokku ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts ssh -T git@github.com Note that if the buildpack or dockerfile build process require ssh key access for other reasons, the above may not always apply. Deploying to subdomains The name of remote repository is used as the name of application to be deployed, as for example above: $ git remote add dokku dokku@dokku.me:ruby-rails-sample $ git push dokku master Is deployed to, remote: -----> Application deployed: remote: http://ruby-rails-sample.dokku.me You can also specify fully qualified names, say app.dokku.me , as $ git remote add dokku dokku@dokku.me:app.dokku.me $ git push dokku master So, after deployment the application will be available at, remote: -----> Application deployed: remote: http://app.dokku.me This is in particular useful, then you want to deploy to root domain, as $ git remote add dokku dokku@dokku.me:dokku.me $ git push dokku master ... deployment ... remote: -----> Application deployed: remote: http://dokku.me Dokku/Docker Container Management Compatibility Dokku is, at its core, a docker container manager. Thus, it does not necessarily play well with other out-of-band processes interacting with the docker daemon. One thing to note as in issue #1220 , dokku executes a cleanup function prior to every deployment. As of 0.5.x, this function removes all containers with the label dokku where the status is either dead or exited , as well as all dangling images. Previous versions would remove dead or exited containers, regardless of their label. Adding deploy users See the user management documentation . Default vhost See the nginx documentation . Dockerfile deployment See the dockerfile documentation . Specifying a custom buildpack See the buildpack documentation . Image tagging See the image tagging documentation . Zero downtime deploy See the zero-downtime deploy documentation .","title":"Deploying to Dokku"},{"location":"application-deployment/#deploying-to-dokku","text":"","title":"Deploying to Dokku"},{"location":"application-deployment/#deploy-tutorial","text":"Once Dokku has been configured with at least one user, applications can be deployed via a git push command. To quickly see Dokku deployment in action, you can use the Heroku Ruby on Rails example app. # from your local machine git clone git@github.com:heroku/ruby-rails-sample.git","title":"Deploy tutorial"},{"location":"application-deployment/#create-the-app","text":"Create the application on the Dokku host. You will need to ssh onto the host to run this command. # on your dokku host dokku apps:create ruby-rails-sample","title":"Create the app"},{"location":"application-deployment/#create-the-backing-services","text":"When you create a new app, Dokku by default does not provide any datastores such as MySQL or PostgreSQL. You will need to install plugins to handle that, but fortunately Dokku has official plugins for common datastores. Our sample app requires a PostgreSQL service: # on your dokku host # install the postgres plugin # plugin installation requires root, hence the user change sudo dokku plugin:install https://github.com/dokku/dokku-postgres.git # create a postgres service with the name rails-database dokku postgres:create rails-database Each services may take a few moments to create.","title":"Create the backing services"},{"location":"application-deployment/#linking-backing-services-to-applications","text":"Once the service creation is complete, set the POSTGRES_URL environment variable by linking the service. # on your dokku host # each official datastore offers a `link` method to link a service to any application dokku postgres:link rails-database ruby-rails-sample You can link a single service to multiple applications or use one service per application.","title":"Linking backing services to applications"},{"location":"application-deployment/#deploy-the-app","text":"Now you can deploy the ruby-rails-sample app to your Dokku server. All you have to do is add a remote to name the app. Applications are created on-the-fly on the Dokku server. # from your local machine git remote add dokku dokku@dokku.me:ruby-rails-sample git push dokku master You should see output similar to the following: Counting objects: 231, done. Delta compression using up to 8 threads. Compressing objects: 100% (162/162), done. Writing objects: 100% (231/231), 36.96 KiB | 0 bytes/s, done. Total 231 (delta 93), reused 147 (delta 53) -----> Cleaning up... -----> Building ruby-rails-sample from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.2.1 -----> Installing dependencies using 1.9.7 Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin -j4 --deployment Fetching gem metadata from https://rubygems.org/........... Fetching version metadata from https://rubygems.org/... Fetching dependency metadata from https://rubygems.org/.. Using rake 10.4.2 ... When the deploy finishes, the application's URL will be shown. ===== > Application deployed: http://ruby-rails-sample.dokku.me Dokku supports deploying applications via Heroku buildpacks with Herokuish or using a project's dockerfile .","title":"Deploy the app"},{"location":"application-deployment/#removing-a-deployed-app","text":"You can also remove an application from your Dokku installation. This will unlink all linked services and destroy any config related to the application. Note that linked services will retain their data for later use (or removal). # on your dokku host # replace APP with the name of your application dokku apps:destroy APP This will prompt you to verify the application's name before destroying it. You may also use the --force flag to circumvent this verification process: # on your dokku host # replace APP with the name of your application dokku --force apps:destroy APP","title":"Removing a deployed app"},{"location":"application-deployment/#renaming-a-deployed-app","text":"New as of 0.4.7 You can rename a deployed app using the apps:rename CLI tool: # on your dokku host dokku apps:rename OLD_NAME NEW_NAME This will copy all of your app's contents into a new app directory with the name of your choice, delete your old app, then rebuild the new version of the app and deploy it. All of your config variables, including database urls, will be preserved.","title":"Renaming a deployed app"},{"location":"application-deployment/#deploying-non-master-branch","text":"Dokku only supports deploying from its master branch, so if you'd like to deploy a different local branch use: git push dokku <local branch>:master You can also support pushing multiple branches using the receive-branch plugin trigger in a custom plugin.","title":"Deploying non-master branch"},{"location":"application-deployment/#skipping-deployment","text":"If you only want to rebuild and tag a container, you can skip the deployment phase by setting $DOKKU_SKIP_DEPLOY to true by running: # on your dokku host dokku config:set ruby-rails-sample DOKKU_SKIP_DEPLOY = true","title":"Skipping deployment"},{"location":"application-deployment/#deploying-with-private-git-submodules","text":"Dokku uses git locally (i.e. not a docker image) to build its own copy of your app repo, including submodules. This is done as the dokku user. Therefore, in order to deploy private git submodules, you'll need to drop your deploy key in /home/dokku/.ssh/ and potentially add github.com (or your VCS host key) into /home/dokku/.ssh/known_hosts . The following test should help confirm you've done it correctly. # on your dokku host su - dokku ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts ssh -T git@github.com Note that if the buildpack or dockerfile build process require ssh key access for other reasons, the above may not always apply.","title":"Deploying with private git submodules"},{"location":"application-deployment/#deploying-to-subdomains","text":"The name of remote repository is used as the name of application to be deployed, as for example above: $ git remote add dokku dokku@dokku.me:ruby-rails-sample $ git push dokku master Is deployed to, remote: -----> Application deployed: remote: http://ruby-rails-sample.dokku.me You can also specify fully qualified names, say app.dokku.me , as $ git remote add dokku dokku@dokku.me:app.dokku.me $ git push dokku master So, after deployment the application will be available at, remote: -----> Application deployed: remote: http://app.dokku.me This is in particular useful, then you want to deploy to root domain, as $ git remote add dokku dokku@dokku.me:dokku.me $ git push dokku master ... deployment ... remote: -----> Application deployed: remote: http://dokku.me","title":"Deploying to subdomains"},{"location":"application-deployment/#dokkudocker-container-management-compatibility","text":"Dokku is, at its core, a docker container manager. Thus, it does not necessarily play well with other out-of-band processes interacting with the docker daemon. One thing to note as in issue #1220 , dokku executes a cleanup function prior to every deployment. As of 0.5.x, this function removes all containers with the label dokku where the status is either dead or exited , as well as all dangling images. Previous versions would remove dead or exited containers, regardless of their label.","title":"Dokku/Docker Container Management Compatibility"},{"location":"application-deployment/#adding-deploy-users","text":"See the user management documentation .","title":"Adding deploy users"},{"location":"application-deployment/#default-vhost","text":"See the nginx documentation .","title":"Default vhost"},{"location":"application-deployment/#dockerfile-deployment","text":"See the dockerfile documentation .","title":"Dockerfile deployment"},{"location":"application-deployment/#specifying-a-custom-buildpack","text":"See the buildpack documentation .","title":"Specifying a custom buildpack"},{"location":"application-deployment/#image-tagging","text":"See the image tagging documentation .","title":"Image tagging"},{"location":"application-deployment/#zero-downtime-deploy","text":"See the zero-downtime deploy documentation .","title":"Zero downtime deploy"},{"location":"backup-recovery/","text":"Backup and Recovery The backup plugin was deprecated in 0.4.x, below are backup recommendations for 0.5.x and later. Backup and Migration Tutorial Because Dokku is git based, rebuilding a deployed app is as easy as pushing from git. You can push to a new server by updating the dokku remote in you local app's repo. $ git remote rm dokku $ git remote add dokku dokku@[dokku.me:dokku.me] $ git push dokku [master] Databases Some plugins, like the official dokku-postgres plugin, have built-in commands that allow non-volatile data be exported and imported. For dokku-postgres , use: dokku postgres:export [db_name] > [db_name].dump dokku postgres:import [db_name] < [db_name].dump Volumes and Static Assets Dokku doesn't enforce a 300mb limit on apps, but it's best practice to keep binary assets outside of git. Since containers are considered volatile in Dokku, external stores like s3 or storage mounts should be used for non-volatile items like user uploads. The dokku storage core plugin can be used to mount local directories / volumes inside the docker container. storage:list <app>, List bind mounts for app's container(s) (host:container) storage:mount <app> <host-dir:container-dir>, Create a new bind mount storage:unmount <app> <host-dir:container-dir>, Remove an existing bind mount Disaster Recovery The best plan for disaster recovery is to always keep multiple (remote) copies of your local repo, static assets and periodic database dumps. In case of an emergency when your git repo and backups are completely lost, you can recover the last pushed copy from your remote dokku server (assuming you still have the ssh key). mkdir [app-name] ; cd !$ git init && git remote add dokku dokku@[dokku.me:app-name] git pull dokku/master && git checkout dokku/master","title":"Backup and Recovery"},{"location":"backup-recovery/#backup-and-recovery","text":"The backup plugin was deprecated in 0.4.x, below are backup recommendations for 0.5.x and later.","title":"Backup and Recovery"},{"location":"backup-recovery/#backup-and-migration-tutorial","text":"Because Dokku is git based, rebuilding a deployed app is as easy as pushing from git. You can push to a new server by updating the dokku remote in you local app's repo. $ git remote rm dokku $ git remote add dokku dokku@[dokku.me:dokku.me] $ git push dokku [master]","title":"Backup and Migration Tutorial"},{"location":"backup-recovery/#databases","text":"Some plugins, like the official dokku-postgres plugin, have built-in commands that allow non-volatile data be exported and imported. For dokku-postgres , use: dokku postgres:export [db_name] > [db_name].dump dokku postgres:import [db_name] < [db_name].dump","title":"Databases"},{"location":"backup-recovery/#volumes-and-static-assets","text":"Dokku doesn't enforce a 300mb limit on apps, but it's best practice to keep binary assets outside of git. Since containers are considered volatile in Dokku, external stores like s3 or storage mounts should be used for non-volatile items like user uploads. The dokku storage core plugin can be used to mount local directories / volumes inside the docker container. storage:list <app>, List bind mounts for app's container(s) (host:container) storage:mount <app> <host-dir:container-dir>, Create a new bind mount storage:unmount <app> <host-dir:container-dir>, Remove an existing bind mount","title":"Volumes and Static Assets"},{"location":"backup-recovery/#disaster-recovery","text":"The best plan for disaster recovery is to always keep multiple (remote) copies of your local repo, static assets and periodic database dumps. In case of an emergency when your git repo and backups are completely lost, you can recover the last pushed copy from your remote dokku server (assuming you still have the ssh key). mkdir [app-name] ; cd !$ git init && git remote add dokku dokku@[dokku.me:app-name] git pull dokku/master && git checkout dokku/master","title":"Disaster Recovery"},{"location":"checks-examples/","text":"Zero Downtime Deploys New as of 0.5.0 checks <app> Show zero-downtime status checks:disable <app> Disable zero-downtime checks checks:enable <app> Enable zero-downtime checks Following a deploy, dokku will wait 10 seconds before routing traffic to the new container to give your application time to boot up. If the application is not running after this time, then the deploy is failed and your old container will continue serving traffic. You can modify this value globally or on a per-application basis: dokku config:set --global DOKKU_DEFAULT_CHECKS_WAIT = 30 dokku config:set <app> DOKKU_DEFAULT_CHECKS_WAIT = 30 You can also choose to skip checks completely on a per-application basis: dokku checks:disable <app> Dokku will wait 60 seconds before stopping the old container so that existing connections are given a chance to complete. You can modify this value globally or on a per-application basis: dokku config:set --global DOKKU_WAIT_TO_RETIRE = 120 dokku config:set <app> DOKKU_WAIT_TO_RETIRE = 120 Note that during this time, multiple containers may be running on your server, which can be an issue for memory-hungry applications on memory-constrained servers. Checks If your application needs a longer period to boot up - perhaps to load data into memory, or because of slow boot time - you may also use dokku's checks functionality to more precisely check whether an application can serve traffic or not. Checks are run against the detected web process from your application's Procfile . For non-web processes, dokku will fallback to the aforementioned process uptime check. To specify checks, add a CHECKS file to the root of your project directory. The CHECKS file should be plain text and may contain: Check instructions Settings (NAME=VALUE) Comments (lines starting with #) Empty lines For dockerfile-based deploys, the file must be in /app/CHECKS within the container. /app is used by default as the root container directory for buildpack-based deploys. Check Instructions The format of a check instruction is a path or relative URL, optionally followed by the expected content: /about Our Amazing Team The CHECKS file can contain multiple checks: / My Amazing App /stylesheets/index.css .body /scripts/index.js $(function() /images/logo.png To check an application that supports multiple hostnames, use relative URLs that include the hostname: //admin.example.com Admin Dashboard //static.example.com/logo.png You can also specify the protocol to explicitly check HTTPS requests: https://admin.example.com Admin Dashboard https://static.example.com/logo.png Check Settings The default behavior is to wait for 5 seconds before running the checks, to timeout the checks after 30 seconds, and to attempt the checks 5 times. If the checks fail 5 times, the deployment is considered failed and the old container will continue serving traffic. You can change the default behavior by setting WAIT , TIMEOUT , and ATTEMPTS to different values in the CHECKS file: WAIT=30 # Wait 1/2 minute TIMEOUT=60 # Timeout after a minute ATTEMPTS=10 # Attempt checks 10 times / My Amazing App You can also override the default WAIT , TIMEOUT , and ATTEMPTS variables for the global dokku installation: dokku config:set --global DOKKU_CHECKS_WAIT = 30 dokku config:set --global DOKKU_CHECKS_TIMEOUT = 60 dokku config:set --global DOKKU_CHECKS_ATTEMPTS = 10 If your application runs multiple processes (a background worker configured in your Procfile , for example) and you have checks to ensure that your web application has booted up, you may want to disable the default check wait time for that application to avoid the 10 second wait per non-web process: dokku config:set <app> DOKKU_DEFAULT_CHECKS_WAIT = 0 Example: Successful Rails Deployment In this example, a Rails application is successfully deployed to dokku. The initial round of checks fails while the server is starting, but once it starts they succeed and the deployment is successful. WAIT is set to 10 because our application takes a while to boot up. ATTEMPTS is set to 6 , but the third attempt succeeds. CHECKS file WAIT=10 ATTEMPTS=6 /check.txt simple_check For this check to work, we've added a line to config/routes.rb that simply returns a string: get '/check.txt', to: proc {[200, {}, ['simple_check']]} Deploy Output Note: The output has been trimmed for brevity git push dokku master -----> Cleaning up... -----> Building myapp from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... -----> Discovering process types Procfile declares types -> web -----> Releasing myapp... -----> Deploying myapp... -----> Running pre-flight checks -----> Attempt 1/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" -----> All checks successful! =====> myapp container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop =====> end myapp container output -----> Running post-deploy -----> Configuring myapp.dokku.example.com... -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx -----> Shutting down old container in 60 seconds =====> Application deployed: http://myapp.dokku.example.com Example: Failing Rails Deployment In this example, a Rails application fails to deploy. The reason for the failure is that the postgres database connection fails. The initial checks will fail while we wait for the server to start up, just like in the above example. However, once the server does start accepting connections, we will see an error 500 due to the postgres database connection failure. Once the attempts have been exceeded, the deployment fails and we see the container output, which shows the Postgres connection errors. CHECKS file WAIT=10 ATTEMPTS=6 / The check to the root url '/' would normally access the database. Deploy Output Note: The output has been trimmed for brevity git push dokku master -----> Cleaning up... -----> Building myapp from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... Discovering process types Procfile declares types -> web Releasing myapp... Deploying myapp... Running pre-flight checks -----> Attempt 1/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 3/6 failed. -----> Attempt 4/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 4/6 failed. -----> Attempt 5/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 5/6 failed. -----> Attempt 6/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error Could not start due to 1 failed checks. ! Check attempt 6/6 failed. =====> myapp container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop Started GET \"/\" for 172.17.42.1 at 2015-03-26 21:36:47 +0000 Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? PG::ConnectionBad (could not connect to server: Connection refused Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? ): vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `connect' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:242:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `postgresql_connection =====> end myapp container output /usr/bin/dokku: line 49: 23409 Killed dokku deploy \"$APP\" To dokku@dokku.example.com:myapp ! [remote rejected] dokku -> master (pre-receive hook declined) error: failed to push some refs to 'dokku@dokku.example.com:myapp' Configuring docker stop timeout By default , docker will wait 10 seconds from the time the stop command is passed to a container before it attempts to kill said container. This timeout can be configured on a per-app basis in dokku by setting the DOKKU_DOCKER_STOP_TIMEOUT configuration variable. This timeout applies to normal zero-downtime deployments as well as the ps:stop and apps:destroy commands. $ dokku config:set $APP DOKKU_DOCKER_STOP_TIMEOUT=20","title":"Zero Downtime Deploys"},{"location":"checks-examples/#zero-downtime-deploys","text":"New as of 0.5.0 checks <app> Show zero-downtime status checks:disable <app> Disable zero-downtime checks checks:enable <app> Enable zero-downtime checks Following a deploy, dokku will wait 10 seconds before routing traffic to the new container to give your application time to boot up. If the application is not running after this time, then the deploy is failed and your old container will continue serving traffic. You can modify this value globally or on a per-application basis: dokku config:set --global DOKKU_DEFAULT_CHECKS_WAIT = 30 dokku config:set <app> DOKKU_DEFAULT_CHECKS_WAIT = 30 You can also choose to skip checks completely on a per-application basis: dokku checks:disable <app> Dokku will wait 60 seconds before stopping the old container so that existing connections are given a chance to complete. You can modify this value globally or on a per-application basis: dokku config:set --global DOKKU_WAIT_TO_RETIRE = 120 dokku config:set <app> DOKKU_WAIT_TO_RETIRE = 120 Note that during this time, multiple containers may be running on your server, which can be an issue for memory-hungry applications on memory-constrained servers.","title":"Zero Downtime Deploys"},{"location":"checks-examples/#checks","text":"If your application needs a longer period to boot up - perhaps to load data into memory, or because of slow boot time - you may also use dokku's checks functionality to more precisely check whether an application can serve traffic or not. Checks are run against the detected web process from your application's Procfile . For non-web processes, dokku will fallback to the aforementioned process uptime check. To specify checks, add a CHECKS file to the root of your project directory. The CHECKS file should be plain text and may contain: Check instructions Settings (NAME=VALUE) Comments (lines starting with #) Empty lines For dockerfile-based deploys, the file must be in /app/CHECKS within the container. /app is used by default as the root container directory for buildpack-based deploys.","title":"Checks"},{"location":"checks-examples/#check-instructions","text":"The format of a check instruction is a path or relative URL, optionally followed by the expected content: /about Our Amazing Team The CHECKS file can contain multiple checks: / My Amazing App /stylesheets/index.css .body /scripts/index.js $(function() /images/logo.png To check an application that supports multiple hostnames, use relative URLs that include the hostname: //admin.example.com Admin Dashboard //static.example.com/logo.png You can also specify the protocol to explicitly check HTTPS requests: https://admin.example.com Admin Dashboard https://static.example.com/logo.png","title":"Check Instructions"},{"location":"checks-examples/#check-settings","text":"The default behavior is to wait for 5 seconds before running the checks, to timeout the checks after 30 seconds, and to attempt the checks 5 times. If the checks fail 5 times, the deployment is considered failed and the old container will continue serving traffic. You can change the default behavior by setting WAIT , TIMEOUT , and ATTEMPTS to different values in the CHECKS file: WAIT=30 # Wait 1/2 minute TIMEOUT=60 # Timeout after a minute ATTEMPTS=10 # Attempt checks 10 times / My Amazing App You can also override the default WAIT , TIMEOUT , and ATTEMPTS variables for the global dokku installation: dokku config:set --global DOKKU_CHECKS_WAIT = 30 dokku config:set --global DOKKU_CHECKS_TIMEOUT = 60 dokku config:set --global DOKKU_CHECKS_ATTEMPTS = 10 If your application runs multiple processes (a background worker configured in your Procfile , for example) and you have checks to ensure that your web application has booted up, you may want to disable the default check wait time for that application to avoid the 10 second wait per non-web process: dokku config:set <app> DOKKU_DEFAULT_CHECKS_WAIT = 0","title":"Check Settings"},{"location":"checks-examples/#example-successful-rails-deployment","text":"In this example, a Rails application is successfully deployed to dokku. The initial round of checks fails while the server is starting, but once it starts they succeed and the deployment is successful. WAIT is set to 10 because our application takes a while to boot up. ATTEMPTS is set to 6 , but the third attempt succeeds.","title":"Example: Successful Rails Deployment"},{"location":"checks-examples/#checks-file","text":"WAIT=10 ATTEMPTS=6 /check.txt simple_check For this check to work, we've added a line to config/routes.rb that simply returns a string: get '/check.txt', to: proc {[200, {}, ['simple_check']]}","title":"CHECKS file"},{"location":"checks-examples/#deploy-output","text":"Note: The output has been trimmed for brevity git push dokku master -----> Cleaning up... -----> Building myapp from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... -----> Discovering process types Procfile declares types -> web -----> Releasing myapp... -----> Deploying myapp... -----> Running pre-flight checks -----> Attempt 1/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" -----> All checks successful! =====> myapp container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop =====> end myapp container output -----> Running post-deploy -----> Configuring myapp.dokku.example.com... -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx -----> Shutting down old container in 60 seconds =====> Application deployed: http://myapp.dokku.example.com","title":"Deploy Output"},{"location":"checks-examples/#example-failing-rails-deployment","text":"In this example, a Rails application fails to deploy. The reason for the failure is that the postgres database connection fails. The initial checks will fail while we wait for the server to start up, just like in the above example. However, once the server does start accepting connections, we will see an error 500 due to the postgres database connection failure. Once the attempts have been exceeded, the deployment fails and we see the container output, which shows the Postgres connection errors.","title":"Example: Failing Rails Deployment"},{"location":"checks-examples/#checks-file_1","text":"WAIT=10 ATTEMPTS=6 / The check to the root url '/' would normally access the database.","title":"CHECKS file"},{"location":"checks-examples/#deploy-output_1","text":"Note: The output has been trimmed for brevity git push dokku master -----> Cleaning up... -----> Building myapp from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... Discovering process types Procfile declares types -> web Releasing myapp... Deploying myapp... Running pre-flight checks -----> Attempt 1/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 3/6 failed. -----> Attempt 4/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 4/6 failed. -----> Attempt 5/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 5/6 failed. -----> Attempt 6/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error Could not start due to 1 failed checks. ! Check attempt 6/6 failed. =====> myapp container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop Started GET \"/\" for 172.17.42.1 at 2015-03-26 21:36:47 +0000 Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? PG::ConnectionBad (could not connect to server: Connection refused Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? ): vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `connect' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:242:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `postgresql_connection =====> end myapp container output /usr/bin/dokku: line 49: 23409 Killed dokku deploy \"$APP\" To dokku@dokku.example.com:myapp ! [remote rejected] dokku -> master (pre-receive hook declined) error: failed to push some refs to 'dokku@dokku.example.com:myapp'","title":"Deploy Output"},{"location":"checks-examples/#configuring-docker-stop-timeout","text":"By default , docker will wait 10 seconds from the time the stop command is passed to a container before it attempts to kill said container. This timeout can be configured on a per-app basis in dokku by setting the DOKKU_DOCKER_STOP_TIMEOUT configuration variable. This timeout applies to normal zero-downtime deployments as well as the ps:stop and apps:destroy commands. $ dokku config:set $APP DOKKU_DOCKER_STOP_TIMEOUT=20","title":"Configuring docker stop timeout"},{"location":"components/","text":"Components Docker - Container runtime and manager Herokuish - Buildpack builder plugn - Shell based plugins and hooks sshcommand - Fixed commands over SSH Looking to keep codebase as simple and hackable as possible, so try to keep your line count down.","title":"Components"},{"location":"components/#components","text":"Docker - Container runtime and manager Herokuish - Buildpack builder plugn - Shell based plugins and hooks sshcommand - Fixed commands over SSH Looking to keep codebase as simple and hackable as possible, so try to keep your line count down.","title":"Components"},{"location":"configuration-management/","text":"Environment Variables Typically an application will require some configuration to run properly. Dokku supports application configuration via environment variables. Environment variables may contain private data, such as passwords or API keys, so it is not recommended to store them in your application's repository. The config plugin provides the following commands to manage your variables: config (<app>|--global) Display all global or app-specific config vars config:get (<app>|--global) KEY Display a global or app-specific config value config:set (<app>|--global) KEY1=VALUE1 [KEY2=VALUE2 ...] Set one or more config vars config:unset (<app>|--global) KEY1 [KEY2 ...] Unset one or more config vars The variables are available both at run time and during the application build/compilation step for buildpack-based deploys. For security reasons - and as per docker recommendations - Dockerfile-based deploys have variables available only during runtime, as noted in this issue . Note: Global ENV files are sourced before app-specific ENV files. This means that app-specific variables will take precedence over global variables. Configuring your global ENV file is manual, and should be considered potentially dangerous as configuration applies to all applications. You can set multiple environment variables at once: dokku config:set node-js-app ENV = prod COMPILE_ASSETS = 1 When setting variables with whitespaces, you need to escape them: dokku config:set node-js-app KEY = \\\" VAL \\ WITH \\ SPACES \\\" When setting or unsetting environment variables, you may wish to avoid an application restart. This is useful when developing plugins or when setting multiple environment variables in a scripted manner. To do so, use the --no-restart flag: dokku config:set --no-restart node-js-app ENV = prod If you wish to have the variables output in an eval -compatible form, you can use the --export flag: dokku config node-js-app --export # outputs variables in the form: # # export ENV='prod' # export COMPILE_ASSETS='1' # source in all the node-js-app app environment variables eval $( dokku config node-js-app --export ) You can also output the variables in a single-line for usage in command-line utilities with the --shell flag: dokku config node-js-app --shell # outputs variables in the form: # # ENV='prod' COMPILE_ASSETS='1'","title":"Environment Variables"},{"location":"configuration-management/#environment-variables","text":"Typically an application will require some configuration to run properly. Dokku supports application configuration via environment variables. Environment variables may contain private data, such as passwords or API keys, so it is not recommended to store them in your application's repository. The config plugin provides the following commands to manage your variables: config (<app>|--global) Display all global or app-specific config vars config:get (<app>|--global) KEY Display a global or app-specific config value config:set (<app>|--global) KEY1=VALUE1 [KEY2=VALUE2 ...] Set one or more config vars config:unset (<app>|--global) KEY1 [KEY2 ...] Unset one or more config vars The variables are available both at run time and during the application build/compilation step for buildpack-based deploys. For security reasons - and as per docker recommendations - Dockerfile-based deploys have variables available only during runtime, as noted in this issue . Note: Global ENV files are sourced before app-specific ENV files. This means that app-specific variables will take precedence over global variables. Configuring your global ENV file is manual, and should be considered potentially dangerous as configuration applies to all applications. You can set multiple environment variables at once: dokku config:set node-js-app ENV = prod COMPILE_ASSETS = 1 When setting variables with whitespaces, you need to escape them: dokku config:set node-js-app KEY = \\\" VAL \\ WITH \\ SPACES \\\" When setting or unsetting environment variables, you may wish to avoid an application restart. This is useful when developing plugins or when setting multiple environment variables in a scripted manner. To do so, use the --no-restart flag: dokku config:set --no-restart node-js-app ENV = prod If you wish to have the variables output in an eval -compatible form, you can use the --export flag: dokku config node-js-app --export # outputs variables in the form: # # export ENV='prod' # export COMPILE_ASSETS='1' # source in all the node-js-app app environment variables eval $( dokku config node-js-app --export ) You can also output the variables in a single-line for usage in command-line utilities with the --shell flag: dokku config node-js-app --shell # outputs variables in the form: # # ENV='prod' COMPILE_ASSETS='1'","title":"Environment Variables"},{"location":"dns/","text":"DNS Configuration Note: This is a work in progress. DNS Versions There are many different DNS servers 'in the wild'. Some of the popular ones on Linux are BIND, dnsmasq, and pdns. Windows has its own built-in DNS server as well as Unbound, Posadis, and more. A full list of DNS packages can be found on Wikipedia under Comparison of DNS Server Software . In addition to the various DNS packages, there are tens of thousands of Managed DNS Providers out that all have different DNS interfaces. Focus Because there are so many different DNS server packages out there as well as a tremendous number of Managed DNS Providers, we will focus on the concepts of DNS as well as providing examples in the 'BIND' format so you can adapt the information to your own server package or managed DNS provider. Assumptions We assume you have a passing familiarity with DNS. If not, you can read an in-depth article on DNS. But basically you need to know that DNS changes names (like example.tld) into addresses (like 127.0.0.1) We assume you already have a domain name registered and pointed to your favorite Managed DNS Provider or have your own BIND DNS server running. You have a server on the internet and are about to follow the instructions in the README to get dokku installed. Don't do the install just yet though. Caching Please remember that DNS relies heavily on caching . Changes you make to DNS could take anywhere from a few seconds to a few days to propagate. If you tried surfing to example.tld, then changed the IP address in DNS, it could be a while before your computer picks up on the changes. HELP! Don't be afraid to ask if you need help. Create a new issue and someone will be glad to assist you. Getting started For the examples, we will use the domain name example.tld and the IP address 127.0.0.1 . Dokku uses DNS to differentiate between apps on your dokku-powered server. If you are using the domain example.tld , and you have two apps myapp1 and myapp2 , dokku will make them available at myapp1.example.tld and myapp2.example.tld . To get started, you need to know the IP address of your dokku server. Connect to it and run ifconfig or ip addr to see the IP address. Now you have to make a decision about your domain. Do you want everything and anything at example.tld to go to your dokku server, or would you rather use a 'sub domain' for your dokku server? In other words, do you want your applications on your dokku server accessible via myapp.example.tld or via myapp.myserver.example.tld ? Using a sub-domain (myapp.myserver.example.tld) Using a sub-domain is easy. When you set up your server, you probably gave it a name like myserver.example.tld . Go in to your Managed DNS provider and create an A record named myserver and put in the IP address you got from your server a few moments ago. Hopefully your managed DNS provider also supports wildcards. Create a second A record named *.myserver along with the IP address you got from your server a few moments ago. If you are using BIND, your zone file will look similar to this: $ORIGIN example.tld $TTL 5m myserver IN A 127.0.0.1 *.myserver IN A 127.0.0.1 You can verify your changes in Linux by trying one or more of the following commands: host myserver.example.tld dig -t A myserver.example.tld nslookup myserver.example.tld Now is a good time to remind you that the answers you get MAY BE CACHED. If everything is working correctly, you should also be able to query for any other name under myserver.example.tld and get back the IP address of your server. Try: host test.myserver.example.tld host xyzzy.myserver.example.tld If they all return your IP address, you have set DNS up properly for dokku. You should also be able to ssh root@myserver.example.tld and access your server. Proceed with the setup instructions in the README Using the root of your domain (myapp.example.tld) This section is a work in progress. It is incomplete. Using the 'root' of your domain is nearly identical to the previous example. hostname is under example.tld , still needs A record Need to modify /home/dokku/HOSTNAME and /home/dokku/VHOST","title":"DNS Configuration"},{"location":"dns/#dns-configuration","text":"Note: This is a work in progress.","title":"DNS Configuration"},{"location":"dns/#dns-versions","text":"There are many different DNS servers 'in the wild'. Some of the popular ones on Linux are BIND, dnsmasq, and pdns. Windows has its own built-in DNS server as well as Unbound, Posadis, and more. A full list of DNS packages can be found on Wikipedia under Comparison of DNS Server Software . In addition to the various DNS packages, there are tens of thousands of Managed DNS Providers out that all have different DNS interfaces.","title":"DNS Versions"},{"location":"dns/#focus","text":"Because there are so many different DNS server packages out there as well as a tremendous number of Managed DNS Providers, we will focus on the concepts of DNS as well as providing examples in the 'BIND' format so you can adapt the information to your own server package or managed DNS provider.","title":"Focus"},{"location":"dns/#assumptions","text":"We assume you have a passing familiarity with DNS. If not, you can read an in-depth article on DNS. But basically you need to know that DNS changes names (like example.tld) into addresses (like 127.0.0.1) We assume you already have a domain name registered and pointed to your favorite Managed DNS Provider or have your own BIND DNS server running. You have a server on the internet and are about to follow the instructions in the README to get dokku installed. Don't do the install just yet though.","title":"Assumptions"},{"location":"dns/#caching","text":"Please remember that DNS relies heavily on caching . Changes you make to DNS could take anywhere from a few seconds to a few days to propagate. If you tried surfing to example.tld, then changed the IP address in DNS, it could be a while before your computer picks up on the changes.","title":"Caching"},{"location":"dns/#help","text":"Don't be afraid to ask if you need help. Create a new issue and someone will be glad to assist you.","title":"HELP!"},{"location":"dns/#getting-started","text":"For the examples, we will use the domain name example.tld and the IP address 127.0.0.1 . Dokku uses DNS to differentiate between apps on your dokku-powered server. If you are using the domain example.tld , and you have two apps myapp1 and myapp2 , dokku will make them available at myapp1.example.tld and myapp2.example.tld . To get started, you need to know the IP address of your dokku server. Connect to it and run ifconfig or ip addr to see the IP address. Now you have to make a decision about your domain. Do you want everything and anything at example.tld to go to your dokku server, or would you rather use a 'sub domain' for your dokku server? In other words, do you want your applications on your dokku server accessible via myapp.example.tld or via myapp.myserver.example.tld ?","title":"Getting started"},{"location":"dns/#using-a-sub-domain-myappmyserverexampletld","text":"Using a sub-domain is easy. When you set up your server, you probably gave it a name like myserver.example.tld . Go in to your Managed DNS provider and create an A record named myserver and put in the IP address you got from your server a few moments ago. Hopefully your managed DNS provider also supports wildcards. Create a second A record named *.myserver along with the IP address you got from your server a few moments ago. If you are using BIND, your zone file will look similar to this: $ORIGIN example.tld $TTL 5m myserver IN A 127.0.0.1 *.myserver IN A 127.0.0.1 You can verify your changes in Linux by trying one or more of the following commands: host myserver.example.tld dig -t A myserver.example.tld nslookup myserver.example.tld Now is a good time to remind you that the answers you get MAY BE CACHED. If everything is working correctly, you should also be able to query for any other name under myserver.example.tld and get back the IP address of your server. Try: host test.myserver.example.tld host xyzzy.myserver.example.tld If they all return your IP address, you have set DNS up properly for dokku. You should also be able to ssh root@myserver.example.tld and access your server. Proceed with the setup instructions in the README","title":"Using a sub-domain (myapp.myserver.example.tld)"},{"location":"dns/#using-the-root-of-your-domain-myappexampletld","text":"This section is a work in progress. It is incomplete. Using the 'root' of your domain is nearly identical to the previous example. hostname is under example.tld , still needs A record Need to modify /home/dokku/HOSTNAME and /home/dokku/VHOST","title":"Using the root of your domain (myapp.example.tld)"},{"location":"docker-options/","text":"Docker Container Options New as of 0.3.17 Pass options to Docker during Dokku's build , deploy and run phases docker-options <app> [phase(s)] Display app's Docker options for all phases (or comma separated phase list) docker-options:add <app> <phase(s)> OPTION Add Docker option to app for phase (comma-separated phase list) docker-options:remove <app> <phase(s)> OPTION Remove Docker option from app for phase (comma-separated phase list) When specifying multiple phases, they must be comma-separated without spaces in between each phase, like so: dokku docker-options:add myapp deploy,run \"-v /home/dokku/logs/myapp:/app/logs\" About Dokku phases Dokku deploys your application in multiple \"phases\" and the docker-options plugin allows you to pass arguments to their underlying docker container: build : the container that executes the appropriate buildpack deploy : the container that executes your running/deployed application run : the container that executes any arbitrary command via dokku run myapp Examples Add Docker options Add some options for the deployed/running app and when executing dokku run : # Mount a host volume in a Docker container: \"-v /host/path:/container/path\" dokku docker-options:add myapp deploy \"-v /home/dokku/logs/myapp:/app/logs\" dokku docker-options:add myapp run \"-v /home/dokku/logs/myapp:/app/logs\" Note: When mounting a host directory in a Dokku app you should first create that directory as user dokku and then mount the directory under /app in the container using docker-options as above. Otherwise the app will lack write permission in the directory. Output Docker options dokku docker-options myapp # Deploy options: # -v /home/dokku/logs/myapp:/app/logs # Run options: # -v /home/dokku/logs/myapp:/app/logs Remove a Docker option dokku docker-options:remove myapp run \"-v /home/dokku/logs/myapp:/app/logs\" Advanced usage In your applications folder /home/dokku/app_name create a file called DOCKER_OPTIONS_RUN (or DOCKER_OPTIONS_BUILD or DOCKER_OPTIONS_DEPLOY ). Inside this file list one Docker option per line. For example: --link container_name:alias -v /host/path:/container/path -v /another/container/path The above example will result in the following options being passed to Docker during dokku run : --link container_name:alias -v /host/path:/container/path -v /another/container/path You may also include comments (lines beginning with a #) and blank lines in the DOCKER_OPTIONS file. Move information on Docker options can be found here: http://docs.docker.io/en/latest/reference/run/ .","title":"Docker Container Options"},{"location":"docker-options/#docker-container-options","text":"New as of 0.3.17 Pass options to Docker during Dokku's build , deploy and run phases docker-options <app> [phase(s)] Display app's Docker options for all phases (or comma separated phase list) docker-options:add <app> <phase(s)> OPTION Add Docker option to app for phase (comma-separated phase list) docker-options:remove <app> <phase(s)> OPTION Remove Docker option from app for phase (comma-separated phase list) When specifying multiple phases, they must be comma-separated without spaces in between each phase, like so: dokku docker-options:add myapp deploy,run \"-v /home/dokku/logs/myapp:/app/logs\"","title":"Docker Container Options"},{"location":"docker-options/#about-dokku-phases","text":"Dokku deploys your application in multiple \"phases\" and the docker-options plugin allows you to pass arguments to their underlying docker container: build : the container that executes the appropriate buildpack deploy : the container that executes your running/deployed application run : the container that executes any arbitrary command via dokku run myapp","title":"About Dokku phases"},{"location":"docker-options/#examples","text":"","title":"Examples"},{"location":"docker-options/#add-docker-options","text":"Add some options for the deployed/running app and when executing dokku run : # Mount a host volume in a Docker container: \"-v /host/path:/container/path\" dokku docker-options:add myapp deploy \"-v /home/dokku/logs/myapp:/app/logs\" dokku docker-options:add myapp run \"-v /home/dokku/logs/myapp:/app/logs\" Note: When mounting a host directory in a Dokku app you should first create that directory as user dokku and then mount the directory under /app in the container using docker-options as above. Otherwise the app will lack write permission in the directory.","title":"Add Docker options"},{"location":"docker-options/#output-docker-options","text":"dokku docker-options myapp # Deploy options: # -v /home/dokku/logs/myapp:/app/logs # Run options: # -v /home/dokku/logs/myapp:/app/logs","title":"Output Docker options"},{"location":"docker-options/#remove-a-docker-option","text":"dokku docker-options:remove myapp run \"-v /home/dokku/logs/myapp:/app/logs\"","title":"Remove a Docker option"},{"location":"docker-options/#advanced-usage","text":"In your applications folder /home/dokku/app_name create a file called DOCKER_OPTIONS_RUN (or DOCKER_OPTIONS_BUILD or DOCKER_OPTIONS_DEPLOY ). Inside this file list one Docker option per line. For example: --link container_name:alias -v /host/path:/container/path -v /another/container/path The above example will result in the following options being passed to Docker during dokku run : --link container_name:alias -v /host/path:/container/path -v /another/container/path You may also include comments (lines beginning with a #) and blank lines in the DOCKER_OPTIONS file. Move information on Docker options can be found here: http://docs.docker.io/en/latest/reference/run/ .","title":"Advanced usage"},{"location":"dokku-events-logs/","text":"Dokku Event Logs New as of 0.3.21 Docker provides an events command to show system's real time events. Likewise, Dokku can record events as syslog entries and also provides a plugin to display the last ones. events [-t] Show the last events (-t follows) events:list List logged events events:on Enable events logger events:off Disable events logger Usage Enable the plugin: $ dokku events:on Enabling dokku events logger Dokku will then write log entries to /var/log/syslog as well as a Dokku-specific logs sub-directory /var/log/dokku/events.log , which can be easily displayed with the command dokku events : Jul 3 16:09:48 dokku.me dokku[127630]: INVOKED: pre-release-buildpack( pythonapp ) Jul 3 16:10:02 dokku.me dokku[128095]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:10:02 dokku.me dokku[128114]: INVOKED: docker-args-run( nhl ) Jul 3 16:10:03 dokku.me dokku[128136]: INVOKED: post-release-buildpack( pythonapp ) Jul 3 16:10:03 dokku.me dokku[128195]: INVOKED: pre-deploy( pythonapp ) Jul 3 16:10:23 dokku.me dokku[129253]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:24 dokku.me dokku[129337]: INVOKED: bind-external-ip( pythonapp ) Jul 3 16:10:24 dokku.me dokku[129451]: INVOKED: check-deploy( pythonapp 6274ced0d4be11af4490cd18abaf77cdd593f025133f403d984e80d86a39acec web 5000 10.0.16.80 ) Jul 3 16:10:35 dokku.me dokku[129561]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:35 dokku.me dokku[129649]: INVOKED: bind-external-ip( pythonapp ) Jul 3 16:10:36 dokku.me dokku[129760]: INVOKED: check-deploy( pythonapp ac88a56ee4161ff37e4b92d1498c3eadc91f0aa7c8b81b44fc077e2a51d54cc0 worker ) Jul 3 16:10:46 dokku.me dokku[129851]: INVOKED: post-deploy( pythonapp ) Jul 3 16:10:46 dokku.me dokku[129945]: INVOKED: nginx-pre-reload( pythonapp ) Jul 3 16:15:02 dokku.me dokku[130397]: INVOKED: docker-args-run( goapp ) Jul 3 16:21:02 dokku.me dokku[130796]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:30:02 dokku.me dokku[131384]: INVOKED: docker-args-run( rubyapp ) You can list all events that are currently being recorded via dokku events:list : =====> Events currently logged docker-args-build pre-delete post-deploy receive-app pre-release-buildpack nginx-pre-reload docker-args-deploy post-build-buildpack post-domains-update post-release-dockerfile check-deploy git-pre-pull git-post-pull nginx-hostname bind-external-ip pre-deploy post-delete dependencies pre-build-buildpack docker-args-run pre-build-dockerfile post-release-buildpack post-build-dockerfile pre-release-dockerfile update","title":"Dokku Event Logs"},{"location":"dokku-events-logs/#dokku-event-logs","text":"New as of 0.3.21 Docker provides an events command to show system's real time events. Likewise, Dokku can record events as syslog entries and also provides a plugin to display the last ones. events [-t] Show the last events (-t follows) events:list List logged events events:on Enable events logger events:off Disable events logger","title":"Dokku Event Logs"},{"location":"dokku-events-logs/#usage","text":"Enable the plugin: $ dokku events:on Enabling dokku events logger Dokku will then write log entries to /var/log/syslog as well as a Dokku-specific logs sub-directory /var/log/dokku/events.log , which can be easily displayed with the command dokku events : Jul 3 16:09:48 dokku.me dokku[127630]: INVOKED: pre-release-buildpack( pythonapp ) Jul 3 16:10:02 dokku.me dokku[128095]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:10:02 dokku.me dokku[128114]: INVOKED: docker-args-run( nhl ) Jul 3 16:10:03 dokku.me dokku[128136]: INVOKED: post-release-buildpack( pythonapp ) Jul 3 16:10:03 dokku.me dokku[128195]: INVOKED: pre-deploy( pythonapp ) Jul 3 16:10:23 dokku.me dokku[129253]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:24 dokku.me dokku[129337]: INVOKED: bind-external-ip( pythonapp ) Jul 3 16:10:24 dokku.me dokku[129451]: INVOKED: check-deploy( pythonapp 6274ced0d4be11af4490cd18abaf77cdd593f025133f403d984e80d86a39acec web 5000 10.0.16.80 ) Jul 3 16:10:35 dokku.me dokku[129561]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:35 dokku.me dokku[129649]: INVOKED: bind-external-ip( pythonapp ) Jul 3 16:10:36 dokku.me dokku[129760]: INVOKED: check-deploy( pythonapp ac88a56ee4161ff37e4b92d1498c3eadc91f0aa7c8b81b44fc077e2a51d54cc0 worker ) Jul 3 16:10:46 dokku.me dokku[129851]: INVOKED: post-deploy( pythonapp ) Jul 3 16:10:46 dokku.me dokku[129945]: INVOKED: nginx-pre-reload( pythonapp ) Jul 3 16:15:02 dokku.me dokku[130397]: INVOKED: docker-args-run( goapp ) Jul 3 16:21:02 dokku.me dokku[130796]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:30:02 dokku.me dokku[131384]: INVOKED: docker-args-run( rubyapp ) You can list all events that are currently being recorded via dokku events:list : =====> Events currently logged docker-args-build pre-delete post-deploy receive-app pre-release-buildpack nginx-pre-reload docker-args-deploy post-build-buildpack post-domains-update post-release-dockerfile check-deploy git-pre-pull git-post-pull nginx-hostname bind-external-ip pre-deploy post-delete dependencies pre-build-buildpack docker-args-run pre-build-dockerfile post-release-buildpack post-build-dockerfile pre-release-dockerfile update","title":"Usage"},{"location":"dokku-storage/","text":"Dokku Core Storage Plugin New as of 0.5.0 The preferred method to mount external containers to a dokku managed container, is to use the dokku storage plugin. storage:list <app>, List bind mounts for app ' s container ( s ) ( host:container ) storage:mount <app> <host-dir:container-dir>, Create a new bind mount storage:unmount <app> <host-dir:container-dir>, Remove an existing bind mount Ideology and Background The storage plugin requires explicit paths on the host side. This is intentional to ensure that new users avoid running into unexpected results with implicit paths that may not exist (a feature deprecate in Docker 1.9.0 ). The container directory is created for the mount point in the container. Any existing directory contents are not accessible after a mount is added to the container. Dokku creates a new directory /var/lib/dokku/data/storage during installation, it's the general consensus that new users should use this directory. Mounts are only available at run and deploy times, you must redeploy (restart) an app to mount or unmount to an existing app's container. Usage This example demonstrates how to mount the recommended directory to /storage inside the container: $ dokku storage:mount app-name /var/lib/dokku/data/storage:/storage Dokku will then mount the shared contents of /var/lib/dokku/data/storage to /storage inside the container. Use Cases Persistent storage Dokku is powered by Docker containers, which recommends in their best practices that containers be treated as ephemeral. In order to manage persistent storage for web applications, like user uploads or large binary assets like images, a directory outside the container should be mounted. Shared storage between containers When scaling your app, you may require a common location to access shared assets between containers, a storage mount can be used in this situation. Shared storage across environments Your app may be used in a cluster that requires containers or resources not running on the same host access your data. Mounting a shared file service (like S3FS or EFS) inside your container will give you great flexibility. Backing up Your app may have services that are running in memory and need to be backed up locally (like a key store). Mount a non ephemeral storage mount will allow backups that are not lost when the app is shut down. Docker-Options Note The storage plugins is compatible with storage mounts created with the docker-options. The storage plugin will only list mounts from the deploy phase.","title":"Dokku Core Storage Plugin"},{"location":"dokku-storage/#dokku-core-storage-plugin","text":"New as of 0.5.0 The preferred method to mount external containers to a dokku managed container, is to use the dokku storage plugin. storage:list <app>, List bind mounts for app ' s container ( s ) ( host:container ) storage:mount <app> <host-dir:container-dir>, Create a new bind mount storage:unmount <app> <host-dir:container-dir>, Remove an existing bind mount","title":"Dokku Core Storage Plugin"},{"location":"dokku-storage/#ideology-and-background","text":"The storage plugin requires explicit paths on the host side. This is intentional to ensure that new users avoid running into unexpected results with implicit paths that may not exist (a feature deprecate in Docker 1.9.0 ). The container directory is created for the mount point in the container. Any existing directory contents are not accessible after a mount is added to the container. Dokku creates a new directory /var/lib/dokku/data/storage during installation, it's the general consensus that new users should use this directory. Mounts are only available at run and deploy times, you must redeploy (restart) an app to mount or unmount to an existing app's container.","title":"Ideology and Background"},{"location":"dokku-storage/#usage","text":"This example demonstrates how to mount the recommended directory to /storage inside the container: $ dokku storage:mount app-name /var/lib/dokku/data/storage:/storage Dokku will then mount the shared contents of /var/lib/dokku/data/storage to /storage inside the container.","title":"Usage"},{"location":"dokku-storage/#use-cases","text":"","title":"Use Cases"},{"location":"dokku-storage/#persistent-storage","text":"Dokku is powered by Docker containers, which recommends in their best practices that containers be treated as ephemeral. In order to manage persistent storage for web applications, like user uploads or large binary assets like images, a directory outside the container should be mounted.","title":"Persistent storage"},{"location":"dokku-storage/#shared-storage-between-containers","text":"When scaling your app, you may require a common location to access shared assets between containers, a storage mount can be used in this situation.","title":"Shared storage between containers"},{"location":"dokku-storage/#shared-storage-across-environments","text":"Your app may be used in a cluster that requires containers or resources not running on the same host access your data. Mounting a shared file service (like S3FS or EFS) inside your container will give you great flexibility.","title":"Shared storage across environments"},{"location":"dokku-storage/#backing-up","text":"Your app may have services that are running in memory and need to be backed up locally (like a key store). Mount a non ephemeral storage mount will allow backups that are not lost when the app is shut down.","title":"Backing up"},{"location":"dokku-storage/#docker-options-note","text":"The storage plugins is compatible with storage mounts created with the docker-options. The storage plugin will only list mounts from the deploy phase.","title":"Docker-Options Note"},{"location":"installation/","text":"Getting Started with Dokku What is Dokku? Dokku is an extensible, open source Platform as a Service that runs on a single server of your choice. To start using Dokku, you'll need a system that meets the following minimum requirements: A fresh installation of Ubuntu 14.04 x64 with the FQDN set [1] At least 1GB of system memory [2] You can optionally have a domain name pointed at the host's IP, though this is not necessary. Dokku is designed for usage on a fresh installation of Ubuntu, and should install all necessary dependencies if installing via the bootstrap method. Installing the latest stable version 1. Install dokku To install the latest stable version of dokku, you can run the following shell commands: # for debian systems, installs dokku via apt-get wget https://raw.githubusercontent.com/dokku/dokku/v0.5.8/bootstrap.sh sudo DOKKU_TAG = v0.5.8 bash bootstrap.sh The installation process takes about 5-10 minutes, depending upon internet connection speed. 2. Setup SSH key and Virtualhost Settings Once the installation is complete, you can open a browser to setup your SSH key and virtualhost settings. Open your browser of choice and navigate to the host's IP address - or the domain you assigned to that IP previously - and configure dokku via the web admin. If you don't complete setup via the web installer (even if you set up SSH keys and virtual hosts otherwise) your dokku installation will remain vulnerable to anyone finding the setup page and inserting their key. 3. Deploy your first application Once you save your settings, the web admin will self-terminate and you should be able to run or deploy to the dokku installation. Installing via other methods For various reasons, certain hosting providers may have other steps that should be preferred to the above. If hosted on any of the following popular hosts, please follow the linked to instructions: Digital Ocean Installation Notes Linode Installation Notes Microsoft Azure Installation Notes As well, you may wish to customize your installation in some other fashion. or experiment with vagrant. The guides below should get you started: Debian Package Installation Notes Vagrant Installation Notes Advanced Install Customization [1]: To check whether your system has an fqdn set, run sudo hostname -f [2]: If your system has less than 1GB of memory, you can use this workaround .","title":"Getting Started with Dokku"},{"location":"installation/#getting-started-with-dokku","text":"","title":"Getting Started with Dokku"},{"location":"installation/#what-is-dokku","text":"Dokku is an extensible, open source Platform as a Service that runs on a single server of your choice. To start using Dokku, you'll need a system that meets the following minimum requirements: A fresh installation of Ubuntu 14.04 x64 with the FQDN set [1] At least 1GB of system memory [2] You can optionally have a domain name pointed at the host's IP, though this is not necessary. Dokku is designed for usage on a fresh installation of Ubuntu, and should install all necessary dependencies if installing via the bootstrap method.","title":"What is Dokku?"},{"location":"installation/#installing-the-latest-stable-version","text":"","title":"Installing the latest stable version"},{"location":"installation/#1-install-dokku","text":"To install the latest stable version of dokku, you can run the following shell commands: # for debian systems, installs dokku via apt-get wget https://raw.githubusercontent.com/dokku/dokku/v0.5.8/bootstrap.sh sudo DOKKU_TAG = v0.5.8 bash bootstrap.sh The installation process takes about 5-10 minutes, depending upon internet connection speed.","title":"1. Install dokku"},{"location":"installation/#2-setup-ssh-key-and-virtualhost-settings","text":"Once the installation is complete, you can open a browser to setup your SSH key and virtualhost settings. Open your browser of choice and navigate to the host's IP address - or the domain you assigned to that IP previously - and configure dokku via the web admin. If you don't complete setup via the web installer (even if you set up SSH keys and virtual hosts otherwise) your dokku installation will remain vulnerable to anyone finding the setup page and inserting their key.","title":"2. Setup SSH key and Virtualhost Settings"},{"location":"installation/#3-deploy-your-first-application","text":"Once you save your settings, the web admin will self-terminate and you should be able to run or deploy to the dokku installation.","title":"3. Deploy your first application"},{"location":"installation/#installing-via-other-methods","text":"For various reasons, certain hosting providers may have other steps that should be preferred to the above. If hosted on any of the following popular hosts, please follow the linked to instructions: Digital Ocean Installation Notes Linode Installation Notes Microsoft Azure Installation Notes As well, you may wish to customize your installation in some other fashion. or experiment with vagrant. The guides below should get you started: Debian Package Installation Notes Vagrant Installation Notes Advanced Install Customization [1]: To check whether your system has an fqdn set, run sudo hostname -f [2]: If your system has less than 1GB of memory, you can use this workaround .","title":"Installing via other methods"},{"location":"nginx/","text":"Nginx Configuration Dokku uses nginx as its server for routing requests to specific applications. By default, access and error logs are written for each app to /var/log/nginx/${APP}-access.log and /var/log/nginx/${APP}-error.log respectively nginx:access-logs <app> [-t] Show the nginx access logs for an application (-t follows) nginx:build-config <app> (Re)builds nginx config for given app nginx:error-logs <app> [-t] Show the nginx error logs for an application (-t follows) Customizing the nginx configuration New as of 0.5.0 Dokku uses a templating library by the name of sigil to generate nginx configuration for each app. If you'd like to provide a custom template for your application, there are a couple options: Copy the following example template to a file named nginx.conf.sigil and either: check it into the root of your app repo ADD it to your dockerfile WORKDIR if your dockerfile has no WORKDIR , ADD it to the /app folder When using a custom nginx.conf.sigil file, depending upon your application configuration, you may be exposing the file externally. As this file is extracted before the container is run, you can, safely delete it in a custom entrypoint.sh configured in a Dockerfile ENTRYPOINT . Example Custom Template Use case: add an X-Served-By header to requests server { listen [::]:{{ .NGINX_PORT }}; listen {{ .NGINX_PORT }}; server_name {{ .NOSSL_SERVER_NAME }}; access_log /var/log/nginx/{{ .APP }}-access.log; error_log /var/log/nginx/{{ .APP }}-error.log; # set a custom header for requests add_header X-Served-By www-ec2-01; gzip on; gzip_min_length 1100; gzip_buffers 4 32k; gzip_types text/css text/javascript text/xml text/plain text/x-component application/javascript application/x-javascript application/json application/xml application/rss+xml font/truetype application/x-font-ttf font/opentype application/vnd.ms-fontobject image/svg+xml; gzip_vary on; gzip_comp_level 6; location / { proxy_pass http://{{ .APP }}; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Port $server_port; proxy_set_header X-Request-Start $msec; } include {{ .DOKKU_ROOT }}/{{ .APP }}/nginx.conf.d/*.conf; } upstream {{ .APP }} { {{ range .DOKKU_APP_LISTENERS | split \" \" }} server {{ . }}; {{ end }} } Available template variables {{ .APP }} Application name {{ .APP_SSL_PATH }} Path to SSL certificate and key {{ .DOKKU_ROOT }} Global dokku root directory (ex: app dir would be `{{ .DOKKU_ROOT }}/{{ .APP }}`) {{ .DOKKU_APP_LISTENERS }} List of IP:PORT pairs of app containers {{ .NGINX_PORT }} Non-SSL nginx listener port (same as `DOKKU_NGINX_PORT` config var) {{ .NGINX_SSL_PORT }} SSL nginx listener port (same as `DOKKU_NGINX_SSL_PORT` config var) {{ .NOSSL_SERVER_NAME }} List of non-SSL VHOSTS {{ .RAW_TCP_PORTS }} List of exposed tcp ports as defined by Dockerfile `EXPOSE` directive (**Dockerfile apps only**) {{ .SSL_INUSE }} Boolean set when an app is SSL-enabled {{ .SSL_SERVER_NAME }} List of SSL VHOSTS NOTE: Application config variables are available for use in custom templates. To do so, use the form of {{ var \"FOO\" }} to access a variable named FOO . Example HTTP to HTTPS Custom Template Use case: a simple dockerfile app that includes EXPOSE 80 server { listen [::]:80; listen 80; server_name {{ .NOSSL_SERVER_NAME }}; access_log /var/log/nginx/{{ .APP }}-access.log; error_log /var/log/nginx/{{ .APP }}-error.log; return 301 https://$host:443$request_uri; } server { listen [::]:443 ssl spdy; listen 443 ssl spdy; {{ if .SSL_SERVER_NAME }}server_name {{ .SSL_SERVER_NAME }}; {{ end }} access_log /var/log/nginx/{{ .APP }}-access.log; error_log /var/log/nginx/{{ .APP }}-error.log; ssl_certificate {{ .APP_SSL_PATH }}/server.crt; ssl_certificate_key {{ .APP_SSL_PATH }}/server.key; keepalive_timeout 70; add_header Alternate-Protocol 443:npn-spdy/2; location / { proxy_pass http://{{ .APP }}; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Port $server_port; proxy_set_header X-Request-Start $msec; } include {{ .DOKKU_ROOT }}/{{ .APP }}/nginx.conf.d/*.conf; } upstream {{ .APP }} { {{ range .DOKKU_APP_LISTENERS | split \" \" }} server {{ . }}; {{ end }} } Customizing via configuration files included by the default templates The default nginx.conf template will include everything from your apps nginx.conf.d/ subdirectory in the main server {} block (see above): include {{ .DOKKU_ROOT }}/{{ .APP }}/nginx.conf.d/*.conf; That means you can put additional configuration in separate files, for example to limit the uploaded body size to 50 megabytes, do mkdir /home/dokku/myapp/nginx.conf.d/ echo 'client_max_body_size 50M;' > /home/dokku/myapp/nginx.conf.d/upload.conf chown dokku:dokku /home/dokku/myapp/nginx.conf.d/upload.conf service nginx reload The example above uses additional configuration files directly on the dokku host. Unlike the nginx.conf.sigil file, these additional files will not be copied over from your application repo, and thus need to be placed in the /home/dokku/myapp/nginx.conf.d/ directory manually. Domains plugin See the domain-configuration documentation . Customizing hostnames See the customizing hostnames documentation . Disabling VHOSTS See the disabling vhosts documentation . Default site See the default site documentation . Running behind a load balancer See the load balancer documentation . HSTS Header See the HSTS documentation . SSL Configuration See the ssl documentation . Disabling Nginx See the proxy documentation .","title":"Nginx Configuration"},{"location":"nginx/#nginx-configuration","text":"Dokku uses nginx as its server for routing requests to specific applications. By default, access and error logs are written for each app to /var/log/nginx/${APP}-access.log and /var/log/nginx/${APP}-error.log respectively nginx:access-logs <app> [-t] Show the nginx access logs for an application (-t follows) nginx:build-config <app> (Re)builds nginx config for given app nginx:error-logs <app> [-t] Show the nginx error logs for an application (-t follows)","title":"Nginx Configuration"},{"location":"nginx/#customizing-the-nginx-configuration","text":"New as of 0.5.0 Dokku uses a templating library by the name of sigil to generate nginx configuration for each app. If you'd like to provide a custom template for your application, there are a couple options: Copy the following example template to a file named nginx.conf.sigil and either: check it into the root of your app repo ADD it to your dockerfile WORKDIR if your dockerfile has no WORKDIR , ADD it to the /app folder When using a custom nginx.conf.sigil file, depending upon your application configuration, you may be exposing the file externally. As this file is extracted before the container is run, you can, safely delete it in a custom entrypoint.sh configured in a Dockerfile ENTRYPOINT .","title":"Customizing the nginx configuration"},{"location":"nginx/#example-custom-template","text":"Use case: add an X-Served-By header to requests server { listen [::]:{{ .NGINX_PORT }}; listen {{ .NGINX_PORT }}; server_name {{ .NOSSL_SERVER_NAME }}; access_log /var/log/nginx/{{ .APP }}-access.log; error_log /var/log/nginx/{{ .APP }}-error.log; # set a custom header for requests add_header X-Served-By www-ec2-01; gzip on; gzip_min_length 1100; gzip_buffers 4 32k; gzip_types text/css text/javascript text/xml text/plain text/x-component application/javascript application/x-javascript application/json application/xml application/rss+xml font/truetype application/x-font-ttf font/opentype application/vnd.ms-fontobject image/svg+xml; gzip_vary on; gzip_comp_level 6; location / { proxy_pass http://{{ .APP }}; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Port $server_port; proxy_set_header X-Request-Start $msec; } include {{ .DOKKU_ROOT }}/{{ .APP }}/nginx.conf.d/*.conf; } upstream {{ .APP }} { {{ range .DOKKU_APP_LISTENERS | split \" \" }} server {{ . }}; {{ end }} }","title":"Example Custom Template"},{"location":"nginx/#available-template-variables","text":"{{ .APP }} Application name {{ .APP_SSL_PATH }} Path to SSL certificate and key {{ .DOKKU_ROOT }} Global dokku root directory (ex: app dir would be `{{ .DOKKU_ROOT }}/{{ .APP }}`) {{ .DOKKU_APP_LISTENERS }} List of IP:PORT pairs of app containers {{ .NGINX_PORT }} Non-SSL nginx listener port (same as `DOKKU_NGINX_PORT` config var) {{ .NGINX_SSL_PORT }} SSL nginx listener port (same as `DOKKU_NGINX_SSL_PORT` config var) {{ .NOSSL_SERVER_NAME }} List of non-SSL VHOSTS {{ .RAW_TCP_PORTS }} List of exposed tcp ports as defined by Dockerfile `EXPOSE` directive (**Dockerfile apps only**) {{ .SSL_INUSE }} Boolean set when an app is SSL-enabled {{ .SSL_SERVER_NAME }} List of SSL VHOSTS NOTE: Application config variables are available for use in custom templates. To do so, use the form of {{ var \"FOO\" }} to access a variable named FOO .","title":"Available template variables"},{"location":"nginx/#example-http-to-https-custom-template","text":"Use case: a simple dockerfile app that includes EXPOSE 80 server { listen [::]:80; listen 80; server_name {{ .NOSSL_SERVER_NAME }}; access_log /var/log/nginx/{{ .APP }}-access.log; error_log /var/log/nginx/{{ .APP }}-error.log; return 301 https://$host:443$request_uri; } server { listen [::]:443 ssl spdy; listen 443 ssl spdy; {{ if .SSL_SERVER_NAME }}server_name {{ .SSL_SERVER_NAME }}; {{ end }} access_log /var/log/nginx/{{ .APP }}-access.log; error_log /var/log/nginx/{{ .APP }}-error.log; ssl_certificate {{ .APP_SSL_PATH }}/server.crt; ssl_certificate_key {{ .APP_SSL_PATH }}/server.key; keepalive_timeout 70; add_header Alternate-Protocol 443:npn-spdy/2; location / { proxy_pass http://{{ .APP }}; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Port $server_port; proxy_set_header X-Request-Start $msec; } include {{ .DOKKU_ROOT }}/{{ .APP }}/nginx.conf.d/*.conf; } upstream {{ .APP }} { {{ range .DOKKU_APP_LISTENERS | split \" \" }} server {{ . }}; {{ end }} }","title":"Example HTTP to HTTPS Custom Template"},{"location":"nginx/#customizing-via-configuration-files-included-by-the-default-templates","text":"The default nginx.conf template will include everything from your apps nginx.conf.d/ subdirectory in the main server {} block (see above): include {{ .DOKKU_ROOT }}/{{ .APP }}/nginx.conf.d/*.conf; That means you can put additional configuration in separate files, for example to limit the uploaded body size to 50 megabytes, do mkdir /home/dokku/myapp/nginx.conf.d/ echo 'client_max_body_size 50M;' > /home/dokku/myapp/nginx.conf.d/upload.conf chown dokku:dokku /home/dokku/myapp/nginx.conf.d/upload.conf service nginx reload The example above uses additional configuration files directly on the dokku host. Unlike the nginx.conf.sigil file, these additional files will not be copied over from your application repo, and thus need to be placed in the /home/dokku/myapp/nginx.conf.d/ directory manually.","title":"Customizing via configuration files included by the default templates"},{"location":"nginx/#domains-plugin","text":"See the domain-configuration documentation .","title":"Domains plugin"},{"location":"nginx/#customizing-hostnames","text":"See the customizing hostnames documentation .","title":"Customizing hostnames"},{"location":"nginx/#disabling-vhosts","text":"See the disabling vhosts documentation .","title":"Disabling VHOSTS"},{"location":"nginx/#default-site","text":"See the default site documentation .","title":"Default site"},{"location":"nginx/#running-behind-a-load-balancer","text":"See the load balancer documentation .","title":"Running behind a load balancer"},{"location":"nginx/#hsts-header","text":"See the HSTS documentation .","title":"HSTS Header"},{"location":"nginx/#ssl-configuration","text":"See the ssl documentation .","title":"SSL Configuration"},{"location":"nginx/#disabling-nginx","text":"See the proxy documentation .","title":"Disabling Nginx"},{"location":"plugins/","text":"Plugins Dokku itself is built out of plugins and uses plugn for its plugin system. In essence a plugin is a collection of scripts that will be run based on naming convention. Let's take a quick look at the current dokku nginx plugin that's shipped with dokku by default. nginx-vhosts/ \u251c\u2500\u2500 plugin.toml # plugin metadata \u251c\u2500\u2500 commands # contains additional commands \u251c\u2500\u2500 install # runs on dokku installation \u2514\u2500\u2500 post-deploy # runs after an app is deployed Installing a plugin # This command requires `root` permissions as the `install` and `install-dependencies` # plugin triggers may utilize commands such as `apt-get`. For non-core plugins, please # inspect those plugins before running the following command as `root` user. sudo dokku plugin:install <git_url> [ --committish tag/branch/commit | --name custom-plugin-name ] # previous versions (0.3.x and below) of dokku require a manual process to install plugins cd /var/lib/dokku/plugins git clone <git url> dokku plugins-install Creating your own plugin See the full documentation . Official Plugins (Beta) The following plugins are available and provided by dokku maintainers. Where noted, these plugins should be considered beta software and may not have been used as thoroughly as community plugins. Please file issues against their respective issue trackers. Plugin Author Compatibility CouchDB (beta) dokku 0.4.0+ Elasticsearch (beta) dokku 0.4.0+ MariaDB (beta) dokku 0.4.0+ Memcached (beta) dokku 0.4.0+ Mongo (beta) dokku 0.4.0+ MySQL (beta) dokku 0.4.0+ Nats (beta) dokku 0.4.0+ Postgres (beta) dokku 0.4.0+ RabbitMQ (beta) dokku 0.4.0+ Redis (beta) dokku 0.4.0+ RethinkDB (beta) dokku 0.4.0+ Copy Files to Image dokku 0.4.0+ HTTP Auth (beta) dokku 0.4.0+ Let's Encrypt (beta) dokku 0.4.0+ Maintenance mode (beta) dokku 0.4.0+ Redirect (beta) dokku 0.4.0+ Community plugins Note: The following plugins have been supplied by our community and may not have been tested by dokku maintainers. Datastores Relational Plugin Author Compatibility MariaDB Kloadut 0.3.x MariaDB (single container) ohardy 0.3.x MariaDB (single container) krisrang 0.3.26+ PostgreSQL jlachowski 0.3.x PostgreSQL (single container) ohardy 0.3.x PostgreSQL (single container) Flink 0.3.26+ Caching Plugin Author Compatibility Nginx Cache Aluxian 0.5.0+ Redis sekjun9878 0.3.26+ Redis (single container) ohardy 0.3.x Varnish Zenedith Varnish cache between nginx and application with base configuration Queuing Plugin Author Compatibility RabbitMQ jlachowski 0.3.x RabbitMQ (single container) jlachowski 0.3.x ElasticMQ (SQS compatible) [cu12][] 0.5.0+ Other Plugin Author Compatibility etcd basgys 0.4.x RethinkDB stuartpb 0.3.x FakeSNS [cu12][] 0.5.0+ Process Managers Plugin Author Compatibility Circus apmorton Forego iskandar Compatible with 0.2.x Forego Flink 0.4.0+ Logging Supervisord sehrope 0.4.0+ Monit cjblomqvist 0.3.x Shoreman statianzo 0.3.x Supervisord statianzo 0.3.x Dokku Features Plugin Author Compatibility App name as env cjblomqvist 0.3.x App User michaelshobbs 0.4.0+ Dokku Clone crisward 0.4.0+ Docker Direct heichblatt Dokku Copy App Config Files alexkruegger Compatible with 0.3.17+ Dokku Copy App Config Files heichblatt Dokku Name alex-sherwin dokku >= c77cbf1 Dokku Registry 1 agco-adm 0.4.0+ Dokku Require 2 crisward 0.4.0+ git rev-parse HEAD in env cjblomqvist 0.4.0+ Graduate (Environment Management) Benjamin-Dobell 0.3.14+ Haproxy tcp load balancer 256dpi 0.4.0+ HTTP Auth Secure Apps matto1990 0.4.0+ Hostname michaelshobbs 0.4.0+ Multi-Buildpack pauldub Nuke Containers heichblatt Open App Ports heichblatt Pre-Deploy Tasks michaelshobbs 0.4.0+ Proctype Filter michaelshobbs 0.4.0+ SSH Deployment Keys 3 cedricziel 0.3.x SSH Hostkeys 4 cedricziel 0.3.x Volume (persistent storage) ohardy 0.3.x 1 On Heroku similar functionality is offered by the heroku-labs pipeline feature , which allows you to promote builds across multiple environments (staging -> production) 2 Extends app.json support to include creating volumes and creating / linking databases on push 3 Adds the possibility to add SSH deployment keys to receive private hosted packages 4 Adds the ability to add custom hosts to the containers known_hosts file to be able to ssh them easily (useful with deployment keys) Other Plugins Plugin Author Compatibility Airbrake deploy Flink 0.4.0+ APT F4-Group 0.2.0+ (tag 0.2.0), 0.3.0+ (tag 0.3.0), 0.4.0+ Chef cookbooks fgrehm Bower install alexanderbeletsky Bower/Grunt thrashr888 Bower/Gulp gdi2290 Bower/Gulp jagandecapri Builders: bower, compass, gulp, grunt ignlg 0.4.0+ Docker auto persist volumes Flink 0.4.0+ HipChat Notifications cef Graphite/statsd jlachowski <0.4.0 Graphite/statsd jlachowski 0.4.0+, graphite & statsd plugin with grafana dashboard frontend Logspout michaelshobbs 0.3.26+ Monorepo iamale 0.4.0+ Node pnegahdar Node ademuk Reset mtime mixxorz 0.3.15+, Dockerfile support Slack Notifications ribot 0.4.0+ Tor michaelshobbs 0.4.0+ User ACL Maciej \u0141ebkowski 0.4.0+ Webhooks nickstenning Wkhtmltopdf mbriskar Wordpress abossard Dokku dev, mariadb, volume, domains Long Timeout [investtools][] 0.4.0+ Hostname michaelshobbs 0.4.0+ Rollbar [iloveitaly][] 0.5.0+ 1 Forked from jezdez/dokku-elasticsearch-plugin : uses Elasticsearch 1.2 (instead of 0.90), doesn't depend on dokku-link, runs as elasticsearch user instead of root, and turns off multicast autodiscovery for use in a VPS environment. Deprecated Plugins The following plugins have been removed as their functionality is now in Dokku Core. Plugin Author In Dokku Since Custom Domains motin v0.3.10 (domains plugin) Debug heichblatt v0.3.9 (trace command) Docker Options dyson v0.3.17 (docker-options plugin) Events Logger alessio v0.3.21 (events plugin) Host Port binding stuartpb v0.3.17 (docker-options plugin) List Containers heichblatt v0.3.14 (ps plugin Link Containers rlaneve v0.3.17 (docker-options plugin) Multiple Domains 1 wmluke v0.3.10 (domains plugin) Named-containers Flink v0.4.2 (named-containers plugin) Nginx-Alt mikexstudios v0.3.10 (domains plugin) Persistent Storage dyson v0.3.17 (docker-options plugin) PrimeCache darkpixel v0.3.0 (zero downtime deploys) Rebuild application scottatron v0.3.14 (ps plugin) Supply env vars to buildpacks 2 cameron-martin v0.3.9 (build-env plugin) user-env-compile 2 musicglue v0.3.9 (build-env plugin) user-env-compile 2 motin v0.3.9 (build-env plugin) VHOSTS Custom Configuration motin v0.3.10 (domains plugin) 1 Conflicts with VHOSTS Custom Configuration 2 Similar to the heroku-labs feature (see https://devcenter.heroku.com/articles/labs-user-env-compile) Unmaintained Plugins The following plugins are no longer maintained by their developers. Plugin Author Compatibility app-url mikecsh Works with 0.2.0 CouchDB (multi containers) Flink 0.4.0+ CouchDB RaceHub Compatible with 0.2.0 Elasticsearch robv Not compatible with >= 0.3.0 (still uses /home/git) Elasticsearch 1 blag Compatible with 0.2.0 Memcached Flink 0.4.0+ MongoDB (single container) jeffutter MySQL hughfletcher Neo4j Aomitayo PostGIS fermuch PostgreSQL (single container) jeffutter This plugin creates a single postgresql container that all your apps can use. Thus only one instance of postgresql running (good for servers without a ton of memory). RiakCS (single container) jeffutter Incompatible with 0.2.0 (checked at dccee02 ) Redis luxifer","title":"Plugins"},{"location":"plugins/#plugins","text":"Dokku itself is built out of plugins and uses plugn for its plugin system. In essence a plugin is a collection of scripts that will be run based on naming convention. Let's take a quick look at the current dokku nginx plugin that's shipped with dokku by default. nginx-vhosts/ \u251c\u2500\u2500 plugin.toml # plugin metadata \u251c\u2500\u2500 commands # contains additional commands \u251c\u2500\u2500 install # runs on dokku installation \u2514\u2500\u2500 post-deploy # runs after an app is deployed","title":"Plugins"},{"location":"plugins/#installing-a-plugin","text":"# This command requires `root` permissions as the `install` and `install-dependencies` # plugin triggers may utilize commands such as `apt-get`. For non-core plugins, please # inspect those plugins before running the following command as `root` user. sudo dokku plugin:install <git_url> [ --committish tag/branch/commit | --name custom-plugin-name ] # previous versions (0.3.x and below) of dokku require a manual process to install plugins cd /var/lib/dokku/plugins git clone <git url> dokku plugins-install","title":"Installing a plugin"},{"location":"plugins/#creating-your-own-plugin","text":"See the full documentation .","title":"Creating your own plugin"},{"location":"plugins/#official-plugins-beta","text":"The following plugins are available and provided by dokku maintainers. Where noted, these plugins should be considered beta software and may not have been used as thoroughly as community plugins. Please file issues against their respective issue trackers. Plugin Author Compatibility CouchDB (beta) dokku 0.4.0+ Elasticsearch (beta) dokku 0.4.0+ MariaDB (beta) dokku 0.4.0+ Memcached (beta) dokku 0.4.0+ Mongo (beta) dokku 0.4.0+ MySQL (beta) dokku 0.4.0+ Nats (beta) dokku 0.4.0+ Postgres (beta) dokku 0.4.0+ RabbitMQ (beta) dokku 0.4.0+ Redis (beta) dokku 0.4.0+ RethinkDB (beta) dokku 0.4.0+ Copy Files to Image dokku 0.4.0+ HTTP Auth (beta) dokku 0.4.0+ Let's Encrypt (beta) dokku 0.4.0+ Maintenance mode (beta) dokku 0.4.0+ Redirect (beta) dokku 0.4.0+","title":"Official Plugins (Beta)"},{"location":"plugins/#community-plugins","text":"Note: The following plugins have been supplied by our community and may not have been tested by dokku maintainers.","title":"Community plugins"},{"location":"plugins/#datastores","text":"","title":"Datastores"},{"location":"plugins/#relational","text":"Plugin Author Compatibility MariaDB Kloadut 0.3.x MariaDB (single container) ohardy 0.3.x MariaDB (single container) krisrang 0.3.26+ PostgreSQL jlachowski 0.3.x PostgreSQL (single container) ohardy 0.3.x PostgreSQL (single container) Flink 0.3.26+","title":"Relational"},{"location":"plugins/#caching","text":"Plugin Author Compatibility Nginx Cache Aluxian 0.5.0+ Redis sekjun9878 0.3.26+ Redis (single container) ohardy 0.3.x Varnish Zenedith Varnish cache between nginx and application with base configuration","title":"Caching"},{"location":"plugins/#queuing","text":"Plugin Author Compatibility RabbitMQ jlachowski 0.3.x RabbitMQ (single container) jlachowski 0.3.x ElasticMQ (SQS compatible) [cu12][] 0.5.0+","title":"Queuing"},{"location":"plugins/#other","text":"Plugin Author Compatibility etcd basgys 0.4.x RethinkDB stuartpb 0.3.x FakeSNS [cu12][] 0.5.0+","title":"Other"},{"location":"plugins/#process-managers","text":"Plugin Author Compatibility Circus apmorton Forego iskandar Compatible with 0.2.x Forego Flink 0.4.0+ Logging Supervisord sehrope 0.4.0+ Monit cjblomqvist 0.3.x Shoreman statianzo 0.3.x Supervisord statianzo 0.3.x","title":"Process Managers"},{"location":"plugins/#dokku-features","text":"Plugin Author Compatibility App name as env cjblomqvist 0.3.x App User michaelshobbs 0.4.0+ Dokku Clone crisward 0.4.0+ Docker Direct heichblatt Dokku Copy App Config Files alexkruegger Compatible with 0.3.17+ Dokku Copy App Config Files heichblatt Dokku Name alex-sherwin dokku >= c77cbf1 Dokku Registry 1 agco-adm 0.4.0+ Dokku Require 2 crisward 0.4.0+ git rev-parse HEAD in env cjblomqvist 0.4.0+ Graduate (Environment Management) Benjamin-Dobell 0.3.14+ Haproxy tcp load balancer 256dpi 0.4.0+ HTTP Auth Secure Apps matto1990 0.4.0+ Hostname michaelshobbs 0.4.0+ Multi-Buildpack pauldub Nuke Containers heichblatt Open App Ports heichblatt Pre-Deploy Tasks michaelshobbs 0.4.0+ Proctype Filter michaelshobbs 0.4.0+ SSH Deployment Keys 3 cedricziel 0.3.x SSH Hostkeys 4 cedricziel 0.3.x Volume (persistent storage) ohardy 0.3.x 1 On Heroku similar functionality is offered by the heroku-labs pipeline feature , which allows you to promote builds across multiple environments (staging -> production) 2 Extends app.json support to include creating volumes and creating / linking databases on push 3 Adds the possibility to add SSH deployment keys to receive private hosted packages 4 Adds the ability to add custom hosts to the containers known_hosts file to be able to ssh them easily (useful with deployment keys)","title":"Dokku Features"},{"location":"plugins/#other-plugins","text":"Plugin Author Compatibility Airbrake deploy Flink 0.4.0+ APT F4-Group 0.2.0+ (tag 0.2.0), 0.3.0+ (tag 0.3.0), 0.4.0+ Chef cookbooks fgrehm Bower install alexanderbeletsky Bower/Grunt thrashr888 Bower/Gulp gdi2290 Bower/Gulp jagandecapri Builders: bower, compass, gulp, grunt ignlg 0.4.0+ Docker auto persist volumes Flink 0.4.0+ HipChat Notifications cef Graphite/statsd jlachowski <0.4.0 Graphite/statsd jlachowski 0.4.0+, graphite & statsd plugin with grafana dashboard frontend Logspout michaelshobbs 0.3.26+ Monorepo iamale 0.4.0+ Node pnegahdar Node ademuk Reset mtime mixxorz 0.3.15+, Dockerfile support Slack Notifications ribot 0.4.0+ Tor michaelshobbs 0.4.0+ User ACL Maciej \u0141ebkowski 0.4.0+ Webhooks nickstenning Wkhtmltopdf mbriskar Wordpress abossard Dokku dev, mariadb, volume, domains Long Timeout [investtools][] 0.4.0+ Hostname michaelshobbs 0.4.0+ Rollbar [iloveitaly][] 0.5.0+ 1 Forked from jezdez/dokku-elasticsearch-plugin : uses Elasticsearch 1.2 (instead of 0.90), doesn't depend on dokku-link, runs as elasticsearch user instead of root, and turns off multicast autodiscovery for use in a VPS environment.","title":"Other Plugins"},{"location":"plugins/#deprecated-plugins","text":"The following plugins have been removed as their functionality is now in Dokku Core. Plugin Author In Dokku Since Custom Domains motin v0.3.10 (domains plugin) Debug heichblatt v0.3.9 (trace command) Docker Options dyson v0.3.17 (docker-options plugin) Events Logger alessio v0.3.21 (events plugin) Host Port binding stuartpb v0.3.17 (docker-options plugin) List Containers heichblatt v0.3.14 (ps plugin Link Containers rlaneve v0.3.17 (docker-options plugin) Multiple Domains 1 wmluke v0.3.10 (domains plugin) Named-containers Flink v0.4.2 (named-containers plugin) Nginx-Alt mikexstudios v0.3.10 (domains plugin) Persistent Storage dyson v0.3.17 (docker-options plugin) PrimeCache darkpixel v0.3.0 (zero downtime deploys) Rebuild application scottatron v0.3.14 (ps plugin) Supply env vars to buildpacks 2 cameron-martin v0.3.9 (build-env plugin) user-env-compile 2 musicglue v0.3.9 (build-env plugin) user-env-compile 2 motin v0.3.9 (build-env plugin) VHOSTS Custom Configuration motin v0.3.10 (domains plugin) 1 Conflicts with VHOSTS Custom Configuration 2 Similar to the heroku-labs feature (see https://devcenter.heroku.com/articles/labs-user-env-compile)","title":"Deprecated Plugins"},{"location":"plugins/#unmaintained-plugins","text":"The following plugins are no longer maintained by their developers. Plugin Author Compatibility app-url mikecsh Works with 0.2.0 CouchDB (multi containers) Flink 0.4.0+ CouchDB RaceHub Compatible with 0.2.0 Elasticsearch robv Not compatible with >= 0.3.0 (still uses /home/git) Elasticsearch 1 blag Compatible with 0.2.0 Memcached Flink 0.4.0+ MongoDB (single container) jeffutter MySQL hughfletcher Neo4j Aomitayo PostGIS fermuch PostgreSQL (single container) jeffutter This plugin creates a single postgresql container that all your apps can use. Thus only one instance of postgresql running (good for servers without a ton of memory). RiakCS (single container) jeffutter Incompatible with 0.2.0 (checked at dccee02 ) Redis luxifer","title":"Unmaintained Plugins"},{"location":"process-management/","text":"Process/Container management New as of 0.3.14 Dokku supports rudimentary process (really container) management via the ps plugin. ps <app> List processes running in app container(s) ps:rebuildall Rebuild all apps ps:rebuild <app> Rebuild an app ps:restartall Restart all deployed app containers ps:restart <app> Restart app container(s) ps:scale <app> <proc>=<count> [<proc>=<count>] Set how many processes of a given process to run ps:start <app> Start app container(s) ps:stop <app> Stop app container(s) Scaling Dokku allows you to run multiple process types at different container counts. For example, if you had an app that contained 1 web app listener and 1 background job processor, dokku can, spin up 1 container for each process type defined in the Procfile. By default, dokku will only start a single web process (if defined.) However, if you wanted, for example, 2 job processors running simultaneously, you can modify this behavior in one of the following ways. DOKKU_SCALE file You can optionally create a DOKKU_SCALE file in the root of your repository. Dokku expects this file to contain one line for every process defined in your Procfile. Example: web=1 worker=2 ps:scale command Dokku can also manage scaling itself via the ps:scale command. This command can be used to scale multiple process types at the same time. dokku ps:scale app_name web=1 worker=2 NOTE : Dokku will always use the DOKKU_SCALE file that ships with the repo to override any local settings. The web proctype Like Heroku, we handle the web proctype differently from others. The web proctype is the only proctype that will invoke custom checks as defined by a CHECKS file. It is also the only proctype that will be launched in a container that is either proxied via nginx or bound to an external port.","title":"Process/Container management"},{"location":"process-management/#processcontainer-management","text":"New as of 0.3.14 Dokku supports rudimentary process (really container) management via the ps plugin. ps <app> List processes running in app container(s) ps:rebuildall Rebuild all apps ps:rebuild <app> Rebuild an app ps:restartall Restart all deployed app containers ps:restart <app> Restart app container(s) ps:scale <app> <proc>=<count> [<proc>=<count>] Set how many processes of a given process to run ps:start <app> Start app container(s) ps:stop <app> Stop app container(s)","title":"Process/Container management"},{"location":"process-management/#scaling","text":"Dokku allows you to run multiple process types at different container counts. For example, if you had an app that contained 1 web app listener and 1 background job processor, dokku can, spin up 1 container for each process type defined in the Procfile. By default, dokku will only start a single web process (if defined.) However, if you wanted, for example, 2 job processors running simultaneously, you can modify this behavior in one of the following ways.","title":"Scaling"},{"location":"process-management/#dokku_scale-file","text":"You can optionally create a DOKKU_SCALE file in the root of your repository. Dokku expects this file to contain one line for every process defined in your Procfile. Example: web=1 worker=2","title":"DOKKU_SCALE file"},{"location":"process-management/#psscale-command","text":"Dokku can also manage scaling itself via the ps:scale command. This command can be used to scale multiple process types at the same time. dokku ps:scale app_name web=1 worker=2 NOTE : Dokku will always use the DOKKU_SCALE file that ships with the repo to override any local settings.","title":"ps:scale command"},{"location":"process-management/#the-web-proctype","text":"Like Heroku, we handle the web proctype differently from others. The web proctype is the only proctype that will invoke custom checks as defined by a CHECKS file. It is also the only proctype that will be launched in a container that is either proxied via nginx or bound to an external port.","title":"The web proctype"},{"location":"proxy/","text":"Proxy plugin New as of 0.5.0 As of dokku 0.5.0, the proxy functionality has been decoupled from the nginx-vhosts plugin into the proxy plugin. In the future this will allow other proxy software (HAproxy for example) to be used instead of nginx. proxy:disable <app> Disable proxy for app proxy:enable <app> Enable proxy for app proxy:set <app> <proxy_type> NOT IMPLEMENTED YET!! Container network interface binding By default, the deployed docker container running your app's web process will bind to the internal docker network interface (i.e. docker inspect --format '{{ .NetworkSettings.IPAddress }}' $CONTAINER_ID ). This behavior can be modified per app by disabling the proxy (i.e. dokku proxy:disable <app> ). In this case, the container will bind to an external interface (i.e. 0.0.0.0) and your app container will be directly accessible by other hosts on your network. If a proxy is disabled, dokku will bind your container's port to a random port on the host, e.g. 0.0.0.0:32771->5000/tcp . # container bound to docker interface root@dokku:~/dokku# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b88d8aec3d1 dokku/node-js-app:latest \"/bin/bash -c '/star About a minute ago Up About a minute node-js-app.web.1 root@dokku:~/dokku# docker inspect --format '{{ .NetworkSettings.IPAddress }}' node-js-app.web.1 172.17.0.6 # container bound to all interfaces root@dokku:/home/dokku# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d6499edb0edb dokku/node-js-app:latest \" /bin/bash -c ' /star About a minute ago Up About a minute 0 .0.0.0:49153->5000/tcp node-js-app.web.1","title":"Proxy plugin"},{"location":"proxy/#proxy-plugin","text":"New as of 0.5.0 As of dokku 0.5.0, the proxy functionality has been decoupled from the nginx-vhosts plugin into the proxy plugin. In the future this will allow other proxy software (HAproxy for example) to be used instead of nginx. proxy:disable <app> Disable proxy for app proxy:enable <app> Enable proxy for app proxy:set <app> <proxy_type> NOT IMPLEMENTED YET!!","title":"Proxy plugin"},{"location":"proxy/#container-network-interface-binding","text":"By default, the deployed docker container running your app's web process will bind to the internal docker network interface (i.e. docker inspect --format '{{ .NetworkSettings.IPAddress }}' $CONTAINER_ID ). This behavior can be modified per app by disabling the proxy (i.e. dokku proxy:disable <app> ). In this case, the container will bind to an external interface (i.e. 0.0.0.0) and your app container will be directly accessible by other hosts on your network. If a proxy is disabled, dokku will bind your container's port to a random port on the host, e.g. 0.0.0.0:32771->5000/tcp . # container bound to docker interface root@dokku:~/dokku# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b88d8aec3d1 dokku/node-js-app:latest \"/bin/bash -c '/star About a minute ago Up About a minute node-js-app.web.1 root@dokku:~/dokku# docker inspect --format '{{ .NetworkSettings.IPAddress }}' node-js-app.web.1 172.17.0.6 # container bound to all interfaces root@dokku:/home/dokku# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d6499edb0edb dokku/node-js-app:latest \" /bin/bash -c ' /star About a minute ago Up About a minute 0 .0.0.0:49153->5000/tcp node-js-app.web.1","title":"Container network interface binding"},{"location":"remote-commands/","text":"Remote Commands Dokku commands can be run over ssh. Anywhere you would run dokku <command> , just run ssh -t dokku@dokku.me <command> The -t is used to request a pty. It is highly recommended to do so. To avoid the need to type the -t option each time, simply create/modify a section in the .ssh/config on the client side, as follows: Host dokku.me RequestTTY yes Behavioral modifiers Dokku also supports certain command-line arguments that augment it's behavior. If using these over ssh, you must use the form ssh -t dokku@dokku.me -- <command> in order to avoid ssh interpretting dokku arguments for itself. --quiet suppress output headers --trace enable DOKKU_TRACE for current execution only --rm | --rm-container remove docker container after successful dokku run <app> <command> --force force flag. currently used in apps:destroy and other \":destroy\" commands Clients You may optionally use a client to connect to your dokku server. Most clients use the configured git remote to locate the dokku server, though some allow for overriding this via an environment variable or flag. Please refer to the clients list for more details.","title":"Remote Commands"},{"location":"remote-commands/#remote-commands","text":"Dokku commands can be run over ssh. Anywhere you would run dokku <command> , just run ssh -t dokku@dokku.me <command> The -t is used to request a pty. It is highly recommended to do so. To avoid the need to type the -t option each time, simply create/modify a section in the .ssh/config on the client side, as follows: Host dokku.me RequestTTY yes","title":"Remote Commands"},{"location":"remote-commands/#behavioral-modifiers","text":"Dokku also supports certain command-line arguments that augment it's behavior. If using these over ssh, you must use the form ssh -t dokku@dokku.me -- <command> in order to avoid ssh interpretting dokku arguments for itself. --quiet suppress output headers --trace enable DOKKU_TRACE for current execution only --rm | --rm-container remove docker container after successful dokku run <app> <command> --force force flag. currently used in apps:destroy and other \":destroy\" commands","title":"Behavioral modifiers"},{"location":"remote-commands/#clients","text":"You may optionally use a client to connect to your dokku server. Most clients use the configured git remote to locate the dokku server, though some allow for overriding this via an environment variable or flag. Please refer to the clients list for more details.","title":"Clients"},{"location":"troubleshooting/","text":"Troubleshooting Symptom: I deployed my app but I am getting the default nginx page Solution: Most of the time it's caused by some defaults newer versions of nginx set. To make sure that's the issue you're having run the following: root@dockerapps:/home/git# nginx nginx: [emerg] could not build the server_names_hash, you should increase server_names_hash_bucket_size: 32 If you get a similar error just edit /etc/nginx/nginx.conf and add the following line to your http section: http { (... existing content ...) server_names_hash_bucket_size 64; (...) } Note that the server_names_hash_bucket_size setting defines the maximum domain name length. A value of 64 would allow domains with up to 64 characters. Set it to 128 if you need longer ones. Save the file and try stopping nginx and starting it again: root@dockerapps:~/dokku# /etc/init.d/nginx stop * Stopping nginx nginx [ OK ] root@dockerapps:~/dokku# /etc/init.d/nginx start * Starting nginx nginx [ OK ] Symptom: I want to deploy my app, but while pushing I get the following error ! [remote rejected] master -> master (pre-receive hook declined) Solution: The remote rejected error does not give enough information. Anything could have failed. To enable dokku tracing, simply run the following command: # Since 0.3.9 dokku trace on In versions older than 0.3.9, you can create a /home/dokku/dokkurc file containing the following : export DOKKU_TRACE=1 This will trace all of dokku's activity. If this does not help you, create a gist containing the full log, and create an issue. Symptom: I get the aforementioned error in the build phase (after turning on dokku tracing) Most errors that happen in this phase are due to transient network issues (either locally or remotely) buildpack bugs. Solution (Less solution, more helpful troubleshooting steps): Find the failed phase's container image ( 077581956a92 in this example) ``` root@dokku:~# docker ps -a | grep build 94d9515e6d93 077581956a92 \"/build\" 29 minutes ago Exited (0) 25 minutes ago cocky_bell ``` Start a new container with the failed image and poke around (i.e. ensure you can access the internet from within the container or attempt the failed command, if known) ``` root@dokku:~# docker run -ti 077581956a92 /bin/bash root@9763ab86e1b4:/# curl -s -S icanhazip.com 192.168.0.1 curl http://s3pository.heroku.com/node/v0.10.30/node-v0.10.30-linux-x64.tar.gz -o node-v0.10.30-linux-x64.tar.gz tar tzf node-v0.10.30-linux-x64.tar.gz ... ``` Sometimes (especially on DO) deploying again seems to get past these seemingly transient issues Additionally we've seen issues if changing networks that have different DNS resolvers. In this case, you can run the following to update your resolv.conf root@dokku:~# resolvconf -u Please see https://github.com/dokku/dokku/issues/841 and https://github.com/dokku/dokku/issues/649 Symptom: I want to deploy my app but I am getting asked for the password of the git user and the error message fatal: 'NAME' does not appear to be a git repository fatal: Could not read from remote repository. Solution: You get asked for a password because your ssh secret key can't be found. This may happen if the private key corresponding to the public key you added with sshcommand acl-add is not located in the default location ~/.ssh/id_rsa . You have to point ssh to the correct secret key for your domain name. Add the following to your ~/.ssh/config : Host DOKKU_HOSTNAME IdentityFile \"~/.ssh/KEYNAME\" Also see issue #116 Symptom: I successfully deployed my application with no deployment errors and receiving Bad Gateway when attempting to access the application Solution: In many cases the application will require the a process.env.PORT port opposed to a specified port. When specifying your port you may want to use something similar to: var port = process.env.PORT || 3000 Please see https://github.com/dokku/dokku/issues/282 Symptom: Deployment fails because of slow internet connection, messages shows gzip: stdin: unexpected end of file Solution: If you see output similar this when deploying: Command: 'set -o pipefail; curl --fail --retry 3 --retry-delay 1 --connect-timeout 3 --max-time 30 https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/ruby-2.0.0-p451-default-cache.tgz -s -o - | tar zxf -' failed unexpectedly: ! ! gzip: stdin: unexpected end of file ! tar: Unexpected EOF in archive ! tar: Unexpected EOF in archive ! tar: Error is not recoverable: exiting now it might that the curl command that is supposed to fetch the buildpack (anything in the low megabyte file size range) takes too long to finish, due to slowish connection. To overwrite the default values (connection timeout: 3 seconds, total maximum time for operation: 30 seconds), set the following environment variables: dokku config:set --global CURL_TIMEOUT = 600 dokku config:set --global CURL_CONNECT_TIMEOUT = 30 References * https://github.com/dokku/dokku/issues/509 * https://github.com/dokku-alt/dokku-alt/issues/169","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"Symptom: I deployed my app but I am getting the default nginx page Solution: Most of the time it's caused by some defaults newer versions of nginx set. To make sure that's the issue you're having run the following: root@dockerapps:/home/git# nginx nginx: [emerg] could not build the server_names_hash, you should increase server_names_hash_bucket_size: 32 If you get a similar error just edit /etc/nginx/nginx.conf and add the following line to your http section: http { (... existing content ...) server_names_hash_bucket_size 64; (...) } Note that the server_names_hash_bucket_size setting defines the maximum domain name length. A value of 64 would allow domains with up to 64 characters. Set it to 128 if you need longer ones. Save the file and try stopping nginx and starting it again: root@dockerapps:~/dokku# /etc/init.d/nginx stop * Stopping nginx nginx [ OK ] root@dockerapps:~/dokku# /etc/init.d/nginx start * Starting nginx nginx [ OK ] Symptom: I want to deploy my app, but while pushing I get the following error ! [remote rejected] master -> master (pre-receive hook declined) Solution: The remote rejected error does not give enough information. Anything could have failed. To enable dokku tracing, simply run the following command: # Since 0.3.9 dokku trace on In versions older than 0.3.9, you can create a /home/dokku/dokkurc file containing the following : export DOKKU_TRACE=1 This will trace all of dokku's activity. If this does not help you, create a gist containing the full log, and create an issue. Symptom: I get the aforementioned error in the build phase (after turning on dokku tracing) Most errors that happen in this phase are due to transient network issues (either locally or remotely) buildpack bugs. Solution (Less solution, more helpful troubleshooting steps): Find the failed phase's container image ( 077581956a92 in this example) ``` root@dokku:~# docker ps -a | grep build 94d9515e6d93 077581956a92 \"/build\" 29 minutes ago Exited (0) 25 minutes ago cocky_bell ``` Start a new container with the failed image and poke around (i.e. ensure you can access the internet from within the container or attempt the failed command, if known) ``` root@dokku:~# docker run -ti 077581956a92 /bin/bash root@9763ab86e1b4:/# curl -s -S icanhazip.com 192.168.0.1 curl http://s3pository.heroku.com/node/v0.10.30/node-v0.10.30-linux-x64.tar.gz -o node-v0.10.30-linux-x64.tar.gz tar tzf node-v0.10.30-linux-x64.tar.gz ... ``` Sometimes (especially on DO) deploying again seems to get past these seemingly transient issues Additionally we've seen issues if changing networks that have different DNS resolvers. In this case, you can run the following to update your resolv.conf root@dokku:~# resolvconf -u Please see https://github.com/dokku/dokku/issues/841 and https://github.com/dokku/dokku/issues/649 Symptom: I want to deploy my app but I am getting asked for the password of the git user and the error message fatal: 'NAME' does not appear to be a git repository fatal: Could not read from remote repository. Solution: You get asked for a password because your ssh secret key can't be found. This may happen if the private key corresponding to the public key you added with sshcommand acl-add is not located in the default location ~/.ssh/id_rsa . You have to point ssh to the correct secret key for your domain name. Add the following to your ~/.ssh/config : Host DOKKU_HOSTNAME IdentityFile \"~/.ssh/KEYNAME\" Also see issue #116 Symptom: I successfully deployed my application with no deployment errors and receiving Bad Gateway when attempting to access the application Solution: In many cases the application will require the a process.env.PORT port opposed to a specified port. When specifying your port you may want to use something similar to: var port = process.env.PORT || 3000 Please see https://github.com/dokku/dokku/issues/282 Symptom: Deployment fails because of slow internet connection, messages shows gzip: stdin: unexpected end of file Solution: If you see output similar this when deploying: Command: 'set -o pipefail; curl --fail --retry 3 --retry-delay 1 --connect-timeout 3 --max-time 30 https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/ruby-2.0.0-p451-default-cache.tgz -s -o - | tar zxf -' failed unexpectedly: ! ! gzip: stdin: unexpected end of file ! tar: Unexpected EOF in archive ! tar: Unexpected EOF in archive ! tar: Error is not recoverable: exiting now it might that the curl command that is supposed to fetch the buildpack (anything in the low megabyte file size range) takes too long to finish, due to slowish connection. To overwrite the default values (connection timeout: 3 seconds, total maximum time for operation: 30 seconds), set the following environment variables: dokku config:set --global CURL_TIMEOUT = 600 dokku config:set --global CURL_CONNECT_TIMEOUT = 30 References * https://github.com/dokku/dokku/issues/509 * https://github.com/dokku-alt/dokku-alt/issues/169","title":"Troubleshooting"},{"location":"upgrading/","text":"Upgrading If your version of dokku is pre 0.3.0 (check with dokku version ), we recommend a fresh install on a new server. Migration Guides Before upgrading, check the migration guides to get comfortable with new features and prepare your deployment to be upgraded. 0.5 Migration Guide Upgrade Instructions If dokku was installed via apt-get install dokku or bootstrap.sh (most common), upgrade with: sudo apt-get update dokku apps dokku ps:stop <app> # repeat to shut down each running app sudo apt-get install -qq -y dokku herokuish dokku ps:rebuildall # restart all applications Upgrade From Source If you installed dokku from source (less common), upgrade with: dokku apps dokku ps:stop <app> # repeat to shut down each running app cd ~/dokku git pull --tags origin master # continue to install from source sudo DOKKU_BRANCH = master make install # upgrade to debian package-based installation sudo make install dokku ps:rebuildall # restart all applications To upgrade herokuish from source, upgrade with: cd /tmp git clone https://github.com/gliderlabs/herokuish.git cd herokuish git pull origin master IMAGE_NAME = gliderlabs/herokuish BUILD_TAG = latest VERSION = master make -e build-in-docker","title":"Upgrading"},{"location":"upgrading/#upgrading","text":"If your version of dokku is pre 0.3.0 (check with dokku version ), we recommend a fresh install on a new server.","title":"Upgrading"},{"location":"upgrading/#migration-guides","text":"Before upgrading, check the migration guides to get comfortable with new features and prepare your deployment to be upgraded. 0.5 Migration Guide","title":"Migration Guides"},{"location":"upgrading/#upgrade-instructions","text":"If dokku was installed via apt-get install dokku or bootstrap.sh (most common), upgrade with: sudo apt-get update dokku apps dokku ps:stop <app> # repeat to shut down each running app sudo apt-get install -qq -y dokku herokuish dokku ps:rebuildall # restart all applications","title":"Upgrade Instructions"},{"location":"upgrading/#upgrade-from-source","text":"If you installed dokku from source (less common), upgrade with: dokku apps dokku ps:stop <app> # repeat to shut down each running app cd ~/dokku git pull --tags origin master # continue to install from source sudo DOKKU_BRANCH = master make install # upgrade to debian package-based installation sudo make install dokku ps:rebuildall # restart all applications To upgrade herokuish from source, upgrade with: cd /tmp git clone https://github.com/gliderlabs/herokuish.git cd herokuish git pull origin master IMAGE_NAME = gliderlabs/herokuish BUILD_TAG = latest VERSION = master make -e build-in-docker","title":"Upgrade From Source"},{"location":"appendices/0.5.0-migration-guide/","text":"0.5.0 Migration Guide nginx-vhosts The nginx-vhosts template language is now sigil No need to escape literal $ characters (or other \"bash-isms\") Template variables are represented as {{ .VARIABLE_NAME }} A detailed list of template variables can be found here A custom nginx-vhosts template must be named nginx.conf.sigil The default path for this custom template is the root of your repo (i.e. /app in the container or WORKDIR if defined in a dockerfile app) Dokku no longer looks for this file in /home/dokku/myapp on the dokku server Check out an example template here Support for server-wide SSL certs have been dropped in favor of using the certs plugin dokku certs:add myapp < certs.tar All domains for an SSL-enabled app will be redirected to https by default This can be overridden with a custom template Replaced \"magic\" NO_VHOST variable with domains:enable/disable Simplified zero downtime control checks:enable/disable Dockerfile apps with exposed ports Dockerfiles with EXPOSE clauses will get all tcp ports proxied by default Note that nginx will proxy the same port numbers to listen publicly UDP ports can be exposed by disabling the nginx proxy with dokku proxy:disable myapp","title":"0.5.0 Migration Guide"},{"location":"appendices/0.5.0-migration-guide/#050-migration-guide","text":"","title":"0.5.0 Migration Guide"},{"location":"appendices/0.5.0-migration-guide/#nginx-vhosts","text":"The nginx-vhosts template language is now sigil No need to escape literal $ characters (or other \"bash-isms\") Template variables are represented as {{ .VARIABLE_NAME }} A detailed list of template variables can be found here A custom nginx-vhosts template must be named nginx.conf.sigil The default path for this custom template is the root of your repo (i.e. /app in the container or WORKDIR if defined in a dockerfile app) Dokku no longer looks for this file in /home/dokku/myapp on the dokku server Check out an example template here Support for server-wide SSL certs have been dropped in favor of using the certs plugin dokku certs:add myapp < certs.tar All domains for an SSL-enabled app will be redirected to https by default This can be overridden with a custom template Replaced \"magic\" NO_VHOST variable with domains:enable/disable Simplified zero downtime control checks:enable/disable","title":"nginx-vhosts"},{"location":"appendices/0.5.0-migration-guide/#dockerfile-apps-with-exposed-ports","text":"Dockerfiles with EXPOSE clauses will get all tcp ports proxied by default Note that nginx will proxy the same port numbers to listen publicly UDP ports can be exposed by disabling the nginx proxy with dokku proxy:disable myapp","title":"Dockerfile apps with exposed ports"},{"location":"community/clients/","text":"Clients Given the constraints, running dokku commands remotely via SSH is fine. For certain configurations, the extra complication of manually invoking ssh can be a burden. While dokku does not yet have an official client, there are a multitude of ways in which you can interact with your dokku installation. The easiest is to use the bash client, though you may wish to use another. (bash, zsh, etc.) dokku_client.sh Of all methods, this is the most official method of interacting with your dokku installation. It is a bash script that interacts with a remote dokku installation via ssh. It is available in contrib/dokku_client.sh in the root of the dokku repository. To install, simply clone the dokku repository down and add the dokku alias pointing at the script: git clone git@github.com:dokku/dokku.git ~/.dokku # optional: make sure that the dokku_client.sh version matches your dokku version cd ~/.dokku git checkout <tag/branch> # add the following to either your # .bashrc, .bash_profile, or .profile file alias dokku = '$HOME/.dokku/contrib/dokku_client.sh' Alternatively, if using another shell such as zsh , create an alias command which invokes the script using bash : # zsh: add the following to either .zshenv or .zshrc alias dokku = 'bash $HOME/.dokku/contrib/dokku_client.sh' # fish: add the following to ~/.config/fish/config.fish alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' # csh: add the following to .cshrc alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' Configure the DOKKU_HOST environment variable or run dokku from a repository with a git remote named dokku pointed at your dokku host in order to use the script as normal. You can also configure a DOKKU_PORT environment variable if you are running ssh on a non-standard port. This defaults to 22 . (nodejs) dokku-toolbelt Dokku-toolbelt is a node-based cli wrapper that proxies requests to the dokku command running on remote hosts. You can install it via the following shell command (assuming you have nodejs and npm installed): npm install -g dokku-toolbelt See documentation here for more information. (python) dokku-client dokku-client is an extensible python-based cli wrapper for remote dokku hosts. You can install it via the following shell command (assuming you have python and pip installed): pip install dokku-client See documentation here for more information. (ruby) Dokku CLI Dokku CLI is a rubygem that acts as a client for your dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku-cli See documentation here for more information. (ruby) DokkuClient DokkuClient is another rubygem that acts as a client for your dokku installation with built-in support for certain external plugins. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku_client See documentation here for more information. (ruby) Dokkufy Dokkufy is a rubygem that handles automation of certain tasks, such as dokku setup, plugin installation, etc. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokkufy See documentation here for more information. (ruby) Dockland Dockland is a rubygem that acts as a client for your dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dockland See documentation here for more information.","title":"Clients"},{"location":"community/clients/#clients","text":"Given the constraints, running dokku commands remotely via SSH is fine. For certain configurations, the extra complication of manually invoking ssh can be a burden. While dokku does not yet have an official client, there are a multitude of ways in which you can interact with your dokku installation. The easiest is to use the bash client, though you may wish to use another.","title":"Clients"},{"location":"community/clients/#bash-zsh-etc-dokku_clientsh","text":"Of all methods, this is the most official method of interacting with your dokku installation. It is a bash script that interacts with a remote dokku installation via ssh. It is available in contrib/dokku_client.sh in the root of the dokku repository. To install, simply clone the dokku repository down and add the dokku alias pointing at the script: git clone git@github.com:dokku/dokku.git ~/.dokku # optional: make sure that the dokku_client.sh version matches your dokku version cd ~/.dokku git checkout <tag/branch> # add the following to either your # .bashrc, .bash_profile, or .profile file alias dokku = '$HOME/.dokku/contrib/dokku_client.sh' Alternatively, if using another shell such as zsh , create an alias command which invokes the script using bash : # zsh: add the following to either .zshenv or .zshrc alias dokku = 'bash $HOME/.dokku/contrib/dokku_client.sh' # fish: add the following to ~/.config/fish/config.fish alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' # csh: add the following to .cshrc alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' Configure the DOKKU_HOST environment variable or run dokku from a repository with a git remote named dokku pointed at your dokku host in order to use the script as normal. You can also configure a DOKKU_PORT environment variable if you are running ssh on a non-standard port. This defaults to 22 .","title":"(bash, zsh, etc.) dokku_client.sh"},{"location":"community/clients/#nodejs-dokku-toolbelt","text":"Dokku-toolbelt is a node-based cli wrapper that proxies requests to the dokku command running on remote hosts. You can install it via the following shell command (assuming you have nodejs and npm installed): npm install -g dokku-toolbelt See documentation here for more information.","title":"(nodejs) dokku-toolbelt"},{"location":"community/clients/#python-dokku-client","text":"dokku-client is an extensible python-based cli wrapper for remote dokku hosts. You can install it via the following shell command (assuming you have python and pip installed): pip install dokku-client See documentation here for more information.","title":"(python) dokku-client"},{"location":"community/clients/#ruby-dokku-cli","text":"Dokku CLI is a rubygem that acts as a client for your dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku-cli See documentation here for more information.","title":"(ruby) Dokku CLI"},{"location":"community/clients/#ruby-dokkuclient","text":"DokkuClient is another rubygem that acts as a client for your dokku installation with built-in support for certain external plugins. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku_client See documentation here for more information.","title":"(ruby) DokkuClient"},{"location":"community/clients/#ruby-dokkufy","text":"Dokkufy is a rubygem that handles automation of certain tasks, such as dokku setup, plugin installation, etc. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokkufy See documentation here for more information.","title":"(ruby) Dokkufy"},{"location":"community/clients/#ruby-dockland","text":"Dockland is a rubygem that acts as a client for your dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dockland See documentation here for more information.","title":"(ruby) Dockland"},{"location":"deployment/buildpacks/","text":"Buildpack Deployment Dokku normally defaults to using heroku buildpacks for deployment, though this may be overridden by committing a valid Dockerfile to the root of your repository and pushing the repository to your Dokku installation. To avoid this automatic Dockerfile deployment detection, you may do one of the following: Use dokku config:set to set the BUILDPACK_URL environment variable. Add BUILDPACK_URL to a committed .env file in the root of your repository. Create a .buildpacks file in the root of your repository. Specifying a custom buildpack In certain cases you may want to specify a custom buildpack. While dokku uses herokuish to support all the official heroku buildpacks , it is possible that the buildpack detection does not work well for your application. As well, you may wish to use a custom buildpack to handle specific application logic. To use a specific buildpack, you can run the following dokku command: # replace APP with the name of your application # replace REPOSITORY_URL with your buildpack's url dokku config:set APP BUILDPACK_URL = REPOSITORY_URL # example: using a specific ruby buildpack version dokku config:set APP BUILDPACK_URL = https://github.com/heroku/heroku-buildpack-ruby.git#v142 Please check the documentation for your particular buildpack as you may need to include configuration files (such as a Procfile) in your project root. Using multiple buildpacks You can only set a single buildpack using the BUILDPACK_URL , though there may be times when you wish to use multiple buildpacks. To do so, simply create a .buildpacks file in the base of your repository. This file should list all the buildpacks, one-per-line. For instance, if you wish to use both the nodejs and ruby buildpacks, your .buildpacks file should contain the following: https://github.com/heroku/heroku-buildpack-nodejs.git#v87 https://github.com/heroku/heroku-buildpack-ruby.git#v142 Always remember to pin your buildpack versions when using the multi-buildpacks method, or you may find deploys changing your deployed environment. You may also choose to set just a single buildpack in this file, though that is up to you. Please check the documentation for your particular buildpack(s) as you may need to include configuration files (such as a Procfile) in your project root. Using a specific buildpack version As Dokku pins all buildpacks via herokuish releases, there may be occasions where a local buildpack version is out of date. If you wish to use a more recent version of the buildpack, you may use any of the above methods to specify a buildpack without the git sha attached like so: # using the latest nodejs buildpack # replace APP with the name of your application dokku config:set APP BUILDPACK_URL = https://github.com/heroku/heroku-buildpack-nodejs You may also wish to use a specific version of a buildpack, which is also simple # using v87 of the nodejs buildpack # replace APP with the name of your application dokku config:set APP BUILDPACK_URL = https://github.com/heroku/heroku-buildpack-nodejs#v87 Specifying commands via Procfile While many buildpacks have a default command that is run when a detected repository is pushed, it is possible to override this command via a Procfile. A Procfile can also be used to specify multiple commands, each of which is subject to process scaling. See the process scaling documentation for more details around scaling individual processes. A Procfile is a file named Procfile . It should be named Procfile exactly, and not anything else. For example, Procfile.txt is not valid. The file should be a simple text file. The file must be placed in the root directory of your application. It will not function if placed in a subdirectory. If the file exists, it should not be empty, as doing so may result in a failed deploy. The syntax for declaring a Procfile is as follows. Note that the format is one process type per line, with no duplicate process types. <process type>: <command> If, for example, you have multiple queue workers and wish to scale them separately, the following would be a valid way to work around the requirement of not duplicating process types: worker: env QUEUE=* bundle exec rake resque:work importantworker: env QUEUE=important bundle exec rake resque:work The web process type holds some significance in that it is the only process type that is automatically scaled to 1 on the initial application deploy. See the process scaling documentation for more details around scaling individual processes. Clearing buildpack cache Building containers with buildpacks currently results in a persistent cache directory between deploys. If you need to clear this cache directory for any reason, you may do so by running the following shell command: # replace APP with the name of your application sudo rm -rf /home/dokku/APP/cache/* Curl Build Timeouts Certain buildpacks may time out in retrieving dependencies via curl. This can happen when your network connection is poor or if there is significant network congestion. You may see a message similar to gzip: stdin: unexpected end of file after a curl command. If you see output similar this when deploying , you may need to override the curl timeouts to increase the length of time allotted to those tasks. You can do so via the config plugin: dokku config:set --global CURL_TIMEOUT = 600 dokku config:set --global CURL_CONNECT_TIMEOUT = 30","title":"Buildpack Deployment"},{"location":"deployment/buildpacks/#buildpack-deployment","text":"Dokku normally defaults to using heroku buildpacks for deployment, though this may be overridden by committing a valid Dockerfile to the root of your repository and pushing the repository to your Dokku installation. To avoid this automatic Dockerfile deployment detection, you may do one of the following: Use dokku config:set to set the BUILDPACK_URL environment variable. Add BUILDPACK_URL to a committed .env file in the root of your repository. Create a .buildpacks file in the root of your repository.","title":"Buildpack Deployment"},{"location":"deployment/buildpacks/#specifying-a-custom-buildpack","text":"In certain cases you may want to specify a custom buildpack. While dokku uses herokuish to support all the official heroku buildpacks , it is possible that the buildpack detection does not work well for your application. As well, you may wish to use a custom buildpack to handle specific application logic. To use a specific buildpack, you can run the following dokku command: # replace APP with the name of your application # replace REPOSITORY_URL with your buildpack's url dokku config:set APP BUILDPACK_URL = REPOSITORY_URL # example: using a specific ruby buildpack version dokku config:set APP BUILDPACK_URL = https://github.com/heroku/heroku-buildpack-ruby.git#v142 Please check the documentation for your particular buildpack as you may need to include configuration files (such as a Procfile) in your project root.","title":"Specifying a custom buildpack"},{"location":"deployment/buildpacks/#using-multiple-buildpacks","text":"You can only set a single buildpack using the BUILDPACK_URL , though there may be times when you wish to use multiple buildpacks. To do so, simply create a .buildpacks file in the base of your repository. This file should list all the buildpacks, one-per-line. For instance, if you wish to use both the nodejs and ruby buildpacks, your .buildpacks file should contain the following: https://github.com/heroku/heroku-buildpack-nodejs.git#v87 https://github.com/heroku/heroku-buildpack-ruby.git#v142 Always remember to pin your buildpack versions when using the multi-buildpacks method, or you may find deploys changing your deployed environment. You may also choose to set just a single buildpack in this file, though that is up to you. Please check the documentation for your particular buildpack(s) as you may need to include configuration files (such as a Procfile) in your project root.","title":"Using multiple buildpacks"},{"location":"deployment/buildpacks/#using-a-specific-buildpack-version","text":"As Dokku pins all buildpacks via herokuish releases, there may be occasions where a local buildpack version is out of date. If you wish to use a more recent version of the buildpack, you may use any of the above methods to specify a buildpack without the git sha attached like so: # using the latest nodejs buildpack # replace APP with the name of your application dokku config:set APP BUILDPACK_URL = https://github.com/heroku/heroku-buildpack-nodejs You may also wish to use a specific version of a buildpack, which is also simple # using v87 of the nodejs buildpack # replace APP with the name of your application dokku config:set APP BUILDPACK_URL = https://github.com/heroku/heroku-buildpack-nodejs#v87","title":"Using a specific buildpack version"},{"location":"deployment/buildpacks/#specifying-commands-via-procfile","text":"While many buildpacks have a default command that is run when a detected repository is pushed, it is possible to override this command via a Procfile. A Procfile can also be used to specify multiple commands, each of which is subject to process scaling. See the process scaling documentation for more details around scaling individual processes. A Procfile is a file named Procfile . It should be named Procfile exactly, and not anything else. For example, Procfile.txt is not valid. The file should be a simple text file. The file must be placed in the root directory of your application. It will not function if placed in a subdirectory. If the file exists, it should not be empty, as doing so may result in a failed deploy. The syntax for declaring a Procfile is as follows. Note that the format is one process type per line, with no duplicate process types. <process type>: <command> If, for example, you have multiple queue workers and wish to scale them separately, the following would be a valid way to work around the requirement of not duplicating process types: worker: env QUEUE=* bundle exec rake resque:work importantworker: env QUEUE=important bundle exec rake resque:work The web process type holds some significance in that it is the only process type that is automatically scaled to 1 on the initial application deploy. See the process scaling documentation for more details around scaling individual processes.","title":"Specifying commands via Procfile"},{"location":"deployment/buildpacks/#clearing-buildpack-cache","text":"Building containers with buildpacks currently results in a persistent cache directory between deploys. If you need to clear this cache directory for any reason, you may do so by running the following shell command: # replace APP with the name of your application sudo rm -rf /home/dokku/APP/cache/*","title":"Clearing buildpack cache"},{"location":"deployment/buildpacks/#curl-build-timeouts","text":"Certain buildpacks may time out in retrieving dependencies via curl. This can happen when your network connection is poor or if there is significant network congestion. You may see a message similar to gzip: stdin: unexpected end of file after a curl command. If you see output similar this when deploying , you may need to override the curl timeouts to increase the length of time allotted to those tasks. You can do so via the config plugin: dokku config:set --global CURL_TIMEOUT = 600 dokku config:set --global CURL_CONNECT_TIMEOUT = 30","title":"Curl Build Timeouts"},{"location":"deployment/deployment-tasks/","text":"Deployment Tasks New as of 0.5.0 Sometimes you need to run a command on at deployment time, but before an app is completely deployed. Common use cases include: Checking a database is initialised Running database migrations Any commands required to set up the server (e.g. something like a Django collectstatic ) app.json and scripts.dokku Dokku accomplishes this by using an app.json file. We (mostly) use the same format as Heroku's app.json . However, dokku currently only supports the nodes scripts.dokku.predeploy and scripts.dokku.postdeploy . Simply place an app.json file in the root of your repository or for dockerfile apps, ADD it to /app. NOTE: postdeploy changes are NOT committed to the app image. Example app.json { \"name\": \"barebones nodejs\", \"description\": \"A barebones Node.js app using Express 4.\", \"keywords\": [ \"nodejs\", \"express\" ], \"repository\": \"https://github.com/michaelshobbs/node-js-sample\", \"scripts\": { \"dokku\": { \"predeploy\": \"touch /app/predeploy.test\", \"postdeploy\": \"curl https://some.external.api.service.com/deployment?state=success\" } }, \"env\": { \"SECRET_TOKEN\": { \"description\": \"A secret key for verifying the integrity of signed cookies.\", \"value\": \"secret\" }, \"WEB_CONCURRENCY\": { \"description\": \"The number of processes to run.\", \"generator\": \"echo 5\" } }, \"image\": \"gliderlabs/herokuish\", \"addons\": [ \"dokku-postgres\", \"dokku-redis\" ], \"buildpacks\": [ { \"url\": \"https://github.com/heroku/heroku-buildpack-nodejs\" } ] }","title":"Deployment Tasks"},{"location":"deployment/deployment-tasks/#deployment-tasks","text":"New as of 0.5.0 Sometimes you need to run a command on at deployment time, but before an app is completely deployed. Common use cases include: Checking a database is initialised Running database migrations Any commands required to set up the server (e.g. something like a Django collectstatic )","title":"Deployment Tasks"},{"location":"deployment/deployment-tasks/#appjson-and-scriptsdokku","text":"Dokku accomplishes this by using an app.json file. We (mostly) use the same format as Heroku's app.json . However, dokku currently only supports the nodes scripts.dokku.predeploy and scripts.dokku.postdeploy . Simply place an app.json file in the root of your repository or for dockerfile apps, ADD it to /app. NOTE: postdeploy changes are NOT committed to the app image.","title":"app.json and scripts.dokku"},{"location":"deployment/deployment-tasks/#example-appjson","text":"{ \"name\": \"barebones nodejs\", \"description\": \"A barebones Node.js app using Express 4.\", \"keywords\": [ \"nodejs\", \"express\" ], \"repository\": \"https://github.com/michaelshobbs/node-js-sample\", \"scripts\": { \"dokku\": { \"predeploy\": \"touch /app/predeploy.test\", \"postdeploy\": \"curl https://some.external.api.service.com/deployment?state=success\" } }, \"env\": { \"SECRET_TOKEN\": { \"description\": \"A secret key for verifying the integrity of signed cookies.\", \"value\": \"secret\" }, \"WEB_CONCURRENCY\": { \"description\": \"The number of processes to run.\", \"generator\": \"echo 5\" } }, \"image\": \"gliderlabs/herokuish\", \"addons\": [ \"dokku-postgres\", \"dokku-redis\" ], \"buildpacks\": [ { \"url\": \"https://github.com/heroku/heroku-buildpack-nodejs\" } ] }","title":"Example app.json"},{"location":"deployment/dockerfiles/","text":"Dockerfile Deployment New as of 0.3.15 While Dokku normally defaults to using heroku buildpacks for deployment, you can also use docker's native Dockerfile system to define a container. Dockerfile support is considered a Power User feature. By using Dockerfile-based deployment, you agree that you will not have the same comfort as that enjoyed by Buildpack users, and Dokku features may work differently. Differences between the two systems will be documented here. To use a dockerfiles for deployment, commit a valid Dockerfile to the root of your repository and push the repository to your Dokku installation. If this file is detected, Dokku will default to using it to construct containers except in the following two cases: The application has a BUILDPACK_URL environment variable set via the dokku config:set command or in a committed .env file. In this case, Dokku will use your specified buildpack. The application has a .buildpacks file in the root of the repository. In this case, Dokku will use your specified buildpack(s). Exposed ports Changed as of 0.5.0 Dokku will extract all tcp ports exposed using the EXPOSE directive (one port per line) and setup nginx to proxy the same port numbers to listen publicly. If you would like to change the exposed port, you should do so within your Dockerfile and app. NOTE: Nginx does not support proxying UDP. UDP ports can be exposed by disabling the nginx proxy with dokku proxy:disable myapp If you do not explicitly EXPOSE a port in your Dockerfile , dokku will configure the nginx proxy to listen on port 80 (and 443 for TLS) and forward traffic to your app listening on port 5000 inside the container. Just like buildpack apps, you can also use the $PORT environment variable in your app to maintain portability. When ports are exposed through the default nginx proxy, they are proxied externally as HTTP ports. At this time, in no case do we proxy plain TCP or UDP ports. If you'd like to investigate alternative proxy methods, please refer to our proxy documentation . Customizing the run command By default no arguments are passed to docker run when deploying the container and the CMD or ENTRYPOINT defined in the Dockerfile are executed. You can take advantage of docker ability of overriding the CMD or passing parameters to your ENTRYPOINT setting $DOKKU_DOCKERFILE_START_CMD . Let's say for example you are deploying a base nodejs image, with the following ENTRYPOINT : ENTRYPOINT [\"node\"] You can do: dokku config:set APP DOKKU_DOCKERFILE_START_CMD=\"--harmony server.js\" To tell docker what to run. Setting $DOKKU_DOCKERFILE_CACHE_BUILD to true or false will enable or disable docker's image layer cache. Lastly, for more granular build control, you may also pass any docker build option to docker , by setting $DOKKU_DOCKER_BUILD_OPTS . Procfiles and Multiple Processes New as of 0.5.0 You can also customize the run command using a Procfile , much like you would on Heroku or with a buildpack deployed app. The Procfile should contain one or more lines defining process types and associated commands . When you deploy your app a Docker image will be built, the Procfile will be extracted from the image (it must be in the folder defined in your Dockerfile as WORKDIR or /app ) and the commands in it will be passed to docker run to start your process(es). Here's an example Procfile : web: bin/run-prod.sh worker: bin/run-worker.sh And Dockerfile : FROM debian:jessie WORKDIR /app COPY . ./ CMD [\"bin/run-dev.sh\"] When you deploy this app the web process will automatically be scaled to 1 and your Docker container will be started basically using the command docker run bin/run-prod.sh . If you want to also run a worker container for this app, you can run dokku ps:scale worker=1 and a new container will be started by running docker run bin/run-worker.sh (the actual docker run commands are a bit more complex, but this is the basic idea). If you use an ENTRYPOINT in your Dockerfile , the lines in your Procfile will be passed as arguments to the ENTRYPOINT script instead of being executed.","title":"Dockerfile Deployment"},{"location":"deployment/dockerfiles/#dockerfile-deployment","text":"New as of 0.3.15 While Dokku normally defaults to using heroku buildpacks for deployment, you can also use docker's native Dockerfile system to define a container. Dockerfile support is considered a Power User feature. By using Dockerfile-based deployment, you agree that you will not have the same comfort as that enjoyed by Buildpack users, and Dokku features may work differently. Differences between the two systems will be documented here. To use a dockerfiles for deployment, commit a valid Dockerfile to the root of your repository and push the repository to your Dokku installation. If this file is detected, Dokku will default to using it to construct containers except in the following two cases: The application has a BUILDPACK_URL environment variable set via the dokku config:set command or in a committed .env file. In this case, Dokku will use your specified buildpack. The application has a .buildpacks file in the root of the repository. In this case, Dokku will use your specified buildpack(s).","title":"Dockerfile Deployment"},{"location":"deployment/dockerfiles/#exposed-ports","text":"Changed as of 0.5.0 Dokku will extract all tcp ports exposed using the EXPOSE directive (one port per line) and setup nginx to proxy the same port numbers to listen publicly. If you would like to change the exposed port, you should do so within your Dockerfile and app. NOTE: Nginx does not support proxying UDP. UDP ports can be exposed by disabling the nginx proxy with dokku proxy:disable myapp If you do not explicitly EXPOSE a port in your Dockerfile , dokku will configure the nginx proxy to listen on port 80 (and 443 for TLS) and forward traffic to your app listening on port 5000 inside the container. Just like buildpack apps, you can also use the $PORT environment variable in your app to maintain portability. When ports are exposed through the default nginx proxy, they are proxied externally as HTTP ports. At this time, in no case do we proxy plain TCP or UDP ports. If you'd like to investigate alternative proxy methods, please refer to our proxy documentation .","title":"Exposed ports"},{"location":"deployment/dockerfiles/#customizing-the-run-command","text":"By default no arguments are passed to docker run when deploying the container and the CMD or ENTRYPOINT defined in the Dockerfile are executed. You can take advantage of docker ability of overriding the CMD or passing parameters to your ENTRYPOINT setting $DOKKU_DOCKERFILE_START_CMD . Let's say for example you are deploying a base nodejs image, with the following ENTRYPOINT : ENTRYPOINT [\"node\"] You can do: dokku config:set APP DOKKU_DOCKERFILE_START_CMD=\"--harmony server.js\" To tell docker what to run. Setting $DOKKU_DOCKERFILE_CACHE_BUILD to true or false will enable or disable docker's image layer cache. Lastly, for more granular build control, you may also pass any docker build option to docker , by setting $DOKKU_DOCKER_BUILD_OPTS .","title":"Customizing the run command"},{"location":"deployment/dockerfiles/#procfiles-and-multiple-processes","text":"New as of 0.5.0 You can also customize the run command using a Procfile , much like you would on Heroku or with a buildpack deployed app. The Procfile should contain one or more lines defining process types and associated commands . When you deploy your app a Docker image will be built, the Procfile will be extracted from the image (it must be in the folder defined in your Dockerfile as WORKDIR or /app ) and the commands in it will be passed to docker run to start your process(es). Here's an example Procfile : web: bin/run-prod.sh worker: bin/run-worker.sh And Dockerfile : FROM debian:jessie WORKDIR /app COPY . ./ CMD [\"bin/run-dev.sh\"] When you deploy this app the web process will automatically be scaled to 1 and your Docker container will be started basically using the command docker run bin/run-prod.sh . If you want to also run a worker container for this app, you can run dokku ps:scale worker=1 and a new container will be started by running docker run bin/run-worker.sh (the actual docker run commands are a bit more complex, but this is the basic idea). If you use an ENTRYPOINT in your Dockerfile , the lines in your Procfile will be passed as arguments to the ENTRYPOINT script instead of being executed.","title":"Procfiles and Multiple Processes"},{"location":"deployment/domain-configuration/","text":"Domain Configuration New as of 0.3.10 domains:add <app> DOMAIN Add a domain to app domains [ <app> ] List domains domains:clear <app> Clear all domains for app domains:disable <app> Disable VHOST support domains:enable <app> Enable VHOST support domains:remove <app> DOMAIN Remove a domain from app domains:set-global <domain> Set global domain name Customizing hostnames Applications typically have the following structure for their hostname: scheme://subdomain.domain.tld The subdomain is inferred from the pushed application name, while the domain.tld is set during initial configuration and stored in the $DOKKU_ROOT/VHOST file. It can then be modified with dokku domains:set-global . This value is used as a default TLD for all applications on a host. If a FQDN such as other.tld is used as the application name, the default $DOKKU_ROOT/VHOST will be ignored and the resulting vhost URL for that application will be other.tld . The exception to this rule being that if the FQDN has the same ending as the default vhost (such as subdomain.domain.tld ), then the entire FQDN will be treated as a subdomain. The application will therefore be deployed at subdomain.domain.tld.domain.tld . You can optionally override this in a plugin by implementing the nginx-hostname plugin trigger. For example, you can reverse the subdomain with the following sample nginx-hostname plugin trigger: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" If the nginx-hostname has no output, the normal hostname algorithm will be executed. Disabling VHOSTS If desired, it is possible to disable vhosts with the domains plugin. dokku domains:disable myapp On subsequent deploys, the nginx virtualhost will be discarded. This is useful when deploying internal-facing services that should not be publicly routeable. As of 0.4.0, nginx will still be configured to proxy your app on some random high port. This allows internal services to maintain the same port between deployments. You may change this port by setting DOKKU_NGINX_PORT and/or DOKKU_NGINX_SSL_PORT (for services configured to use SSL.) The domains plugin allows you to specify custom domains for applications. This plugin is aware of any ssl certificates that are imported via certs:add . Be aware that disabling domains (with domains:disable ) will override any custom domains. # where `myapp` is the name of your app # add a domain to an app dokku domains:add myapp example.com # list custom domains for app dokku domains myapp # clear all custom domains for app dokku domains:clear myapp # remove a custom domain from app dokku domains:remove myapp example.com Default site By default, dokku will route any received request with an unknown HOST header value to the lexicographically first site in the nginx config stack. If this is not the desired behavior, you may want to add the following configuration to the global nginx configuration. This will catch all unknown HOST header values and return a 410 Gone response. You can replace the return 410; with return 444; which will cause nginx to not respond to requests that do not match known domains (connection refused). server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 410; log_not_found off; } You may also wish to use a separate vhost in your /etc/nginx/sites-enabled directory. To do so, create the vhost in that directory as /etc/nginx/sites-enabled/00-default.conf . You will also need to change two lines in the main nginx.conf : # Swap both conf.d include line and the sites-enabled include line. From: include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; # to the following include /etc/nginx/sites-enabled/*; include /etc/nginx/conf.d/*.conf; Alternatively, you may push an app to your dokku host with a name like \"00-default\". As long as it lists first in ls /home/dokku/*/nginx.conf | head , it will be used as the default nginx vhost.","title":"Domain Configuration"},{"location":"deployment/domain-configuration/#domain-configuration","text":"New as of 0.3.10 domains:add <app> DOMAIN Add a domain to app domains [ <app> ] List domains domains:clear <app> Clear all domains for app domains:disable <app> Disable VHOST support domains:enable <app> Enable VHOST support domains:remove <app> DOMAIN Remove a domain from app domains:set-global <domain> Set global domain name","title":"Domain Configuration"},{"location":"deployment/domain-configuration/#customizing-hostnames","text":"Applications typically have the following structure for their hostname: scheme://subdomain.domain.tld The subdomain is inferred from the pushed application name, while the domain.tld is set during initial configuration and stored in the $DOKKU_ROOT/VHOST file. It can then be modified with dokku domains:set-global . This value is used as a default TLD for all applications on a host. If a FQDN such as other.tld is used as the application name, the default $DOKKU_ROOT/VHOST will be ignored and the resulting vhost URL for that application will be other.tld . The exception to this rule being that if the FQDN has the same ending as the default vhost (such as subdomain.domain.tld ), then the entire FQDN will be treated as a subdomain. The application will therefore be deployed at subdomain.domain.tld.domain.tld . You can optionally override this in a plugin by implementing the nginx-hostname plugin trigger. For example, you can reverse the subdomain with the following sample nginx-hostname plugin trigger: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" If the nginx-hostname has no output, the normal hostname algorithm will be executed.","title":"Customizing hostnames"},{"location":"deployment/domain-configuration/#disabling-vhosts","text":"If desired, it is possible to disable vhosts with the domains plugin. dokku domains:disable myapp On subsequent deploys, the nginx virtualhost will be discarded. This is useful when deploying internal-facing services that should not be publicly routeable. As of 0.4.0, nginx will still be configured to proxy your app on some random high port. This allows internal services to maintain the same port between deployments. You may change this port by setting DOKKU_NGINX_PORT and/or DOKKU_NGINX_SSL_PORT (for services configured to use SSL.) The domains plugin allows you to specify custom domains for applications. This plugin is aware of any ssl certificates that are imported via certs:add . Be aware that disabling domains (with domains:disable ) will override any custom domains. # where `myapp` is the name of your app # add a domain to an app dokku domains:add myapp example.com # list custom domains for app dokku domains myapp # clear all custom domains for app dokku domains:clear myapp # remove a custom domain from app dokku domains:remove myapp example.com","title":"Disabling VHOSTS"},{"location":"deployment/domain-configuration/#default-site","text":"By default, dokku will route any received request with an unknown HOST header value to the lexicographically first site in the nginx config stack. If this is not the desired behavior, you may want to add the following configuration to the global nginx configuration. This will catch all unknown HOST header values and return a 410 Gone response. You can replace the return 410; with return 444; which will cause nginx to not respond to requests that do not match known domains (connection refused). server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 410; log_not_found off; } You may also wish to use a separate vhost in your /etc/nginx/sites-enabled directory. To do so, create the vhost in that directory as /etc/nginx/sites-enabled/00-default.conf . You will also need to change two lines in the main nginx.conf : # Swap both conf.d include line and the sites-enabled include line. From: include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; # to the following include /etc/nginx/sites-enabled/*; include /etc/nginx/conf.d/*.conf; Alternatively, you may push an app to your dokku host with a name like \"00-default\". As long as it lists first in ls /home/dokku/*/nginx.conf | head , it will be used as the default nginx vhost.","title":"Default site"},{"location":"deployment/images/","text":"Image Tagging New as of 0.4.0 The dokku tags plugin allows you to add docker image tags to the currently deployed app image for versioning and subsequent deployment. tags <app> List all app image tags tags:create <app> <tag> Add tag to latest running app image tags:deploy <app> <tag> Deploy tagged app image tags:destroy <app> <tag> Remove app image tag Example: root@dokku:~# dokku tags node-js-app =====> Image tags for dokku/node-js-app REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE dokku/node-js-app latest 936a42f25901 About a minute ago 1.025 GB root@dokku:~# dokku tags:create node-js-app v0.9.0 =====> Added v0.9.0 tag to dokku/node-js-app root@dokku:~# dokku tags node-js-app =====> Image tags for dokku/node-js-app REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE dokku/node-js-app latest 936a42f25901 About a minute ago 1.025 GB dokku/node-js-app v0.9.0 936a42f25901 About a minute ago 1.025 GB root@dokku:~# dokku tags:deploy node-js-app v0.9.0 -----> Releasing node-js-app (dokku/node-js-app:v0.9.0)... -----> Deploying node-js-app (dokku/node-js-app:v0.9.0)... -----> Running pre-flight checks For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/checks-examples.md for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! =====> node-js-app container output: Detected 512 MB available memory, 512 MB limit per process (WEB_MEMORY) Recommending WEB_CONCURRENCY=1 > node-js-app@0.1.0 start /app > node index.js Node app is running at localhost:5000 =====> end node-js-app container output -----> Running post-deploy -----> Configuring node-js-app.dokku.me... -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx -----> Shutting down old containers in 60 seconds =====> 025eec3fa3b442fded90933d58d8ed8422901f0449f5ea0c23d00515af5d3137 =====> Application deployed: http://node-js-app.dokku.me Deploying from a Docker Registry You can alternatively add image pulled from a docker Registry and deploy app from it by using tagging feature. In this example, we are deploying from Docker Hub. Create dokku app as usual dokku apps:create test-app Pull image from Docker Hub docker pull demo-repo/some-image:v12 Retag the image to match the created app docker tag demo-repo/some-image:v12 dokku/test-app:v12 Deploy tag dokku tags:deploy test-app v12 Note: When deploying an image, we will use docker inspect to extract the ExposedPorts configuration and if defined, use that to populate DOKKU_DOCKERFILE_PORTS . If this behavior is not desired, you can override that configuration variable with the config:set command. Example: dokku config:set test-app DOKKU_DOCKERFILE_PORTS=\"5984/tcp 80/tcp\" Deploying an image from CI To ensure your builds are always reproducible, it's considered bad practice to store build artifacts in your repository. For some projects however, building artifacts during deployment to dokku may affect the performance of running applications. One solution is to build a finished Docker image on a CI service (or even locally) and deploy it directly to the host running dokku. Build image on CI (or locally) docker build -t dokku/test-app:v12 # Note: The image must be tagged `dokku/<app-name>:<version>` Deploy image to dokku host docker save dokku/test-app:v12 | ssh my.dokku.host \"docker load | dokku tags:deploy test-app v12\" Note: You can also use a Docker Registry to push and pull the image rather than uploading it directly. Here's a more complete example using the above method: # build the image docker build -t dokku/test-app:v12 # copy the image to the dokku host docker save dokku/test-app:v12 | bzip2 | ssh my.dokku.host \"bunzip2 | docker load\" # tag and deploy the image ssh my.dokku.host \"dokku tags:create test-app previous; dokku tags:deploy test-app v12 && dokku tags:create test-app latest\"","title":"Image Tagging"},{"location":"deployment/images/#image-tagging","text":"New as of 0.4.0 The dokku tags plugin allows you to add docker image tags to the currently deployed app image for versioning and subsequent deployment. tags <app> List all app image tags tags:create <app> <tag> Add tag to latest running app image tags:deploy <app> <tag> Deploy tagged app image tags:destroy <app> <tag> Remove app image tag Example: root@dokku:~# dokku tags node-js-app =====> Image tags for dokku/node-js-app REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE dokku/node-js-app latest 936a42f25901 About a minute ago 1.025 GB root@dokku:~# dokku tags:create node-js-app v0.9.0 =====> Added v0.9.0 tag to dokku/node-js-app root@dokku:~# dokku tags node-js-app =====> Image tags for dokku/node-js-app REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE dokku/node-js-app latest 936a42f25901 About a minute ago 1.025 GB dokku/node-js-app v0.9.0 936a42f25901 About a minute ago 1.025 GB root@dokku:~# dokku tags:deploy node-js-app v0.9.0 -----> Releasing node-js-app (dokku/node-js-app:v0.9.0)... -----> Deploying node-js-app (dokku/node-js-app:v0.9.0)... -----> Running pre-flight checks For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/checks-examples.md for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! =====> node-js-app container output: Detected 512 MB available memory, 512 MB limit per process (WEB_MEMORY) Recommending WEB_CONCURRENCY=1 > node-js-app@0.1.0 start /app > node index.js Node app is running at localhost:5000 =====> end node-js-app container output -----> Running post-deploy -----> Configuring node-js-app.dokku.me... -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx -----> Shutting down old containers in 60 seconds =====> 025eec3fa3b442fded90933d58d8ed8422901f0449f5ea0c23d00515af5d3137 =====> Application deployed: http://node-js-app.dokku.me","title":"Image Tagging"},{"location":"deployment/images/#deploying-from-a-docker-registry","text":"You can alternatively add image pulled from a docker Registry and deploy app from it by using tagging feature. In this example, we are deploying from Docker Hub. Create dokku app as usual dokku apps:create test-app Pull image from Docker Hub docker pull demo-repo/some-image:v12 Retag the image to match the created app docker tag demo-repo/some-image:v12 dokku/test-app:v12 Deploy tag dokku tags:deploy test-app v12 Note: When deploying an image, we will use docker inspect to extract the ExposedPorts configuration and if defined, use that to populate DOKKU_DOCKERFILE_PORTS . If this behavior is not desired, you can override that configuration variable with the config:set command. Example: dokku config:set test-app DOKKU_DOCKERFILE_PORTS=\"5984/tcp 80/tcp\"","title":"Deploying from a Docker Registry"},{"location":"deployment/images/#deploying-an-image-from-ci","text":"To ensure your builds are always reproducible, it's considered bad practice to store build artifacts in your repository. For some projects however, building artifacts during deployment to dokku may affect the performance of running applications. One solution is to build a finished Docker image on a CI service (or even locally) and deploy it directly to the host running dokku. Build image on CI (or locally) docker build -t dokku/test-app:v12 # Note: The image must be tagged `dokku/<app-name>:<version>` Deploy image to dokku host docker save dokku/test-app:v12 | ssh my.dokku.host \"docker load | dokku tags:deploy test-app v12\" Note: You can also use a Docker Registry to push and pull the image rather than uploading it directly. Here's a more complete example using the above method: # build the image docker build -t dokku/test-app:v12 # copy the image to the dokku host docker save dokku/test-app:v12 | bzip2 | ssh my.dokku.host \"bunzip2 | docker load\" # tag and deploy the image ssh my.dokku.host \"dokku tags:create test-app previous; dokku tags:deploy test-app v12 && dokku tags:create test-app latest\"","title":"Deploying an image from CI"},{"location":"deployment/one-off-processes/","text":"One-off Processes and Cron Sometimes you need to either inspect running containers or run a one-off command under an application. In those cases, Dokku makes it easy to either connect to a running container or run a fresh container. Run a command in an app environment run <app> <cmd> Run a command in the environment of an application The run command can be used to run a one-off process for a specific command. This will start a new container and run the desired command within that container. Note that this container will be stay around even after command completes. The container will be the same container as was used to start the currently deployed application. # runs `ls -lah` in the `/app` directory of the application `node-js-app` dokku run node-js-app ls -lah If you want to remove the container after a command has started, you can run the following command: # keep `run` containers around dokku config:set --global DOKKU_RM_CONTAINER = 1 # revert the above setting and keep containers around dokku config:unset --global DOKKU_RM_CONTAINER You may also use the --rm-container or --rm dokku flags to remove the containers automatically: dokku --rm-container run node-js-app ls -lah dokku --rm run node-js-app ls -lah Finally, you may wish to run a container in \"detached\" mode via the --detach dokku flag. Running a process in detached mode will immediately return a CONTAINER_ID . It is up to the user to then further manage this container in whatever manner they see fit, as dokku will not automatically terminate the container. dokku --detach run node-js-app ls -lah # returns the ID of the new container Note that you may not use the --rm-container or --rm flags when running containers in detached mode, and attempting to do so will result in the --detach flag being ignored. Using run for cron tasks You can always use a one-off container to run an application task: dokku --rm run node-js-app some-command dokku --rm-container run node-js-app some-command For tasks that should not be interrupted, run is the preferred method of handling cron tasks, as the container will continue running even during a deploy or scaling event. The trade-off is that there will be an increase in memory usage if there are multiple concurrent tasks running. Entering existing containers New as of 0.4.0 enter <app> [<container-type> || --container-id <container-id>] Connect to a specific app container The enter command can be used to enter a running container. The following variations of the command exist: dokku enter node-js-app web dokku enter node-js-app web.1 dokku enter node-js-app --container-id ID Additionally, you can run enter with no container-type. If only a single container-type is defined in your app, you will be dropped into the only running container. This behavior is not supported when specifying a custom command; as described below. By default, it runs a /bin/bash , but can also be used to run a custom command: # just echo hi dokku enter node-js-app web echo hi # run a long-running command, as one might for a cron task dokku enter node-js-app web python script/background-worker.py Using enter for cron tasks Your procfile can have the following entry: cron: sleep infinity With the cron process scaled to 1 : dokku ps:scale node-js-app cron = 1 You can now run all your commands in that container: dokku enter api cron some-command Note that you can also run multiple commands at the same time to reduce memory usage, though that may result in polluting the container environment. For tasks that will properly resume, you should use the above method, as running tasks will be interrupted during deploys and scaling events, and subsequent commands will always run with the latest container. Note that if you scale the cron container down, this may interrupt proper running of the task. General Cron Recommendations Regularly scheduled tasks can be a bit of a pain with dokku. The following are general recommendations to follow to help ensure successful task runs. Use the dokku user's crontab If you do not, dokku will attempt to execute with sudo dokku, and your cron run with fail with sudo: no tty present and no askpass program specified Add a MAILTO environment variable to ship cron emails to yourself. Add a PATH environment variable or specify the full path to binaries on the host. Add a SHELL environment variable to specify bash when running commands. Keep your cron tasks in time-sorted order. Keep your server time in UTC so you don't need to translate daylight saving's time when reading the cronfile. Run tasks at the lowest traffic times if possible. Use cron to trigger jobs, not run them. Use a real queuing system such as rabbitmq to actually process jobs. Try to keep tasks quiet so that mails only send on errors. Do not silence standard error or standard out. If you silence the former, you will miss failures. Silencing the latter means you should actually make application changes to handle log levels. Use a service such as Dead Man's Snitch to verify that cron tasks completed successfully. Add lots of comments to your cronfile, including what a task is doing, so that you don't spend time deciphering the file later. Place your cronfiles in a pattern such as /etc/cron.d/APP . Do not use non-ascii characters in your cronfile names. Cron is finicky. Remember to have trailing newlines in your cronfile! Cron is finicky. The following is a sample cronfile that you can use for your applications: # server cron jobs MAILTO=\"mail@example.com\" PATH=/usr/local/bin:/usr/bin:/bin SHELL=/bin/bash # m h dom mon dow username command # * * * * * dokku command to be executed # - - - - - # | | | | | # | | | | +----- day of week (0 - 6) (Sunday=0) # | | | +------- month (1 - 12) # | | +--------- day of month (1 - 31) # | +----------- hour (0 - 23) # +----------- min (0 - 59) ### HIGH TRAFFIC TIME IS B/W 00:00 - 04:00 AND 14:00 - 23:59 ### RUN YOUR TASKS FROM 04:00 - 14:00 ### KEEP SORTED IN TIME ORDER ### PLACE ALL CRON TASKS BELOW # removes unresponsive users from the subscriber list to decrease bounce rates 0 0 * * * dokku dokku --rm run node-js-app some-command # sends out our email alerts to users 0 1 * * * dokku dokku ps:scale node-js-app cron=1 && dokku enter node-js-app cron some-other-command && dokku ps:scale node-js-app cron=0 ### PLACE ALL CRON TASKS ABOVE, DO NOT REMOVE THE WHITESPACE AFTER THIS LINE","title":"One-off Processes and Cron"},{"location":"deployment/one-off-processes/#one-off-processes-and-cron","text":"Sometimes you need to either inspect running containers or run a one-off command under an application. In those cases, Dokku makes it easy to either connect to a running container or run a fresh container.","title":"One-off Processes and Cron"},{"location":"deployment/one-off-processes/#run-a-command-in-an-app-environment","text":"run <app> <cmd> Run a command in the environment of an application The run command can be used to run a one-off process for a specific command. This will start a new container and run the desired command within that container. Note that this container will be stay around even after command completes. The container will be the same container as was used to start the currently deployed application. # runs `ls -lah` in the `/app` directory of the application `node-js-app` dokku run node-js-app ls -lah If you want to remove the container after a command has started, you can run the following command: # keep `run` containers around dokku config:set --global DOKKU_RM_CONTAINER = 1 # revert the above setting and keep containers around dokku config:unset --global DOKKU_RM_CONTAINER You may also use the --rm-container or --rm dokku flags to remove the containers automatically: dokku --rm-container run node-js-app ls -lah dokku --rm run node-js-app ls -lah Finally, you may wish to run a container in \"detached\" mode via the --detach dokku flag. Running a process in detached mode will immediately return a CONTAINER_ID . It is up to the user to then further manage this container in whatever manner they see fit, as dokku will not automatically terminate the container. dokku --detach run node-js-app ls -lah # returns the ID of the new container Note that you may not use the --rm-container or --rm flags when running containers in detached mode, and attempting to do so will result in the --detach flag being ignored.","title":"Run a command in an app environment"},{"location":"deployment/one-off-processes/#using-run-for-cron-tasks","text":"You can always use a one-off container to run an application task: dokku --rm run node-js-app some-command dokku --rm-container run node-js-app some-command For tasks that should not be interrupted, run is the preferred method of handling cron tasks, as the container will continue running even during a deploy or scaling event. The trade-off is that there will be an increase in memory usage if there are multiple concurrent tasks running.","title":"Using run for cron tasks"},{"location":"deployment/one-off-processes/#entering-existing-containers","text":"New as of 0.4.0 enter <app> [<container-type> || --container-id <container-id>] Connect to a specific app container The enter command can be used to enter a running container. The following variations of the command exist: dokku enter node-js-app web dokku enter node-js-app web.1 dokku enter node-js-app --container-id ID Additionally, you can run enter with no container-type. If only a single container-type is defined in your app, you will be dropped into the only running container. This behavior is not supported when specifying a custom command; as described below. By default, it runs a /bin/bash , but can also be used to run a custom command: # just echo hi dokku enter node-js-app web echo hi # run a long-running command, as one might for a cron task dokku enter node-js-app web python script/background-worker.py","title":"Entering existing containers"},{"location":"deployment/one-off-processes/#using-enter-for-cron-tasks","text":"Your procfile can have the following entry: cron: sleep infinity With the cron process scaled to 1 : dokku ps:scale node-js-app cron = 1 You can now run all your commands in that container: dokku enter api cron some-command Note that you can also run multiple commands at the same time to reduce memory usage, though that may result in polluting the container environment. For tasks that will properly resume, you should use the above method, as running tasks will be interrupted during deploys and scaling events, and subsequent commands will always run with the latest container. Note that if you scale the cron container down, this may interrupt proper running of the task.","title":"Using enter for cron tasks"},{"location":"deployment/one-off-processes/#general-cron-recommendations","text":"Regularly scheduled tasks can be a bit of a pain with dokku. The following are general recommendations to follow to help ensure successful task runs. Use the dokku user's crontab If you do not, dokku will attempt to execute with sudo dokku, and your cron run with fail with sudo: no tty present and no askpass program specified Add a MAILTO environment variable to ship cron emails to yourself. Add a PATH environment variable or specify the full path to binaries on the host. Add a SHELL environment variable to specify bash when running commands. Keep your cron tasks in time-sorted order. Keep your server time in UTC so you don't need to translate daylight saving's time when reading the cronfile. Run tasks at the lowest traffic times if possible. Use cron to trigger jobs, not run them. Use a real queuing system such as rabbitmq to actually process jobs. Try to keep tasks quiet so that mails only send on errors. Do not silence standard error or standard out. If you silence the former, you will miss failures. Silencing the latter means you should actually make application changes to handle log levels. Use a service such as Dead Man's Snitch to verify that cron tasks completed successfully. Add lots of comments to your cronfile, including what a task is doing, so that you don't spend time deciphering the file later. Place your cronfiles in a pattern such as /etc/cron.d/APP . Do not use non-ascii characters in your cronfile names. Cron is finicky. Remember to have trailing newlines in your cronfile! Cron is finicky. The following is a sample cronfile that you can use for your applications: # server cron jobs MAILTO=\"mail@example.com\" PATH=/usr/local/bin:/usr/bin:/bin SHELL=/bin/bash # m h dom mon dow username command # * * * * * dokku command to be executed # - - - - - # | | | | | # | | | | +----- day of week (0 - 6) (Sunday=0) # | | | +------- month (1 - 12) # | | +--------- day of month (1 - 31) # | +----------- hour (0 - 23) # +----------- min (0 - 59) ### HIGH TRAFFIC TIME IS B/W 00:00 - 04:00 AND 14:00 - 23:59 ### RUN YOUR TASKS FROM 04:00 - 14:00 ### KEEP SORTED IN TIME ORDER ### PLACE ALL CRON TASKS BELOW # removes unresponsive users from the subscriber list to decrease bounce rates 0 0 * * * dokku dokku --rm run node-js-app some-command # sends out our email alerts to users 0 1 * * * dokku dokku ps:scale node-js-app cron=1 && dokku enter node-js-app cron some-other-command && dokku ps:scale node-js-app cron=0 ### PLACE ALL CRON TASKS ABOVE, DO NOT REMOVE THE WHITESPACE AFTER THIS LINE","title":"General Cron Recommendations"},{"location":"deployment/ssl-configuration/","text":"SSL Configuration New as of 0.4.0 Dokku supports SSL/TLS certificate inspection and CSR/Self-signed certificate generation via the certs plugin. Note that whenever SSL/TLS support is enabled SPDY is also enabled. certs:add <app> CRT KEY Add an ssl endpoint to an app. Can also import from a tarball on stdin. certs:generate <app> DOMAIN Generate a key and certificate signing request (and self-signed certificate) certs:info <app> Show certificate information for an ssl endpoint. certs:remove <app> Remove an SSL Endpoint from an app. certs:update <app> CRT KEY Update an SSL Endpoint on an app. Can also import from a tarball on stdin # for 0.3.x dokku nginx:import-ssl <app> < certs.tar Per-application certificate management Dokku provides built-in support for managing SSL certificates on a per-application basis. SSL is managed via nginx outside of application containers, and as such can be updated on-the-fly without rebuilding containers. At this time, applications only support a single SSL certificate at a time. To support multiple domains for a single application, wildcard certificate usage is encouraged. Certificate setting The certs:add command can be used to push a tar containing a certificate .crt and .key file to a single application. The command should correctly handle cases where the .crt and .key are not named properly or are nested in a subdirectory of said tar file. You can import it as follows: tar cvf cert-key.tar server.crt server.key # replace APP with the name of your application dokku certs:add <app> < cert-key.tar Note: If your .crt file came alongside a .ca-bundle , you'll want to concatenate those into a single .crt file before adding it to the .tar . cat yourdomain_com.crt yourdomain_com.ca-bundle > server.crt SSL and Multiple Domains When an SSL certificate is associated to an application, the certificate will be associated with all domains currently associated with said application. Your certificate should be associated with all of those domains, otherwise accessing the application will result in SSL errors. If you wish to remove one of the domains from the application, refer to the domain configuration documentation . Note that with the default nginx template, requests will be redirected to the https version of the domain. If this is not the desired state of request resolution, you may customize the nginx template in use. For more details, see the nginx documentation . Certificate generation Note: Using this method will create a self-signed certificate, which is only recommended for development or staging use, not production environments. The certs:generate command will walk you through the correct openssl commands to create a key, csr and a self-signed cert for a given app/domain. We automatically put the self-signed cert in place as well as add the specified domain to the application configuration. If you decide to obtain a CA signed certficate, you can import that certificate using the aformentioned dokku certs:add command. Certificate information The certs:info command will simply inspect the install SSL cert and print out details. NOTE: The server-wide certificate will be inspect if installed and no app-specific certificate exists. root@dokku:~/dokku# dokku certs:info node-js-app -----> Fetching SSL Endpoint info for node-js-app... -----> Certificate details: =====> Common Name(s): =====> test.dokku.me =====> Expires At: Aug 24 23:32:59 2016 GMT =====> Issuer: C=US, ST=California, L=San Francisco, O=dokku.me, CN=test.dokku.me =====> Starts At: Aug 25 23:32:59 2015 GMT =====> Subject: C=US; ST=California; L=San Francisco; O=dokku.me; CN=test.dokku.me =====> SSL certificate is self signed. Certificate removal The certs:remove command only works on app-specific certificates. It will rm the app-specific tls directory, rebuild the nginx configuration, and reload nginx. HSTS Header The HSTS header is an HTTP header that can inform browsers that all requests to a given site should be made via HTTPS. dokku does not, by default, enable this header. It is thus left up to you, the user, to enable it for your site. Beware that if you enable the header and a subsequent deploy of your application results in an HTTP deploy (for whatever reason), the way the header works means that a browser will not attempt to request the HTTP version of your site if the HTTPS version fails. Running behind a load balancer Your application has access to the HTTP headers X-Forwarded-Proto , X-Forwarded-For and X-Forwarded-Port . These headers indicate the protocol of the original request (HTTP or HTTPS), the port number, and the IP address of the client making the request, respectively. The default configuration is for Nginx to set these headers. If your server runs behind an HTTP/S load balancer, then Nginx will see all requests as coming from the load balancer. If your load balancer sets the X-Forwarded- headers, you can tell Nginx to pass these headers from load balancer to your application by using the following nginx custom template server { listen [ :: ] : {{ .NGINX_PORT }} ; listen {{ .NGINX_PORT }} ; server_name {{ .NOSSL_SERVER_NAME }} ; access_log /var/log/nginx/ {{ .APP }} -access.log ; error_log /var/log/nginx/ {{ .APP }} -error.log ; # set a custom header for requests add_header X-Served-By www-ec2-01 ; location / { proxy_pass http:// {{ .APP }} ; proxy_http_version 1 .1 ; proxy_set_header Upgrade $http_upgrade ; proxy_set_header Connection \"upgrade\" ; proxy_set_header Host $http_host ; proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto ; proxy_set_header X-Forwarded-For $http_x_forwarded_for ; proxy_set_header X-Forwarded-Port $http_x_forwarded_port ; proxy_set_header X-Request-Start $msec ; } include {{ .DOKKU_ROOT }} / {{ .APP }} /nginx.conf.d/*.conf ; } upstream {{ .APP }} { {{ range .DOKKU_APP_LISTENERS | split \" \" }} server {{ . }} ; {{ end }} } Only use this option if: 1. All requests are terminated at the load balancer, and forwarded to Nginx 2. The load balancer is configured to send the X-Forwarded- headers (this may be off by default) If it's possible to make HTTP/S requests directly to Nginx, bypassing the load balancer, or if the load balancer is not configured to set these headers, then it becomes possible for a client to set these headers to arbitrary values. This could result in security issue, for example, if your application looks at the value of the X-Forwarded-Proto to determine if the request was made over HTTPS.","title":"SSL Configuration"},{"location":"deployment/ssl-configuration/#ssl-configuration","text":"New as of 0.4.0 Dokku supports SSL/TLS certificate inspection and CSR/Self-signed certificate generation via the certs plugin. Note that whenever SSL/TLS support is enabled SPDY is also enabled. certs:add <app> CRT KEY Add an ssl endpoint to an app. Can also import from a tarball on stdin. certs:generate <app> DOMAIN Generate a key and certificate signing request (and self-signed certificate) certs:info <app> Show certificate information for an ssl endpoint. certs:remove <app> Remove an SSL Endpoint from an app. certs:update <app> CRT KEY Update an SSL Endpoint on an app. Can also import from a tarball on stdin # for 0.3.x dokku nginx:import-ssl <app> < certs.tar","title":"SSL Configuration"},{"location":"deployment/ssl-configuration/#per-application-certificate-management","text":"Dokku provides built-in support for managing SSL certificates on a per-application basis. SSL is managed via nginx outside of application containers, and as such can be updated on-the-fly without rebuilding containers. At this time, applications only support a single SSL certificate at a time. To support multiple domains for a single application, wildcard certificate usage is encouraged.","title":"Per-application certificate management"},{"location":"deployment/ssl-configuration/#certificate-setting","text":"The certs:add command can be used to push a tar containing a certificate .crt and .key file to a single application. The command should correctly handle cases where the .crt and .key are not named properly or are nested in a subdirectory of said tar file. You can import it as follows: tar cvf cert-key.tar server.crt server.key # replace APP with the name of your application dokku certs:add <app> < cert-key.tar Note: If your .crt file came alongside a .ca-bundle , you'll want to concatenate those into a single .crt file before adding it to the .tar . cat yourdomain_com.crt yourdomain_com.ca-bundle > server.crt","title":"Certificate setting"},{"location":"deployment/ssl-configuration/#ssl-and-multiple-domains","text":"When an SSL certificate is associated to an application, the certificate will be associated with all domains currently associated with said application. Your certificate should be associated with all of those domains, otherwise accessing the application will result in SSL errors. If you wish to remove one of the domains from the application, refer to the domain configuration documentation . Note that with the default nginx template, requests will be redirected to the https version of the domain. If this is not the desired state of request resolution, you may customize the nginx template in use. For more details, see the nginx documentation .","title":"SSL and Multiple Domains"},{"location":"deployment/ssl-configuration/#certificate-generation","text":"Note: Using this method will create a self-signed certificate, which is only recommended for development or staging use, not production environments. The certs:generate command will walk you through the correct openssl commands to create a key, csr and a self-signed cert for a given app/domain. We automatically put the self-signed cert in place as well as add the specified domain to the application configuration. If you decide to obtain a CA signed certficate, you can import that certificate using the aformentioned dokku certs:add command.","title":"Certificate generation"},{"location":"deployment/ssl-configuration/#certificate-information","text":"The certs:info command will simply inspect the install SSL cert and print out details. NOTE: The server-wide certificate will be inspect if installed and no app-specific certificate exists. root@dokku:~/dokku# dokku certs:info node-js-app -----> Fetching SSL Endpoint info for node-js-app... -----> Certificate details: =====> Common Name(s): =====> test.dokku.me =====> Expires At: Aug 24 23:32:59 2016 GMT =====> Issuer: C=US, ST=California, L=San Francisco, O=dokku.me, CN=test.dokku.me =====> Starts At: Aug 25 23:32:59 2015 GMT =====> Subject: C=US; ST=California; L=San Francisco; O=dokku.me; CN=test.dokku.me =====> SSL certificate is self signed.","title":"Certificate information"},{"location":"deployment/ssl-configuration/#certificate-removal","text":"The certs:remove command only works on app-specific certificates. It will rm the app-specific tls directory, rebuild the nginx configuration, and reload nginx.","title":"Certificate removal"},{"location":"deployment/ssl-configuration/#hsts-header","text":"The HSTS header is an HTTP header that can inform browsers that all requests to a given site should be made via HTTPS. dokku does not, by default, enable this header. It is thus left up to you, the user, to enable it for your site. Beware that if you enable the header and a subsequent deploy of your application results in an HTTP deploy (for whatever reason), the way the header works means that a browser will not attempt to request the HTTP version of your site if the HTTPS version fails.","title":"HSTS Header"},{"location":"deployment/ssl-configuration/#running-behind-a-load-balancer","text":"Your application has access to the HTTP headers X-Forwarded-Proto , X-Forwarded-For and X-Forwarded-Port . These headers indicate the protocol of the original request (HTTP or HTTPS), the port number, and the IP address of the client making the request, respectively. The default configuration is for Nginx to set these headers. If your server runs behind an HTTP/S load balancer, then Nginx will see all requests as coming from the load balancer. If your load balancer sets the X-Forwarded- headers, you can tell Nginx to pass these headers from load balancer to your application by using the following nginx custom template server { listen [ :: ] : {{ .NGINX_PORT }} ; listen {{ .NGINX_PORT }} ; server_name {{ .NOSSL_SERVER_NAME }} ; access_log /var/log/nginx/ {{ .APP }} -access.log ; error_log /var/log/nginx/ {{ .APP }} -error.log ; # set a custom header for requests add_header X-Served-By www-ec2-01 ; location / { proxy_pass http:// {{ .APP }} ; proxy_http_version 1 .1 ; proxy_set_header Upgrade $http_upgrade ; proxy_set_header Connection \"upgrade\" ; proxy_set_header Host $http_host ; proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto ; proxy_set_header X-Forwarded-For $http_x_forwarded_for ; proxy_set_header X-Forwarded-Port $http_x_forwarded_port ; proxy_set_header X-Request-Start $msec ; } include {{ .DOKKU_ROOT }} / {{ .APP }} /nginx.conf.d/*.conf ; } upstream {{ .APP }} { {{ range .DOKKU_APP_LISTENERS | split \" \" }} server {{ . }} ; {{ end }} } Only use this option if: 1. All requests are terminated at the load balancer, and forwarded to Nginx 2. The load balancer is configured to send the X-Forwarded- headers (this may be off by default) If it's possible to make HTTP/S requests directly to Nginx, bypassing the load balancer, or if the load balancer is not configured to set these headers, then it becomes possible for a client to set these headers to arbitrary values. This could result in security issue, for example, if your application looks at the value of the X-Forwarded-Proto to determine if the request was made over HTTPS.","title":"Running behind a load balancer"},{"location":"deployment/user-management/","text":"User Management While it is possible to use password-based authorization to push to Dokku, it is preferable to use key-based authentication for security. Users in dokku are managed via the ~/dokku/.ssh/authorized_keys file. While you can manually edit this file, it is highly recommended that you follow the below steps to manage users on a dokku server. SSHCommand Dokku uses the sshcommand utility to manage ssh keys for the dokku user. The following is the usage output for sshcommand. sshcommand create <user> <command> # creates a user forced to run command when SSH connects sshcommand acl-add <user> <ssh-key-name> # adds named SSH key to user from STDIN sshcommand acl-remove <user> <ssh-key-name> # removes SSH key by name sshcommand help # displays the usage help message In dokku's case, the <user> section is always dokku , as this is the system user that the dokku binary performs all it's actions. Keys are given unique names, which can be used in conjunction with the user-auth plugin trigger to handle command authorization. Adding deploy users You can add your public key to the dokku user's ~/dokku/.ssh/authorized_keys file with the following command: # from your local machine # replace dokku.me with your domain name or the host's IP # replace root with your server's root user # USER is the username you use to refer to this particular key cat ~/.ssh/id_rsa.pub | ssh root@dokku.me \"sudo sshcommand acl-add dokku USER\" At it's base, the sshcommand must be run under a user with sudo access, as it sets keys for the dokku user. For instance, if you stored your public key at ~/.ssh/id_rsa.pub-open and are deploying to EC2 where the default root-enabled user is ubuntu , you can run the following command to add your key under the superuser username: cat ~/.ssh/id_rsa.pub-open | ssh ubuntu@dokku.me \"sudo sshcommand acl-add dokku superuser\" If you are using the vagrant installation, you can also use the make vagrant-acl-add target to add your public key to dokku (it will use your host username as the USER ): cat ~/.ssh/id_rsa.pub | make vagrant-acl-add Scoping commands to specific users See the user auth plugin trigger documentation .","title":"User Management"},{"location":"deployment/user-management/#user-management","text":"While it is possible to use password-based authorization to push to Dokku, it is preferable to use key-based authentication for security. Users in dokku are managed via the ~/dokku/.ssh/authorized_keys file. While you can manually edit this file, it is highly recommended that you follow the below steps to manage users on a dokku server.","title":"User Management"},{"location":"deployment/user-management/#sshcommand","text":"Dokku uses the sshcommand utility to manage ssh keys for the dokku user. The following is the usage output for sshcommand. sshcommand create <user> <command> # creates a user forced to run command when SSH connects sshcommand acl-add <user> <ssh-key-name> # adds named SSH key to user from STDIN sshcommand acl-remove <user> <ssh-key-name> # removes SSH key by name sshcommand help # displays the usage help message In dokku's case, the <user> section is always dokku , as this is the system user that the dokku binary performs all it's actions. Keys are given unique names, which can be used in conjunction with the user-auth plugin trigger to handle command authorization.","title":"SSHCommand"},{"location":"deployment/user-management/#adding-deploy-users","text":"You can add your public key to the dokku user's ~/dokku/.ssh/authorized_keys file with the following command: # from your local machine # replace dokku.me with your domain name or the host's IP # replace root with your server's root user # USER is the username you use to refer to this particular key cat ~/.ssh/id_rsa.pub | ssh root@dokku.me \"sudo sshcommand acl-add dokku USER\" At it's base, the sshcommand must be run under a user with sudo access, as it sets keys for the dokku user. For instance, if you stored your public key at ~/.ssh/id_rsa.pub-open and are deploying to EC2 where the default root-enabled user is ubuntu , you can run the following command to add your key under the superuser username: cat ~/.ssh/id_rsa.pub-open | ssh ubuntu@dokku.me \"sudo sshcommand acl-add dokku superuser\" If you are using the vagrant installation, you can also use the make vagrant-acl-add target to add your public key to dokku (it will use your host username as the USER ): cat ~/.ssh/id_rsa.pub | make vagrant-acl-add","title":"Adding deploy users"},{"location":"deployment/user-management/#scoping-commands-to-specific-users","text":"See the user auth plugin trigger documentation .","title":"Scoping commands to specific users"},{"location":"development/plugin-creation/","text":"Plugin Creation If you create your own plugin: Take a look at the plugins shipped with dokku and hack away! Check out the list of triggers your plugin can implement. Upload your plugin to github with a repository name in form of dokku-<name> (e.g. dokku-mariadb ) Edit this page and add a link to it. Subscribe to the dokku development blog to be notified about API changes and releases Sample plugin The below plugin is a dummy dokku hello plugin. hello/subcommands/default #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" hello_main_cmd () { declare desc = \"prints Hello \\$APP\" local cmd = \"hello\" # Support --app/$DOKKU_APP_NAME flag # Use the following lines to reorder args into \"$cmd $DOKKU_APP_NAME $@\"\" local argv =( \" $@ \" ) [[ ${ argv [0] } == \" $cmd \" ]] && shift 1 [[ ! -z $DOKKU_APP_NAME ]] && set -- $DOKKU_APP_NAME $@ set -- $cmd $@ ## [[ -z $2 ]] && echo \"Please specify an app to run the command on\" && exit 1 verify_app_name \" $2 \" local APP = \" $2 \" ; echo \"Hello $APP \" } hello_main_cmd \" $@ \" hello/subcommands/world #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" hello_world_cmd () { declare desc = \"prints Hello World\" local cmd = \"hello:world\" # Support --app/$DOKKU_APP_NAME flag # Use the following lines to reorder args into \"$cmd $DOKKU_APP_NAME $@\"\" local argv =( \" $@ \" ) [[ ${ argv [0] } == \" $cmd \" ]] && shift 1 [[ ! -z $DOKKU_APP_NAME ]] && set -- $DOKKU_APP_NAME $@ set -- $cmd $@ ## [[ -z $2 ]] && echo \"Please specify an app to run the command on\" && exit 1 verify_app_name \" $2 \" local APP = \" $2 \" ; echo \"Hello world\" } hello_world_cmd \" $@ \" hello/commands #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | hello:help ) help_content_func () { declare desc = \"return help_content string\" cat <<help_content hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" help_content } if [[ $1 = \"hello:help\" ]] ; then echo -e 'Usage: dokku hello[:world] [<app>]' echo '' echo 'Say Hello World.' echo '' echo 'Example:' echo '' echo '$ dokku hello:world' echo 'Hello world' echo '' echo 'Additional commands:' help_content_func | sort | column -c2 -t -s, else help_content_func fi ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac Each plugin requires a plugin.toml descriptor file with the following required fields: [ plugin ] description = \"dokku hello plugin\" version = \"0.1.0\" [ plugin.config ] A few notes: You should always support DOKKU_TRACE as specified on the 2nd line of the plugin. If your command requires that an application exists, ensure you check for it's existence in the manner prescribed above. A help command is required, though it is allowed to be empty. Also, the command syntax will need to separated by , in order to maintain columnar output alignment. Commands should be namespaced. As of 0.3.3, a catch-all should be implemented which exits with a DOKKU_NOT_IMPLEMENTED_EXIT code. This allows dokku to output a command not found message. Be sure you want the \"set -eo pipefail\" option. Look at the following example : IMAGE = $( docker images | grep \"user/repo\" | awk '{print $3}' ) if [[ -z $IMAGE ]] ; then dokku_log_fail \"user/repo image not found... Did you run 'dokku plugin:install'?\" fi In the case where the \"user/repo\" is not installed, dokku exits just before the awk command, you will never see the message printed with echo. You just want \"set -e\" in this case. Here is the documentation of the 'set -eo pipefail' option: help set Options: -e Exit immediately if a command exits with a non-zero status. -o option-name pipefail the return value of a pipeline is the status of the last command to exit with a non-zero status, or zero if no command exited with a non-zero status - As some plugins require access to set app config settings and do not want/require the default Heroku-style behavior of a restart, we have the following \"internal\" commands that provide this functionality : dokku config:set --no-restart APP KEY1 = VALUE1 [ KEY2 = VALUE2 ... ] dokku config:unset --no-restart APP KEY1 [ KEY2 ... ] - From time to time you may want to allow other plugins access to (some of) your plugin's functionality. You can expose this by including a functions file in your plugin for others to source. Consider all functions in that file to be publicly accessible by other plugins. Any functions not wished to be made \"public\" should reside within your plugin trigger or commands files. - As of 0.4.0, we allow image tagging and deployment of said tagged images. Therefore, hard-coding of $IMAGE as dokku/$APP is no longer sufficient. Instead, for non pre/post-build-* plugins, use get_running_image_tag() & get_app_image_name() as sourced from common/functions. See the plugin triggers doc for examples. - As of 0.5.0, we use container labels to help cleanup intermediate containers with dokku cleanup . If manually calling docker run , include $DOKKU_GLOBAL_RUN_ARGS . This will ensure you intermediate containers labeled correctly.","title":"Plugin Creation"},{"location":"development/plugin-creation/#plugin-creation","text":"If you create your own plugin: Take a look at the plugins shipped with dokku and hack away! Check out the list of triggers your plugin can implement. Upload your plugin to github with a repository name in form of dokku-<name> (e.g. dokku-mariadb ) Edit this page and add a link to it. Subscribe to the dokku development blog to be notified about API changes and releases","title":"Plugin Creation"},{"location":"development/plugin-creation/#sample-plugin","text":"The below plugin is a dummy dokku hello plugin. hello/subcommands/default #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" hello_main_cmd () { declare desc = \"prints Hello \\$APP\" local cmd = \"hello\" # Support --app/$DOKKU_APP_NAME flag # Use the following lines to reorder args into \"$cmd $DOKKU_APP_NAME $@\"\" local argv =( \" $@ \" ) [[ ${ argv [0] } == \" $cmd \" ]] && shift 1 [[ ! -z $DOKKU_APP_NAME ]] && set -- $DOKKU_APP_NAME $@ set -- $cmd $@ ## [[ -z $2 ]] && echo \"Please specify an app to run the command on\" && exit 1 verify_app_name \" $2 \" local APP = \" $2 \" ; echo \"Hello $APP \" } hello_main_cmd \" $@ \" hello/subcommands/world #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" hello_world_cmd () { declare desc = \"prints Hello World\" local cmd = \"hello:world\" # Support --app/$DOKKU_APP_NAME flag # Use the following lines to reorder args into \"$cmd $DOKKU_APP_NAME $@\"\" local argv =( \" $@ \" ) [[ ${ argv [0] } == \" $cmd \" ]] && shift 1 [[ ! -z $DOKKU_APP_NAME ]] && set -- $DOKKU_APP_NAME $@ set -- $cmd $@ ## [[ -z $2 ]] && echo \"Please specify an app to run the command on\" && exit 1 verify_app_name \" $2 \" local APP = \" $2 \" ; echo \"Hello world\" } hello_world_cmd \" $@ \" hello/commands #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | hello:help ) help_content_func () { declare desc = \"return help_content string\" cat <<help_content hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" help_content } if [[ $1 = \"hello:help\" ]] ; then echo -e 'Usage: dokku hello[:world] [<app>]' echo '' echo 'Say Hello World.' echo '' echo 'Example:' echo '' echo '$ dokku hello:world' echo 'Hello world' echo '' echo 'Additional commands:' help_content_func | sort | column -c2 -t -s, else help_content_func fi ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac Each plugin requires a plugin.toml descriptor file with the following required fields: [ plugin ] description = \"dokku hello plugin\" version = \"0.1.0\" [ plugin.config ] A few notes: You should always support DOKKU_TRACE as specified on the 2nd line of the plugin. If your command requires that an application exists, ensure you check for it's existence in the manner prescribed above. A help command is required, though it is allowed to be empty. Also, the command syntax will need to separated by , in order to maintain columnar output alignment. Commands should be namespaced. As of 0.3.3, a catch-all should be implemented which exits with a DOKKU_NOT_IMPLEMENTED_EXIT code. This allows dokku to output a command not found message. Be sure you want the \"set -eo pipefail\" option. Look at the following example : IMAGE = $( docker images | grep \"user/repo\" | awk '{print $3}' ) if [[ -z $IMAGE ]] ; then dokku_log_fail \"user/repo image not found... Did you run 'dokku plugin:install'?\" fi In the case where the \"user/repo\" is not installed, dokku exits just before the awk command, you will never see the message printed with echo. You just want \"set -e\" in this case. Here is the documentation of the 'set -eo pipefail' option: help set Options: -e Exit immediately if a command exits with a non-zero status. -o option-name pipefail the return value of a pipeline is the status of the last command to exit with a non-zero status, or zero if no command exited with a non-zero status - As some plugins require access to set app config settings and do not want/require the default Heroku-style behavior of a restart, we have the following \"internal\" commands that provide this functionality : dokku config:set --no-restart APP KEY1 = VALUE1 [ KEY2 = VALUE2 ... ] dokku config:unset --no-restart APP KEY1 [ KEY2 ... ] - From time to time you may want to allow other plugins access to (some of) your plugin's functionality. You can expose this by including a functions file in your plugin for others to source. Consider all functions in that file to be publicly accessible by other plugins. Any functions not wished to be made \"public\" should reside within your plugin trigger or commands files. - As of 0.4.0, we allow image tagging and deployment of said tagged images. Therefore, hard-coding of $IMAGE as dokku/$APP is no longer sufficient. Instead, for non pre/post-build-* plugins, use get_running_image_tag() & get_app_image_name() as sourced from common/functions. See the plugin triggers doc for examples. - As of 0.5.0, we use container labels to help cleanup intermediate containers with dokku cleanup . If manually calling docker run , include $DOKKU_GLOBAL_RUN_ARGS . This will ensure you intermediate containers labeled correctly.","title":"Sample plugin"},{"location":"development/plugin-triggers/","text":"Plugin triggers Plugin triggers (formerly pluginhooks ) are a good way to jack into existing dokku infrastructure. You can use them to modify the output of various dokku commands or override internal configuration. Plugin triggers are simply scripts that are executed by the system. You can use any language you want, so long as the script: Is executable Has the proper language requirements installed For instance, if you wanted to write a plugin trigger in PHP, you would need to have php installed and available on the CLI prior to plugin trigger invocation. The following is an example for the nginx-hostname plugin trigger. It reverses the hostname that is provided to nginx during deploys. If you created an executable file named nginx-hostname with the following code in your plugin trigger, it would be invoked by dokku during the normal app deployment process: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" Available plugin triggers There are a number of plugin-related triggers. These can be optionally implemented by plugins and allow integration into the standard dokku setup/teardown process. The following plugin triggers describe those available to a dokku installation. As well, there is an example for each trigger that you can use as templates for your own plugin development. The example plugin trigger code is not guaranteed to be implemented as in within dokkku, and are merely simplified examples. Please look at the dokku source for larger, more in-depth examples. post-config-update Description: Allows you to get notified when one or more configs is added or removed. Action can be set or unset Invoked by: dokku config:set , dokku config:unset Arguments: $APP set|unset key1=VALUE1 key2=VALUE2 Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO bind-external-ip Description: Allows you to disable binding to the external box ip Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash # Force always binding to the docker ip, no matter # what the settings are for a given app. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x echo false check-deploy Description: Allows you to run checks on a deploy before dokku allows the container to handle requests. Invoked by: dokku deploy Arguments: $CONTAINER_ID $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Disables deploys of containers based on whether the # `DOKKU_DISABLE_DEPLOY` env var is set to `true` for an app set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_AVAILABLE_PATH /config/functions\" CONTAINERID = \" $1 \" ; APP = \" $2 \" ; PORT = \" $3 \" ; HOSTNAME = \" ${ 4 :- localhost } \" eval \" $( config_export app $APP ) \" DOKKU_DISABLE_DEPLOY = \" ${ DOKKU_DISABLE_DEPLOY :- false } \" if [[ \" $DOKKU_DISABLE_DEPLOY \" = \"true\" ]] ; then echo -e \"\\033[31m\\033[1mDeploys disabled, sorry.\\033[0m\" exit 1 fi comands help and commands <PLUGIN_NAME>:help Description: Your plugin should implement a help command in your commands file to take advantage of this plugin trigger. commands help is used by dokku help to aggregate all plugins abbreviated help output. Implementing <PLUGIN_NAME>:help in your commands file gives users looking for help, a more detailed output. 'commands help' must be implemented inside the commands plugin file. It's recommended that PLUGIN_NAME:help be added to the commands file to ensure consistency among community plugins and give you a new avenue to share rich help content with your user. Invoked by: dokku help and commands <PLUGIN_NAME>:help Arguments: None Example: #!/usr/bin/env bash # Outputs help for the derp plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | hello:help ) help_content_func () { declare desc = \"return help_content string\" cat <<help_content hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" help_content } if [[ $1 = \"hello:help\" ]] ; then echo -e 'Usage: dokku hello[:world] [<app>]' echo '' echo 'Say Hello World.' echo '' echo 'Example:' echo '' echo '$ dokku hello:world' echo 'Hello world' echo '' echo 'Additional commands:' help_content_func | sort | column -c2 -t -s, else help_content_func fi ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac dependencies Description: Used to install system-level dependencies. Invoked by plugin:install-dependencies . Invoked by: dokku plugin:install-dependencies Arguments: None Example: #!/usr/bin/env bash # Installs nginx for the current plugin # Supports both opensuse and ubuntu set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x export DEBIAN_FRONTEND = noninteractive case \" $DOKKU_DISTRO \" in debian | ubuntu ) apt-get install --force-yes -qq -y nginx ;; opensuse ) zypper -q in -y nginx ;; esac docker-args-build Description: Invoked by: dokku build Arguments: $APP $IMAGE_SOURCE_TYPE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO docker-args-deploy Description: Invoked by: dokku deploy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO docker-args-run Description: Invoked by: dokku run Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO git-post-pull Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO git-pre-pull Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO install Description: Used to setup any files/configuration for a plugin. Invoked by: dokku plugin:install . Arguments: None Example: #!/usr/bin/env bash # Sets the hostname of the dokku server # based on the output of `hostname -f` set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x if [[ ! -f \" $DOKKU_ROOT /HOSTNAME\" ]] ; then hostname -f > $DOKKU_ROOT /HOSTNAME fi nginx-hostname Description: Allows you to customize the hostname for a given application. Invoked by: dokku domains:setup Arguments: $APP $SUBDOMAIN $VHOST Example: #!/usr/bin/env bash # Reverses the hostname for the application set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" nginx-pre-reload Description: Run before nginx reloads hosts Invoked by: dokku nginx:build-config Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Runs a check against all nginx conf files # to ensure they are valid set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x nginx -t post-build-buildpack Description: Allows you to run commands after the build image is create for a given app. Only applies to applications using buildpacks. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-build-dockerfile Description: Allows you to run commands after the build image is create for a given app. Only applies to applications using a dockerfile. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-create Description: Can be used to run commands after an application is created. Invoked by: dokku apps:create Arguments: $APP Example: #!/usr/bin/env bash # Runs a command to ensure that an app # has a postgres database when it is starting set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; POSTGRES = \" $1 \" dokku postgres:create $POSTGRES dokku postgres:link $POSTGRES $APP post-delete Description: Can be used to run commands after an application is deleted. Invoked by: dokku apps:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Runs a command to ensure that an app's # postgres installation is removed set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku postgres:destroy $APP post-deploy Description: Allows running of commands after an application's processes have been scaled up, but before old containers are torn down. Dokku core currently uses this to switch traffic on nginx. Invoked by: dokku deploy Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS $IMAGE_TAG Example: #!/usr/bin/env bash # Notify an external service that a successful deploy has occurred. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x curl \"http://httpstat.us/200\" post-domains-update Description: Allows you to run commands once the domain for an application has been updated. It also sends in the command that has been used. This can be \"add\", \"clear\" or \"remove\". The third argument will be the optional list of domains Invoked by: dokku domains:add , dokku domains:clear , dokku domains:remove Arguments: $APP action name domains Example: #!/usr/bin/env bash # Reloads haproxy for our imaginary haproxy plugin # that replaces the nginx-vhosts plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x sudo service haproxy reload post-release-buildpack Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to applications using buildpacks. Invoked by: dokku release Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Installs a package specified by the `CONTAINER_PACKAGE` env var set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" dokku_log_info1 \" Installing $CONTAINER_PACKAGE ...\" CMD = \"cat > gm && \\ dpkg -s CONTAINER_PACKAGE > /dev/null 2>&1 || \\ (apt-get update && apt-get install -y CONTAINER_PACKAGE && apt-get clean)\" ID = $( docker run $DOKKU_GLOBAL_RUN_ARGS -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $ID ) -eq 0 docker commit $ID $IMAGE > /dev/null post-release-dockerfile Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to applications using a dockerfile. Invoked by: dokku release Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO post-stop Description: Can be used to run commands after an application is manually stopped Invoked by: dokku ps:stop Arguments: $APP Example: #!/usr/bin/env bash # Marks an application as manually stopped set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku config:set --no-restart $APP MANUALLY_STOPPED = 1 pre-build-buildpack Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to applications using buildpacks. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO pre-build-dockerfile Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to applications using a dockerfile. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO pre-delete Description: Can be used to run commands before an app is deleted. Invoked by: dokku apps:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Clears out the gulp asset build cache for applications set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; GULP_CACHE_DIR = \" $DOKKU_ROOT / $APP /gulp\" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" if [[ -d $GULP_CACHE_DIR ]] ; then docker run $DOKKU_GLOBAL_RUN_ARGS --rm -v \" $GULP_CACHE_DIR :/gulp\" \" $IMAGE \" find /gulp -depth -mindepth 1 -maxdepth 1 -exec rm -Rf {} \\; || true fi pre-deploy Description: Allows the running of code before the application's processes are scaled up and after the docker images are prepared. Invoked by: dokku deploy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Runs gulp in our container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" dokku_log_info1 \"Running gulp\" id = $( docker run $DOKKU_GLOBAL_RUN_ARGS -d $IMAGE /bin/bash -c \"cd /app && gulp default\" ) test $( docker wait $id ) -eq 0 docker commit $id $IMAGE > /dev/null dokku_log_info1 \"Building UI Complete\" pre-receive-app Description: Allows you to customize the contents of an application directory before they are processed for deployment. The IMAGE_SOURCE_TYPE can be any of [herokuish, dockerfile] Invoked by: dokku git-hook , dokku tar-build-locked Arguments: $APP $IMAGE_SOURCE_TYPE $TMP_WORK_DIR $REV Example: #!/usr/bin/env bash # Adds a file called `dokku-is-awesome` to the repository # the contents will be the application name set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $2 \" ; TMP_WORK_DIR = \" $3 \" ; REV = \" $4 \" echo \" $APP \" > \" $TMP_WORK_DIR /dokku-is-awesome\" pre-release-buildpack Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to applications using buildpacks. Invoked by: dokku release Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Installs the graphicsmagick package into the container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" dokku_log_info1 \" Installing GraphicsMagick...\" CMD = \"cat > gm && \\ dpkg -s graphicsmagick > /dev/null 2>&1 || \\ (apt-get update && apt-get install -y graphicsmagick && apt-get clean)\" ID = $( docker run $DOKKU_GLOBAL_RUN_ARGS -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $ID ) -eq 0 docker commit $ID $IMAGE > /dev/null pre-release-dockerfile Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to applications using a dockerfile. Invoked by: dokku release Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO receive-app Description: Allows you to customize what occurs when an app is received. Normally just triggers an application build. Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV Example: #!/usr/bin/env bash # For our imaginary mercurial plugin, triggers a rebuild set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; REV = \" $2 \" dokku hg-build $APP $REV receive-branch Description: Allows you to customize what occurs when a specific branch is received. Can be used to add support for specific branch names Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV $REFNAME Example: #!/bin/bash # Gives dokku the ability to support multiple branches for a given service # Allowing you to have multiple staging environments on a per-branch basis reference_app = $1 refname = $3 newrev = $2 APP = ${ refname /* \\/ / } . $reference_app if [[ ! -d \" $DOKKU_ROOT / $APP \" ]] ; then REFERENCE_REPO = \" $DOKKU_ROOT / $reference_app git clone --bare --shared --reference \" $REFERENCE_REPO \" \" $REFERENCE_REPO \" \" $DOKKU_ROOT / $APP \" > /dev/null fi plugn trigger receive-app $APP $newrev retire-container-failed Description: Allows you to run commands if/when retiring old containers has failed Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash # Send an email when a container failed to retire set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; HOSTNAME = $( hostname -s ) mail -s \" $APP containers on $HOSTNAME failed to retire\" ops@example.com tags-create Description: Allows you to run commands once a tag for an application image has been added Invoked by: dokku tags:create Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Upload an application image to docker hub set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) IMAGE_ID = $( docker inspect --format '{{ .Id }}' $IMAGE ) docker tag -f $IMAGE_ID $DOCKER_HUB_USER / $APP : $IMAGE_TAG docker push $DOCKER_HUB_USER / $APP : $IMAGE_TAG tags-destroy Description: Allows you to run commands once a tag for an application image has been removed Invoked by: dokku tags:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Remove an image tag from docker hub set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_TAG = \" $2 \" some code to remove a docker hub tag because it ' s not implemented in the CLI.... update Description: Can be used to run plugin updates on a regular interval. You can schedule the invoker in a cron-task to ensure your system gets regular updates. Invoked by: dokku plugin:update . Arguments: None Example: #!/usr/bin/env bash # Update the herokuish image from git source set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x cd /root/dokku sudo BUILD_STACK = true make install user-auth This is a special plugin trigger that is executed on every command run. As dokku sometimes internally invokes the dokku command, special care should be taken to properly handle internal command redirects. Note that the trigger should exit as follows: 0 to continue running as normal 1 to halt execution of the command The SSH_USER is the original ssh user. If you are running remote commands, this user will typically be dokku , and as such should not be trusted when checking permissions. If you are connected via ssh as a different user who then invokes dokku , the value of this variable will be that user's name ( root , myuser , etc.). The SSH_NAME is the NAME variable set via the sshcommand acl-add command. If you have set a user via the dokku-installer , this value will be set to admin . For installs via debian package, this value may be default . For reference, the following command can be run as the root user to specify a specific NAME for a given ssh key: sshcommand acl-add dokku NAME < $PATH_TO_SSH_KEY Note that the NAME value is set at the first ssh key match. If an ssh key is set in the /home/dokku/.ssh/authorized_keys multiple times, the first match will decide the value. Description: Allows you to deny access to a dokku command by either ssh user or associated ssh-command NAME user. Invoked by dokku Arguments: $SSH_USER $SSH_NAME $DOKKU_COMMAND Example: #!/usr/bin/env bash # Allow root/admin users to do everything # Deny plugin access to default users # Allow access to all other commands set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x SSH_USER = $1 SSH_NAME = $2 shift 2 [[ \" $SSH_USER \" == \"root\" ]] && exit 0 [[ \" $SSH_NAME \" == \"admin\" ]] && exit 0 [[ \" $SSH_NAME \" == \"default\" && $1 == plugin:* ]] && exit 1 exit 0","title":"Plugin triggers"},{"location":"development/plugin-triggers/#plugin-triggers","text":"Plugin triggers (formerly pluginhooks ) are a good way to jack into existing dokku infrastructure. You can use them to modify the output of various dokku commands or override internal configuration. Plugin triggers are simply scripts that are executed by the system. You can use any language you want, so long as the script: Is executable Has the proper language requirements installed For instance, if you wanted to write a plugin trigger in PHP, you would need to have php installed and available on the CLI prior to plugin trigger invocation. The following is an example for the nginx-hostname plugin trigger. It reverses the hostname that is provided to nginx during deploys. If you created an executable file named nginx-hostname with the following code in your plugin trigger, it would be invoked by dokku during the normal app deployment process: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \"","title":"Plugin triggers"},{"location":"development/plugin-triggers/#available-plugin-triggers","text":"There are a number of plugin-related triggers. These can be optionally implemented by plugins and allow integration into the standard dokku setup/teardown process. The following plugin triggers describe those available to a dokku installation. As well, there is an example for each trigger that you can use as templates for your own plugin development. The example plugin trigger code is not guaranteed to be implemented as in within dokkku, and are merely simplified examples. Please look at the dokku source for larger, more in-depth examples.","title":"Available plugin triggers"},{"location":"development/plugin-triggers/#post-config-update","text":"Description: Allows you to get notified when one or more configs is added or removed. Action can be set or unset Invoked by: dokku config:set , dokku config:unset Arguments: $APP set|unset key1=VALUE1 key2=VALUE2 Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-config-update"},{"location":"development/plugin-triggers/#bind-external-ip","text":"Description: Allows you to disable binding to the external box ip Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash # Force always binding to the docker ip, no matter # what the settings are for a given app. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x echo false","title":"bind-external-ip"},{"location":"development/plugin-triggers/#check-deploy","text":"Description: Allows you to run checks on a deploy before dokku allows the container to handle requests. Invoked by: dokku deploy Arguments: $CONTAINER_ID $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Disables deploys of containers based on whether the # `DOKKU_DISABLE_DEPLOY` env var is set to `true` for an app set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_AVAILABLE_PATH /config/functions\" CONTAINERID = \" $1 \" ; APP = \" $2 \" ; PORT = \" $3 \" ; HOSTNAME = \" ${ 4 :- localhost } \" eval \" $( config_export app $APP ) \" DOKKU_DISABLE_DEPLOY = \" ${ DOKKU_DISABLE_DEPLOY :- false } \" if [[ \" $DOKKU_DISABLE_DEPLOY \" = \"true\" ]] ; then echo -e \"\\033[31m\\033[1mDeploys disabled, sorry.\\033[0m\" exit 1 fi","title":"check-deploy"},{"location":"development/plugin-triggers/#comands-help-and-commands-plugin_namehelp","text":"Description: Your plugin should implement a help command in your commands file to take advantage of this plugin trigger. commands help is used by dokku help to aggregate all plugins abbreviated help output. Implementing <PLUGIN_NAME>:help in your commands file gives users looking for help, a more detailed output. 'commands help' must be implemented inside the commands plugin file. It's recommended that PLUGIN_NAME:help be added to the commands file to ensure consistency among community plugins and give you a new avenue to share rich help content with your user. Invoked by: dokku help and commands <PLUGIN_NAME>:help Arguments: None Example: #!/usr/bin/env bash # Outputs help for the derp plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | hello:help ) help_content_func () { declare desc = \"return help_content string\" cat <<help_content hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" help_content } if [[ $1 = \"hello:help\" ]] ; then echo -e 'Usage: dokku hello[:world] [<app>]' echo '' echo 'Say Hello World.' echo '' echo 'Example:' echo '' echo '$ dokku hello:world' echo 'Hello world' echo '' echo 'Additional commands:' help_content_func | sort | column -c2 -t -s, else help_content_func fi ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac","title":"comands help and commands &lt;PLUGIN_NAME&gt;:help"},{"location":"development/plugin-triggers/#dependencies","text":"Description: Used to install system-level dependencies. Invoked by plugin:install-dependencies . Invoked by: dokku plugin:install-dependencies Arguments: None Example: #!/usr/bin/env bash # Installs nginx for the current plugin # Supports both opensuse and ubuntu set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x export DEBIAN_FRONTEND = noninteractive case \" $DOKKU_DISTRO \" in debian | ubuntu ) apt-get install --force-yes -qq -y nginx ;; opensuse ) zypper -q in -y nginx ;; esac","title":"dependencies"},{"location":"development/plugin-triggers/#docker-args-build","text":"Description: Invoked by: dokku build Arguments: $APP $IMAGE_SOURCE_TYPE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"docker-args-build"},{"location":"development/plugin-triggers/#docker-args-deploy","text":"Description: Invoked by: dokku deploy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO","title":"docker-args-deploy"},{"location":"development/plugin-triggers/#docker-args-run","text":"Description: Invoked by: dokku run Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO","title":"docker-args-run"},{"location":"development/plugin-triggers/#git-post-pull","text":"Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"git-post-pull"},{"location":"development/plugin-triggers/#git-pre-pull","text":"Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"git-pre-pull"},{"location":"development/plugin-triggers/#install","text":"Description: Used to setup any files/configuration for a plugin. Invoked by: dokku plugin:install . Arguments: None Example: #!/usr/bin/env bash # Sets the hostname of the dokku server # based on the output of `hostname -f` set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x if [[ ! -f \" $DOKKU_ROOT /HOSTNAME\" ]] ; then hostname -f > $DOKKU_ROOT /HOSTNAME fi","title":"install"},{"location":"development/plugin-triggers/#nginx-hostname","text":"Description: Allows you to customize the hostname for a given application. Invoked by: dokku domains:setup Arguments: $APP $SUBDOMAIN $VHOST Example: #!/usr/bin/env bash # Reverses the hostname for the application set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \"","title":"nginx-hostname"},{"location":"development/plugin-triggers/#nginx-pre-reload","text":"Description: Run before nginx reloads hosts Invoked by: dokku nginx:build-config Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Runs a check against all nginx conf files # to ensure they are valid set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x nginx -t","title":"nginx-pre-reload"},{"location":"development/plugin-triggers/#post-build-buildpack","text":"Description: Allows you to run commands after the build image is create for a given app. Only applies to applications using buildpacks. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-build-buildpack"},{"location":"development/plugin-triggers/#post-build-dockerfile","text":"Description: Allows you to run commands after the build image is create for a given app. Only applies to applications using a dockerfile. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-build-dockerfile"},{"location":"development/plugin-triggers/#post-create","text":"Description: Can be used to run commands after an application is created. Invoked by: dokku apps:create Arguments: $APP Example: #!/usr/bin/env bash # Runs a command to ensure that an app # has a postgres database when it is starting set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; POSTGRES = \" $1 \" dokku postgres:create $POSTGRES dokku postgres:link $POSTGRES $APP","title":"post-create"},{"location":"development/plugin-triggers/#post-delete","text":"Description: Can be used to run commands after an application is deleted. Invoked by: dokku apps:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Runs a command to ensure that an app's # postgres installation is removed set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku postgres:destroy $APP","title":"post-delete"},{"location":"development/plugin-triggers/#post-deploy","text":"Description: Allows running of commands after an application's processes have been scaled up, but before old containers are torn down. Dokku core currently uses this to switch traffic on nginx. Invoked by: dokku deploy Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS $IMAGE_TAG Example: #!/usr/bin/env bash # Notify an external service that a successful deploy has occurred. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x curl \"http://httpstat.us/200\"","title":"post-deploy"},{"location":"development/plugin-triggers/#post-domains-update","text":"Description: Allows you to run commands once the domain for an application has been updated. It also sends in the command that has been used. This can be \"add\", \"clear\" or \"remove\". The third argument will be the optional list of domains Invoked by: dokku domains:add , dokku domains:clear , dokku domains:remove Arguments: $APP action name domains Example: #!/usr/bin/env bash # Reloads haproxy for our imaginary haproxy plugin # that replaces the nginx-vhosts plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x sudo service haproxy reload","title":"post-domains-update"},{"location":"development/plugin-triggers/#post-release-buildpack","text":"Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to applications using buildpacks. Invoked by: dokku release Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Installs a package specified by the `CONTAINER_PACKAGE` env var set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" dokku_log_info1 \" Installing $CONTAINER_PACKAGE ...\" CMD = \"cat > gm && \\ dpkg -s CONTAINER_PACKAGE > /dev/null 2>&1 || \\ (apt-get update && apt-get install -y CONTAINER_PACKAGE && apt-get clean)\" ID = $( docker run $DOKKU_GLOBAL_RUN_ARGS -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $ID ) -eq 0 docker commit $ID $IMAGE > /dev/null","title":"post-release-buildpack"},{"location":"development/plugin-triggers/#post-release-dockerfile","text":"Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to applications using a dockerfile. Invoked by: dokku release Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO","title":"post-release-dockerfile"},{"location":"development/plugin-triggers/#post-stop","text":"Description: Can be used to run commands after an application is manually stopped Invoked by: dokku ps:stop Arguments: $APP Example: #!/usr/bin/env bash # Marks an application as manually stopped set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku config:set --no-restart $APP MANUALLY_STOPPED = 1","title":"post-stop"},{"location":"development/plugin-triggers/#pre-build-buildpack","text":"Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to applications using buildpacks. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"pre-build-buildpack"},{"location":"development/plugin-triggers/#pre-build-dockerfile","text":"Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to applications using a dockerfile. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"pre-build-dockerfile"},{"location":"development/plugin-triggers/#pre-delete","text":"Description: Can be used to run commands before an app is deleted. Invoked by: dokku apps:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Clears out the gulp asset build cache for applications set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; GULP_CACHE_DIR = \" $DOKKU_ROOT / $APP /gulp\" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" if [[ -d $GULP_CACHE_DIR ]] ; then docker run $DOKKU_GLOBAL_RUN_ARGS --rm -v \" $GULP_CACHE_DIR :/gulp\" \" $IMAGE \" find /gulp -depth -mindepth 1 -maxdepth 1 -exec rm -Rf {} \\; || true fi","title":"pre-delete"},{"location":"development/plugin-triggers/#pre-deploy","text":"Description: Allows the running of code before the application's processes are scaled up and after the docker images are prepared. Invoked by: dokku deploy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Runs gulp in our container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" dokku_log_info1 \"Running gulp\" id = $( docker run $DOKKU_GLOBAL_RUN_ARGS -d $IMAGE /bin/bash -c \"cd /app && gulp default\" ) test $( docker wait $id ) -eq 0 docker commit $id $IMAGE > /dev/null dokku_log_info1 \"Building UI Complete\"","title":"pre-deploy"},{"location":"development/plugin-triggers/#pre-receive-app","text":"Description: Allows you to customize the contents of an application directory before they are processed for deployment. The IMAGE_SOURCE_TYPE can be any of [herokuish, dockerfile] Invoked by: dokku git-hook , dokku tar-build-locked Arguments: $APP $IMAGE_SOURCE_TYPE $TMP_WORK_DIR $REV Example: #!/usr/bin/env bash # Adds a file called `dokku-is-awesome` to the repository # the contents will be the application name set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $2 \" ; TMP_WORK_DIR = \" $3 \" ; REV = \" $4 \" echo \" $APP \" > \" $TMP_WORK_DIR /dokku-is-awesome\"","title":"pre-receive-app"},{"location":"development/plugin-triggers/#pre-release-buildpack","text":"Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to applications using buildpacks. Invoked by: dokku release Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Installs the graphicsmagick package into the container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" dokku_log_info1 \" Installing GraphicsMagick...\" CMD = \"cat > gm && \\ dpkg -s graphicsmagick > /dev/null 2>&1 || \\ (apt-get update && apt-get install -y graphicsmagick && apt-get clean)\" ID = $( docker run $DOKKU_GLOBAL_RUN_ARGS -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $ID ) -eq 0 docker commit $ID $IMAGE > /dev/null","title":"pre-release-buildpack"},{"location":"development/plugin-triggers/#pre-release-dockerfile","text":"Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to applications using a dockerfile. Invoked by: dokku release Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO","title":"pre-release-dockerfile"},{"location":"development/plugin-triggers/#receive-app","text":"Description: Allows you to customize what occurs when an app is received. Normally just triggers an application build. Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV Example: #!/usr/bin/env bash # For our imaginary mercurial plugin, triggers a rebuild set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; REV = \" $2 \" dokku hg-build $APP $REV","title":"receive-app"},{"location":"development/plugin-triggers/#receive-branch","text":"Description: Allows you to customize what occurs when a specific branch is received. Can be used to add support for specific branch names Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV $REFNAME Example: #!/bin/bash # Gives dokku the ability to support multiple branches for a given service # Allowing you to have multiple staging environments on a per-branch basis reference_app = $1 refname = $3 newrev = $2 APP = ${ refname /* \\/ / } . $reference_app if [[ ! -d \" $DOKKU_ROOT / $APP \" ]] ; then REFERENCE_REPO = \" $DOKKU_ROOT / $reference_app git clone --bare --shared --reference \" $REFERENCE_REPO \" \" $REFERENCE_REPO \" \" $DOKKU_ROOT / $APP \" > /dev/null fi plugn trigger receive-app $APP $newrev","title":"receive-branch"},{"location":"development/plugin-triggers/#retire-container-failed","text":"Description: Allows you to run commands if/when retiring old containers has failed Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash # Send an email when a container failed to retire set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; HOSTNAME = $( hostname -s ) mail -s \" $APP containers on $HOSTNAME failed to retire\" ops@example.com","title":"retire-container-failed"},{"location":"development/plugin-triggers/#tags-create","text":"Description: Allows you to run commands once a tag for an application image has been added Invoked by: dokku tags:create Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Upload an application image to docker hub set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) IMAGE_ID = $( docker inspect --format '{{ .Id }}' $IMAGE ) docker tag -f $IMAGE_ID $DOCKER_HUB_USER / $APP : $IMAGE_TAG docker push $DOCKER_HUB_USER / $APP : $IMAGE_TAG","title":"tags-create"},{"location":"development/plugin-triggers/#tags-destroy","text":"Description: Allows you to run commands once a tag for an application image has been removed Invoked by: dokku tags:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Remove an image tag from docker hub set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_TAG = \" $2 \" some code to remove a docker hub tag because it ' s not implemented in the CLI....","title":"tags-destroy"},{"location":"development/plugin-triggers/#update","text":"Description: Can be used to run plugin updates on a regular interval. You can schedule the invoker in a cron-task to ensure your system gets regular updates. Invoked by: dokku plugin:update . Arguments: None Example: #!/usr/bin/env bash # Update the herokuish image from git source set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x cd /root/dokku sudo BUILD_STACK = true make install","title":"update"},{"location":"development/plugin-triggers/#user-auth","text":"This is a special plugin trigger that is executed on every command run. As dokku sometimes internally invokes the dokku command, special care should be taken to properly handle internal command redirects. Note that the trigger should exit as follows: 0 to continue running as normal 1 to halt execution of the command The SSH_USER is the original ssh user. If you are running remote commands, this user will typically be dokku , and as such should not be trusted when checking permissions. If you are connected via ssh as a different user who then invokes dokku , the value of this variable will be that user's name ( root , myuser , etc.). The SSH_NAME is the NAME variable set via the sshcommand acl-add command. If you have set a user via the dokku-installer , this value will be set to admin . For installs via debian package, this value may be default . For reference, the following command can be run as the root user to specify a specific NAME for a given ssh key: sshcommand acl-add dokku NAME < $PATH_TO_SSH_KEY Note that the NAME value is set at the first ssh key match. If an ssh key is set in the /home/dokku/.ssh/authorized_keys multiple times, the first match will decide the value. Description: Allows you to deny access to a dokku command by either ssh user or associated ssh-command NAME user. Invoked by dokku Arguments: $SSH_USER $SSH_NAME $DOKKU_COMMAND Example: #!/usr/bin/env bash # Allow root/admin users to do everything # Deny plugin access to default users # Allow access to all other commands set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x SSH_USER = $1 SSH_NAME = $2 shift 2 [[ \" $SSH_USER \" == \"root\" ]] && exit 0 [[ \" $SSH_NAME \" == \"admin\" ]] && exit 0 [[ \" $SSH_NAME \" == \"default\" && $1 == plugin:* ]] && exit 1 exit 0","title":"user-auth"},{"location":"development/release-process/","text":"Release Process Dokku is released in intervals at most three weeks apart, though may be released much quicker. To propose a release, the following tasks need to be performed: Update all blockquote references of not yet released and only available in master to point to release version. The installable version must be changed in the contrib/dokku-installer.py file. The installable version must be changed in the debian/control file. The installable version must be changed in the docs/home.html file The installable version must be changed in the docs/installation.md file. The installable version must be changed in the docs/template.html file. The installable version must be changed in the README.md file. The embedded css should be cleared in the docs/template.html file. The versioned links should be updated in the docs/assets/favicons/browserconfig.xml file. The versioned links should be updated in the docs/assets/favicons/manifest.json file. The versioned links should be updated in the docs/assets/style.css file. The versioned links should be updated in the docs/home.html file. The versioned links should be updated in the docs/template.html file. The versioned links should be updated or added to the docs/assets/versions.json file. A list of changes must be made in the HISTORY.md . A tag must be created locally with your release version Debian packages must be created via vagrant up build The packages should be uploaded to packagecloud.io All changes are pushed to master and the tag should be turned into a release which will contain the changelog. ArchLinux package description must be updated via vagrant up build-arch (needs to be done after the tag is pushed to GitHub, because it is based on that) Versioning Dokku follows semver standards. As we are not yet at a stable release, breaking changes will require only a minor release, while all other changes only require a patch release. Once we hit stable, breaking changes will require a major release. Tags should be created via the following method: git tag v0.9.9 At the moment, tags need not be signed, though that may change in the future. Debian Packages The build target in the dokku Vagrantfile creates debian packages for dokku at a point in time. The version will be based upon the latest local tag - you may create your own, internal tags/releases if that is so desired. Debian package information is held in the debian directory of the dokku project. For the public project, releases should be pushed to packagecloud.io after a tag is created but before said tag is pushed to github. The following may be the release workflow: git tag v0.9.9 vagrant up build export PACKAGECLOUD_TOKEN = SOME_TOKEN package_cloud push dokku/dokku/ubuntu/trusty dokku_0.9.9_amd64.deb If new versions of other packages were created, these should also be pushed at this time. If you are a maintainer and need the PACKAGECLOUD_TOKEN in order to make a release, please contact @josegonzalez to get this information. ArchLinux Packages ArchLinux packages are not really build, because all that is needed for an Arch User Repo (AUR) package is the description of how to build the package. To make this process as easy as possible there is a vagrant box called build-arch that updates the version of this build description (a file called PKGBUILD ), then runs some helper scripts to fill all additional information and does test if the package could be build. Then only those changes need to be pushed to the AUR repo and an updated version of the package is ready for usage for our ArchLinux users. For detailed information see the section below. The workflow looks like this: # having dokku-arch in ../dokku-arch vagrant up build-arch # wait for \"==> build-arch: ==> Finished making: dokku 0.5.8-2 (Mon Feb 22 23:20:37 CET 2016)\" cd ../dokku-arch git add PKGBUILD .SRCINFO git commit -m 'Update to dokku 0.9.9' git push aur master If you are a maintainer and need access to the AUR repositories in order to make a release, please contact @morrisjobke or @josegonzalez to get this co-maintainership. Changelog format The HISTORY.md should be added to based on the changes made since the previous release. This can be done by reviewing all merged pull requests to the master branch on github. The format is as follows: ## 0.9.9 Some description concerning major changes in this release, or potential incompatibilities. ### New Features - #SOME_ID: @pull-request-creator Description ### Bug Fixes - #SOME_ID: @pull-request-creator Description ### Docs Changes - #SOME_ID: @pull-request-creator Description Detailed information for ArchLinux packages All of the information to build the ArchLinux package is in the AUR git repository (see dokku AUR page ). The release of a AUR package only consists of pushing the package information into the AUR git repo. Then users could use that information to build the package on their machines. To update the package clone the repository and adjust the files in the repository. Then a helper script - updpkgsums - to update the SHA sum could be called (check against the original SHA sum). Another helper script - mksrcinfo - needs to be called to update the meta information of the package in a file called .SRCINFO . The next step builds the package locally for verification - makepkg . As last step commit your changes and push the commit. dependencies are defined in the depends attribute in PKGBUILD build steps during package build time are defined in the package() method in PKGBUILD steps that should be executed during install/update/remove time are defined in the file dokku.install detailed information about all attributes in PKGBUILD could be found in the ArchLinux wiki detailed information about the AUR workflow could be found in the AUR article in the ArchLinux wiki That is the usual workflow: updpkgsums # update sha sums - compare them with the original ones mksrcinfo # update package metadata for AUR makepkg # test package builds git add PKGBUILD .SRCINFO git commit -m 'Update to dokku 0.9.9' git push If there is something unclear simply ask @morrisjobke for help.","title":"Release Process"},{"location":"development/release-process/#release-process","text":"Dokku is released in intervals at most three weeks apart, though may be released much quicker. To propose a release, the following tasks need to be performed: Update all blockquote references of not yet released and only available in master to point to release version. The installable version must be changed in the contrib/dokku-installer.py file. The installable version must be changed in the debian/control file. The installable version must be changed in the docs/home.html file The installable version must be changed in the docs/installation.md file. The installable version must be changed in the docs/template.html file. The installable version must be changed in the README.md file. The embedded css should be cleared in the docs/template.html file. The versioned links should be updated in the docs/assets/favicons/browserconfig.xml file. The versioned links should be updated in the docs/assets/favicons/manifest.json file. The versioned links should be updated in the docs/assets/style.css file. The versioned links should be updated in the docs/home.html file. The versioned links should be updated in the docs/template.html file. The versioned links should be updated or added to the docs/assets/versions.json file. A list of changes must be made in the HISTORY.md . A tag must be created locally with your release version Debian packages must be created via vagrant up build The packages should be uploaded to packagecloud.io All changes are pushed to master and the tag should be turned into a release which will contain the changelog. ArchLinux package description must be updated via vagrant up build-arch (needs to be done after the tag is pushed to GitHub, because it is based on that)","title":"Release Process"},{"location":"development/release-process/#versioning","text":"Dokku follows semver standards. As we are not yet at a stable release, breaking changes will require only a minor release, while all other changes only require a patch release. Once we hit stable, breaking changes will require a major release. Tags should be created via the following method: git tag v0.9.9 At the moment, tags need not be signed, though that may change in the future.","title":"Versioning"},{"location":"development/release-process/#debian-packages","text":"The build target in the dokku Vagrantfile creates debian packages for dokku at a point in time. The version will be based upon the latest local tag - you may create your own, internal tags/releases if that is so desired. Debian package information is held in the debian directory of the dokku project. For the public project, releases should be pushed to packagecloud.io after a tag is created but before said tag is pushed to github. The following may be the release workflow: git tag v0.9.9 vagrant up build export PACKAGECLOUD_TOKEN = SOME_TOKEN package_cloud push dokku/dokku/ubuntu/trusty dokku_0.9.9_amd64.deb If new versions of other packages were created, these should also be pushed at this time. If you are a maintainer and need the PACKAGECLOUD_TOKEN in order to make a release, please contact @josegonzalez to get this information.","title":"Debian Packages"},{"location":"development/release-process/#archlinux-packages","text":"ArchLinux packages are not really build, because all that is needed for an Arch User Repo (AUR) package is the description of how to build the package. To make this process as easy as possible there is a vagrant box called build-arch that updates the version of this build description (a file called PKGBUILD ), then runs some helper scripts to fill all additional information and does test if the package could be build. Then only those changes need to be pushed to the AUR repo and an updated version of the package is ready for usage for our ArchLinux users. For detailed information see the section below. The workflow looks like this: # having dokku-arch in ../dokku-arch vagrant up build-arch # wait for \"==> build-arch: ==> Finished making: dokku 0.5.8-2 (Mon Feb 22 23:20:37 CET 2016)\" cd ../dokku-arch git add PKGBUILD .SRCINFO git commit -m 'Update to dokku 0.9.9' git push aur master If you are a maintainer and need access to the AUR repositories in order to make a release, please contact @morrisjobke or @josegonzalez to get this co-maintainership.","title":"ArchLinux Packages"},{"location":"development/release-process/#changelog-format","text":"The HISTORY.md should be added to based on the changes made since the previous release. This can be done by reviewing all merged pull requests to the master branch on github. The format is as follows: ## 0.9.9 Some description concerning major changes in this release, or potential incompatibilities. ### New Features - #SOME_ID: @pull-request-creator Description ### Bug Fixes - #SOME_ID: @pull-request-creator Description ### Docs Changes - #SOME_ID: @pull-request-creator Description","title":"Changelog format"},{"location":"development/release-process/#detailed-information-for-archlinux-packages","text":"All of the information to build the ArchLinux package is in the AUR git repository (see dokku AUR page ). The release of a AUR package only consists of pushing the package information into the AUR git repo. Then users could use that information to build the package on their machines. To update the package clone the repository and adjust the files in the repository. Then a helper script - updpkgsums - to update the SHA sum could be called (check against the original SHA sum). Another helper script - mksrcinfo - needs to be called to update the meta information of the package in a file called .SRCINFO . The next step builds the package locally for verification - makepkg . As last step commit your changes and push the commit. dependencies are defined in the depends attribute in PKGBUILD build steps during package build time are defined in the package() method in PKGBUILD steps that should be executed during install/update/remove time are defined in the file dokku.install detailed information about all attributes in PKGBUILD could be found in the ArchLinux wiki detailed information about the AUR workflow could be found in the AUR article in the ArchLinux wiki That is the usual workflow: updpkgsums # update sha sums - compare them with the original ones mksrcinfo # update package metadata for AUR makepkg # test package builds git add PKGBUILD .SRCINFO git commit -m 'Update to dokku 0.9.9' git push If there is something unclear simply ask @morrisjobke for help.","title":"Detailed information for ArchLinux packages"},{"location":"development/testing/","text":"Dokku test suite Dokku now has a full test suite to assist in quick iterating development. These tests include a linter using shellcheck , functional unit tests using the bats testing framework , and a deployment suite of example apps that use the most popular languages and frameworks. Bats tests can be found here: tests/unit/*.bats Example apps can be found here: tests/apps/ Executing tests locally Setup dokku in a vagrant vm Test setup and execution $ vagrant ssh $ sudo su - $ cd ~/dokku $ make ci-dependencies setup-deploy-tests $ make test # execute the entire test suite (linter, bats tests, and app deployment tests) $ $ make lint copyfiles # run linter & update vagrant dokku install from local git clone $ make unit-tests # execute all bats tests $ make deploy-tests # execute all app deployment tests - Additionally you may run a specific app deployment tests with a target similar to: $ make deploy-test-nodejs-express - For a full list of test make targets check out tests.mk in the root of the dokku repository.","title":"Dokku test suite"},{"location":"development/testing/#dokku-test-suite","text":"Dokku now has a full test suite to assist in quick iterating development. These tests include a linter using shellcheck , functional unit tests using the bats testing framework , and a deployment suite of example apps that use the most popular languages and frameworks. Bats tests can be found here: tests/unit/*.bats Example apps can be found here: tests/apps/","title":"Dokku test suite"},{"location":"development/testing/#executing-tests-locally","text":"Setup dokku in a vagrant vm Test setup and execution $ vagrant ssh $ sudo su - $ cd ~/dokku $ make ci-dependencies setup-deploy-tests $ make test # execute the entire test suite (linter, bats tests, and app deployment tests) $ $ make lint copyfiles # run linter & update vagrant dokku install from local git clone $ make unit-tests # execute all bats tests $ make deploy-tests # execute all app deployment tests - Additionally you may run a specific app deployment tests with a target similar to: $ make deploy-test-nodejs-express - For a full list of test make targets check out tests.mk in the root of the dokku repository.","title":"Executing tests locally"},{"location":"getting-started/where-to-get-help/","text":"Where to Get Help If you\u2019re stuck, there are a number of places you can get help: The Official Dokku Website http://dokku.viewdocs.io/dokku The Official Dokku website is always a great place to visit. It features links to oft-used developer tools, community plugins, and guides on using dokku. The IRC and Slack Channels irc.freenode.net/#dokku Gliderlabs Slack If you\u2019re stumped, give us a holler in the Dokku IRC or Slack channels. Someone from the development team is usually there, especially during the daylight hours for North and South America users. We\u2019d love to hear from you, whether you need some help, want to find users in your area, or would like to donate your brand new sports car. Stack Overflow http://stackoverflow.com/ Tag your questions with dokku to enable existing users of Stack Overflow to find your questions.","title":"Where to Get Help"},{"location":"getting-started/where-to-get-help/#where-to-get-help","text":"If you\u2019re stuck, there are a number of places you can get help:","title":"Where to Get Help"},{"location":"getting-started/where-to-get-help/#the-official-dokku-website","text":"http://dokku.viewdocs.io/dokku The Official Dokku website is always a great place to visit. It features links to oft-used developer tools, community plugins, and guides on using dokku.","title":"The Official Dokku Website"},{"location":"getting-started/where-to-get-help/#the-irc-and-slack-channels","text":"irc.freenode.net/#dokku Gliderlabs Slack If you\u2019re stumped, give us a holler in the Dokku IRC or Slack channels. Someone from the development team is usually there, especially during the daylight hours for North and South America users. We\u2019d love to hear from you, whether you need some help, want to find users in your area, or would like to donate your brand new sports car.","title":"The IRC and Slack Channels"},{"location":"getting-started/where-to-get-help/#stack-overflow","text":"http://stackoverflow.com/ Tag your questions with dokku to enable existing users of Stack Overflow to find your questions.","title":"Stack Overflow"},{"location":"getting-started/install/azure/","text":"Microsoft Azure If you don't already have one generate an SSH key pair . Go to the dokku on azure deployment page and click Deploy to Azure . You'll be prompted to enter a few parameters, including a unique storage account name and a unique name for the sub-domain used for your public IP address. For the sshKeyData parameter, copy and paste the contents of the public key file you just created. After a few minutes the Dokku instance will be deployed. In your browser of choice, navigate to http://[[dnsNameForPublicIP]].[[location]].cloudapp.azure.com . Where [[dnsNameForPublicIP]] and [[location]] are template parameters you used to deploy the template. Finish your dokku setup like you normally would by creating a new public/private key pair for your deployments using ssh-keygen (don't use the same one as you created in the first step). You should select 'Use Virtual Host Naming' and set the Hostname to a public dns name that you own such as one you would purchase from namecheap . Alternatively thanks to xip.io you can just use yourAzurePublicIP.xip.io for free. For example, if your public IP is 44.44.44.44 then you would set it to 44.44.44.44.xip.io .","title":"Microsoft Azure"},{"location":"getting-started/install/azure/#microsoft-azure","text":"If you don't already have one generate an SSH key pair . Go to the dokku on azure deployment page and click Deploy to Azure . You'll be prompted to enter a few parameters, including a unique storage account name and a unique name for the sub-domain used for your public IP address. For the sshKeyData parameter, copy and paste the contents of the public key file you just created. After a few minutes the Dokku instance will be deployed. In your browser of choice, navigate to http://[[dnsNameForPublicIP]].[[location]].cloudapp.azure.com . Where [[dnsNameForPublicIP]] and [[location]] are template parameters you used to deploy the template. Finish your dokku setup like you normally would by creating a new public/private key pair for your deployments using ssh-keygen (don't use the same one as you created in the first step). You should select 'Use Virtual Host Naming' and set the Hostname to a public dns name that you own such as one you would purchase from namecheap . Alternatively thanks to xip.io you can just use yourAzurePublicIP.xip.io for free. For example, if your public IP is 44.44.44.44 then you would set it to 44.44.44.44.xip.io .","title":"Microsoft Azure"},{"location":"getting-started/install/debian/","text":"Debian Package Installation Notes As of 0.3.18, dokku defaults to being installed via debian package. While certain hosts may require extra work to get running, you may optionally wish to automate the installation of dokku without the use of our bootstrap.sh bash script. The following are the steps run by said script: # install prerequisites sudo apt-get update -qq > /dev/null sudo apt-get install -qq -y apt-transport-https # install docker wget -nv -O - https://get.docker.com/ | sh # install dokku wget -nv -O - https://packagecloud.io/gpg.key | apt-key add - echo \"deb https://packagecloud.io/dokku/dokku/ubuntu/ trusty main\" | sudo tee /etc/apt/sources.list.d/dokku.list sudo apt-get update -qq > /dev/null sudo apt-get install dokku sudo dokku plugin:install-dependencies --core Unattended installation In case you want to perform an unattended installation of dokku, this is made possible through debconf , which allows you to configure a package before installing it. You can set any of the below options through the debconf-set-selections command, for example to enable vhost-based deployments: echo \"dokku dokku/vhost_enable boolean true\" | sudo debconf-set-selections After setting the desired options, proceed with the installation as described above. debconf options Name Type Default Description dokku/web_config boolean true Use web-based config for below options dokku/vhost_enable boolean false Use vhost-based deployments (e.g. .dokku.me) dokku/hostname string dokku.me Hostname, used as vhost domain and for showing app URL after deploy dokku/skip_key_file boolean false Don't check for the existence of the dokku/key_file. Warning: This setting this to true, will require you to manually add an SSH key later on. dokku/key_file string /root/.ssh/id_rsa.pub SSH key to add to the Dokku user (Will be ignored on dpkg-reconfigure )","title":"Debian Package Installation Notes"},{"location":"getting-started/install/debian/#debian-package-installation-notes","text":"As of 0.3.18, dokku defaults to being installed via debian package. While certain hosts may require extra work to get running, you may optionally wish to automate the installation of dokku without the use of our bootstrap.sh bash script. The following are the steps run by said script: # install prerequisites sudo apt-get update -qq > /dev/null sudo apt-get install -qq -y apt-transport-https # install docker wget -nv -O - https://get.docker.com/ | sh # install dokku wget -nv -O - https://packagecloud.io/gpg.key | apt-key add - echo \"deb https://packagecloud.io/dokku/dokku/ubuntu/ trusty main\" | sudo tee /etc/apt/sources.list.d/dokku.list sudo apt-get update -qq > /dev/null sudo apt-get install dokku sudo dokku plugin:install-dependencies --core","title":"Debian Package Installation Notes"},{"location":"getting-started/install/debian/#unattended-installation","text":"In case you want to perform an unattended installation of dokku, this is made possible through debconf , which allows you to configure a package before installing it. You can set any of the below options through the debconf-set-selections command, for example to enable vhost-based deployments: echo \"dokku dokku/vhost_enable boolean true\" | sudo debconf-set-selections After setting the desired options, proceed with the installation as described above.","title":"Unattended installation"},{"location":"getting-started/install/debian/#debconf-options","text":"Name Type Default Description dokku/web_config boolean true Use web-based config for below options dokku/vhost_enable boolean false Use vhost-based deployments (e.g. .dokku.me) dokku/hostname string dokku.me Hostname, used as vhost domain and for showing app URL after deploy dokku/skip_key_file boolean false Don't check for the existence of the dokku/key_file. Warning: This setting this to true, will require you to manually add an SSH key later on. dokku/key_file string /root/.ssh/id_rsa.pub SSH key to add to the Dokku user (Will be ignored on dpkg-reconfigure )","title":"debconf options"},{"location":"getting-started/install/digitalocean/","text":"Digital Ocean On Digital Ocean, there is a pre-made image that can be run for Dokku. You can choose to run this image on any sized droplet, though larger droplets will allow you to run larger applications. When choosing your Droplet configuration, please disable IPv6 on the droplet. There are known issues with IPv6 on Digital Ocean and Docker, and many have been reported to the Dokku issue tracker. If you would like to run Dokku on an IPv6 Digital Ocean Droplet, please consult this guide for modifying Docker to run under the Digital Ocean IPv6 configuration.","title":"Digital Ocean"},{"location":"getting-started/install/digitalocean/#digital-ocean","text":"On Digital Ocean, there is a pre-made image that can be run for Dokku. You can choose to run this image on any sized droplet, though larger droplets will allow you to run larger applications. When choosing your Droplet configuration, please disable IPv6 on the droplet. There are known issues with IPv6 on Digital Ocean and Docker, and many have been reported to the Dokku issue tracker. If you would like to run Dokku on an IPv6 Digital Ocean Droplet, please consult this guide for modifying Docker to run under the Digital Ocean IPv6 configuration.","title":"Digital Ocean"},{"location":"getting-started/install/linode/","text":"Installing on Linode When installing Dokku on a Linode server, you'll likely see an error during Docker installation: Warning: current kernel is not supported by the linux-image-extra-virtual package. We have no AUFS support. Consider installing the packages linux-image-virtual kernel and linux-image-extra-virtual for AUFS support. After 10 seconds, the installation will continue as normal. This warning is the result of Linode using its own kernel, which does not support AUFS, instead of using the kernel supplied by Ubuntu. If you ignore the warning, Docker will fall back to using the DeviceMapper storage backend and Dokku will work normally. However, AUFS is better tested and will perform better. If you would like to use AUFS, follow the steps below to install Ubuntu's kernel and configure your server to boot it instead of Linode's. Preparing your Linode for AUFS Warning : These steps will delete everything on your Linode. Open your server's dashboard in the Linode Manager . Make sure your Linode is using KVM , not Xen, for virtualization. In the \"Rebuild\" tab, select \"Ubuntu 14.04 LTS\", set a root password, and rebuild. Once your Linode has been created, click \"Boot\" and wait for it to complete. SSH into your Linode as root and run the following commands: apt-get update apt-get -qq upgrade apt-get -qq install linux-image-virtual linux-image-extra-virtual When prompted, install Grub onto the first hard drive. Back in your server's dashboard, click \"Edit\" on its Configuration Profile Change the \"Kernel\" option to \"GRUB 2\" and save your changes. Lastly, reboot the Linode. Once your server comes back online, you'll be running Ubuntu's default kernel. You can now follow Dokku's normal installation instructions and bootstrap.sh will take care of everything else.","title":"Installing on Linode"},{"location":"getting-started/install/linode/#installing-on-linode","text":"When installing Dokku on a Linode server, you'll likely see an error during Docker installation: Warning: current kernel is not supported by the linux-image-extra-virtual package. We have no AUFS support. Consider installing the packages linux-image-virtual kernel and linux-image-extra-virtual for AUFS support. After 10 seconds, the installation will continue as normal. This warning is the result of Linode using its own kernel, which does not support AUFS, instead of using the kernel supplied by Ubuntu. If you ignore the warning, Docker will fall back to using the DeviceMapper storage backend and Dokku will work normally. However, AUFS is better tested and will perform better. If you would like to use AUFS, follow the steps below to install Ubuntu's kernel and configure your server to boot it instead of Linode's.","title":"Installing on Linode"},{"location":"getting-started/install/linode/#preparing-your-linode-for-aufs","text":"Warning : These steps will delete everything on your Linode. Open your server's dashboard in the Linode Manager . Make sure your Linode is using KVM , not Xen, for virtualization. In the \"Rebuild\" tab, select \"Ubuntu 14.04 LTS\", set a root password, and rebuild. Once your Linode has been created, click \"Boot\" and wait for it to complete. SSH into your Linode as root and run the following commands: apt-get update apt-get -qq upgrade apt-get -qq install linux-image-virtual linux-image-extra-virtual When prompted, install Grub onto the first hard drive. Back in your server's dashboard, click \"Edit\" on its Configuration Profile Change the \"Kernel\" option to \"GRUB 2\" and save your changes. Lastly, reboot the Linode. Once your server comes back online, you'll be running Ubuntu's default kernel. You can now follow Dokku's normal installation instructions and bootstrap.sh will take care of everything else.","title":"Preparing your Linode for AUFS"},{"location":"getting-started/install/vagrant/","text":"Install Dokku using Vagrant Download and install VirtualBox Download and install Vagrant Clone Dokku git clone https://github.com/dokku/dokku.git Create VM # Optional ENV arguments: # - `BOX_NAME` # - `BOX_URI` # - `BOX_MEMORY` # - `DOKKU_DOMAIN` # - `DOKKU_IP` # - `FORWARDED_PORT`. cd path/to/dokku vagrant up Setup SSH Config in ~/.ssh/config . The port listed here is usually correct, though you may want to verify that it is the same as the one listed in the output of vagrant ssh-config dokku Host dokku.me Port 22 Copy your SSH key via cat ~/.ssh/id_rsa.pub | pbcopy and paste it into the dokku-installer at http://dokku.me . Change the Hostname field on the Dokku Setup screen to your domain and then check the box that says Use virtualhost naming . Then click Finish Setup to install your key. You'll be directed to application deployment instructions from here. Please note, the dokku.me domain is setup to point to 10.0.0.2 along with all subdomains (ie yourapp.dokku.me). If you change the DOKKU_IP in your vagrant setup you'll need to update your /etc/hosts file to point your reconfigured ip address. You are now ready to deploy an app or install plugins.","title":"Install Dokku using Vagrant"},{"location":"getting-started/install/vagrant/#install-dokku-using-vagrant","text":"Download and install VirtualBox Download and install Vagrant Clone Dokku git clone https://github.com/dokku/dokku.git Create VM # Optional ENV arguments: # - `BOX_NAME` # - `BOX_URI` # - `BOX_MEMORY` # - `DOKKU_DOMAIN` # - `DOKKU_IP` # - `FORWARDED_PORT`. cd path/to/dokku vagrant up Setup SSH Config in ~/.ssh/config . The port listed here is usually correct, though you may want to verify that it is the same as the one listed in the output of vagrant ssh-config dokku Host dokku.me Port 22 Copy your SSH key via cat ~/.ssh/id_rsa.pub | pbcopy and paste it into the dokku-installer at http://dokku.me . Change the Hostname field on the Dokku Setup screen to your domain and then check the box that says Use virtualhost naming . Then click Finish Setup to install your key. You'll be directed to application deployment instructions from here. Please note, the dokku.me domain is setup to point to 10.0.0.2 along with all subdomains (ie yourapp.dokku.me). If you change the DOKKU_IP in your vagrant setup you'll need to update your /etc/hosts file to point your reconfigured ip address. You are now ready to deploy an app or install plugins.","title":"Install Dokku using Vagrant"}]}