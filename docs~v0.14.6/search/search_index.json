{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"advanced-usage/backup-recovery/","text":"Backup and Recovery The backup plugin was deprecated in 0.4.x, below are backup recommendations for 0.5.x and later. Backup and Migration Tutorial Because Dokku is git based, rebuilding a deployed app is as easy as pushing from git. You can push to a new server by updating the dokku remote in you local app's repo. git remote rm dokku git remote add dokku dokku@ [ dokku.me:dokku.me ] git push dokku [ master ] Databases Some plugins, like the official dokku-postgres plugin, have built-in commands that allow non-volatile data be exported and imported. For dokku-postgres , use: dokku postgres:export [ db_name ] > [ db_name ] .dump dokku postgres:import [ db_name ] < [ db_name ] .dump Volumes and Static Assets Dokku doesn't enforce a 300mb limit on apps, but it's best practice to keep binary assets outside of git. Since containers are considered volatile in Dokku, external stores like s3 or storage mounts should be used for non-volatile items like user uploads. The Dokku storage core plugin can be used to mount local directories / volumes inside the docker container. See the persistent storage documentation for more details. Disaster Recovery The best plan for disaster recovery is to always keep multiple (remote) copies of your local repo, static assets and periodic database dumps. In case of an emergency when your git repo and backups are completely lost, you can recover the last pushed copy from your remote Dokku server (assuming you still have the ssh key). mkdir [ app-name ] ; cd !$ git init && git remote add dokku dokku@ [ dokku.me:app-name ] git pull dokku/master && git checkout dokku/master","title":"Backup and Recovery"},{"location":"advanced-usage/backup-recovery/#backup-and-recovery","text":"The backup plugin was deprecated in 0.4.x, below are backup recommendations for 0.5.x and later.","title":"Backup and Recovery"},{"location":"advanced-usage/backup-recovery/#backup-and-migration-tutorial","text":"Because Dokku is git based, rebuilding a deployed app is as easy as pushing from git. You can push to a new server by updating the dokku remote in you local app's repo. git remote rm dokku git remote add dokku dokku@ [ dokku.me:dokku.me ] git push dokku [ master ]","title":"Backup and Migration Tutorial"},{"location":"advanced-usage/backup-recovery/#databases","text":"Some plugins, like the official dokku-postgres plugin, have built-in commands that allow non-volatile data be exported and imported. For dokku-postgres , use: dokku postgres:export [ db_name ] > [ db_name ] .dump dokku postgres:import [ db_name ] < [ db_name ] .dump","title":"Databases"},{"location":"advanced-usage/backup-recovery/#volumes-and-static-assets","text":"Dokku doesn't enforce a 300mb limit on apps, but it's best practice to keep binary assets outside of git. Since containers are considered volatile in Dokku, external stores like s3 or storage mounts should be used for non-volatile items like user uploads. The Dokku storage core plugin can be used to mount local directories / volumes inside the docker container. See the persistent storage documentation for more details.","title":"Volumes and Static Assets"},{"location":"advanced-usage/backup-recovery/#disaster-recovery","text":"The best plan for disaster recovery is to always keep multiple (remote) copies of your local repo, static assets and periodic database dumps. In case of an emergency when your git repo and backups are completely lost, you can recover the last pushed copy from your remote Dokku server (assuming you still have the ssh key). mkdir [ app-name ] ; cd !$ git init && git remote add dokku dokku@ [ dokku.me:app-name ] git pull dokku/master && git checkout dokku/master","title":"Disaster Recovery"},{"location":"advanced-usage/deployment-tasks/","text":"Deployment Tasks New as of 0.5.0 Sometimes you need to run a command on at deployment time, but before an app is completely deployed. Common use cases include: Checking a database is initialized Running database migrations Any commands required to set up the server (e.g. something like a Django collectstatic ) To support this, Dokku provides support for a special release command within your app's Procfile , as well as a special scripts.dokku key inside of your app's app.json file. Be aware that all commands are run within the context of the built docker image - no commands affect the host unless there are volume mounts attached to your app. Each \"phase\" has different expectations and limitations: app.json : scripts.dokku.predeploy When to use: This should be used if your app does not support arbitrary build commands and you need to make changes to the built image. Are changes committed to the image at this phase: Yes Example use-cases Bundling assets in a slightly different way Installing a custom package from source or copying a binary into place app.json : scripts.dokku.postdeploy When to use: This should be used in conjunction with external systems to signal the completion of your deploy. Are changes committed to the image at this phase: No Example use-cases Notifying slack that your app is deployed Coordinating traffic routing with a central load balancer Procfile : release When to use: This should be used in conjunction with external systems to signal the completion of your app image build. Are changes committed to the image at this phase: No Example use-cases Sending CSS, JS, and other assets from your app\u2019s slug to a CDN or S3 bucket Priming or invalidating cache stores Running database migrations Please keep the above in mind when utilizing deployment tasks. To execute commands on the host during a release phase, see the plugin creation documentation docs for more information on building your own custom plugin. app.json deployment tasks Dokku provides limited support for the app.json manifest from Heroku (documentation available here ). The keys available for use with Deployment Tasks are: scripts.dokku.predeploy : This is run after an app's docker image is built, but before any containers are scheduled. Changes made to your image are committed at this phase. scripts.dokku.postdeploy : This is run after an app's containers are scheduled. Changes made to your image are not committed at this phase. For buildpack-based deployments, the location of the app.json file should be at the root of your repository. Dockerfile-based app deploys should have the app.json in the configured WORKDIR directory; otherwise Dokku defaults to the buildpack app behavior of looking in /app . Warning: Any failed app.json deployment task will fail the deploy. In the case of either phase, a failure will not affect any running containers. The following is an example app.json file. Please note that only the scripts.dokku.predeploy and scripts.dokku.postdeploy tasks are supported by Dokku at this time. All other fields will be ignored and can be omitted. { \"scripts\" : { \"dokku\" : { \"predeploy\" : \"touch /app/predeploy.test\" , \"postdeploy\" : \"curl https://some.external.api.service.com/deployment?state=success\" } } } Procfile Release command New as of 0.14.0 The Procfile also supports a special release command which acts in a similar way to the Heroku Release Phase . This command is executed after an app's docker image is built, but before any containers are scheduled. This is also run after any command executed by scripts.dokku.predeploy . To use the release command, simply add a release stanza to your Procfile. release : curl https : //some.external.api.service.com/deployment ? state = built Unlike the scripts.dokku.predeploy command, changes made during by the release command are not persisted to disk. Warning: scaling the release command up will likely result in unspecified issues within your deployment, and is highly discouraged.","title":"Deployment Tasks"},{"location":"advanced-usage/deployment-tasks/#deployment-tasks","text":"New as of 0.5.0 Sometimes you need to run a command on at deployment time, but before an app is completely deployed. Common use cases include: Checking a database is initialized Running database migrations Any commands required to set up the server (e.g. something like a Django collectstatic ) To support this, Dokku provides support for a special release command within your app's Procfile , as well as a special scripts.dokku key inside of your app's app.json file. Be aware that all commands are run within the context of the built docker image - no commands affect the host unless there are volume mounts attached to your app. Each \"phase\" has different expectations and limitations: app.json : scripts.dokku.predeploy When to use: This should be used if your app does not support arbitrary build commands and you need to make changes to the built image. Are changes committed to the image at this phase: Yes Example use-cases Bundling assets in a slightly different way Installing a custom package from source or copying a binary into place app.json : scripts.dokku.postdeploy When to use: This should be used in conjunction with external systems to signal the completion of your deploy. Are changes committed to the image at this phase: No Example use-cases Notifying slack that your app is deployed Coordinating traffic routing with a central load balancer Procfile : release When to use: This should be used in conjunction with external systems to signal the completion of your app image build. Are changes committed to the image at this phase: No Example use-cases Sending CSS, JS, and other assets from your app\u2019s slug to a CDN or S3 bucket Priming or invalidating cache stores Running database migrations Please keep the above in mind when utilizing deployment tasks. To execute commands on the host during a release phase, see the plugin creation documentation docs for more information on building your own custom plugin.","title":"Deployment Tasks"},{"location":"advanced-usage/deployment-tasks/#appjson-deployment-tasks","text":"Dokku provides limited support for the app.json manifest from Heroku (documentation available here ). The keys available for use with Deployment Tasks are: scripts.dokku.predeploy : This is run after an app's docker image is built, but before any containers are scheduled. Changes made to your image are committed at this phase. scripts.dokku.postdeploy : This is run after an app's containers are scheduled. Changes made to your image are not committed at this phase. For buildpack-based deployments, the location of the app.json file should be at the root of your repository. Dockerfile-based app deploys should have the app.json in the configured WORKDIR directory; otherwise Dokku defaults to the buildpack app behavior of looking in /app . Warning: Any failed app.json deployment task will fail the deploy. In the case of either phase, a failure will not affect any running containers. The following is an example app.json file. Please note that only the scripts.dokku.predeploy and scripts.dokku.postdeploy tasks are supported by Dokku at this time. All other fields will be ignored and can be omitted. { \"scripts\" : { \"dokku\" : { \"predeploy\" : \"touch /app/predeploy.test\" , \"postdeploy\" : \"curl https://some.external.api.service.com/deployment?state=success\" } } }","title":"app.json deployment tasks"},{"location":"advanced-usage/deployment-tasks/#procfile-release-command","text":"New as of 0.14.0 The Procfile also supports a special release command which acts in a similar way to the Heroku Release Phase . This command is executed after an app's docker image is built, but before any containers are scheduled. This is also run after any command executed by scripts.dokku.predeploy . To use the release command, simply add a release stanza to your Procfile. release : curl https : //some.external.api.service.com/deployment ? state = built Unlike the scripts.dokku.predeploy command, changes made during by the release command are not persisted to disk. Warning: scaling the release command up will likely result in unspecified issues within your deployment, and is highly discouraged.","title":"Procfile Release command"},{"location":"advanced-usage/docker-options/","text":"Docker Container Options New as of 0.3.17 Pass options to Docker during Dokku's build , deploy and run phases docker-options:add <app> <phase(s)> OPTION # Add Docker option to app for phase (comma-separated phase list) docker-options:remove <app> <phase(s)> OPTION # Remove Docker option from app for phase (comma-separated phase list) docker-options:report [<app>] [<flag>] # Displays a docker options report for one or more apps When specifying multiple phases, they must be comma-separated without spaces in between each phase, like so: dokku docker-options:add node-js-app deploy,run \"-v /var/log/node-js-app:/app/logs\" About Dokku phases Dokku deploys your application in multiple \"phases\" and the docker-options plugin allows you to pass arguments to their underlying docker container: build : the container that executes the appropriate buildpack deploy : the container that executes your running/deployed application run : the container that executes any arbitrary command via dokku run Examples Add Docker options Add some options for the deployed/running app and when executing dokku run : # Mount a host volume in a Docker container: \"-v /host/path:/container/path\" dokku docker-options:add node-js-app deploy \"-v /var/log/node-js-app:/app/logs\" dokku docker-options:add node-js-app run \"-v /var/log/node-js-app:/app/logs\" Note: When mounting a host directory in a Dokku app you should first create that directory as user dokku and then mount the directory under /app in the container using docker-options as above. Otherwise the app will lack write permission in the directory. Remove a Docker option dokku docker-options:remove node-js-app run \"-v /var/log/node-js-app:/app/logs\" Displaying docker-options reports about an app New as of 0.8.1 You can get a report about the app's docker-options status using the docker-options:report command: dokku docker-options:report =====> node-js-app docker options information Docker options build: Docker options deploy: -v /var/log/node-js-app:/app/logs Docker options run: -v /var/log/node-js-app:/app/logs =====> python-sample docker options information Docker options build: Docker options deploy: Docker options run: =====> ruby-sample docker options information Docker options build: Docker options deploy: Docker options run: You can run the command for a specific app also. dokku docker-options:report node-js-app =====> node-js-app docker options information Storage build mounts: Storage deploy mounts: -v /var/log/node-js-app:/app/logs Storage run mounts: -v /var/log/node-js-app:/app/logs You can pass flags which will output only the value of the specific information you want. For example: dokku docker-options:report node-js-app --docker-options-build Advanced usage In your applications folder /home/dokku/app_name create a file called DOCKER_OPTIONS_RUN (or DOCKER_OPTIONS_BUILD or DOCKER_OPTIONS_DEPLOY ). Inside this file list one Docker option per line. For example: --link container_name:alias -v /host/path:/container/path -v /another/container/path The above example will result in the following options being passed to Docker during dokku run : --link container_name:alias -v /host/path:/container/path -v /another/container/path You may also include comments (lines beginning with a #) and blank lines in the DOCKER_OPTIONS file. More information on Docker options can be found here: https://docs.docker.com/engine/reference/commandline/run/.","title":"Docker Container Options"},{"location":"advanced-usage/docker-options/#docker-container-options","text":"New as of 0.3.17 Pass options to Docker during Dokku's build , deploy and run phases docker-options:add <app> <phase(s)> OPTION # Add Docker option to app for phase (comma-separated phase list) docker-options:remove <app> <phase(s)> OPTION # Remove Docker option from app for phase (comma-separated phase list) docker-options:report [<app>] [<flag>] # Displays a docker options report for one or more apps When specifying multiple phases, they must be comma-separated without spaces in between each phase, like so: dokku docker-options:add node-js-app deploy,run \"-v /var/log/node-js-app:/app/logs\"","title":"Docker Container Options"},{"location":"advanced-usage/docker-options/#about-dokku-phases","text":"Dokku deploys your application in multiple \"phases\" and the docker-options plugin allows you to pass arguments to their underlying docker container: build : the container that executes the appropriate buildpack deploy : the container that executes your running/deployed application run : the container that executes any arbitrary command via dokku run","title":"About Dokku phases"},{"location":"advanced-usage/docker-options/#examples","text":"","title":"Examples"},{"location":"advanced-usage/docker-options/#add-docker-options","text":"Add some options for the deployed/running app and when executing dokku run : # Mount a host volume in a Docker container: \"-v /host/path:/container/path\" dokku docker-options:add node-js-app deploy \"-v /var/log/node-js-app:/app/logs\" dokku docker-options:add node-js-app run \"-v /var/log/node-js-app:/app/logs\" Note: When mounting a host directory in a Dokku app you should first create that directory as user dokku and then mount the directory under /app in the container using docker-options as above. Otherwise the app will lack write permission in the directory.","title":"Add Docker options"},{"location":"advanced-usage/docker-options/#remove-a-docker-option","text":"dokku docker-options:remove node-js-app run \"-v /var/log/node-js-app:/app/logs\"","title":"Remove a Docker option"},{"location":"advanced-usage/docker-options/#displaying-docker-options-reports-about-an-app","text":"New as of 0.8.1 You can get a report about the app's docker-options status using the docker-options:report command: dokku docker-options:report =====> node-js-app docker options information Docker options build: Docker options deploy: -v /var/log/node-js-app:/app/logs Docker options run: -v /var/log/node-js-app:/app/logs =====> python-sample docker options information Docker options build: Docker options deploy: Docker options run: =====> ruby-sample docker options information Docker options build: Docker options deploy: Docker options run: You can run the command for a specific app also. dokku docker-options:report node-js-app =====> node-js-app docker options information Storage build mounts: Storage deploy mounts: -v /var/log/node-js-app:/app/logs Storage run mounts: -v /var/log/node-js-app:/app/logs You can pass flags which will output only the value of the specific information you want. For example: dokku docker-options:report node-js-app --docker-options-build","title":"Displaying docker-options reports about an app"},{"location":"advanced-usage/docker-options/#advanced-usage","text":"In your applications folder /home/dokku/app_name create a file called DOCKER_OPTIONS_RUN (or DOCKER_OPTIONS_BUILD or DOCKER_OPTIONS_DEPLOY ). Inside this file list one Docker option per line. For example: --link container_name:alias -v /host/path:/container/path -v /another/container/path The above example will result in the following options being passed to Docker during dokku run : --link container_name:alias -v /host/path:/container/path -v /another/container/path You may also include comments (lines beginning with a #) and blank lines in the DOCKER_OPTIONS file. More information on Docker options can be found here: https://docs.docker.com/engine/reference/commandline/run/.","title":"Advanced usage"},{"location":"advanced-usage/event-logs/","text":"Dokku Event Logs New as of 0.3.21 Docker provides an events command to show system's real time events. Likewise, Dokku can record events as syslog entries and also provides a plugin to display the last ones. events [-t] # Show the last events (-t follows) events:list # List logged events events:on # Enable events logger events:off # Disable events logger Usage Enable the plugin: dokku events:on Enabling dokku events logger Dokku will then write log entries to /var/log/syslog as well as a Dokku-specific logs sub-directory /var/log/dokku/events.log , which can be easily displayed with the command dokku events : dokku events Jul 3 16:09:48 dokku.me dokku[127630]: INVOKED: pre-release-buildpack( pythonapp ) Jul 3 16:10:02 dokku.me dokku[128095]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:10:02 dokku.me dokku[128114]: INVOKED: docker-args-run( nhl ) Jul 3 16:10:03 dokku.me dokku[128136]: INVOKED: post-release-buildpack( pythonapp ) Jul 3 16:10:03 dokku.me dokku[128195]: INVOKED: pre-deploy( pythonapp ) Jul 3 16:10:23 dokku.me dokku[129253]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:24 dokku.me dokku[129451]: INVOKED: check-deploy( pythonapp 6274ced0d4be11af4490cd18abaf77cdd593f025133f403d984e80d86a39acec web 5000 10.0.16.80 ) Jul 3 16:10:35 dokku.me dokku[129561]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:36 dokku.me dokku[129760]: INVOKED: check-deploy( pythonapp ac88a56ee4161ff37e4b92d1498c3eadc91f0aa7c8b81b44fc077e2a51d54cc0 worker ) Jul 3 16:10:46 dokku.me dokku[129851]: INVOKED: post-deploy( pythonapp ) Jul 3 16:10:46 dokku.me dokku[129945]: INVOKED: nginx-pre-reload( pythonapp ) Jul 3 16:15:02 dokku.me dokku[130397]: INVOKED: docker-args-run( goapp ) Jul 3 16:21:02 dokku.me dokku[130796]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:30:02 dokku.me dokku[131384]: INVOKED: docker-args-run( rubyapp ) You can list all events that are currently being recorded via dokku events:list : dokku events:list =====> Events currently logged check-deploy dependencies docker-args-build docker-args-deploy docker-args-run git-post-pull git-pre-pull nginx-hostname nginx-pre-reload post-build-buildpack post-build-dockerfile post-delete post-deploy post-domains-update post-release-buildpack post-release-dockerfile pre-build-buildpack pre-build-dockerfile pre-delete pre-deploy pre-release-buildpack pre-release-dockerfile receive-app update","title":"Dokku Event Logs"},{"location":"advanced-usage/event-logs/#dokku-event-logs","text":"New as of 0.3.21 Docker provides an events command to show system's real time events. Likewise, Dokku can record events as syslog entries and also provides a plugin to display the last ones. events [-t] # Show the last events (-t follows) events:list # List logged events events:on # Enable events logger events:off # Disable events logger","title":"Dokku Event Logs"},{"location":"advanced-usage/event-logs/#usage","text":"Enable the plugin: dokku events:on Enabling dokku events logger Dokku will then write log entries to /var/log/syslog as well as a Dokku-specific logs sub-directory /var/log/dokku/events.log , which can be easily displayed with the command dokku events : dokku events Jul 3 16:09:48 dokku.me dokku[127630]: INVOKED: pre-release-buildpack( pythonapp ) Jul 3 16:10:02 dokku.me dokku[128095]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:10:02 dokku.me dokku[128114]: INVOKED: docker-args-run( nhl ) Jul 3 16:10:03 dokku.me dokku[128136]: INVOKED: post-release-buildpack( pythonapp ) Jul 3 16:10:03 dokku.me dokku[128195]: INVOKED: pre-deploy( pythonapp ) Jul 3 16:10:23 dokku.me dokku[129253]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:24 dokku.me dokku[129451]: INVOKED: check-deploy( pythonapp 6274ced0d4be11af4490cd18abaf77cdd593f025133f403d984e80d86a39acec web 5000 10.0.16.80 ) Jul 3 16:10:35 dokku.me dokku[129561]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:36 dokku.me dokku[129760]: INVOKED: check-deploy( pythonapp ac88a56ee4161ff37e4b92d1498c3eadc91f0aa7c8b81b44fc077e2a51d54cc0 worker ) Jul 3 16:10:46 dokku.me dokku[129851]: INVOKED: post-deploy( pythonapp ) Jul 3 16:10:46 dokku.me dokku[129945]: INVOKED: nginx-pre-reload( pythonapp ) Jul 3 16:15:02 dokku.me dokku[130397]: INVOKED: docker-args-run( goapp ) Jul 3 16:21:02 dokku.me dokku[130796]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:30:02 dokku.me dokku[131384]: INVOKED: docker-args-run( rubyapp ) You can list all events that are currently being recorded via dokku events:list : dokku events:list =====> Events currently logged check-deploy dependencies docker-args-build docker-args-deploy docker-args-run git-post-pull git-pre-pull nginx-hostname nginx-pre-reload post-build-buildpack post-build-dockerfile post-delete post-deploy post-domains-update post-release-buildpack post-release-dockerfile pre-build-buildpack pre-build-dockerfile pre-delete pre-deploy pre-release-buildpack pre-release-dockerfile receive-app update","title":"Usage"},{"location":"advanced-usage/persistent-storage/","text":"Persistent Storage New as of 0.5.0 The preferred method to mount external containers to a Dokku managed container, is to use the Dokku storage plugin. storage:list <app> # List bind mounts for app's container(s) (host:container) storage:mount <app> <host-dir:container-dir> # Create a new bind mount storage:report [<app>] [<flag>] # Displays a checks report for one or more apps storage:unmount <app> <host-dir:container-dir> # Remove an existing bind mount The storage plugin is compatible with storage mounts created with the docker-options. The storage plugin will only list mounts from the deploy/run phase. The storage plugin supports the following mount points: explicit paths that exist on the host docker volumes There are a few caveats to using the persistent storage plugin: Using implicit paths that do not exist are no longer supported, and actually deprecated in Docker 1.9.0 . When you specify a persistent storage mount, the host directory is not autocreated by either Dokku or Docker. We recommend using the directory /var/lib/dokku/data/storage directory as the root host path for mounts, and we create this on Dokku installation. Mounts are only available at run and deploy times, and you must redeploy (restart) an app to mount or unmount to an existing app's container. When a directory is mounted, any existing files within the container will be overwritten. If you are writing assets during the build process and then replace the directory with a mount, those files will no longer exist. This is a Docker limitation. Paths are mounted within the container at the root of the disk - / - and are not relative to /app (for buildpacks deploys) or the WORKDIR (for Dockerfile/Docker images). For applications using buildpack deploys, the host directory should be owned by the user and group id 32767 . This is due to how permissions within Herokuish - which builds the Docker images - works. For Dockerfile or Docker image deployments, please use the user and group id which corresponds to the one running the process within the container. Usage This example demonstrates how to mount the recommended directory to /storage inside an application called node-js-app : # we use a subdirectory inside of the host directory to scope it to just the app dokku storage:mount node-js-app /var/lib/dokku/data/storage/node-js-app:/storage Dokku will then mount the shared contents of /var/lib/dokku/data/storage to /storage inside the container. Once you have mounted persistent storage, you will also need to restart the application. See the process scaling documentation for more information. dokku ps:restart app-name A more complete workflow may require making a custom directory for your application and mounting it within your /app/storage directory instead. The mount point is not relative to your application's working directory, and is instead relative to the root of the container. # creating storage for the app 'node-js-app' mkdir -p /var/lib/dokku/data/storage/node-js-app # ensure the proper user has access to this directory chown -R dokku:dokku /var/lib/dokku/data/storage/node-js-app # as of 0.7.x, you should chown using the `32767` user and group id for buildpack deploys # For dockerfile deploys, substitute the user and group id in use within the image chown -R 32767 :32767 /var/lib/dokku/data/storage/node-js-app # mount the directory into your container's /app/storage directory, relative to root dokku storage:mount app-name /var/lib/dokku/data/storage/node-js-app:/app/storage You can mount one or more directories as desired by following the above pattern. Displaying storage reports about an app New as of 0.8.1 You can get a report about the app's storage status using the storage:report command: dokku storage:report =====> node-js-app storage information Storage build mounts: Storage deploy mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage Storage run mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage =====> python-sample storage information Storage build mounts: Storage deploy mounts: Storage run mounts: =====> ruby-sample storage information Storage build mounts: Storage deploy mounts: Storage run mounts: You can run the command for a specific app also. dokku storage:report node-js-app =====> node-js-app storage information Storage build mounts: Storage deploy mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage Storage run mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage You can pass flags which will output only the value of the specific information you want. For example: dokku storage:report node-js-app --storage-deploy-mounts Use Cases Persistent storage Dokku is powered by Docker containers, which recommends in their best practices that containers be treated as ephemeral. In order to manage persistent storage for web applications, like user uploads or large binary assets like images, a directory outside the container should be mounted. Shared storage between containers When scaling your app, you may require a common location to access shared assets between containers, a storage mount can be used in this situation. Shared storage across environments Your app may be used in a cluster that requires containers or resources not running on the same host access your data. Mounting a shared file service (like S3FS or EFS) inside your container will give you great flexibility. Backing up Your app may have services that are running in memory and need to be backed up locally (like a key store). Mount a non ephemeral storage mount will allow backups that are not lost when the app is shut down. Build phase By default, Dokku will only bind storage mounts during the deploy and run phases. Under certain conditions, one might want to bind a storage mount during the build phase. This can be accomplished by using the docker-options plugin directly. dokku docker-options:add node-js-app build \"-v /tmp/python-test:/opt/test\" You cannot use mounted volumes during the build phase of a Dockerfile deploy. This is because Docker does not support volumes when executing docker build . Note: This can cause data loss if you bind a mount under /app in buildpack apps as herokuish will attempt to remove the original app path during the build phase. Application User and Persistent Storage file ownership (buildpack apps only) New as of 0.7.1 By default, Dokku will execute your buildpack application processes as the herokuishuser user. You may override this by setting the DOKKU_APP_USER config variable. NOTE: this user must exist in your herokuish image. Additionally, the default docker-local scheduler that comes with Dokku will ensure your storage mounts are owned by either herokuishuser or the overridden value you have set in DOKKU_APP_USER . See the scheduler-docker-local documentation docs for more information.","title":"Persistent Storage"},{"location":"advanced-usage/persistent-storage/#persistent-storage","text":"New as of 0.5.0 The preferred method to mount external containers to a Dokku managed container, is to use the Dokku storage plugin. storage:list <app> # List bind mounts for app's container(s) (host:container) storage:mount <app> <host-dir:container-dir> # Create a new bind mount storage:report [<app>] [<flag>] # Displays a checks report for one or more apps storage:unmount <app> <host-dir:container-dir> # Remove an existing bind mount The storage plugin is compatible with storage mounts created with the docker-options. The storage plugin will only list mounts from the deploy/run phase. The storage plugin supports the following mount points: explicit paths that exist on the host docker volumes There are a few caveats to using the persistent storage plugin: Using implicit paths that do not exist are no longer supported, and actually deprecated in Docker 1.9.0 . When you specify a persistent storage mount, the host directory is not autocreated by either Dokku or Docker. We recommend using the directory /var/lib/dokku/data/storage directory as the root host path for mounts, and we create this on Dokku installation. Mounts are only available at run and deploy times, and you must redeploy (restart) an app to mount or unmount to an existing app's container. When a directory is mounted, any existing files within the container will be overwritten. If you are writing assets during the build process and then replace the directory with a mount, those files will no longer exist. This is a Docker limitation. Paths are mounted within the container at the root of the disk - / - and are not relative to /app (for buildpacks deploys) or the WORKDIR (for Dockerfile/Docker images). For applications using buildpack deploys, the host directory should be owned by the user and group id 32767 . This is due to how permissions within Herokuish - which builds the Docker images - works. For Dockerfile or Docker image deployments, please use the user and group id which corresponds to the one running the process within the container.","title":"Persistent Storage"},{"location":"advanced-usage/persistent-storage/#usage","text":"This example demonstrates how to mount the recommended directory to /storage inside an application called node-js-app : # we use a subdirectory inside of the host directory to scope it to just the app dokku storage:mount node-js-app /var/lib/dokku/data/storage/node-js-app:/storage Dokku will then mount the shared contents of /var/lib/dokku/data/storage to /storage inside the container. Once you have mounted persistent storage, you will also need to restart the application. See the process scaling documentation for more information. dokku ps:restart app-name A more complete workflow may require making a custom directory for your application and mounting it within your /app/storage directory instead. The mount point is not relative to your application's working directory, and is instead relative to the root of the container. # creating storage for the app 'node-js-app' mkdir -p /var/lib/dokku/data/storage/node-js-app # ensure the proper user has access to this directory chown -R dokku:dokku /var/lib/dokku/data/storage/node-js-app # as of 0.7.x, you should chown using the `32767` user and group id for buildpack deploys # For dockerfile deploys, substitute the user and group id in use within the image chown -R 32767 :32767 /var/lib/dokku/data/storage/node-js-app # mount the directory into your container's /app/storage directory, relative to root dokku storage:mount app-name /var/lib/dokku/data/storage/node-js-app:/app/storage You can mount one or more directories as desired by following the above pattern.","title":"Usage"},{"location":"advanced-usage/persistent-storage/#displaying-storage-reports-about-an-app","text":"New as of 0.8.1 You can get a report about the app's storage status using the storage:report command: dokku storage:report =====> node-js-app storage information Storage build mounts: Storage deploy mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage Storage run mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage =====> python-sample storage information Storage build mounts: Storage deploy mounts: Storage run mounts: =====> ruby-sample storage information Storage build mounts: Storage deploy mounts: Storage run mounts: You can run the command for a specific app also. dokku storage:report node-js-app =====> node-js-app storage information Storage build mounts: Storage deploy mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage Storage run mounts: -v /var/lib/dokku/data/storage/node-js-app:/app/storage You can pass flags which will output only the value of the specific information you want. For example: dokku storage:report node-js-app --storage-deploy-mounts","title":"Displaying storage reports about an app"},{"location":"advanced-usage/persistent-storage/#use-cases","text":"","title":"Use Cases"},{"location":"advanced-usage/persistent-storage/#persistent-storage_1","text":"Dokku is powered by Docker containers, which recommends in their best practices that containers be treated as ephemeral. In order to manage persistent storage for web applications, like user uploads or large binary assets like images, a directory outside the container should be mounted.","title":"Persistent storage"},{"location":"advanced-usage/persistent-storage/#shared-storage-between-containers","text":"When scaling your app, you may require a common location to access shared assets between containers, a storage mount can be used in this situation.","title":"Shared storage between containers"},{"location":"advanced-usage/persistent-storage/#shared-storage-across-environments","text":"Your app may be used in a cluster that requires containers or resources not running on the same host access your data. Mounting a shared file service (like S3FS or EFS) inside your container will give you great flexibility.","title":"Shared storage across environments"},{"location":"advanced-usage/persistent-storage/#backing-up","text":"Your app may have services that are running in memory and need to be backed up locally (like a key store). Mount a non ephemeral storage mount will allow backups that are not lost when the app is shut down.","title":"Backing up"},{"location":"advanced-usage/persistent-storage/#build-phase","text":"By default, Dokku will only bind storage mounts during the deploy and run phases. Under certain conditions, one might want to bind a storage mount during the build phase. This can be accomplished by using the docker-options plugin directly. dokku docker-options:add node-js-app build \"-v /tmp/python-test:/opt/test\" You cannot use mounted volumes during the build phase of a Dockerfile deploy. This is because Docker does not support volumes when executing docker build . Note: This can cause data loss if you bind a mount under /app in buildpack apps as herokuish will attempt to remove the original app path during the build phase.","title":"Build phase"},{"location":"advanced-usage/persistent-storage/#application-user-and-persistent-storage-file-ownership-buildpack-apps-only","text":"New as of 0.7.1 By default, Dokku will execute your buildpack application processes as the herokuishuser user. You may override this by setting the DOKKU_APP_USER config variable. NOTE: this user must exist in your herokuish image. Additionally, the default docker-local scheduler that comes with Dokku will ensure your storage mounts are owned by either herokuishuser or the overridden value you have set in DOKKU_APP_USER . See the scheduler-docker-local documentation docs for more information.","title":"Application User and Persistent Storage file ownership (buildpack apps only)"},{"location":"advanced-usage/plugin-management/","text":"Plugin Management New as of 0.4.0 plugin:disable <name> # Disable an installed plugin (third-party only) plugin:enable <name> # Enable a previously disabled plugin plugin:install [--core|git-url [--committish tag|branch|commit|--name custom-plugin-name]] # Optionally download git-url (with custom tag/committish) & run install trigger for active plugins (or only core ones) plugin:install-dependencies [--core] # Run install-dependencies trigger for active plugins (or only core ones) plugin:list # Print active plugins plugin:uninstall <name> # Uninstall a plugin (third-party only) plugin:update [name [committish]] # Optionally update named plugin from git (with custom tag/committish) & run update trigger for active plugins # for 0.3.x cd /var/lib/dokku/plugins git clone <git url> dokku plugins-install These commands require root permissions as the install and install-dependencies plugin triggers may utilize commands such as apt-get . For non-core plugins, please inspect those plugins before running the following command as root user. Usage You can list all installed plugins using the plugin command: dokku plugin plugn: dev 00_dokku-standard 0.14.6 enabled dokku core standard plugin 20_events 0.14.6 enabled dokku core events logging plugin apps 0.14.6 enabled dokku core apps plugin build-env 0.14.6 enabled dokku core build-env plugin certs 0.14.6 enabled dokku core certificate management plugin checks 0.14.6 enabled dokku core checks plugin common 0.14.6 enabled dokku core common plugin config 0.14.6 enabled dokku core config plugin docker-options 0.14.6 enabled dokku core docker-options plugin domains 0.14.6 enabled dokku core domains plugin enter 0.14.6 enabled dokku core enter plugin git 0.14.6 enabled dokku core git plugin logs 0.14.6 enabled dokku core logs plugin named-containers 0.14.6 enabled dokku core named containers plugin network 0.14.6 enabled dokku core network plugin nginx-vhosts 0.14.6 enabled dokku core nginx-vhosts plugin plugin 0.14.6 enabled dokku core plugin plugin proxy 0.14.6 enabled dokku core proxy plugin ps 0.14.6 enabled dokku core ps plugin repo 0.14.6 enabled dokku core repo plugin shell 0.14.6 enabled dokku core shell plugin ssh-keys 0.14.6 enabled dokku core ssh-keys plugin storage 0.14.6 enabled dokku core storage plugin tags 0.14.6 enabled dokku core tags plugin tar 0.14.6 enabled dokku core tar plugin Installing a plugin is easy as well using the plugin:install command. This command will also trigger the install pluginhook on all existing plugins. dokku plugin:install https://github.com/dokku/dokku-postgres.git -----> Cloning plugin repo https://github.com/dokku/dokku-postgres.git to /var/lib/dokku/plugins/available/postgres Cloning into 'postgres'... remote: Counting objects: 646, done. remote: Total 646 (delta 0), reused 0 (delta 0), pack-reused 646 Receiving objects: 100% (646/646), 134.24 KiB | 0 bytes/s, done. Resolving deltas: 100% (406/406), done. Checking connectivity... done. -----> Plugin postgres enabled You can also uninstall a third-party plugin using the plugin:uninstall command: dokku plugin:uninstall postgres -----> Plugin postgres uninstalled Enabling or disabling a plugin can also be useful in cases where you are debugging whether a third-party plugin is causing issues in your Dokku installation: dokku plugin:disable postgres -----> Plugin postgres disabled dokku plugin:enable postgres -----> Plugin postgres enabled Finally, you can update an installed third-party plugin. This should be done after any upgrades of Dokku as there may be changes in the internal api that require an update of how the plugin interfaces with Dokku. dokku plugin:update postgres Plugin (postgres) updated","title":"Plugin Management"},{"location":"advanced-usage/plugin-management/#plugin-management","text":"New as of 0.4.0 plugin:disable <name> # Disable an installed plugin (third-party only) plugin:enable <name> # Enable a previously disabled plugin plugin:install [--core|git-url [--committish tag|branch|commit|--name custom-plugin-name]] # Optionally download git-url (with custom tag/committish) & run install trigger for active plugins (or only core ones) plugin:install-dependencies [--core] # Run install-dependencies trigger for active plugins (or only core ones) plugin:list # Print active plugins plugin:uninstall <name> # Uninstall a plugin (third-party only) plugin:update [name [committish]] # Optionally update named plugin from git (with custom tag/committish) & run update trigger for active plugins # for 0.3.x cd /var/lib/dokku/plugins git clone <git url> dokku plugins-install These commands require root permissions as the install and install-dependencies plugin triggers may utilize commands such as apt-get . For non-core plugins, please inspect those plugins before running the following command as root user.","title":"Plugin Management"},{"location":"advanced-usage/plugin-management/#usage","text":"You can list all installed plugins using the plugin command: dokku plugin plugn: dev 00_dokku-standard 0.14.6 enabled dokku core standard plugin 20_events 0.14.6 enabled dokku core events logging plugin apps 0.14.6 enabled dokku core apps plugin build-env 0.14.6 enabled dokku core build-env plugin certs 0.14.6 enabled dokku core certificate management plugin checks 0.14.6 enabled dokku core checks plugin common 0.14.6 enabled dokku core common plugin config 0.14.6 enabled dokku core config plugin docker-options 0.14.6 enabled dokku core docker-options plugin domains 0.14.6 enabled dokku core domains plugin enter 0.14.6 enabled dokku core enter plugin git 0.14.6 enabled dokku core git plugin logs 0.14.6 enabled dokku core logs plugin named-containers 0.14.6 enabled dokku core named containers plugin network 0.14.6 enabled dokku core network plugin nginx-vhosts 0.14.6 enabled dokku core nginx-vhosts plugin plugin 0.14.6 enabled dokku core plugin plugin proxy 0.14.6 enabled dokku core proxy plugin ps 0.14.6 enabled dokku core ps plugin repo 0.14.6 enabled dokku core repo plugin shell 0.14.6 enabled dokku core shell plugin ssh-keys 0.14.6 enabled dokku core ssh-keys plugin storage 0.14.6 enabled dokku core storage plugin tags 0.14.6 enabled dokku core tags plugin tar 0.14.6 enabled dokku core tar plugin Installing a plugin is easy as well using the plugin:install command. This command will also trigger the install pluginhook on all existing plugins. dokku plugin:install https://github.com/dokku/dokku-postgres.git -----> Cloning plugin repo https://github.com/dokku/dokku-postgres.git to /var/lib/dokku/plugins/available/postgres Cloning into 'postgres'... remote: Counting objects: 646, done. remote: Total 646 (delta 0), reused 0 (delta 0), pack-reused 646 Receiving objects: 100% (646/646), 134.24 KiB | 0 bytes/s, done. Resolving deltas: 100% (406/406), done. Checking connectivity... done. -----> Plugin postgres enabled You can also uninstall a third-party plugin using the plugin:uninstall command: dokku plugin:uninstall postgres -----> Plugin postgres uninstalled Enabling or disabling a plugin can also be useful in cases where you are debugging whether a third-party plugin is causing issues in your Dokku installation: dokku plugin:disable postgres -----> Plugin postgres disabled dokku plugin:enable postgres -----> Plugin postgres enabled Finally, you can update an installed third-party plugin. This should be done after any upgrades of Dokku as there may be changes in the internal api that require an update of how the plugin interfaces with Dokku. dokku plugin:update postgres Plugin (postgres) updated","title":"Usage"},{"location":"advanced-usage/repository-management/","text":"Repository Management New as of 0.6.0 repo:gc <app> # Runs 'git gc --aggressive' against the application's repo repo:purge-cache <app> # Deletes the contents of the build cache stored in the repository The repository plugin is meant to allow users to perform management commands against a repository. Usage Git Garbage Collection This will run a git gc --aggressive against the applications repo. This is performed on the Dokku host, and not within an application container. dokku repo:gc node-js-app Counting objects: 396, done. Delta compression using up to 2 threads. Compressing objects: 100% (365/365), done. Writing objects: 100% (396/396), done. Total 396 (delta 79), reused 315 (delta 0) Clearing Application cache Building containers with buildpacks currently results in a persistent cache directory between deploys. If you need to clear this cache directory for any reason, you may do so by running the following shell command: dokku repo:purge-cache node-js-app","title":"Repository Management"},{"location":"advanced-usage/repository-management/#repository-management","text":"New as of 0.6.0 repo:gc <app> # Runs 'git gc --aggressive' against the application's repo repo:purge-cache <app> # Deletes the contents of the build cache stored in the repository The repository plugin is meant to allow users to perform management commands against a repository.","title":"Repository Management"},{"location":"advanced-usage/repository-management/#usage","text":"","title":"Usage"},{"location":"advanced-usage/repository-management/#git-garbage-collection","text":"This will run a git gc --aggressive against the applications repo. This is performed on the Dokku host, and not within an application container. dokku repo:gc node-js-app Counting objects: 396, done. Delta compression using up to 2 threads. Compressing objects: 100% (365/365), done. Writing objects: 100% (396/396), done. Total 396 (delta 79), reused 315 (delta 0)","title":"Git Garbage Collection"},{"location":"advanced-usage/repository-management/#clearing-application-cache","text":"Building containers with buildpacks currently results in a persistent cache directory between deploys. If you need to clear this cache directory for any reason, you may do so by running the following shell command: dokku repo:purge-cache node-js-app","title":"Clearing Application cache"},{"location":"advanced-usage/schedulers/docker-local/","text":"Docker Local Scheduler Subcommands new as of 0.12.12 scheduler-docker-local:report [<app>] [<flag>] # Displays a scheduler-docker-local report for one or more apps scheduler-docker-local:set <app> <key> (<value>) # Set or clear a scheduler-docker-local property for an app New as of 0.12.0 Dokku natively includes functionality to manage application lifecycles for a single server using the scheduler-docker-local plugin. It is the default scheduler, but as with all schedulers, it is set on a per-application basis. The scheduler can currently be overridden by running the following command: dokku config:set node-js-app DOCKER_SCHEDULER = docker-local As it is the default, unsetting the DOCKER_SCHEDULER config variable is also a valid way to reset the scheduler. dokku config:unset node-js-app DOCKER_SCHEDULER Usage Disabling chown of persistent storage The scheduler-docker-local plugin will ensure your storage mounts are owned by either herokuishuser or the overridden value you have set in DOKKU_APP_USER . You may disable this by running the following scheduler-docker-local:set command for your application: dokku scheduler-docker-local:set node-js-app disable-chown true Once set, you may re-enable it by setting a blank value for disable-chown : dokku scheduler-docker-local:set node-js-app disable-chown Implemented Triggers This plugin implements various functionality through plugn triggers to integrate with Docker for running apps on a single server. The following functionality is supported by the scheduler-docker-local plugin. check-deploy core-post-deploy post-delete pre-deploy pre-restore scheduler-deploy scheduler-docker-cleanup scheduler-logs-failed scheduler-run scheduler-stop scheduler-tags-create scheduler-tags-destroy","title":"Docker Local Scheduler"},{"location":"advanced-usage/schedulers/docker-local/#docker-local-scheduler","text":"Subcommands new as of 0.12.12 scheduler-docker-local:report [<app>] [<flag>] # Displays a scheduler-docker-local report for one or more apps scheduler-docker-local:set <app> <key> (<value>) # Set or clear a scheduler-docker-local property for an app New as of 0.12.0 Dokku natively includes functionality to manage application lifecycles for a single server using the scheduler-docker-local plugin. It is the default scheduler, but as with all schedulers, it is set on a per-application basis. The scheduler can currently be overridden by running the following command: dokku config:set node-js-app DOCKER_SCHEDULER = docker-local As it is the default, unsetting the DOCKER_SCHEDULER config variable is also a valid way to reset the scheduler. dokku config:unset node-js-app DOCKER_SCHEDULER","title":"Docker Local Scheduler"},{"location":"advanced-usage/schedulers/docker-local/#usage","text":"","title":"Usage"},{"location":"advanced-usage/schedulers/docker-local/#disabling-chown-of-persistent-storage","text":"The scheduler-docker-local plugin will ensure your storage mounts are owned by either herokuishuser or the overridden value you have set in DOKKU_APP_USER . You may disable this by running the following scheduler-docker-local:set command for your application: dokku scheduler-docker-local:set node-js-app disable-chown true Once set, you may re-enable it by setting a blank value for disable-chown : dokku scheduler-docker-local:set node-js-app disable-chown","title":"Disabling chown of persistent storage"},{"location":"advanced-usage/schedulers/docker-local/#implemented-triggers","text":"This plugin implements various functionality through plugn triggers to integrate with Docker for running apps on a single server. The following functionality is supported by the scheduler-docker-local plugin. check-deploy core-post-deploy post-delete pre-deploy pre-restore scheduler-deploy scheduler-docker-cleanup scheduler-logs-failed scheduler-run scheduler-stop scheduler-tags-create scheduler-tags-destroy","title":"Implemented Triggers"},{"location":"appendices/0.10.0-migration-guide/","text":"0.10.0 Migration Guide PCI Compliance By default, Dokku will ship a PCI Compliant nginx configuration. For developers whose users are on older browsers or mobile devices, you may need to ship a custom nginx.conf.sigil to enable ciphers for older browsers. See the nginx customization docs for more details. Nginx Error Pages We now ship with nicer error pages by default. You are free to customize your Dokku installation via a custom nginx.conf.sigil to change what error pages are displayed in different circumstances. See the nginx customization docs for more details.","title":"0.10.0 Migration Guide"},{"location":"appendices/0.10.0-migration-guide/#0100-migration-guide","text":"","title":"0.10.0 Migration Guide"},{"location":"appendices/0.10.0-migration-guide/#pci-compliance","text":"By default, Dokku will ship a PCI Compliant nginx configuration. For developers whose users are on older browsers or mobile devices, you may need to ship a custom nginx.conf.sigil to enable ciphers for older browsers. See the nginx customization docs for more details.","title":"PCI Compliance"},{"location":"appendices/0.10.0-migration-guide/#nginx-error-pages","text":"We now ship with nicer error pages by default. You are free to customize your Dokku installation via a custom nginx.conf.sigil to change what error pages are displayed in different circumstances. See the nginx customization docs for more details.","title":"Nginx Error Pages"},{"location":"appendices/0.5.0-migration-guide/","text":"0.5.0 Migration Guide nginx-vhosts plugin The nginx-vhosts template language is now sigil No need to escape literal $ characters (or other \"bash-isms\") Template variables are represented as {{ .VARIABLE_NAME }} A detailed list of template variables can be found here A custom nginx-vhosts template must be named nginx.conf.sigil The default path for this custom template is the root of your repo (i.e. /app in the container or WORKDIR if defined in a dockerfile app) Dokku no longer looks for this file in /home/dokku/node-js-app on the Dokku server Check out an example template here Support for server-wide SSL certs have been dropped in favor of using the certs plugin dokku certs:add node-js-app < certs.tar All domains for an SSL-enabled app will be redirected to https by default This can be overridden with a custom template Replaced \"magic\" NO_VHOST variable with domains:enable/disable Simplified zero downtime control checks:enable/disable Dockerfile apps with exposed ports Dockerfiles with EXPOSE clauses will get all tcp ports proxied by default Note that nginx will proxy the same port numbers to listen publicly UDP ports can be exposed by disabling the nginx proxy with dokku proxy:disable node-js-app","title":"0.5.0 Migration Guide"},{"location":"appendices/0.5.0-migration-guide/#050-migration-guide","text":"","title":"0.5.0 Migration Guide"},{"location":"appendices/0.5.0-migration-guide/#nginx-vhosts-plugin","text":"The nginx-vhosts template language is now sigil No need to escape literal $ characters (or other \"bash-isms\") Template variables are represented as {{ .VARIABLE_NAME }} A detailed list of template variables can be found here A custom nginx-vhosts template must be named nginx.conf.sigil The default path for this custom template is the root of your repo (i.e. /app in the container or WORKDIR if defined in a dockerfile app) Dokku no longer looks for this file in /home/dokku/node-js-app on the Dokku server Check out an example template here Support for server-wide SSL certs have been dropped in favor of using the certs plugin dokku certs:add node-js-app < certs.tar All domains for an SSL-enabled app will be redirected to https by default This can be overridden with a custom template Replaced \"magic\" NO_VHOST variable with domains:enable/disable Simplified zero downtime control checks:enable/disable","title":"nginx-vhosts plugin"},{"location":"appendices/0.5.0-migration-guide/#dockerfile-apps-with-exposed-ports","text":"Dockerfiles with EXPOSE clauses will get all tcp ports proxied by default Note that nginx will proxy the same port numbers to listen publicly UDP ports can be exposed by disabling the nginx proxy with dokku proxy:disable node-js-app","title":"Dockerfile apps with exposed ports"},{"location":"appendices/0.6.0-migration-guide/","text":"0.6.0 Migration Guide Zero-downtime deployment You can now actually disable zero-downtime deployments per-app and per-process-type Some config variables have been moved around DOKKU_CHECKS_ENABLED has been migrated to DOKKU_CHECKS_SKIPPED DOKKU_CHECKS_DISABLED is now a thing The values for the above can be a comma-separated list of process-types or the literal string _all_ See the updated checks docs for more info Proxy port mapping You can now configure host -> container proxy port mappings The UI is handled by the proxy interface plugin by setting the DOKKU_PROXY_PORT_MAP config variable in the format of scheme:host-port:container-port . The default nginx-vhosts proxy plugin supports both the http and https schemes. Default port mappings buildpack apps will be set to http:80:5000 and will also include https:443:5000 if SSL is enabled. dockerfile apps with explicitly exposed ports (i.e. using the EXPOSE directive) will be configured with a listener on each exposed port that proxies to the same port of the deployed application container. You may override this behavior with the proxy:ports-* commands or by directly setting DOKKU_PROXY_PORT_MAP with the config:set command dockerfile apps without explicitly exposed ports will behave the same as a buildpack app NOTE: These defaults are not automatically changed on subsequent pushes and must be manipulated with the aforementioned commands Calling the dokku binary Plugins should not call the dokku binary directly. Clients using the --app argument are potentially broken, amongst others, when doing so. Instead, please source the functions file for a given plugin when attempting to call Dokku internal functions. As a result, the following Dokku commands are no longer publicly exposed: dokku build dokku receive dokku release dokku tar:build dokku tar:build-locked dokku git:build dokku git:build-locked","title":"0.6.0 Migration Guide"},{"location":"appendices/0.6.0-migration-guide/#060-migration-guide","text":"","title":"0.6.0 Migration Guide"},{"location":"appendices/0.6.0-migration-guide/#zero-downtime-deployment","text":"You can now actually disable zero-downtime deployments per-app and per-process-type Some config variables have been moved around DOKKU_CHECKS_ENABLED has been migrated to DOKKU_CHECKS_SKIPPED DOKKU_CHECKS_DISABLED is now a thing The values for the above can be a comma-separated list of process-types or the literal string _all_ See the updated checks docs for more info","title":"Zero-downtime deployment"},{"location":"appendices/0.6.0-migration-guide/#proxy-port-mapping","text":"You can now configure host -> container proxy port mappings The UI is handled by the proxy interface plugin by setting the DOKKU_PROXY_PORT_MAP config variable in the format of scheme:host-port:container-port . The default nginx-vhosts proxy plugin supports both the http and https schemes. Default port mappings buildpack apps will be set to http:80:5000 and will also include https:443:5000 if SSL is enabled. dockerfile apps with explicitly exposed ports (i.e. using the EXPOSE directive) will be configured with a listener on each exposed port that proxies to the same port of the deployed application container. You may override this behavior with the proxy:ports-* commands or by directly setting DOKKU_PROXY_PORT_MAP with the config:set command dockerfile apps without explicitly exposed ports will behave the same as a buildpack app NOTE: These defaults are not automatically changed on subsequent pushes and must be manipulated with the aforementioned commands","title":"Proxy port mapping"},{"location":"appendices/0.6.0-migration-guide/#calling-the-dokku-binary","text":"Plugins should not call the dokku binary directly. Clients using the --app argument are potentially broken, amongst others, when doing so. Instead, please source the functions file for a given plugin when attempting to call Dokku internal functions. As a result, the following Dokku commands are no longer publicly exposed: dokku build dokku receive dokku release dokku tar:build dokku tar:build-locked dokku git:build dokku git:build-locked","title":"Calling the dokku binary"},{"location":"appendices/0.7.0-migration-guide/","text":"0.7.0 Migration Guide Persistent Storage We should now properly handle file ownership for mounted directories. This was enhanced in 0.7.1. See the persistent storage documentation for more details. Restart Policies If you previously managed container restart policies via docker-options, these can now be managed natively via the built-in ps plugin. There is no migration necessary. See the restart policy documentation for more details. SSH Keys Dokku now has an ssh-keys plugin that can be used to manage ssh keys for the dokku user on the host operating system. See the user management documentation for more details.","title":"0.7.0 Migration Guide"},{"location":"appendices/0.7.0-migration-guide/#070-migration-guide","text":"","title":"0.7.0 Migration Guide"},{"location":"appendices/0.7.0-migration-guide/#persistent-storage","text":"We should now properly handle file ownership for mounted directories. This was enhanced in 0.7.1. See the persistent storage documentation for more details.","title":"Persistent Storage"},{"location":"appendices/0.7.0-migration-guide/#restart-policies","text":"If you previously managed container restart policies via docker-options, these can now be managed natively via the built-in ps plugin. There is no migration necessary. See the restart policy documentation for more details.","title":"Restart Policies"},{"location":"appendices/0.7.0-migration-guide/#ssh-keys","text":"Dokku now has an ssh-keys plugin that can be used to manage ssh keys for the dokku user on the host operating system. See the user management documentation for more details.","title":"SSH Keys"},{"location":"appendices/0.8.0-migration-guide/","text":"0.8.0 Migration Guide Domain Management You can now set global and app domains via domains:set and domains:set-global . See the domains documentation for more details. Plugin Uninstallation A new uninstall plugin trigger was introduced. This functionality may be in use for newer plugins, so be aware that older Dokku versions may require manual cleanup. See the uninstall trigger documentation for implementation instructions. Deployment Tasks Should a pre or post deployment task fail, we now fail the entire deploy. Nginx HTTP2 Support Due to bugs in Nginx, the minimum version for HTTP2 is now 1.11.5.","title":"0.8.0 Migration Guide"},{"location":"appendices/0.8.0-migration-guide/#080-migration-guide","text":"","title":"0.8.0 Migration Guide"},{"location":"appendices/0.8.0-migration-guide/#domain-management","text":"You can now set global and app domains via domains:set and domains:set-global . See the domains documentation for more details.","title":"Domain Management"},{"location":"appendices/0.8.0-migration-guide/#plugin-uninstallation","text":"A new uninstall plugin trigger was introduced. This functionality may be in use for newer plugins, so be aware that older Dokku versions may require manual cleanup. See the uninstall trigger documentation for implementation instructions.","title":"Plugin Uninstallation"},{"location":"appendices/0.8.0-migration-guide/#deployment-tasks","text":"Should a pre or post deployment task fail, we now fail the entire deploy.","title":"Deployment Tasks"},{"location":"appendices/0.8.0-migration-guide/#nginx-http2-support","text":"Due to bugs in Nginx, the minimum version for HTTP2 is now 1.11.5.","title":"Nginx HTTP2 Support"},{"location":"appendices/0.9.0-migration-guide/","text":"0.9.0 Migration Guide Golang Migration There is an ongoing migration to rewrite Dokku in Golang. The reasons are beyond the scope of this document, but this may impact any patches you have for Dokku. As of 0.9.0, only the repo plugin is in Golang. The following shall remain true, regardless of the state of our rewrite: You will be able to write custom plugins in any language. You will be able to enable or disable core plugins. plugn will continue to be used for executing plugin triggers. We will provide bash wrappers that can be sourced to execute core functionality that is implemented in golang.","title":"0.9.0 Migration Guide"},{"location":"appendices/0.9.0-migration-guide/#090-migration-guide","text":"","title":"0.9.0 Migration Guide"},{"location":"appendices/0.9.0-migration-guide/#golang-migration","text":"There is an ongoing migration to rewrite Dokku in Golang. The reasons are beyond the scope of this document, but this may impact any patches you have for Dokku. As of 0.9.0, only the repo plugin is in Golang. The following shall remain true, regardless of the state of our rewrite: You will be able to write custom plugins in any language. You will be able to enable or disable core plugins. plugn will continue to be used for executing plugin triggers. We will provide bash wrappers that can be sourced to execute core functionality that is implemented in golang.","title":"Golang Migration"},{"location":"community/clients/","text":"Clients Given the constraints, running Dokku commands remotely via SSH is fine. For certain configurations, the extra complication of manually invoking ssh can be a burden. While Dokku does not yet have an official client, there are a multitude of ways in which you can interact with your Dokku installation. The easiest is to use the bash client, though you may wish to use another. (bash, zsh, etc.) dokku_client.sh Of all methods, this is the most official method of interacting with your Dokku installation. It is a bash script that interacts with a remote Dokku installation via ssh. It is available in contrib/dokku_client.sh in the root of the Dokku repository. To install, simply clone the Dokku repository down and add the dokku alias pointing at the script: git clone git@github.com:dokku/dokku.git ~/.dokku # optional: make sure that the dokku_client.sh version matches your Dokku version cd ~/.dokku git checkout <tag/branch> # add the following to either your # .bashrc, .bash_profile, or .profile file alias dokku = '$HOME/.dokku/contrib/dokku_client.sh' Alternatively, if using another shell such as zsh , create an alias command which invokes the script using bash : # zsh: add the following to either .zshenv or .zshrc alias dokku = 'bash $HOME/.dokku/contrib/dokku_client.sh' # fish: add the following to ~/.config/fish/config.fish alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' # csh: add the following to .cshrc alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' Configure the DOKKU_HOST environment variable or run dokku from a repository with a git remote named dokku pointed at your Dokku host in order to use the script as normal. You can also configure a DOKKU_PORT environment variable if you are running ssh on a non-standard port. This defaults to 22 . (nodejs) dokku-toolbelt Dokku-toolbelt is a node-based cli wrapper that proxies requests to the Dokku command running on remote hosts. You can install it via the following shell command (assuming you have nodejs and npm installed): npm install -g dokku-toolbelt See documentation here for more information. (python) dokku-client dokku-client is an extensible python-based cli wrapper for remote Dokku hosts. You can install it via the following shell command (assuming you have python and pip installed): pip install dokku-client See documentation here for more information. (ruby) Dokku CLI Dokku CLI is a rubygem that acts as a client for your Dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku-cli See documentation here for more information. (ruby) DokkuClient DokkuClient is another rubygem that acts as a client for your Dokku installation with built-in support for certain external plugins. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku_client See documentation here for more information. (ruby) Dokkufy Dokkufy is a rubygem that handles automation of certain tasks, such as Dokku setup, plugin installation, etc. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokkufy See documentation here for more information. (ruby) Dockland Dockland is a rubygem that acts as a client for your Dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dockland See documentation here for more information.","title":"Clients"},{"location":"community/clients/#clients","text":"Given the constraints, running Dokku commands remotely via SSH is fine. For certain configurations, the extra complication of manually invoking ssh can be a burden. While Dokku does not yet have an official client, there are a multitude of ways in which you can interact with your Dokku installation. The easiest is to use the bash client, though you may wish to use another.","title":"Clients"},{"location":"community/clients/#bash-zsh-etc-dokku_clientsh","text":"Of all methods, this is the most official method of interacting with your Dokku installation. It is a bash script that interacts with a remote Dokku installation via ssh. It is available in contrib/dokku_client.sh in the root of the Dokku repository. To install, simply clone the Dokku repository down and add the dokku alias pointing at the script: git clone git@github.com:dokku/dokku.git ~/.dokku # optional: make sure that the dokku_client.sh version matches your Dokku version cd ~/.dokku git checkout <tag/branch> # add the following to either your # .bashrc, .bash_profile, or .profile file alias dokku = '$HOME/.dokku/contrib/dokku_client.sh' Alternatively, if using another shell such as zsh , create an alias command which invokes the script using bash : # zsh: add the following to either .zshenv or .zshrc alias dokku = 'bash $HOME/.dokku/contrib/dokku_client.sh' # fish: add the following to ~/.config/fish/config.fish alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' # csh: add the following to .cshrc alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' Configure the DOKKU_HOST environment variable or run dokku from a repository with a git remote named dokku pointed at your Dokku host in order to use the script as normal. You can also configure a DOKKU_PORT environment variable if you are running ssh on a non-standard port. This defaults to 22 .","title":"(bash, zsh, etc.) dokku_client.sh"},{"location":"community/clients/#nodejs-dokku-toolbelt","text":"Dokku-toolbelt is a node-based cli wrapper that proxies requests to the Dokku command running on remote hosts. You can install it via the following shell command (assuming you have nodejs and npm installed): npm install -g dokku-toolbelt See documentation here for more information.","title":"(nodejs) dokku-toolbelt"},{"location":"community/clients/#python-dokku-client","text":"dokku-client is an extensible python-based cli wrapper for remote Dokku hosts. You can install it via the following shell command (assuming you have python and pip installed): pip install dokku-client See documentation here for more information.","title":"(python) dokku-client"},{"location":"community/clients/#ruby-dokku-cli","text":"Dokku CLI is a rubygem that acts as a client for your Dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku-cli See documentation here for more information.","title":"(ruby) Dokku CLI"},{"location":"community/clients/#ruby-dokkuclient","text":"DokkuClient is another rubygem that acts as a client for your Dokku installation with built-in support for certain external plugins. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku_client See documentation here for more information.","title":"(ruby) DokkuClient"},{"location":"community/clients/#ruby-dokkufy","text":"Dokkufy is a rubygem that handles automation of certain tasks, such as Dokku setup, plugin installation, etc. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokkufy See documentation here for more information.","title":"(ruby) Dokkufy"},{"location":"community/clients/#ruby-dockland","text":"Dockland is a rubygem that acts as a client for your Dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dockland See documentation here for more information.","title":"(ruby) Dockland"},{"location":"community/plugins/","text":"Plugins Dokku itself is built out of plugins and uses plugn for its plugin system. In essence a plugin is a collection of scripts that will be run based on naming convention. Let's take a quick look at the current Dokku nginx plugin that's shipped with Dokku by default. nginx-vhosts/ \u251c\u2500\u2500 plugin.toml # plugin metadata \u251c\u2500\u2500 commands # contains additional commands \u251c\u2500\u2500 install # runs on Dokku installation \u2514\u2500\u2500 post-deploy # runs after an app is deployed Installing a plugin See the plugin management documentation . Creating your own plugin See the full documentation . Official Plugins (Beta) The following plugins are available and provided by Dokku maintainers. Where noted, these plugins should be considered beta software and may not have been used as thoroughly as community plugins. Please file issues against their respective issue trackers. Plugin Author Compatibility CouchDB (beta) dokku 0.4.0+ Elasticsearch (beta) dokku 0.4.0+ Grafana/Graphite/Statsd (beta) dokku 0.4.0+ MariaDB (beta) dokku 0.4.0+ Memcached (beta) dokku 0.4.0+ Mongo (beta) dokku 0.4.0+ MySQL (beta) dokku 0.4.0+ Nats (beta) dokku 0.4.0+ Postgres (beta) dokku 0.4.0+ RabbitMQ (beta) dokku 0.4.0+ Redis (beta) dokku 0.4.0+ RethinkDB (beta) dokku 0.4.0+ Copy Files to Image dokku 0.4.0+ HTTP Auth (beta) dokku 0.4.0+ Let's Encrypt (beta) dokku 0.4.0+ Maintenance mode (beta) dokku 0.4.0+ Redirect (beta) dokku 0.4.0+ Community plugins Warning: The following plugins have been supplied by our community and may not have been tested by Dokku maintainers. Datastores Relational Plugin Author Compatibility MariaDB Kloadut 0.3.x MariaDB (single container) ohardy 0.3.x MariaDB (single container) krisrang 0.3.26+ PostgreSQL jlachowski 0.3.x PostgreSQL (single container) ohardy 0.3.x PostgreSQL (single container) Flink 0.3.26+ Caching Plugin Author Compatibility Nginx Cache Aluxian 0.5.0+ Redis (single container) ohardy 0.3.x Varnish Zenedith Varnish cache between nginx and application with base configuration Queuing Plugin Author Compatibility RabbitMQ jlachowski 0.3.x RabbitMQ (single container) jlachowski 0.3.x ElasticMQ (SQS compatible) cu12 0.5.0+ VerneMQ (MQTT Broker) mrname 0.4.0+ Other Plugin Author Compatibility etcd basgys 0.4.x FakeSNS cu12 0.5.0+ InfluxDB basgys 0.4.x RethinkDB stuartpb 0.3.x Plugins Implementing New Dokku Functionality Plugin Author Compatibility App name as env cjblomqvist 0.3.x Docker Direct josegonzalez 0.4.0+ Dokku Clone crisward 0.4.0+ Dokku Copy App Config Files josegonzalez 0.4.0+ Dockerfile custom path mimischi 0.8.0+ Dokku Registry 1 agco-adm 0.4.0+ Dokku Require 2 crisward 0.4.0+ Global Certificates josegonzalez 0.5.0+ Graduate (Environment Management) Benjamin-Dobell 0.4.0+ Haproxy tcp load balancer 256dpi 0.4.0+ Hostname michaelshobbs 0.4.0+ HTTP Auth Secure Apps matto1990 0.4.0+ Monit (Health Checks) mbreit 0.8.0+ Nuke Containers josegonzalez 0.4.0+ Open App Ports josegonzalez 0.3.x Proctype Filter michaelshobbs 0.4.0+ robots.txt candlewaster 0.4.x SSH Deployment Keys 3 cedricziel 0.4.0+ SSH Hostkeys 4 cedricziel 0.3.x Application build hook fteychene 0.4.0+ Post Deploy Script baikunz 0.4.0+ 1 On Heroku similar functionality is offered by the heroku-labs pipeline feature , which allows you to promote builds across multiple environments (staging -> production) 2 Extends app.json support to include creating volumes and creating / linking databases on push 3 Adds the possibility to add SSH deployment keys to receive private hosted packages 4 Adds the ability to add custom hosts to the containers known_hosts file to be able to ssh them easily (useful with deployment keys) Other Plugins Plugin Author Compatibility Airbrake deploy Flink 0.4.0+ APT F4-Group 0.4.0+ Bower install alexanderbeletsky 0.3.x Bower/Grunt thrashr888 0.3.x Bower/Gulp gdi2290 0.3.x Bower/Gulp jagandecapri 0.3.x Builders: bower, compass, gulp, grunt ignlg 0.4.0+ Chef cookbook nickcharlton Docker auto persist volumes Flink 0.4.0+ Hostname michaelshobbs 0.4.0+ Limit (Resource management) sarendsen 0.9.0+ Logspout michaelshobbs 0.4.0+ Syslog michaelshobbs 0.10.4+ Long Timeout investtools 0.4.0+ Monit cjblomqvist 0.3.x Monorepo iamale 0.4.0+ Node ademuk 0.3.x Node pnegahdar 0.3.x Rollbar iloveitaly 0.5.0+ Slack Notifications ribot 0.4.0+ Telegram Notifications m0rth1um 0.4.0+ Tor michaelshobbs 0.4.0+ User ACL Maciej \u0141ebkowski 0.4.0+ Webhooks nickstenning 0.3.x Wkhtmltopdf mbriskar 0.4.0+ Dokku Wordpress dokku-community 0.4.0+ Access mainto 0.4.0+ Deprecated Plugins The following plugins have been removed as their functionality is now in Dokku Core. Plugin Author In Dokku Since App User michaelshobbs v0.7.1 (herokuish 0.3.18) Custom Domains motin v0.3.10 (domains plugin) Debug josegonzalez v0.3.9 (trace command) Docker Options dyson v0.3.17 (docker-options plugin) Dokku Name alex-sherwin v0.4.2 (named containers plugin) Events Logger alessio v0.3.21 (events plugin) git rev-parse HEAD in env cjblomqvist v0.12.0 (enhanced core git plugin) Host Port binding stuartpb v0.3.17 (docker-options plugin) Link Containers rlaneve v0.3.17 (docker-options plugin) List Containers josegonzalez v0.3.14 (ps plugin) Multi-Buildpack pauldub v0.4.0 (herokuish) Multiple Domains 1 wmluke v0.3.10 (domains plugin) Named-containers Flink v0.4.2 (named-containers plugin) Nginx-Alt mikexstudios v0.3.10 (domains plugin) Persistent Storage dyson v0.3.17 (docker-options plugin) Pre-Deploy Tasks michaelshobbs v0.5.0 (deployment tasks) PrimeCache darkpixel v0.3.0 (zero downtime deploys) Process Manager: Circus apmorton v0.3.14/0.7.0 (ps/restart policy plugin) Process Manager: Forego Flink v0.3.14/0.7.0 (ps plugin) Process Manager: Forego iskandar v0.3.14/0.7.0 (ps plugin) Process Manager: Logging Supervisord sehrope v0.3.14/0.7.0 (ps plugin) Process Manager: Shoreman statianzo v0.3.14/0.7.0 (ps plugin) Process Manager: Supervisord statianzo v0.3.14/0.7.0 (ps plugin) Rebuild application scottatron v0.3.14 (ps plugin) Reset mtime mixxorz Docker 1.8+ Supply env vars to buildpacks 2 cameron-martin v0.3.9 (build-env plugin) user-env-compile 2 motin v0.3.9 (build-env plugin) user-env-compile 2 musicglue v0.3.9 (build-env plugin) VHOSTS Custom Configuration motin v0.3.10 (domains plugin) Volume (persistent storage) ohardy v0.5.0 (storage plugin) 1 Conflicts with VHOSTS Custom Configuration 2 Similar to the heroku-labs feature (see https://devcenter.heroku.com/articles/labs-user-env-compile) Unmaintained Plugins The following plugins are no longer maintained by their developers. Plugin Author Compatibility app-url mikecsh Works with 0.2.0 Chef cookbooks fgrehm CouchDB (multi containers) Flink 0.4.0+ CouchDB RaceHub Compatible with 0.2.0 Dokku Copy App Config Files alexkruegger Compatible with 0.3.17+ Elasticsearch robv Not compatible with >= 0.3.0 (still uses /home/git) Elasticsearch 1 blag Compatible with 0.2.0 Graphite/statsd jlachowski < 0.4.0 HipChat Notifications cef Memcached Flink 0.4.0+ MongoDB (single container) jeffutter MySQL hughfletcher Neo4j Aomitayo PostGIS fermuch PostgreSQL (single container) jeffutter This plugin creates a single postgresql container that all your apps can use. Thus only one instance of postgresql running (good for servers without a ton of memory). RiakCS (single container) jeffutter Incompatible with 0.2.0 (checked at dccee02 ) Redis luxifer Redis sekjun9878 0.3.26+ 1 Forked from jezdez/dokku-elasticsearch-plugin : uses Elasticsearch 1.2 (instead of 0.90), doesn't depend on dokku-link, runs as elasticsearch user instead of root, and turns off multicast autodiscovery for use in a VPS environment.","title":"Plugins"},{"location":"community/plugins/#plugins","text":"Dokku itself is built out of plugins and uses plugn for its plugin system. In essence a plugin is a collection of scripts that will be run based on naming convention. Let's take a quick look at the current Dokku nginx plugin that's shipped with Dokku by default. nginx-vhosts/ \u251c\u2500\u2500 plugin.toml # plugin metadata \u251c\u2500\u2500 commands # contains additional commands \u251c\u2500\u2500 install # runs on Dokku installation \u2514\u2500\u2500 post-deploy # runs after an app is deployed","title":"Plugins"},{"location":"community/plugins/#installing-a-plugin","text":"See the plugin management documentation .","title":"Installing a plugin"},{"location":"community/plugins/#creating-your-own-plugin","text":"See the full documentation .","title":"Creating your own plugin"},{"location":"community/plugins/#official-plugins-beta","text":"The following plugins are available and provided by Dokku maintainers. Where noted, these plugins should be considered beta software and may not have been used as thoroughly as community plugins. Please file issues against their respective issue trackers. Plugin Author Compatibility CouchDB (beta) dokku 0.4.0+ Elasticsearch (beta) dokku 0.4.0+ Grafana/Graphite/Statsd (beta) dokku 0.4.0+ MariaDB (beta) dokku 0.4.0+ Memcached (beta) dokku 0.4.0+ Mongo (beta) dokku 0.4.0+ MySQL (beta) dokku 0.4.0+ Nats (beta) dokku 0.4.0+ Postgres (beta) dokku 0.4.0+ RabbitMQ (beta) dokku 0.4.0+ Redis (beta) dokku 0.4.0+ RethinkDB (beta) dokku 0.4.0+ Copy Files to Image dokku 0.4.0+ HTTP Auth (beta) dokku 0.4.0+ Let's Encrypt (beta) dokku 0.4.0+ Maintenance mode (beta) dokku 0.4.0+ Redirect (beta) dokku 0.4.0+","title":"Official Plugins (Beta)"},{"location":"community/plugins/#community-plugins","text":"Warning: The following plugins have been supplied by our community and may not have been tested by Dokku maintainers.","title":"Community plugins"},{"location":"community/plugins/#datastores","text":"","title":"Datastores"},{"location":"community/plugins/#relational","text":"Plugin Author Compatibility MariaDB Kloadut 0.3.x MariaDB (single container) ohardy 0.3.x MariaDB (single container) krisrang 0.3.26+ PostgreSQL jlachowski 0.3.x PostgreSQL (single container) ohardy 0.3.x PostgreSQL (single container) Flink 0.3.26+","title":"Relational"},{"location":"community/plugins/#caching","text":"Plugin Author Compatibility Nginx Cache Aluxian 0.5.0+ Redis (single container) ohardy 0.3.x Varnish Zenedith Varnish cache between nginx and application with base configuration","title":"Caching"},{"location":"community/plugins/#queuing","text":"Plugin Author Compatibility RabbitMQ jlachowski 0.3.x RabbitMQ (single container) jlachowski 0.3.x ElasticMQ (SQS compatible) cu12 0.5.0+ VerneMQ (MQTT Broker) mrname 0.4.0+","title":"Queuing"},{"location":"community/plugins/#other","text":"Plugin Author Compatibility etcd basgys 0.4.x FakeSNS cu12 0.5.0+ InfluxDB basgys 0.4.x RethinkDB stuartpb 0.3.x","title":"Other"},{"location":"community/plugins/#plugins-implementing-new-dokku-functionality","text":"Plugin Author Compatibility App name as env cjblomqvist 0.3.x Docker Direct josegonzalez 0.4.0+ Dokku Clone crisward 0.4.0+ Dokku Copy App Config Files josegonzalez 0.4.0+ Dockerfile custom path mimischi 0.8.0+ Dokku Registry 1 agco-adm 0.4.0+ Dokku Require 2 crisward 0.4.0+ Global Certificates josegonzalez 0.5.0+ Graduate (Environment Management) Benjamin-Dobell 0.4.0+ Haproxy tcp load balancer 256dpi 0.4.0+ Hostname michaelshobbs 0.4.0+ HTTP Auth Secure Apps matto1990 0.4.0+ Monit (Health Checks) mbreit 0.8.0+ Nuke Containers josegonzalez 0.4.0+ Open App Ports josegonzalez 0.3.x Proctype Filter michaelshobbs 0.4.0+ robots.txt candlewaster 0.4.x SSH Deployment Keys 3 cedricziel 0.4.0+ SSH Hostkeys 4 cedricziel 0.3.x Application build hook fteychene 0.4.0+ Post Deploy Script baikunz 0.4.0+ 1 On Heroku similar functionality is offered by the heroku-labs pipeline feature , which allows you to promote builds across multiple environments (staging -> production) 2 Extends app.json support to include creating volumes and creating / linking databases on push 3 Adds the possibility to add SSH deployment keys to receive private hosted packages 4 Adds the ability to add custom hosts to the containers known_hosts file to be able to ssh them easily (useful with deployment keys)","title":"Plugins Implementing New Dokku Functionality"},{"location":"community/plugins/#other-plugins","text":"Plugin Author Compatibility Airbrake deploy Flink 0.4.0+ APT F4-Group 0.4.0+ Bower install alexanderbeletsky 0.3.x Bower/Grunt thrashr888 0.3.x Bower/Gulp gdi2290 0.3.x Bower/Gulp jagandecapri 0.3.x Builders: bower, compass, gulp, grunt ignlg 0.4.0+ Chef cookbook nickcharlton Docker auto persist volumes Flink 0.4.0+ Hostname michaelshobbs 0.4.0+ Limit (Resource management) sarendsen 0.9.0+ Logspout michaelshobbs 0.4.0+ Syslog michaelshobbs 0.10.4+ Long Timeout investtools 0.4.0+ Monit cjblomqvist 0.3.x Monorepo iamale 0.4.0+ Node ademuk 0.3.x Node pnegahdar 0.3.x Rollbar iloveitaly 0.5.0+ Slack Notifications ribot 0.4.0+ Telegram Notifications m0rth1um 0.4.0+ Tor michaelshobbs 0.4.0+ User ACL Maciej \u0141ebkowski 0.4.0+ Webhooks nickstenning 0.3.x Wkhtmltopdf mbriskar 0.4.0+ Dokku Wordpress dokku-community 0.4.0+ Access mainto 0.4.0+","title":"Other Plugins"},{"location":"community/plugins/#deprecated-plugins","text":"The following plugins have been removed as their functionality is now in Dokku Core. Plugin Author In Dokku Since App User michaelshobbs v0.7.1 (herokuish 0.3.18) Custom Domains motin v0.3.10 (domains plugin) Debug josegonzalez v0.3.9 (trace command) Docker Options dyson v0.3.17 (docker-options plugin) Dokku Name alex-sherwin v0.4.2 (named containers plugin) Events Logger alessio v0.3.21 (events plugin) git rev-parse HEAD in env cjblomqvist v0.12.0 (enhanced core git plugin) Host Port binding stuartpb v0.3.17 (docker-options plugin) Link Containers rlaneve v0.3.17 (docker-options plugin) List Containers josegonzalez v0.3.14 (ps plugin) Multi-Buildpack pauldub v0.4.0 (herokuish) Multiple Domains 1 wmluke v0.3.10 (domains plugin) Named-containers Flink v0.4.2 (named-containers plugin) Nginx-Alt mikexstudios v0.3.10 (domains plugin) Persistent Storage dyson v0.3.17 (docker-options plugin) Pre-Deploy Tasks michaelshobbs v0.5.0 (deployment tasks) PrimeCache darkpixel v0.3.0 (zero downtime deploys) Process Manager: Circus apmorton v0.3.14/0.7.0 (ps/restart policy plugin) Process Manager: Forego Flink v0.3.14/0.7.0 (ps plugin) Process Manager: Forego iskandar v0.3.14/0.7.0 (ps plugin) Process Manager: Logging Supervisord sehrope v0.3.14/0.7.0 (ps plugin) Process Manager: Shoreman statianzo v0.3.14/0.7.0 (ps plugin) Process Manager: Supervisord statianzo v0.3.14/0.7.0 (ps plugin) Rebuild application scottatron v0.3.14 (ps plugin) Reset mtime mixxorz Docker 1.8+ Supply env vars to buildpacks 2 cameron-martin v0.3.9 (build-env plugin) user-env-compile 2 motin v0.3.9 (build-env plugin) user-env-compile 2 musicglue v0.3.9 (build-env plugin) VHOSTS Custom Configuration motin v0.3.10 (domains plugin) Volume (persistent storage) ohardy v0.5.0 (storage plugin) 1 Conflicts with VHOSTS Custom Configuration 2 Similar to the heroku-labs feature (see https://devcenter.heroku.com/articles/labs-user-env-compile)","title":"Deprecated Plugins"},{"location":"community/plugins/#unmaintained-plugins","text":"The following plugins are no longer maintained by their developers. Plugin Author Compatibility app-url mikecsh Works with 0.2.0 Chef cookbooks fgrehm CouchDB (multi containers) Flink 0.4.0+ CouchDB RaceHub Compatible with 0.2.0 Dokku Copy App Config Files alexkruegger Compatible with 0.3.17+ Elasticsearch robv Not compatible with >= 0.3.0 (still uses /home/git) Elasticsearch 1 blag Compatible with 0.2.0 Graphite/statsd jlachowski < 0.4.0 HipChat Notifications cef Memcached Flink 0.4.0+ MongoDB (single container) jeffutter MySQL hughfletcher Neo4j Aomitayo PostGIS fermuch PostgreSQL (single container) jeffutter This plugin creates a single postgresql container that all your apps can use. Thus only one instance of postgresql running (good for servers without a ton of memory). RiakCS (single container) jeffutter Incompatible with 0.2.0 (checked at dccee02 ) Redis luxifer Redis sekjun9878 0.3.26+ 1 Forked from jezdez/dokku-elasticsearch-plugin : uses Elasticsearch 1.2 (instead of 0.90), doesn't depend on dokku-link, runs as elasticsearch user instead of root, and turns off multicast autodiscovery for use in a VPS environment.","title":"Unmaintained Plugins"},{"location":"community/tutorials/deploying-with-gitlab-ci/","text":"Deploying with Gitlab CI Gitlab-CI can be used to automatically deploy a Dokku application using the ilyasemenov/gitlab-ci-git-push image docker image. Prerequisites Make sure you have a Gitlab account and a Dokku project hosted on Gitlab. This method works whether if you are using buildpacks or Dockerfile. Make sure you have set up an app on the remote machine following these instructions and can successfully deploy to it from the local machine. Deploy automatically to production Add a secret variable Browse to the repository in question and visit the following path: the Gitlab project > Settings > CI/CD. Click on Secret variables > Expand and fill in the blanks. Key: SSH_PRIVATE_KEY Value: paste in an SSH private key registered in Dokku: -----BEGIN RSA PRIVATE KEY----- ... -----END RSA PRIVATE KEY----- Environment scope: production (This make sure that SSH_PRIVATE_KEY is not available on merge requests or tests) Protected: Do not check this checkbox unless you know what you are doing Add CI script Create a file named .gitlab-ci.yml at the root directory of the repository with the following contents: stages : - deploy variables : APP_NAME : node-js-app deploy : image : ilyasemenov/gitlab-ci-git-push stage : deploy environment : name : production url : https://$APP_NAME.dokku.me/ only : - master script : - git-push ssh://dokku@dokku.me:22/$APP_NAME You will need to modify the APP_NAME variable to the correct value for your application name. Running git push origin master will now trigger a gitlab-ci pipeline that will automatically deploy your application to your Dokku server. Go to your project on Gitlab and visit \"Project > Pipelines\" to see the deployment log. Review Applications One useful feature of gitlab is to be able to create review applications for non-production branches. This allows teams to review changes before they are pushed to production. First, recreate the SSH_PRIVATE_KEY secret - do not delete the existing secret - but scoped to the review/* environment. This will allow non-production gitlab environments access to the secret. Next, we'll need to create the review_app gitlab job in our .gitlab-ci.yaml . review_app : image : ilyasemenov/gitlab-ci-git-push stage : deploy environment : name : review/$CI_ENVIRONMENT_SLUG url : https://$CI_ENVIRONMENT_SLUG.dokku.me/ on_stop : stop_review_app only : - branches except : - master script : - mkdir -p ~/.ssh && echo \"$SSH_PRIVATE_KEY\" | tr -d '\\r' > ~/.ssh/id_rsa && chmod 600 ~/.ssh/id_rsa - ssh-keyscan -H 22 \"dokku.me\" >> ~/.ssh/known_hosts - ssh -t dokku@dokku.me -- apps:clone --ignore-existing --skip-deploy \"$APP_NAME\" \"$CI_ENVIRONMENT_SLUG\" - git-push ssh://dokku@dokku.me:22/$CI_ENVIRONMENT_SLUG The first two lines ensure that Gitlab can talk to the Dokku server. Next, we take advantage of the apps:clone command, and clone the existing application and all of it's configuration to a new location. If the new application already exists, the third line of the script step will be ignored. We also ignore the first deploy script to speed up the cloning process. Finally, the fourth line of the script step will deploy the code as normal. The above only runs for non-master branches, and will also trigger an on_stop job called stop_review_app . When the branch is deleted or the code is merged, the stop_review_app job will be triggered. stop_review_app : image : ilyasemenov/gitlab-ci-git-push stage : deploy environment : name : review/$CI_ENVIRONMENT_SLUG action : stop when : manual script : - mkdir -p ~/.ssh && echo \"$SSH_PRIVATE_KEY\" | tr -d '\\r' > ~/.ssh/id_rsa && chmod 600 ~/.ssh/id_rsa - ssh-keyscan -H 22 \"dokku.me\" >> ~/.ssh/known_hosts - ssh -t dokku@dokku.me -- --force apps:destroy \"$CI_ENVIRONMENT_SLUG\" The stop_review_app step will delete the temporary application, cleaning up now unused server resources. Going further, the following modifications can be done: Notify via chat whenever a review application is created/destroyed. Push to a separate, staging server as opposed to a production server. Clone a \"staging\" application so that review applications do not affect production datasets.","title":"Deploying with Gitlab CI"},{"location":"community/tutorials/deploying-with-gitlab-ci/#deploying-with-gitlab-ci","text":"Gitlab-CI can be used to automatically deploy a Dokku application using the ilyasemenov/gitlab-ci-git-push image docker image.","title":"Deploying with Gitlab CI"},{"location":"community/tutorials/deploying-with-gitlab-ci/#prerequisites","text":"Make sure you have a Gitlab account and a Dokku project hosted on Gitlab. This method works whether if you are using buildpacks or Dockerfile. Make sure you have set up an app on the remote machine following these instructions and can successfully deploy to it from the local machine.","title":"Prerequisites"},{"location":"community/tutorials/deploying-with-gitlab-ci/#deploy-automatically-to-production","text":"","title":"Deploy automatically to production"},{"location":"community/tutorials/deploying-with-gitlab-ci/#add-a-secret-variable","text":"Browse to the repository in question and visit the following path: the Gitlab project > Settings > CI/CD. Click on Secret variables > Expand and fill in the blanks. Key: SSH_PRIVATE_KEY Value: paste in an SSH private key registered in Dokku: -----BEGIN RSA PRIVATE KEY----- ... -----END RSA PRIVATE KEY----- Environment scope: production (This make sure that SSH_PRIVATE_KEY is not available on merge requests or tests) Protected: Do not check this checkbox unless you know what you are doing","title":"Add a secret variable"},{"location":"community/tutorials/deploying-with-gitlab-ci/#add-ci-script","text":"Create a file named .gitlab-ci.yml at the root directory of the repository with the following contents: stages : - deploy variables : APP_NAME : node-js-app deploy : image : ilyasemenov/gitlab-ci-git-push stage : deploy environment : name : production url : https://$APP_NAME.dokku.me/ only : - master script : - git-push ssh://dokku@dokku.me:22/$APP_NAME You will need to modify the APP_NAME variable to the correct value for your application name. Running git push origin master will now trigger a gitlab-ci pipeline that will automatically deploy your application to your Dokku server. Go to your project on Gitlab and visit \"Project > Pipelines\" to see the deployment log.","title":"Add CI script"},{"location":"community/tutorials/deploying-with-gitlab-ci/#review-applications","text":"One useful feature of gitlab is to be able to create review applications for non-production branches. This allows teams to review changes before they are pushed to production. First, recreate the SSH_PRIVATE_KEY secret - do not delete the existing secret - but scoped to the review/* environment. This will allow non-production gitlab environments access to the secret. Next, we'll need to create the review_app gitlab job in our .gitlab-ci.yaml . review_app : image : ilyasemenov/gitlab-ci-git-push stage : deploy environment : name : review/$CI_ENVIRONMENT_SLUG url : https://$CI_ENVIRONMENT_SLUG.dokku.me/ on_stop : stop_review_app only : - branches except : - master script : - mkdir -p ~/.ssh && echo \"$SSH_PRIVATE_KEY\" | tr -d '\\r' > ~/.ssh/id_rsa && chmod 600 ~/.ssh/id_rsa - ssh-keyscan -H 22 \"dokku.me\" >> ~/.ssh/known_hosts - ssh -t dokku@dokku.me -- apps:clone --ignore-existing --skip-deploy \"$APP_NAME\" \"$CI_ENVIRONMENT_SLUG\" - git-push ssh://dokku@dokku.me:22/$CI_ENVIRONMENT_SLUG The first two lines ensure that Gitlab can talk to the Dokku server. Next, we take advantage of the apps:clone command, and clone the existing application and all of it's configuration to a new location. If the new application already exists, the third line of the script step will be ignored. We also ignore the first deploy script to speed up the cloning process. Finally, the fourth line of the script step will deploy the code as normal. The above only runs for non-master branches, and will also trigger an on_stop job called stop_review_app . When the branch is deleted or the code is merged, the stop_review_app job will be triggered. stop_review_app : image : ilyasemenov/gitlab-ci-git-push stage : deploy environment : name : review/$CI_ENVIRONMENT_SLUG action : stop when : manual script : - mkdir -p ~/.ssh && echo \"$SSH_PRIVATE_KEY\" | tr -d '\\r' > ~/.ssh/id_rsa && chmod 600 ~/.ssh/id_rsa - ssh-keyscan -H 22 \"dokku.me\" >> ~/.ssh/known_hosts - ssh -t dokku@dokku.me -- --force apps:destroy \"$CI_ENVIRONMENT_SLUG\" The stop_review_app step will delete the temporary application, cleaning up now unused server resources. Going further, the following modifications can be done: Notify via chat whenever a review application is created/destroyed. Push to a separate, staging server as opposed to a production server. Clone a \"staging\" application so that review applications do not affect production datasets.","title":"Review Applications"},{"location":"community/tutorials/run-on-external-volume/","text":"Run Dokku on External Volume In order to leverage cloud-provider facilities like attachable volumes , ( a.k.a. block storage ) the following is an easy tutorial to achieve Dokku runs on them. Warning: If the block storage is not available and attached on boot it is possible that containers will not correctly start. Please keep this in mind when considering moving Dokku and/or Docker to network attached storage. Tutorial The following is intended to be executed on the dokku host machine as root . Say, for instance , that our volume is mapped into the systems as /dev/vdb1 . Stop docker daemon systemctl stop docker Prepare the filesystem: mkfs -t ext4 /dev/vdb1 mkdir /mnt/volume mount /dev/vdb1 /mnt/volume Move the old data directories: mv /home/dokku /home/dokku.OLD mv /var/lib/docker /var/lib/docker.OLD mv /var/lib/dokku /var/lib/dokku.OLD Move the data on the volume mkdir /mnt/volume/home/ mkdir /mnt/volume/var/lib/ mv /home/dokku.OLD /mnt/volume/home/dokku mv /var/lib/dokku.OLD /mnt/volume/var/lib/dokku mv /var/lib/docker.OLD /mnt/volume/var/lib/docker Prepare the mountpoints mkdir /home/dokku mkdir /var/lib/dokku mkdir /var/lib/docker chown dokku:dokku /home/dokku # respect the original ownership chmod 711 /var/lib/docker # respect the original permissions Mount bind mount -o bind /mnt/volume/home/dokku /home/dokku mount -o bind /mnt/volume/var/lib/dokku /var/lib/dokku mount -o bind /mnt/volume/var/lib/docker /var/lib/docker Start docker daemon systemctl start docker At this point all should be working fine, please check it out. Then, let the changes be reboot-persistent echo '/dev/vdb1 /mnt/volume ext4 defaults 0 2' | sudo tee -a /etc/fstab echo '/mnt/volume/home/dokku /home/dokku none defaults,bind 0 0' | sudo tee -a /etc/fstab echo '/mnt/volume/var/lib/dokku /var/lib/dokku none defaults,bind 0 0' | sudo tee -a /etc/fstab echo '/mnt/volume/var/lib/docker /var/lib/docker none defaults,bind 0 0' | sudo tee -a /etc/fstab","title":"Run Dokku on External Volume"},{"location":"community/tutorials/run-on-external-volume/#run-dokku-on-external-volume","text":"In order to leverage cloud-provider facilities like attachable volumes , ( a.k.a. block storage ) the following is an easy tutorial to achieve Dokku runs on them. Warning: If the block storage is not available and attached on boot it is possible that containers will not correctly start. Please keep this in mind when considering moving Dokku and/or Docker to network attached storage.","title":"Run Dokku on External Volume"},{"location":"community/tutorials/run-on-external-volume/#tutorial","text":"The following is intended to be executed on the dokku host machine as root . Say, for instance , that our volume is mapped into the systems as /dev/vdb1 . Stop docker daemon systemctl stop docker Prepare the filesystem: mkfs -t ext4 /dev/vdb1 mkdir /mnt/volume mount /dev/vdb1 /mnt/volume Move the old data directories: mv /home/dokku /home/dokku.OLD mv /var/lib/docker /var/lib/docker.OLD mv /var/lib/dokku /var/lib/dokku.OLD Move the data on the volume mkdir /mnt/volume/home/ mkdir /mnt/volume/var/lib/ mv /home/dokku.OLD /mnt/volume/home/dokku mv /var/lib/dokku.OLD /mnt/volume/var/lib/dokku mv /var/lib/docker.OLD /mnt/volume/var/lib/docker Prepare the mountpoints mkdir /home/dokku mkdir /var/lib/dokku mkdir /var/lib/docker chown dokku:dokku /home/dokku # respect the original ownership chmod 711 /var/lib/docker # respect the original permissions Mount bind mount -o bind /mnt/volume/home/dokku /home/dokku mount -o bind /mnt/volume/var/lib/dokku /var/lib/dokku mount -o bind /mnt/volume/var/lib/docker /var/lib/docker Start docker daemon systemctl start docker At this point all should be working fine, please check it out. Then, let the changes be reboot-persistent echo '/dev/vdb1 /mnt/volume ext4 defaults 0 2' | sudo tee -a /etc/fstab echo '/mnt/volume/home/dokku /home/dokku none defaults,bind 0 0' | sudo tee -a /etc/fstab echo '/mnt/volume/var/lib/dokku /var/lib/dokku none defaults,bind 0 0' | sudo tee -a /etc/fstab echo '/mnt/volume/var/lib/docker /var/lib/docker none defaults,bind 0 0' | sudo tee -a /etc/fstab","title":"Tutorial"},{"location":"configuration/domains/","text":"Domain Configuration New as of 0.3.10 domains:add <app> <domain> [<domain> ...] # Add domains to app domains:add-global <domain> [<domain> ...] # Add global domain names domains:clear <app> # Clear all domains for app domains:disable <app> # Disable VHOST support domains:enable <app> # Enable VHOST support domains:remove <app> <domain> [<domain> ...] # Remove domains from app domains:remove-global <domain> [<domain> ...] # Remove global domain names domains:report [<app>] [<flag>] # Displays a domains report for one or more apps domains:set <app> <domain> [<domain> ...] # Set domains for app domains:set-global <domain> [<domain> ...] # Set global domain names Adding a domain before deploying an application will result in port mappings being set. This may cause issues for applications that use non-standard ports, as those will not be automatically detected. Please refer to the proxy documentation for information as to how to reconfigure the mappings. Customizing hostnames Applications typically have the following structure for their hostname: scheme://subdomain.domain.tld The subdomain is inferred from the pushed application name, while the domain.tld is set during initial dokku configuration. It can then be modified with dokku domains:add-global and dokku domains:remove-global . This value is used as a default TLD for all applications on a host. If a FQDN such as other.tld is used as the application name, the global virtualhost will be ignored and the resulting vhost URL for that application will be other.tld . The exception to this rule being that if the FQDN has the same ending as the default vhost (such as subdomain.domain.tld ), then the entire FQDN will be treated as a subdomain. The application will therefore be deployed at subdomain.domain.tld.domain.tld . You can optionally override this in a plugin by implementing the nginx-hostname plugin trigger. For example, you can reverse the subdomain with the following sample nginx-hostname plugin trigger: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" If the nginx-hostname plugin has no output, the normal hostname algorithm will be executed. Disabling VHOSTS If desired, it is possible to disable vhosts with the domains plugin. dokku domains:disable node-js-app On subsequent deploys, the nginx virtualhost will be discarded. This is useful when deploying internal-facing services that should not be publicly routeable. As of 0.4.0, nginx will still be configured to proxy your app on some random high port. This allows internal services to maintain the same port between deployments. You may change this port by setting DOKKU_PROXY_PORT and/or DOKKU_PROXY_SSL_PORT (for services configured to use SSL.) The domains plugin allows you to specify custom domains for applications. This plugin is aware of any ssl certificates that are imported via certs:add . Be aware that disabling domains (with domains:disable ) will override any custom domains. # where `node-js-app` is the name of your app # add a domain to an app dokku domains:add node-js-app dokku.me # list custom domains for app dokku domains node-js-app # clear all custom domains for app dokku domains:clear node-js-app # remove a custom domain from app dokku domains:remove node-js-app dokku.me # set all custom domains for app dokku domains:set node-js-app dokku.me dokku.org Displaying domains reports about an app New as of 0.8.1 You can get a report about the app's domains status using the domains:report command: dokku domains:report =====> node-js-app domains information Domains app enabled: true Domains app vhosts: node-js-sample.dokku.org Domains global enabled: true Domains global vhosts: dokku.org =====> python-sample domains information Domains app enabled: true Domains app vhosts: python-sample.dokku.org Domains global enabled: true Domains global vhosts: dokku.org =====> ruby-sample domains information Domains app enabled: true Domains app vhosts: ruby-sample.dokku.org Domains global enabled: true Domains global vhosts: dokku.org You can run the command for a specific app also. dokku domains:report node-js-app =====> node-js-app domains information Domains app enabled: true Domains app vhosts: node-js-app.dokku.org Domains global enabled: true Domains global vhosts: dokku.org You can pass flags which will output only the value of the specific information you want. For example: dokku domains:report node-js-app --domains-app-enabled Default site By default, Dokku will route any received request with an unknown HOST header value to the lexicographically first site in the nginx config stack. If this is not the desired behavior, you may want to add the following configuration to the global nginx configuration. Create the file at /etc/nginx/conf.d/00-default-vhost.conf : server { listen 80 default_server ; server_name _ ; access_log off ; return 410 ; } # To handle HTTPS requests, you can uncomment the following section. # # Please note that in order to let this work as expected, you need a valid # SSL certificate for any domains being served. Browsers will show SSL # errors in all other cases. # # Note that the key and certificate files in the below example need to # be copied into /etc/nginx/ssl/ folder. # # server { # listen 443 ssl; # server_name _; # ssl_certificate /etc/nginx/ssl/cert.crt; # ssl_certificate_key /etc/nginx/ssl/cert.key; # access_log off; # return 410; # } Make sure to reload nginx after creating this file by running service nginx reload . This will catch all unknown HOST header values and return a 410 Gone response. You can replace the return 410; with return 444; which will cause nginx to not respond to requests that do not match known domains (connection refused). The configuration file must be loaded before /etc/nginx/conf.d/dokku.conf , so it can not be arranged as a vhost in /etc/nginx/sites-enabled that is only processed afterwards. Alternatively, you may push an app to your Dokku host with a name like \"00-default\". As long as it lists first in ls /home/dokku/*/nginx.conf | head , it will be used as the default nginx vhost.","title":"Domain Configuration"},{"location":"configuration/domains/#domain-configuration","text":"New as of 0.3.10 domains:add <app> <domain> [<domain> ...] # Add domains to app domains:add-global <domain> [<domain> ...] # Add global domain names domains:clear <app> # Clear all domains for app domains:disable <app> # Disable VHOST support domains:enable <app> # Enable VHOST support domains:remove <app> <domain> [<domain> ...] # Remove domains from app domains:remove-global <domain> [<domain> ...] # Remove global domain names domains:report [<app>] [<flag>] # Displays a domains report for one or more apps domains:set <app> <domain> [<domain> ...] # Set domains for app domains:set-global <domain> [<domain> ...] # Set global domain names Adding a domain before deploying an application will result in port mappings being set. This may cause issues for applications that use non-standard ports, as those will not be automatically detected. Please refer to the proxy documentation for information as to how to reconfigure the mappings.","title":"Domain Configuration"},{"location":"configuration/domains/#customizing-hostnames","text":"Applications typically have the following structure for their hostname: scheme://subdomain.domain.tld The subdomain is inferred from the pushed application name, while the domain.tld is set during initial dokku configuration. It can then be modified with dokku domains:add-global and dokku domains:remove-global . This value is used as a default TLD for all applications on a host. If a FQDN such as other.tld is used as the application name, the global virtualhost will be ignored and the resulting vhost URL for that application will be other.tld . The exception to this rule being that if the FQDN has the same ending as the default vhost (such as subdomain.domain.tld ), then the entire FQDN will be treated as a subdomain. The application will therefore be deployed at subdomain.domain.tld.domain.tld . You can optionally override this in a plugin by implementing the nginx-hostname plugin trigger. For example, you can reverse the subdomain with the following sample nginx-hostname plugin trigger: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" If the nginx-hostname plugin has no output, the normal hostname algorithm will be executed.","title":"Customizing hostnames"},{"location":"configuration/domains/#disabling-vhosts","text":"If desired, it is possible to disable vhosts with the domains plugin. dokku domains:disable node-js-app On subsequent deploys, the nginx virtualhost will be discarded. This is useful when deploying internal-facing services that should not be publicly routeable. As of 0.4.0, nginx will still be configured to proxy your app on some random high port. This allows internal services to maintain the same port between deployments. You may change this port by setting DOKKU_PROXY_PORT and/or DOKKU_PROXY_SSL_PORT (for services configured to use SSL.) The domains plugin allows you to specify custom domains for applications. This plugin is aware of any ssl certificates that are imported via certs:add . Be aware that disabling domains (with domains:disable ) will override any custom domains. # where `node-js-app` is the name of your app # add a domain to an app dokku domains:add node-js-app dokku.me # list custom domains for app dokku domains node-js-app # clear all custom domains for app dokku domains:clear node-js-app # remove a custom domain from app dokku domains:remove node-js-app dokku.me # set all custom domains for app dokku domains:set node-js-app dokku.me dokku.org","title":"Disabling VHOSTS"},{"location":"configuration/domains/#displaying-domains-reports-about-an-app","text":"New as of 0.8.1 You can get a report about the app's domains status using the domains:report command: dokku domains:report =====> node-js-app domains information Domains app enabled: true Domains app vhosts: node-js-sample.dokku.org Domains global enabled: true Domains global vhosts: dokku.org =====> python-sample domains information Domains app enabled: true Domains app vhosts: python-sample.dokku.org Domains global enabled: true Domains global vhosts: dokku.org =====> ruby-sample domains information Domains app enabled: true Domains app vhosts: ruby-sample.dokku.org Domains global enabled: true Domains global vhosts: dokku.org You can run the command for a specific app also. dokku domains:report node-js-app =====> node-js-app domains information Domains app enabled: true Domains app vhosts: node-js-app.dokku.org Domains global enabled: true Domains global vhosts: dokku.org You can pass flags which will output only the value of the specific information you want. For example: dokku domains:report node-js-app --domains-app-enabled","title":"Displaying domains reports about an app"},{"location":"configuration/domains/#default-site","text":"By default, Dokku will route any received request with an unknown HOST header value to the lexicographically first site in the nginx config stack. If this is not the desired behavior, you may want to add the following configuration to the global nginx configuration. Create the file at /etc/nginx/conf.d/00-default-vhost.conf : server { listen 80 default_server ; server_name _ ; access_log off ; return 410 ; } # To handle HTTPS requests, you can uncomment the following section. # # Please note that in order to let this work as expected, you need a valid # SSL certificate for any domains being served. Browsers will show SSL # errors in all other cases. # # Note that the key and certificate files in the below example need to # be copied into /etc/nginx/ssl/ folder. # # server { # listen 443 ssl; # server_name _; # ssl_certificate /etc/nginx/ssl/cert.crt; # ssl_certificate_key /etc/nginx/ssl/cert.key; # access_log off; # return 410; # } Make sure to reload nginx after creating this file by running service nginx reload . This will catch all unknown HOST header values and return a 410 Gone response. You can replace the return 410; with return 444; which will cause nginx to not respond to requests that do not match known domains (connection refused). The configuration file must be loaded before /etc/nginx/conf.d/dokku.conf , so it can not be arranged as a vhost in /etc/nginx/sites-enabled that is only processed afterwards. Alternatively, you may push an app to your Dokku host with a name like \"00-default\". As long as it lists first in ls /home/dokku/*/nginx.conf | head , it will be used as the default nginx vhost.","title":"Default site"},{"location":"configuration/environment-variables/","text":"Environment Variables Typically an application will require some configuration to run properly. Dokku supports application configuration via environment variables. Environment variables may contain private data, such as passwords or API keys, so it is not recommended to store them in your application's repository. The config plugin provides the following commands to manage your variables: config (<app>|--global) Pretty-print an app or global environment config:get (<app>|--global) KEY Display a global or app-specific config value config:set [--encoded] [--no-restart] (<app>|--global) KEY1=VALUE1 [KEY2=VALUE2 ...] Set one or more config vars config:unset [--no-restart] (<app>|--global) KEY1 [KEY2 ...] Unset one or more config vars config:export (<app>|--global) [--envfile] Export a global or app environment config:keys (<app>|--global) [--merged] Show keys set in environment config:bundle (<app>|--global) [--merged] Bundle environment into tarfile For security reasons - and as per docker recommendations - Dockerfile-based deploys have variables available only during runtime, as noted in this issue . Environment variables are available both at run time and during the application build/compilation step for buildpack-based deploys. For buildpack deploys, Dokku will create a /app/.env file that can be used for legacy buildpacks. Note that this is not updated when config:set or config:unset is called, and is only written during a deploy or ps:rebuild . Developers are encouraged to instead read from the application environment directly, as the proper values will be available then. Note: Global ENV files are sourced before app-specific ENV files. This means that app-specific variables will take precedence over global variables. Configuring your global ENV file is manual, and should be considered potentially dangerous as configuration applies to all applications. You can set multiple environment variables at once: dokku config:set node-js-app ENV = prod COMPILE_ASSETS = 1 Note: Whitespace and special characters get tricky. If you are using dokku locally you don't need to do any special escaping. If you are using dokku over ssh you will need to backslash-escape spaces: dokku config:set node-js-app KEY = \"VAL\\ WITH\\ SPACES\" Dokku can also read base64 encoded values. That's the easiest way to set a value with newlines or spaces. To set a value with newlines you need to base64 encode it first and pass the --encoded flag: dokku config:set --encoded node-js-app KEY = \" $( base64 ~/.ssh/id_rsa ) \" When setting or unsetting environment variables, you may wish to avoid an application restart. This is useful when developing plugins or when setting multiple environment variables in a scripted manner. To do so, use the --no-restart flag: dokku config:set --no-restart node-js-app ENV = prod If you wish to have the variables output in an eval -compatible form, you can use the config:export command dokku config:export node-js-app # outputs variables in the form: # # export ENV='prod' # export COMPILE_ASSETS='1' # source in all the node-js-app app environment variables eval $( dokku config:export node-js-app ) You can control the format of the exported variables with the --format flag. --format=shell will output the variables in a single-line for usage in command-line utilities: dokku config:export --format shell node-js-app # outputs variables in the form: # # ENV='prod' COMPILE_ASSETS='1' Special Config Variables The following list config variables have special meaning and can be set in a variety of ways. Warning: This list is not exhaustive, and may vary from version to version. Name Default How to modify Description DOKKU_ROOT ~dokku /etc/environment The root directory where dokku will store application repositories, as well as certain configuration files. DOKKU_IMAGE gliderlabs/herokuish /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The default image to use when building herokuish containers. DOKKU_LIB_ROOT /var/lib/dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory where plugins, certain data, and general configuration is stored. PLUGIN_PATH $DOKKU_LIB_ROOT/plugins\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The top-level directory where plugins are stored. PLUGIN_AVAILABLE_PATH $PLUGIN_PATH/available\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that holds all available plugins, including core. PLUGIN_ENABLED_PATH $PLUGIN_PATH/enabled\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that holds all enabled plugins, including core. PLUGIN_CORE_PATH $DOKKU_LIB_ROOT/core-plugins\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that stores all core plugins. PLUGIN_CORE_AVAILABLE_PATH $PLUGIN_CORE_PATH/available\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that stores all available core plugins. PLUGIN_CORE_ENABLED_PATH $PLUGIN_CORE_PATH/enabled\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that stores all enabled core plugins. DOKKU_LOGS_DIR /var/log/dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Where dokku logs should be written to. DOKKU_EVENTS_LOGFILE $DOKKU_LOGS_DIR/events.log /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Where the events log file is written to. DOKKU_APP_NAME none --app APP flag Name of application to work on. Respected by core plugins. DOKKU_APPS_FORCE_DELETE none --force flag Whether to force delete an application. Also used by other plugins for destructive actions. DOKKU_DETACH_CONTAINER none --detach flag Whether to detach a container started via dokku run . DOKKU_QUIET_OUTPUT none --quiet flag Silences certain header output for dokku commands. DOKKU_RM_CONTAINER none dokku config:set --rm-container flag --rm flag Whether to keep dokku run containers around or not. DOKKU_TRACE none dokku trace on dokku trace false --trace flag Turn on very verbose debugging. DOKKU_APP_PROXY_TYPE nginx dokku proxy:set DOKKU_APP_RESTORE 1 dokku config:set dokku ps:stop DOKKU_APP_SHELL /bin/bash dokku config:set Allows users to change the default shell used by Dokku for dokku enter and execution of deployment tasks. DOKKU_APP_TYPE herokuish Auto-detected by using buildpacks or dockerfile DOKKU_CHECKS_DISABLED none dokku checks:disable DOKKU_CHECKS_ENABLED none dokku checks:enable DOKKU_CHECKS_SKIPPED none dokku checks:skip DOKKU_CHECKS_WAIT 5 dokku config:set Wait this many seconds for the container to start before running checks. DOKKU_CHECKS_TIMEOUT 30 dokku config:set Wait this many seconds for each response before marking it as a failure. DOKKU_CHECKS_ATTEMPTS 5 dokku config:set Number of retries for to run for a specific check before marking it as a failure DOKKU_DEFAULT_CHECKS_WAIT 10 dokku config:set If no user-defined checks are specified - or if the process being checked is not a web process - this is the period of time Dokku will wait before checking that a container is still running. DOKKU_DISABLE_PROXY none dokku proxy:disable dokku proxy:enable Disables the proxy in front of your application, resulting in publicly routing the docker container. DOKKU_DISABLE_ANSI_PREFIX_REMOVAL none dokku config:set /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Disables removal of the ANSI prefix during deploys. Can be used in cases where the client deployer does not understand ansi escape codes. DOKKU_DISABLE_APP_AUTOCREATION none dokku config:set Disables automatic creation of a non-existent app on deploy. DOKKU_DOCKER_STOP_TIMEOUT 10 dokku config:set Configurable grace period given to the docker stop command. If a container has not stopped by this time, a kill -9 signal or equivalent is sent in order to force-terminate the container. Both the ps:stop and apps:destroy commands also respect this value. If not specified, the docker defaults for the docker stop command will be used. DOKKU_DOCKERFILE_CMD dockerfile cmd dokku config:set DOKKU_DOCKERFILE_CACHE_BUILD none dokku config:set DOKKU_DOCKERFILE_ENTRYPOINT dockerfile entrypoint dokku config:set DOKKU_DOCKERFILE_PORTS dockerfile ports dokku config:set DOKKU_DOCKERFILE_START_CMD none dokku config:set DOKKU_PROXY_PORT automatically assigned dokku config:set DOKKU_PROXY_SSL_PORT automatically assigned dokku config:set DOKKU_PROXY_PORT_MAP automatically assigned dokku proxy:ports-add dokku proxy:ports-remove , dokku proxy:ports-clear DOKKU_SKIP_ALL_CHECKS none dokku config:set DOKKU_SKIP_CLEANUP /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* When a deploy is triggered, if this is set to a non-empty value, then old docker containers and images will not be removed. DOKKU_SKIP_DEFAULT_CHECKS dokku config:set DOKKU_SKIP_DEPLOY dokku config:set DOKKU_SYSTEM_GROUP dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* System group to chown files as. DOKKU_SYSTEM_USER dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* System user to chown files as. DOKKU_WAIT_TO_RETIRE 60 dokku config:set After a successful deploy, the grace period given to old containers before they are stopped/terminated. This is useful for ensuring completion of long-running http connections.","title":"Environment Variables"},{"location":"configuration/environment-variables/#environment-variables","text":"Typically an application will require some configuration to run properly. Dokku supports application configuration via environment variables. Environment variables may contain private data, such as passwords or API keys, so it is not recommended to store them in your application's repository. The config plugin provides the following commands to manage your variables: config (<app>|--global) Pretty-print an app or global environment config:get (<app>|--global) KEY Display a global or app-specific config value config:set [--encoded] [--no-restart] (<app>|--global) KEY1=VALUE1 [KEY2=VALUE2 ...] Set one or more config vars config:unset [--no-restart] (<app>|--global) KEY1 [KEY2 ...] Unset one or more config vars config:export (<app>|--global) [--envfile] Export a global or app environment config:keys (<app>|--global) [--merged] Show keys set in environment config:bundle (<app>|--global) [--merged] Bundle environment into tarfile For security reasons - and as per docker recommendations - Dockerfile-based deploys have variables available only during runtime, as noted in this issue . Environment variables are available both at run time and during the application build/compilation step for buildpack-based deploys. For buildpack deploys, Dokku will create a /app/.env file that can be used for legacy buildpacks. Note that this is not updated when config:set or config:unset is called, and is only written during a deploy or ps:rebuild . Developers are encouraged to instead read from the application environment directly, as the proper values will be available then. Note: Global ENV files are sourced before app-specific ENV files. This means that app-specific variables will take precedence over global variables. Configuring your global ENV file is manual, and should be considered potentially dangerous as configuration applies to all applications. You can set multiple environment variables at once: dokku config:set node-js-app ENV = prod COMPILE_ASSETS = 1 Note: Whitespace and special characters get tricky. If you are using dokku locally you don't need to do any special escaping. If you are using dokku over ssh you will need to backslash-escape spaces: dokku config:set node-js-app KEY = \"VAL\\ WITH\\ SPACES\" Dokku can also read base64 encoded values. That's the easiest way to set a value with newlines or spaces. To set a value with newlines you need to base64 encode it first and pass the --encoded flag: dokku config:set --encoded node-js-app KEY = \" $( base64 ~/.ssh/id_rsa ) \" When setting or unsetting environment variables, you may wish to avoid an application restart. This is useful when developing plugins or when setting multiple environment variables in a scripted manner. To do so, use the --no-restart flag: dokku config:set --no-restart node-js-app ENV = prod If you wish to have the variables output in an eval -compatible form, you can use the config:export command dokku config:export node-js-app # outputs variables in the form: # # export ENV='prod' # export COMPILE_ASSETS='1' # source in all the node-js-app app environment variables eval $( dokku config:export node-js-app ) You can control the format of the exported variables with the --format flag. --format=shell will output the variables in a single-line for usage in command-line utilities: dokku config:export --format shell node-js-app # outputs variables in the form: # # ENV='prod' COMPILE_ASSETS='1'","title":"Environment Variables"},{"location":"configuration/environment-variables/#special-config-variables","text":"The following list config variables have special meaning and can be set in a variety of ways. Warning: This list is not exhaustive, and may vary from version to version. Name Default How to modify Description DOKKU_ROOT ~dokku /etc/environment The root directory where dokku will store application repositories, as well as certain configuration files. DOKKU_IMAGE gliderlabs/herokuish /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The default image to use when building herokuish containers. DOKKU_LIB_ROOT /var/lib/dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory where plugins, certain data, and general configuration is stored. PLUGIN_PATH $DOKKU_LIB_ROOT/plugins\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The top-level directory where plugins are stored. PLUGIN_AVAILABLE_PATH $PLUGIN_PATH/available\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that holds all available plugins, including core. PLUGIN_ENABLED_PATH $PLUGIN_PATH/enabled\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that holds all enabled plugins, including core. PLUGIN_CORE_PATH $DOKKU_LIB_ROOT/core-plugins\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that stores all core plugins. PLUGIN_CORE_AVAILABLE_PATH $PLUGIN_CORE_PATH/available\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that stores all available core plugins. PLUGIN_CORE_ENABLED_PATH $PLUGIN_CORE_PATH/enabled\" /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* The directory that stores all enabled core plugins. DOKKU_LOGS_DIR /var/log/dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Where dokku logs should be written to. DOKKU_EVENTS_LOGFILE $DOKKU_LOGS_DIR/events.log /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Where the events log file is written to. DOKKU_APP_NAME none --app APP flag Name of application to work on. Respected by core plugins. DOKKU_APPS_FORCE_DELETE none --force flag Whether to force delete an application. Also used by other plugins for destructive actions. DOKKU_DETACH_CONTAINER none --detach flag Whether to detach a container started via dokku run . DOKKU_QUIET_OUTPUT none --quiet flag Silences certain header output for dokku commands. DOKKU_RM_CONTAINER none dokku config:set --rm-container flag --rm flag Whether to keep dokku run containers around or not. DOKKU_TRACE none dokku trace on dokku trace false --trace flag Turn on very verbose debugging. DOKKU_APP_PROXY_TYPE nginx dokku proxy:set DOKKU_APP_RESTORE 1 dokku config:set dokku ps:stop DOKKU_APP_SHELL /bin/bash dokku config:set Allows users to change the default shell used by Dokku for dokku enter and execution of deployment tasks. DOKKU_APP_TYPE herokuish Auto-detected by using buildpacks or dockerfile DOKKU_CHECKS_DISABLED none dokku checks:disable DOKKU_CHECKS_ENABLED none dokku checks:enable DOKKU_CHECKS_SKIPPED none dokku checks:skip DOKKU_CHECKS_WAIT 5 dokku config:set Wait this many seconds for the container to start before running checks. DOKKU_CHECKS_TIMEOUT 30 dokku config:set Wait this many seconds for each response before marking it as a failure. DOKKU_CHECKS_ATTEMPTS 5 dokku config:set Number of retries for to run for a specific check before marking it as a failure DOKKU_DEFAULT_CHECKS_WAIT 10 dokku config:set If no user-defined checks are specified - or if the process being checked is not a web process - this is the period of time Dokku will wait before checking that a container is still running. DOKKU_DISABLE_PROXY none dokku proxy:disable dokku proxy:enable Disables the proxy in front of your application, resulting in publicly routing the docker container. DOKKU_DISABLE_ANSI_PREFIX_REMOVAL none dokku config:set /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* Disables removal of the ANSI prefix during deploys. Can be used in cases where the client deployer does not understand ansi escape codes. DOKKU_DISABLE_APP_AUTOCREATION none dokku config:set Disables automatic creation of a non-existent app on deploy. DOKKU_DOCKER_STOP_TIMEOUT 10 dokku config:set Configurable grace period given to the docker stop command. If a container has not stopped by this time, a kill -9 signal or equivalent is sent in order to force-terminate the container. Both the ps:stop and apps:destroy commands also respect this value. If not specified, the docker defaults for the docker stop command will be used. DOKKU_DOCKERFILE_CMD dockerfile cmd dokku config:set DOKKU_DOCKERFILE_CACHE_BUILD none dokku config:set DOKKU_DOCKERFILE_ENTRYPOINT dockerfile entrypoint dokku config:set DOKKU_DOCKERFILE_PORTS dockerfile ports dokku config:set DOKKU_DOCKERFILE_START_CMD none dokku config:set DOKKU_PROXY_PORT automatically assigned dokku config:set DOKKU_PROXY_SSL_PORT automatically assigned dokku config:set DOKKU_PROXY_PORT_MAP automatically assigned dokku proxy:ports-add dokku proxy:ports-remove , dokku proxy:ports-clear DOKKU_SKIP_ALL_CHECKS none dokku config:set DOKKU_SKIP_CLEANUP /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* When a deploy is triggered, if this is set to a non-empty value, then old docker containers and images will not be removed. DOKKU_SKIP_DEFAULT_CHECKS dokku config:set DOKKU_SKIP_DEPLOY dokku config:set DOKKU_SYSTEM_GROUP dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* System group to chown files as. DOKKU_SYSTEM_USER dokku /etc/environment ~dokku/.dokkurc ~dokku/.dokkurc/* System user to chown files as. DOKKU_WAIT_TO_RETIRE 60 dokku config:set After a successful deploy, the grace period given to old containers before they are stopped/terminated. This is useful for ensuring completion of long-running http connections.","title":"Special Config Variables"},{"location":"configuration/nginx/","text":"Nginx Configuration Dokku uses nginx as its server for routing requests to specific applications. By default, access and error logs are written for each app to /var/log/nginx/${APP}-access.log and /var/log/nginx/${APP}-error.log respectively nginx:access-logs <app> [-t] # Show the nginx access logs for an application (-t follows) nginx:build-config <app> # (Re)builds nginx config for given app nginx:error-logs <app> [-t] # Show the nginx error logs for an application (-t follows) nginx:validate [<app>] [--clean] # Validates and optionally cleans up invalid nginx configurations Checking access logs You may check nginx access logs via the nginx:access-logs command. This assumes that app access logs are being stored in /var/log/nginx/$APP-access.log , as is the default in the generated nginx.conf . dokku nginx:access-logs node-js-app You may also follow the logs by specifying the -t flag. dokku nginx:access-logs node-js-app -t Checking error logs You may check nginx error logs via the nginx:access-logs command. This assumes that app error logs are being stored in /var/log/nginx/$APP-error.log , as is the default in the generated nginx.conf . dokku nginx:error-logs node-js-app You may also follow the logs by specifying the -t flag. dokku nginx:error-logs node-js-app -t Regenerating nginx config In certain cases, your app nginx configs may drift from the correct config for your app. You may regenerate the config at any point via the nginx:build-config command. This may fail if there are no current web listeners for your app. dokku nginx:build-config node-js-app Validating nginx configs It may be desired to validate an nginx config outside of the deployment process. To do so, run the nginx:validate command. With no arguments, this will validate all app nginx configs, one at a time. A minimal wrapper nginx config is generated for each app's nginx config, upon which nginx -t will be run. dokku nginx:validate As app nginx configs are actually executed within a shared context, it is possible for an individual config to be invalid when being validated standalone but also be valid within the global server context. As such, the exit code for the nginx:validate command is the exit code of nginx -t against the server's real nginx config. The nginx:validate command also takes an optional --clean flag. If specified, invalid nginx configs will be removed. Warning: Invalid app nginx config's will be removed even if the config is valid in the global server context. dokku nginx:validate --clean The --clean flag may also be specified for a given app: dokku nginx:validate node-js-app --clean Customizing the nginx configuration New as of 0.5.0 Dokku uses a templating library by the name of sigil to generate nginx configuration for each app. You may also provide a custom template for your application as follows: Copy the following example template to a file named nginx.conf.sigil and either: If using a buildpack application, you must check it into the root of your app repo. ADD it to your dockerfile WORKDIR if your dockerfile has no WORKDIR , ADD it to the /app folder When using a custom nginx.conf.sigil file, depending upon your application configuration, you may be exposing the file externally. As this file is extracted before the container is run, you can, safely delete it in a custom entrypoint.sh configured in a Dockerfile ENTRYPOINT . The default template is available here , and can be used as a guide for your own, custom nginx.conf.sigil file. Please refer to the appropriate template file version for your Dokku version. Available template variables {{ .APP }} Application name {{ .APP_SSL_PATH }} Path to SSL certificate and key {{ .DOKKU_ROOT }} Global Dokku root directory (ex: app dir would be `{{ .DOKKU_ROOT }}/{{ .APP }}`) {{ .DOKKU_APP_LISTENERS }} List of IP:PORT pairs of app containers {{ .PROXY_PORT }} Non-SSL nginx listener port (same as `DOKKU_PROXY_PORT` config var) {{ .PROXY_SSL_PORT }} SSL nginx listener port (same as `DOKKU_PROXY_SSL_PORT` config var) {{ .NOSSL_SERVER_NAME }} List of non-SSL VHOSTS {{ .PROXY_PORT_MAP }} List of port mappings (same as `DOKKU_PROXY_PORT_MAP` config var) {{ .PROXY_UPSTREAM_PORTS }} List of configured upstream ports (derived from `DOKKU_PROXY_PORT_MAP` config var) {{ .RAW_TCP_PORTS }} List of exposed tcp ports as defined by Dockerfile `EXPOSE` directive (**Dockerfile apps only**) {{ .SSL_INUSE }} Boolean set when an app is SSL-enabled {{ .SSL_SERVER_NAME }} List of SSL VHOSTS Note: Application config variables are available for use in custom templates. To do so, use the form of {{ var \"FOO\" }} to access a variable named FOO . Customizing via configuration files included by the default templates The default nginx.conf template will include everything from your apps nginx.conf.d/ subdirectory in the main server {} block (see above): include {{ .DOKKU_ROOT }}/{{ .APP }}/nginx.conf.d/*.conf; That means you can put additional configuration in separate files, for example to limit the uploaded body size to 50 megabytes, do mkdir /home/dokku/node-js-app/nginx.conf.d/ echo 'client_max_body_size 50m;' > /home/dokku/node-js-app/nginx.conf.d/upload.conf chown dokku:dokku /home/dokku/node-js-app/nginx.conf.d/upload.conf service nginx reload The example above uses additional configuration files directly on the Dokku host. Unlike the nginx.conf.sigil file, these additional files will not be copied over from your application repo, and thus need to be placed in the /home/dokku/node-js-app/nginx.conf.d/ directory manually. For PHP Buildpack users, you will also need to provide a Procfile and an accompanying nginx.conf file to customize the nginx config within the container. The following are example contents for your Procfile web: vendor/bin/heroku-php-nginx -C nginx.conf -i php.ini php/ Your nginx.conf file - not to be confused with Dokku's nginx.conf.sigil - would also need to be configured as shown in this example: client_max_body_size 50m; location / { index index.php; try_files $uri $uri/ /index.php$is_args$args; } Please adjust the Procfile and nginx.conf file as appropriate. Custom Error Pages By default, Dokku provides custom error pages for the following three categories of errors: 4xx: For all non-404 errors with a 4xx response code. 404: For \"404 Not Found\" errors. 5xx: For all 5xx error responses These are provided as an alternative to the generic Nginx error page, are shared for all applications, and their contents are located on disk at /var/lib/dokku/data/nginx-vhosts/dokku-errors . To customize them for a specific app, create a custom nginx.conf.sigil as described above and change the paths to point elsewhere. Domains plugin See the domain configuration documentation . Customizing hostnames See the customizing hostnames documentation . Disabling VHOSTS See the disabling vhosts documentation . Default site See the default site documentation . Running behind a load balancer See the load balancer documentation . HSTS Header See the HSTS documentation . SSL Configuration See the ssl documentation . Disabling Nginx See the proxy documentation . Managing Proxy Port mappings See the proxy documentation .","title":"Nginx Configuration"},{"location":"configuration/nginx/#nginx-configuration","text":"Dokku uses nginx as its server for routing requests to specific applications. By default, access and error logs are written for each app to /var/log/nginx/${APP}-access.log and /var/log/nginx/${APP}-error.log respectively nginx:access-logs <app> [-t] # Show the nginx access logs for an application (-t follows) nginx:build-config <app> # (Re)builds nginx config for given app nginx:error-logs <app> [-t] # Show the nginx error logs for an application (-t follows) nginx:validate [<app>] [--clean] # Validates and optionally cleans up invalid nginx configurations","title":"Nginx Configuration"},{"location":"configuration/nginx/#checking-access-logs","text":"You may check nginx access logs via the nginx:access-logs command. This assumes that app access logs are being stored in /var/log/nginx/$APP-access.log , as is the default in the generated nginx.conf . dokku nginx:access-logs node-js-app You may also follow the logs by specifying the -t flag. dokku nginx:access-logs node-js-app -t","title":"Checking access logs"},{"location":"configuration/nginx/#checking-error-logs","text":"You may check nginx error logs via the nginx:access-logs command. This assumes that app error logs are being stored in /var/log/nginx/$APP-error.log , as is the default in the generated nginx.conf . dokku nginx:error-logs node-js-app You may also follow the logs by specifying the -t flag. dokku nginx:error-logs node-js-app -t","title":"Checking error logs"},{"location":"configuration/nginx/#regenerating-nginx-config","text":"In certain cases, your app nginx configs may drift from the correct config for your app. You may regenerate the config at any point via the nginx:build-config command. This may fail if there are no current web listeners for your app. dokku nginx:build-config node-js-app","title":"Regenerating nginx config"},{"location":"configuration/nginx/#validating-nginx-configs","text":"It may be desired to validate an nginx config outside of the deployment process. To do so, run the nginx:validate command. With no arguments, this will validate all app nginx configs, one at a time. A minimal wrapper nginx config is generated for each app's nginx config, upon which nginx -t will be run. dokku nginx:validate As app nginx configs are actually executed within a shared context, it is possible for an individual config to be invalid when being validated standalone but also be valid within the global server context. As such, the exit code for the nginx:validate command is the exit code of nginx -t against the server's real nginx config. The nginx:validate command also takes an optional --clean flag. If specified, invalid nginx configs will be removed. Warning: Invalid app nginx config's will be removed even if the config is valid in the global server context. dokku nginx:validate --clean The --clean flag may also be specified for a given app: dokku nginx:validate node-js-app --clean","title":"Validating nginx configs"},{"location":"configuration/nginx/#customizing-the-nginx-configuration","text":"New as of 0.5.0 Dokku uses a templating library by the name of sigil to generate nginx configuration for each app. You may also provide a custom template for your application as follows: Copy the following example template to a file named nginx.conf.sigil and either: If using a buildpack application, you must check it into the root of your app repo. ADD it to your dockerfile WORKDIR if your dockerfile has no WORKDIR , ADD it to the /app folder When using a custom nginx.conf.sigil file, depending upon your application configuration, you may be exposing the file externally. As this file is extracted before the container is run, you can, safely delete it in a custom entrypoint.sh configured in a Dockerfile ENTRYPOINT . The default template is available here , and can be used as a guide for your own, custom nginx.conf.sigil file. Please refer to the appropriate template file version for your Dokku version.","title":"Customizing the nginx configuration"},{"location":"configuration/nginx/#available-template-variables","text":"{{ .APP }} Application name {{ .APP_SSL_PATH }} Path to SSL certificate and key {{ .DOKKU_ROOT }} Global Dokku root directory (ex: app dir would be `{{ .DOKKU_ROOT }}/{{ .APP }}`) {{ .DOKKU_APP_LISTENERS }} List of IP:PORT pairs of app containers {{ .PROXY_PORT }} Non-SSL nginx listener port (same as `DOKKU_PROXY_PORT` config var) {{ .PROXY_SSL_PORT }} SSL nginx listener port (same as `DOKKU_PROXY_SSL_PORT` config var) {{ .NOSSL_SERVER_NAME }} List of non-SSL VHOSTS {{ .PROXY_PORT_MAP }} List of port mappings (same as `DOKKU_PROXY_PORT_MAP` config var) {{ .PROXY_UPSTREAM_PORTS }} List of configured upstream ports (derived from `DOKKU_PROXY_PORT_MAP` config var) {{ .RAW_TCP_PORTS }} List of exposed tcp ports as defined by Dockerfile `EXPOSE` directive (**Dockerfile apps only**) {{ .SSL_INUSE }} Boolean set when an app is SSL-enabled {{ .SSL_SERVER_NAME }} List of SSL VHOSTS Note: Application config variables are available for use in custom templates. To do so, use the form of {{ var \"FOO\" }} to access a variable named FOO .","title":"Available template variables"},{"location":"configuration/nginx/#customizing-via-configuration-files-included-by-the-default-templates","text":"The default nginx.conf template will include everything from your apps nginx.conf.d/ subdirectory in the main server {} block (see above): include {{ .DOKKU_ROOT }}/{{ .APP }}/nginx.conf.d/*.conf; That means you can put additional configuration in separate files, for example to limit the uploaded body size to 50 megabytes, do mkdir /home/dokku/node-js-app/nginx.conf.d/ echo 'client_max_body_size 50m;' > /home/dokku/node-js-app/nginx.conf.d/upload.conf chown dokku:dokku /home/dokku/node-js-app/nginx.conf.d/upload.conf service nginx reload The example above uses additional configuration files directly on the Dokku host. Unlike the nginx.conf.sigil file, these additional files will not be copied over from your application repo, and thus need to be placed in the /home/dokku/node-js-app/nginx.conf.d/ directory manually. For PHP Buildpack users, you will also need to provide a Procfile and an accompanying nginx.conf file to customize the nginx config within the container. The following are example contents for your Procfile web: vendor/bin/heroku-php-nginx -C nginx.conf -i php.ini php/ Your nginx.conf file - not to be confused with Dokku's nginx.conf.sigil - would also need to be configured as shown in this example: client_max_body_size 50m; location / { index index.php; try_files $uri $uri/ /index.php$is_args$args; } Please adjust the Procfile and nginx.conf file as appropriate.","title":"Customizing via configuration files included by the default templates"},{"location":"configuration/nginx/#custom-error-pages","text":"By default, Dokku provides custom error pages for the following three categories of errors: 4xx: For all non-404 errors with a 4xx response code. 404: For \"404 Not Found\" errors. 5xx: For all 5xx error responses These are provided as an alternative to the generic Nginx error page, are shared for all applications, and their contents are located on disk at /var/lib/dokku/data/nginx-vhosts/dokku-errors . To customize them for a specific app, create a custom nginx.conf.sigil as described above and change the paths to point elsewhere.","title":"Custom Error Pages"},{"location":"configuration/nginx/#domains-plugin","text":"See the domain configuration documentation .","title":"Domains plugin"},{"location":"configuration/nginx/#customizing-hostnames","text":"See the customizing hostnames documentation .","title":"Customizing hostnames"},{"location":"configuration/nginx/#disabling-vhosts","text":"See the disabling vhosts documentation .","title":"Disabling VHOSTS"},{"location":"configuration/nginx/#default-site","text":"See the default site documentation .","title":"Default site"},{"location":"configuration/nginx/#running-behind-a-load-balancer","text":"See the load balancer documentation .","title":"Running behind a load balancer"},{"location":"configuration/nginx/#hsts-header","text":"See the HSTS documentation .","title":"HSTS Header"},{"location":"configuration/nginx/#ssl-configuration","text":"See the ssl documentation .","title":"SSL Configuration"},{"location":"configuration/nginx/#disabling-nginx","text":"See the proxy documentation .","title":"Disabling Nginx"},{"location":"configuration/nginx/#managing-proxy-port-mappings","text":"See the proxy documentation .","title":"Managing Proxy Port mappings"},{"location":"configuration/ssl/","text":"SSL Configuration New as of 0.4.0 Dokku supports SSL/TLS certificate inspection and CSR/Self-signed certificate generation via the certs plugin. Note that whenever SSL/TLS support is enabled SPDY is also enabled. certs:add <app> CRT KEY # Add an ssl endpoint to an app. Can also import from a tarball on stdin. certs:generate <app> DOMAIN # Generate a key and certificate signing request (and self-signed certificate) certs:remove <app> # Remove an SSL Endpoint from an app. certs:report [<app>] [<flag>] # Displays an ssl report for one or more apps certs:update <app> CRT KEY # Update an SSL Endpoint on an app. Can also import from a tarball on stdin # for 0.3.x dokku nginx:import-ssl <app> < certs.tar Adding an ssl certificate before deploying an application will result in port mappings being updated. This may cause issues for applications that use non-standard ports, as those may not be automatically detected. Please refer to the proxy documentation for information as to how to reconfigure the mappings. Per-application certificate management Dokku provides built-in support for managing SSL certificates on a per-application basis. SSL is managed via nginx outside of application containers, and as such can be updated on-the-fly without rebuilding containers. At this time, applications only support a single SSL certificate at a time. To support multiple domains for a single application, wildcard certificate usage is encouraged. Certificate setting The certs:add command can be used to push a tar containing a certificate .crt and .key file to a single application. The command should correctly handle cases where the .crt and .key are not named properly or are nested in a subdirectory of said tar file. You can import it as follows: tar cvf cert-key.tar server.crt server.key dokku certs:add node-js-app < cert-key.tar Note: If your .crt file came alongside a .ca-bundle , you'll want to concatenate those into a single .crt file before adding it to the .tar . cat yourdomain_com.crt yourdomain_com.ca-bundle > server.crt SSL and Multiple Domains When an SSL certificate is associated to an application, the certificate will be associated with all domains currently associated with said application. Your certificate should be associated with all of those domains, otherwise accessing the application will result in SSL errors. If you wish to remove one of the domains from the application, refer to the domain configuration documentation . Note that with the default nginx template, requests will be redirected to the https version of the domain. If this is not the desired state of request resolution, you may customize the nginx template in use. For more details, see the nginx documentation . Certificate generation Note: Using this method will create a self-signed certificate, which is only recommended for development or staging use, not production environments. The certs:generate command will walk you through the correct openssl commands to create a key, csr and a self-signed cert for a given app/domain. We automatically put the self-signed cert in place as well as add the specified domain to the application configuration. If you decide to obtain a CA signed certificate, you can import that certificate using the aforementioned dokku certs:add command. Certificate removal The certs:remove command only works on app-specific certificates. It will rm the app-specific tls directory, rebuild the nginx configuration, and reload nginx. Displaying certificate reports about an app New as of 0.8.1 You can get a report about the apps ssl status using the certs:report command: dokku certs:report =====> node-js-sample Ssl dir: /home/dokku/node-js-sample/tls Ssl enabled: true Ssl hostnames: *.node-js-sample.org node-js-sample.org Ssl expires at: Oct 5 23:59:59 2019 GMT Ssl issuer: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited, CN=COMODO RSA Domain Validation Secure Server CA Ssl starts at: Oct 5 00:00:00 2016 GMT Ssl subject: OU=Domain Control Validated; OU=PositiveSSL Wildcard; CN=*.node-js-sample.org Ssl verified: self signed. =====> python-sample Ssl dir: /home/dokku/python-sample/tls Ssl enabled: false Ssl hostnames: Ssl expires at: Ssl issuer: Ssl starts at: Ssl subject: Ssl verified: You can run the command for a specific app also. dokku certs:report node-js-sample =====> node-js-sample ssl information Ssl dir: /home/dokku/node-js-sample/tls Ssl enabled: true Ssl hostnames: *.dokku.org dokku.org Ssl expires at: Oct 5 23:59:59 2019 GMT Ssl issuer: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited, CN=COMODO RSA Domain Validation Secure Server CA Ssl starts at: Oct 5 00:00:00 2016 GMT Ssl subject: OU=Domain Control Validated; OU=PositiveSSL Wildcard; CN=*.dokku.org Ssl verified: self signed. You can pass flags which will output only the value of the specific information you want. For example: dokku certs:report node-js-sample --ssl-enabled HSTS Header The HSTS header is an HTTP header that can inform browsers that all requests to a given site should be made via HTTPS. Dokku does not, by default, enable this header. It is thus left up to you, the user, to enable it for your site. Beware that if you enable the header and a subsequent deploy of your application results in an HTTP deploy (for whatever reason), the way the header works means that a browser will not attempt to request the HTTP version of your site if the HTTPS version fails. HTTP/2 support Certain versions of nginx have bugs that prevent HTTP/2 from properly responding to all clients, thus causing applications to be unavailable. For HTTP/2 to be enabled in your applications' nginx configs, you need to have installed nginx 1.11.5 or higher. See issue 2435 for more details. Running behind a load balancer Your application has access to the HTTP headers X-Forwarded-Proto , X-Forwarded-Port and X-Forwarded-For . These headers indicate the protocol of the original request (HTTP or HTTPS), the port number, and the IP address of the client making the request, respectively. The default configuration is for Nginx to set these headers. If your server runs behind an HTTP/S load balancer, then Nginx will see all requests as coming from the load balancer. If your load balancer sets the X-Forwarded- headers, you can tell Nginx to pass these headers from load balancer to your application by using the following nginx custom template server { listen [::]:{{ . PROXY_PORT }}; listen {{ . PROXY_PORT }}; server_name {{ . NOSSL_SERVER_NAME }}; access_log / var / log / nginx / {{ . APP }} - access . log ; error_log / var / log / nginx / {{ . APP }} - error . log ; location / { proxy_pass http : //{{ .APP }}; proxy_http_version 1.1 ; proxy_set_header Upgrade $ http_upgrade ; proxy_set_header Connection \"upgrade\" ; proxy_set_header Host $ http_host ; proxy_set_header X - Forwarded - Proto $ http_x_forwarded_proto ; proxy_set_header X - Forwarded - For $ http_x_forwarded_for ; proxy_set_header X - Forwarded - Port $ http_x_forwarded_port ; proxy_set_header X - Request - Start $ msec ; } include {{ . DOKKU_ROOT }} / {{ . APP }} / nginx . conf . d /* . conf ; } upstream {{ . APP }} { {{ range . DOKKU_APP_LISTENERS | split \" \" }} server {{ . }}; {{ end }} } Only use this option if: 1. All requests are terminated at the load balancer, and forwarded to Nginx 2. The load balancer is configured to send the X-Forwarded- headers (this may be off by default) If it's possible to make HTTP/S requests directly to Nginx, bypassing the load balancer, or if the load balancer is not configured to set these headers, then it becomes possible for a client to set these headers to arbitrary values. This could result in security issue, for example, if your application looks at the value of the X-Forwarded-Proto to determine if the request was made over HTTPS. SSL Port Exposure When your app is served from port 80 then the /home/dokku/APP/nginx.conf file will automatically be updated to instruct nginx to respond to ssl on port 443 as a new cert is added. If your app uses a non-standard port (perhaps you have a dockerfile deploy exposing port 99999 ) you may need to manually expose an ssl port via dokku proxy:ports-add <APP> https:443:99999 .","title":"SSL Configuration"},{"location":"configuration/ssl/#ssl-configuration","text":"New as of 0.4.0 Dokku supports SSL/TLS certificate inspection and CSR/Self-signed certificate generation via the certs plugin. Note that whenever SSL/TLS support is enabled SPDY is also enabled. certs:add <app> CRT KEY # Add an ssl endpoint to an app. Can also import from a tarball on stdin. certs:generate <app> DOMAIN # Generate a key and certificate signing request (and self-signed certificate) certs:remove <app> # Remove an SSL Endpoint from an app. certs:report [<app>] [<flag>] # Displays an ssl report for one or more apps certs:update <app> CRT KEY # Update an SSL Endpoint on an app. Can also import from a tarball on stdin # for 0.3.x dokku nginx:import-ssl <app> < certs.tar Adding an ssl certificate before deploying an application will result in port mappings being updated. This may cause issues for applications that use non-standard ports, as those may not be automatically detected. Please refer to the proxy documentation for information as to how to reconfigure the mappings.","title":"SSL Configuration"},{"location":"configuration/ssl/#per-application-certificate-management","text":"Dokku provides built-in support for managing SSL certificates on a per-application basis. SSL is managed via nginx outside of application containers, and as such can be updated on-the-fly without rebuilding containers. At this time, applications only support a single SSL certificate at a time. To support multiple domains for a single application, wildcard certificate usage is encouraged.","title":"Per-application certificate management"},{"location":"configuration/ssl/#certificate-setting","text":"The certs:add command can be used to push a tar containing a certificate .crt and .key file to a single application. The command should correctly handle cases where the .crt and .key are not named properly or are nested in a subdirectory of said tar file. You can import it as follows: tar cvf cert-key.tar server.crt server.key dokku certs:add node-js-app < cert-key.tar Note: If your .crt file came alongside a .ca-bundle , you'll want to concatenate those into a single .crt file before adding it to the .tar . cat yourdomain_com.crt yourdomain_com.ca-bundle > server.crt","title":"Certificate setting"},{"location":"configuration/ssl/#ssl-and-multiple-domains","text":"When an SSL certificate is associated to an application, the certificate will be associated with all domains currently associated with said application. Your certificate should be associated with all of those domains, otherwise accessing the application will result in SSL errors. If you wish to remove one of the domains from the application, refer to the domain configuration documentation . Note that with the default nginx template, requests will be redirected to the https version of the domain. If this is not the desired state of request resolution, you may customize the nginx template in use. For more details, see the nginx documentation .","title":"SSL and Multiple Domains"},{"location":"configuration/ssl/#certificate-generation","text":"Note: Using this method will create a self-signed certificate, which is only recommended for development or staging use, not production environments. The certs:generate command will walk you through the correct openssl commands to create a key, csr and a self-signed cert for a given app/domain. We automatically put the self-signed cert in place as well as add the specified domain to the application configuration. If you decide to obtain a CA signed certificate, you can import that certificate using the aforementioned dokku certs:add command.","title":"Certificate generation"},{"location":"configuration/ssl/#certificate-removal","text":"The certs:remove command only works on app-specific certificates. It will rm the app-specific tls directory, rebuild the nginx configuration, and reload nginx.","title":"Certificate removal"},{"location":"configuration/ssl/#displaying-certificate-reports-about-an-app","text":"New as of 0.8.1 You can get a report about the apps ssl status using the certs:report command: dokku certs:report =====> node-js-sample Ssl dir: /home/dokku/node-js-sample/tls Ssl enabled: true Ssl hostnames: *.node-js-sample.org node-js-sample.org Ssl expires at: Oct 5 23:59:59 2019 GMT Ssl issuer: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited, CN=COMODO RSA Domain Validation Secure Server CA Ssl starts at: Oct 5 00:00:00 2016 GMT Ssl subject: OU=Domain Control Validated; OU=PositiveSSL Wildcard; CN=*.node-js-sample.org Ssl verified: self signed. =====> python-sample Ssl dir: /home/dokku/python-sample/tls Ssl enabled: false Ssl hostnames: Ssl expires at: Ssl issuer: Ssl starts at: Ssl subject: Ssl verified: You can run the command for a specific app also. dokku certs:report node-js-sample =====> node-js-sample ssl information Ssl dir: /home/dokku/node-js-sample/tls Ssl enabled: true Ssl hostnames: *.dokku.org dokku.org Ssl expires at: Oct 5 23:59:59 2019 GMT Ssl issuer: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited, CN=COMODO RSA Domain Validation Secure Server CA Ssl starts at: Oct 5 00:00:00 2016 GMT Ssl subject: OU=Domain Control Validated; OU=PositiveSSL Wildcard; CN=*.dokku.org Ssl verified: self signed. You can pass flags which will output only the value of the specific information you want. For example: dokku certs:report node-js-sample --ssl-enabled","title":"Displaying certificate reports about an app"},{"location":"configuration/ssl/#hsts-header","text":"The HSTS header is an HTTP header that can inform browsers that all requests to a given site should be made via HTTPS. Dokku does not, by default, enable this header. It is thus left up to you, the user, to enable it for your site. Beware that if you enable the header and a subsequent deploy of your application results in an HTTP deploy (for whatever reason), the way the header works means that a browser will not attempt to request the HTTP version of your site if the HTTPS version fails.","title":"HSTS Header"},{"location":"configuration/ssl/#http2-support","text":"Certain versions of nginx have bugs that prevent HTTP/2 from properly responding to all clients, thus causing applications to be unavailable. For HTTP/2 to be enabled in your applications' nginx configs, you need to have installed nginx 1.11.5 or higher. See issue 2435 for more details.","title":"HTTP/2 support"},{"location":"configuration/ssl/#running-behind-a-load-balancer","text":"Your application has access to the HTTP headers X-Forwarded-Proto , X-Forwarded-Port and X-Forwarded-For . These headers indicate the protocol of the original request (HTTP or HTTPS), the port number, and the IP address of the client making the request, respectively. The default configuration is for Nginx to set these headers. If your server runs behind an HTTP/S load balancer, then Nginx will see all requests as coming from the load balancer. If your load balancer sets the X-Forwarded- headers, you can tell Nginx to pass these headers from load balancer to your application by using the following nginx custom template server { listen [::]:{{ . PROXY_PORT }}; listen {{ . PROXY_PORT }}; server_name {{ . NOSSL_SERVER_NAME }}; access_log / var / log / nginx / {{ . APP }} - access . log ; error_log / var / log / nginx / {{ . APP }} - error . log ; location / { proxy_pass http : //{{ .APP }}; proxy_http_version 1.1 ; proxy_set_header Upgrade $ http_upgrade ; proxy_set_header Connection \"upgrade\" ; proxy_set_header Host $ http_host ; proxy_set_header X - Forwarded - Proto $ http_x_forwarded_proto ; proxy_set_header X - Forwarded - For $ http_x_forwarded_for ; proxy_set_header X - Forwarded - Port $ http_x_forwarded_port ; proxy_set_header X - Request - Start $ msec ; } include {{ . DOKKU_ROOT }} / {{ . APP }} / nginx . conf . d /* . conf ; } upstream {{ . APP }} { {{ range . DOKKU_APP_LISTENERS | split \" \" }} server {{ . }}; {{ end }} } Only use this option if: 1. All requests are terminated at the load balancer, and forwarded to Nginx 2. The load balancer is configured to send the X-Forwarded- headers (this may be off by default) If it's possible to make HTTP/S requests directly to Nginx, bypassing the load balancer, or if the load balancer is not configured to set these headers, then it becomes possible for a client to set these headers to arbitrary values. This could result in security issue, for example, if your application looks at the value of the X-Forwarded-Proto to determine if the request was made over HTTPS.","title":"Running behind a load balancer"},{"location":"configuration/ssl/#ssl-port-exposure","text":"When your app is served from port 80 then the /home/dokku/APP/nginx.conf file will automatically be updated to instruct nginx to respond to ssl on port 443 as a new cert is added. If your app uses a non-standard port (perhaps you have a dockerfile deploy exposing port 99999 ) you may need to manually expose an ssl port via dokku proxy:ports-add <APP> https:443:99999 .","title":"SSL Port Exposure"},{"location":"deployment/application-deployment/","text":"Deploying to Dokku Note: This document uses the hostname dokku.me in commands. For your server, please substitute your server's hostname instead. Deploy tutorial Once Dokku has been configured with at least one user, applications can be deployed via a git push command. To quickly see Dokku deployment in action, you can use the Heroku Ruby on Rails example app. # from your local machine # SSH access to github must be enabled on this host git clone git@github.com:heroku/ruby-rails-sample.git Create the app Create the application on the Dokku host. You will need to SSH onto the host to run this command. # on the Dokku host dokku apps:create ruby-rails-sample Create the backing services When you create a new app, Dokku by default does not provide any datastores such as MySQL or PostgreSQL. You will need to install plugins to handle that, but fortunately Dokku has official plugins for common datastores. Our sample app requires a PostgreSQL service: # on the Dokku host # install the postgres plugin # plugin installation requires root, hence the user change sudo dokku plugin:install https://github.com/dokku/dokku-postgres.git # create a postgres service with the name rails-database dokku postgres:create rails-database Each service may take a few moments to create. Linking backing services to applications Once the service creation is complete, set the DATABASE_URL environment variable by linking the service. # on the Dokku host # each official datastore offers a `link` method to link a service to any application dokku postgres:link rails-database ruby-rails-sample You can link a single service to multiple applications or use one service per application. Deploy the app Warning: Your application should respect the PORT environment variable or it may not respond to web requests. Please see the port management documentation for details. Now you can deploy the ruby-rails-sample app to your Dokku server. All you have to do is add a remote to name the app. Applications are created on-the-fly on the Dokku server. # from your local machine # the remote username *must* be dokku or pushes will fail cd ruby-rails-sample git remote add dokku dokku@dokku.me:ruby-rails-sample git push dokku master Note: Some tools may not support the short-upstream syntax referenced above, and you may need to prefix the upstream with the scheme ssh:// like so: ssh://dokku@dokku.me:ruby-rails-sample Please see the Git documentation for more details. Note: Your private key should be registered with ssh-agent in local development. If you get a permission denied error when pushing you can register your private key by running ssh-add -k ~/<your private key> . Counting objects: 231, done. Delta compression using up to 8 threads. Compressing objects: 100% (162/162), done. Writing objects: 100% (231/231), 36.96 KiB | 0 bytes/s, done. Total 231 (delta 93), reused 147 (delta 53) -----> Cleaning up... -----> Building ruby-rails-sample from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.2.1 -----> Installing dependencies using 1.9.7 Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin -j4 --deployment Fetching gem metadata from https://rubygems.org/........... Fetching version metadata from https://rubygems.org/... Fetching dependency metadata from https://rubygems.org/.. Using rake 10.4.2 ... =====> Application deployed: http://ruby-rails-sample.dokku.me When the deploy finishes, the application's URL will be shown as seen above. Dokku supports deploying applications via Heroku buildpacks with Herokuish or using a project's Dockerfile . Skipping deployment If you only want to rebuild and tag a container, you can skip the deployment phase by setting $DOKKU_SKIP_DEPLOY to true by running: # on the Dokku host dokku config:set ruby-rails-sample DOKKU_SKIP_DEPLOY = true Redeploying or restarting If you need to redeploy (or restart) your app: # on the Dokku host dokku ps:rebuild ruby-rails-sample See the process scaling documentation for more information. Deploying with private git submodules Dokku uses Git locally (i.e. not a Docker image) to build its own copy of your app repo, including submodules. This is done as the dokku user. Therefore, in order to deploy private Git submodules, you'll need to drop your deploy key in /home/dokku/.ssh/ and potentially add github.com (or your VCS host key) into /home/dokku/.ssh/known_hosts . The following test should help confirm you've done it correctly. # on the Dokku host su - dokku ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts ssh -T git@github.com Note that if the buildpack or Dockerfile build process require SSH key access for other reasons, the above may not always apply. Deploying to subdomains The name of remote repository is used as the name of application to be deployed, as for example above: # from your local machine # the remote username *must* be dokku or pushes will fail git remote add dokku dokku@dokku.me:ruby-rails-sample git push dokku master remote: -----> Application deployed: remote: http://ruby-rails-sample.dokku.me You can also specify fully qualified names, say app.dokku.me , as # from your local machine # the remote username *must* be dokku or pushes will fail git remote add dokku dokku@dokku.me:app.dokku.me git push dokku master remote: -----> Application deployed: remote: http://app.dokku.me This is in particular useful, then you want to deploy to root domain, as # from your local machine # the remote username *must* be dokku or pushes will fail git remote add dokku dokku@dokku.me:dokku.me git push dokku master ... deployment ... remote: -----> Application deployed: remote: http://dokku.me Dokku/Docker container management compatibility Dokku is, at its core, a Docker container manager. Thus, it does not necessarily play well with other out-of-band processes interacting with the Docker daemon. One thing to note as in issue #1220 , Dokku executes a cleanup function prior to every deployment. As of 0.5.x, this function removes all containers with the label dokku where the status is either dead or exited , as well as all dangling images. Previous versions would remove dead or exited containers, regardless of their label. Adding deploy users See the user management documentation . Default vhost See the nginx documentation . Deploying non-master branch See the Git documentation . Dockerfile deployment See the Dockerfile documentation . Image tagging See the image tagging documentation . Specifying a custom buildpack See the buildpack documentation . Removing a deployed app See the application management documentation . Renaming a deployed app See the application management documentation . Zero downtime deploy See the zero-downtime deploy documentation .","title":"Deploying to Dokku"},{"location":"deployment/application-deployment/#deploying-to-dokku","text":"Note: This document uses the hostname dokku.me in commands. For your server, please substitute your server's hostname instead.","title":"Deploying to Dokku"},{"location":"deployment/application-deployment/#deploy-tutorial","text":"Once Dokku has been configured with at least one user, applications can be deployed via a git push command. To quickly see Dokku deployment in action, you can use the Heroku Ruby on Rails example app. # from your local machine # SSH access to github must be enabled on this host git clone git@github.com:heroku/ruby-rails-sample.git","title":"Deploy tutorial"},{"location":"deployment/application-deployment/#create-the-app","text":"Create the application on the Dokku host. You will need to SSH onto the host to run this command. # on the Dokku host dokku apps:create ruby-rails-sample","title":"Create the app"},{"location":"deployment/application-deployment/#create-the-backing-services","text":"When you create a new app, Dokku by default does not provide any datastores such as MySQL or PostgreSQL. You will need to install plugins to handle that, but fortunately Dokku has official plugins for common datastores. Our sample app requires a PostgreSQL service: # on the Dokku host # install the postgres plugin # plugin installation requires root, hence the user change sudo dokku plugin:install https://github.com/dokku/dokku-postgres.git # create a postgres service with the name rails-database dokku postgres:create rails-database Each service may take a few moments to create.","title":"Create the backing services"},{"location":"deployment/application-deployment/#linking-backing-services-to-applications","text":"Once the service creation is complete, set the DATABASE_URL environment variable by linking the service. # on the Dokku host # each official datastore offers a `link` method to link a service to any application dokku postgres:link rails-database ruby-rails-sample You can link a single service to multiple applications or use one service per application.","title":"Linking backing services to applications"},{"location":"deployment/application-deployment/#deploy-the-app","text":"Warning: Your application should respect the PORT environment variable or it may not respond to web requests. Please see the port management documentation for details. Now you can deploy the ruby-rails-sample app to your Dokku server. All you have to do is add a remote to name the app. Applications are created on-the-fly on the Dokku server. # from your local machine # the remote username *must* be dokku or pushes will fail cd ruby-rails-sample git remote add dokku dokku@dokku.me:ruby-rails-sample git push dokku master Note: Some tools may not support the short-upstream syntax referenced above, and you may need to prefix the upstream with the scheme ssh:// like so: ssh://dokku@dokku.me:ruby-rails-sample Please see the Git documentation for more details. Note: Your private key should be registered with ssh-agent in local development. If you get a permission denied error when pushing you can register your private key by running ssh-add -k ~/<your private key> . Counting objects: 231, done. Delta compression using up to 8 threads. Compressing objects: 100% (162/162), done. Writing objects: 100% (231/231), 36.96 KiB | 0 bytes/s, done. Total 231 (delta 93), reused 147 (delta 53) -----> Cleaning up... -----> Building ruby-rails-sample from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.2.1 -----> Installing dependencies using 1.9.7 Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin -j4 --deployment Fetching gem metadata from https://rubygems.org/........... Fetching version metadata from https://rubygems.org/... Fetching dependency metadata from https://rubygems.org/.. Using rake 10.4.2 ... =====> Application deployed: http://ruby-rails-sample.dokku.me When the deploy finishes, the application's URL will be shown as seen above. Dokku supports deploying applications via Heroku buildpacks with Herokuish or using a project's Dockerfile .","title":"Deploy the app"},{"location":"deployment/application-deployment/#skipping-deployment","text":"If you only want to rebuild and tag a container, you can skip the deployment phase by setting $DOKKU_SKIP_DEPLOY to true by running: # on the Dokku host dokku config:set ruby-rails-sample DOKKU_SKIP_DEPLOY = true","title":"Skipping deployment"},{"location":"deployment/application-deployment/#redeploying-or-restarting","text":"If you need to redeploy (or restart) your app: # on the Dokku host dokku ps:rebuild ruby-rails-sample See the process scaling documentation for more information.","title":"Redeploying or restarting"},{"location":"deployment/application-deployment/#deploying-with-private-git-submodules","text":"Dokku uses Git locally (i.e. not a Docker image) to build its own copy of your app repo, including submodules. This is done as the dokku user. Therefore, in order to deploy private Git submodules, you'll need to drop your deploy key in /home/dokku/.ssh/ and potentially add github.com (or your VCS host key) into /home/dokku/.ssh/known_hosts . The following test should help confirm you've done it correctly. # on the Dokku host su - dokku ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts ssh -T git@github.com Note that if the buildpack or Dockerfile build process require SSH key access for other reasons, the above may not always apply.","title":"Deploying with private git submodules"},{"location":"deployment/application-deployment/#deploying-to-subdomains","text":"The name of remote repository is used as the name of application to be deployed, as for example above: # from your local machine # the remote username *must* be dokku or pushes will fail git remote add dokku dokku@dokku.me:ruby-rails-sample git push dokku master remote: -----> Application deployed: remote: http://ruby-rails-sample.dokku.me You can also specify fully qualified names, say app.dokku.me , as # from your local machine # the remote username *must* be dokku or pushes will fail git remote add dokku dokku@dokku.me:app.dokku.me git push dokku master remote: -----> Application deployed: remote: http://app.dokku.me This is in particular useful, then you want to deploy to root domain, as # from your local machine # the remote username *must* be dokku or pushes will fail git remote add dokku dokku@dokku.me:dokku.me git push dokku master ... deployment ... remote: -----> Application deployed: remote: http://dokku.me","title":"Deploying to subdomains"},{"location":"deployment/application-deployment/#dokkudocker-container-management-compatibility","text":"Dokku is, at its core, a Docker container manager. Thus, it does not necessarily play well with other out-of-band processes interacting with the Docker daemon. One thing to note as in issue #1220 , Dokku executes a cleanup function prior to every deployment. As of 0.5.x, this function removes all containers with the label dokku where the status is either dead or exited , as well as all dangling images. Previous versions would remove dead or exited containers, regardless of their label.","title":"Dokku/Docker container management compatibility"},{"location":"deployment/application-deployment/#adding-deploy-users","text":"See the user management documentation .","title":"Adding deploy users"},{"location":"deployment/application-deployment/#default-vhost","text":"See the nginx documentation .","title":"Default vhost"},{"location":"deployment/application-deployment/#deploying-non-master-branch","text":"See the Git documentation .","title":"Deploying non-master branch"},{"location":"deployment/application-deployment/#dockerfile-deployment","text":"See the Dockerfile documentation .","title":"Dockerfile deployment"},{"location":"deployment/application-deployment/#image-tagging","text":"See the image tagging documentation .","title":"Image tagging"},{"location":"deployment/application-deployment/#specifying-a-custom-buildpack","text":"See the buildpack documentation .","title":"Specifying a custom buildpack"},{"location":"deployment/application-deployment/#removing-a-deployed-app","text":"See the application management documentation .","title":"Removing a deployed app"},{"location":"deployment/application-deployment/#renaming-a-deployed-app","text":"See the application management documentation .","title":"Renaming a deployed app"},{"location":"deployment/application-deployment/#zero-downtime-deploy","text":"See the zero-downtime deploy documentation .","title":"Zero downtime deploy"},{"location":"deployment/application-management/","text":"Application Management New as of 0.3.1 apps:clone <old-app> <new-app> # Clones an app apps:create <app> # Create a new app apps:destroy <app> # Permanently destroy an app apps:exists <app> # Checks if an app exists apps:list # List your apps apps:lock <app> # Locks an app for deployment apps:locked <app> # Checks if an app is locked for deployment apps:rename <old-app> <new-app> # Rename an app apps:report [<app>] [<flag>] # Display report about an app apps:unlock <app> # Unlocks an app for deployment Usage Listing applications New as of 0.8.1. Use the apps command for older versions. You can easily list all available applications using the apps:list command: dokku apps:list =====> My Apps node-js-app python-app Note that you can easily hide extra output from Dokku commands by using the --quiet flag, which makes it easier to parse on the command line. dokku --quiet apps:list node-js-app python-app Checking if an application exists For CI/CD pipelines, it may be useful to see if an application exists before creating a \"review\" application for a specific branch. You can do so via the apps:exists command: dokku apps:exists node-js-app App does not exist The apps:exists command will return non-zero if the application does not exist, and zero if it does. Manually creating an application A common pattern for deploying applications to Dokku is to configure an application before deploying it. You can do so via the apps:create command: dokku apps:create node-js-app Creating node-js-app... done Once created, you can configure the application as normal, and deploy the application whenever ready. This is useful for cases where you may wish to do any of the following kinds of tasks: Configure domain names and SSL certificates. Create and link datastores. Set environment variables. Removing a deployed app In some cases, you may need to destroy an application, whether it is because the application is temporary or because it was misconfigured. In these cases, you can use the apps:destroy command. Performing any destructive actions in Dokku requires confirmation, and this command will ask for the name of the application being deleted before doing so. dokku apps:destroy node-js-app ! WARNING: Potentially Destructive Action ! This command will destroy node-js-app (including all add-ons). ! To proceed, type \"node-js-app\" > node-js-app Destroying node-js-app (including all add-ons) This will prompt you to verify the application's name before destroying it. You may also use the --force flag to circumvent this verification process: dokku --force apps:destroy node-js-app Destroying node-js-app (including all add-ons) Destroying an application will unlink all linked services and destroy any config related to the application. Note that linked services will retain their data for later use (or removal). Renaming a deployed app New as of 0.4.7 You can rename a deployed app using the apps:rename command. Note that the application must have been deployed at least once, or the rename will not complete successfully: dokku apps:rename node-js-app io-js-app Destroying node-js-app (including all add-ons) -----> Cleaning up... -----> Building io-js-app from herokuish... -----> Adding BUILD_ENV to build environment... -----> Node.js app detected -----> Creating runtime environment ... =====> Application deployed: http://io-js-app.ci.dokku.me Renaming node-js-app to io-js-app... done This will copy all of your app's contents into a new app directory with the name of your choice, delete your old app, then rebuild the new version of the app and deploy it. All of your config variables, including database urls, will be preserved. Cloning an existing app New as of 0.11.5 You can clone an existing app using the apps:clone command. Note that the application must have been deployed at least once, or cloning will not complete successfully: dokku apps:clone node-js-app io-js-app Cloning node-js-app to io-js-app... done This will copy all of your app's contents into a new app directory with the name of your choice and then rebuild the new version of the app and deploy it with the following caveats: All of your environment variables, including database urls, will be preserved. Custom domains are not applied to the new app. SSL certificates will not be copied to the new app. Port mappings with the scheme https and host-port 443 will be skipped. Warning: If you have exposed specific ports via docker-options plugin, or performed anything that cannot be done against multiple applications, apps:clone may result in errors. By default, Dokku will deploy this new application, though you can skip the deploy by using the --skip-deploy flag: dokku apps:clone --skip-deploy node-js-app io-js-app Finally, if the application already exists, you may wish to ignore errors resulting from attempting to clone over it. To do so, you can use the --ignore-existing flag. A warning will be emitted, but the command will return 0 . dokku apps:clone --ignore-existing node-js-app io-js-app Locking app deploys New as of 0.11.6 If you wish to disable deploying for a period of time, this can be done via deploy locks. Normally, deploy locks exist only for the duration of a deploy so as to avoid deploys from colliding, but a deploy lock can be created by running the apps:lock command. dokku apps:lock node-js-app -----> Deploy lock created Unlocking app deploys New as of 0.11.6 In some cases, it may be necessary to remove an existing deploy lock. This can be performed via the apps:unlock command. Warning: Removing the deploy lock will not stop in progress deploys. At this time, in progress deploys will need to be manually terminated by someone with server access. dokku apps:unlock node-js-app ! A deploy may be in progress. ! Removing the app lock will not stop in progress deploys. -----> Deploy lock removed. Checking lock status New as of 0.13.0 In some cases, you may wish to inspect the state of an app lock. To do so, you can issue an apps:lock command. This will exit non-zero if there is no app lock in place. dokku apps:locked node-js-app Deploy lock does not exist Displaying reports about an app New as of 0.8.1 You can get a report about the deployed apps using the apps:report command: dokku apps:report =====> node-js-app App dir: /home/dokku/node-js-app Git sha: dbddc3f Deploy source: git Locked: false =====> python-sample not deployed =====> ruby-sample App dir: /home/dokku/ruby-sample Git sha: a2d477c Deploy source: git Locked: false You can run the command for a specific app also. dokku apps:report node-js-app =====> node-js-app App dir: /home/dokku/node-js-app Git sha: dbddc3f Deploy source: git Locked: false You can pass flags which will output only the value of the specific information you want. For example: dokku apps:report node-js-app --git-sha","title":"Application Management"},{"location":"deployment/application-management/#application-management","text":"New as of 0.3.1 apps:clone <old-app> <new-app> # Clones an app apps:create <app> # Create a new app apps:destroy <app> # Permanently destroy an app apps:exists <app> # Checks if an app exists apps:list # List your apps apps:lock <app> # Locks an app for deployment apps:locked <app> # Checks if an app is locked for deployment apps:rename <old-app> <new-app> # Rename an app apps:report [<app>] [<flag>] # Display report about an app apps:unlock <app> # Unlocks an app for deployment","title":"Application Management"},{"location":"deployment/application-management/#usage","text":"","title":"Usage"},{"location":"deployment/application-management/#listing-applications","text":"New as of 0.8.1. Use the apps command for older versions. You can easily list all available applications using the apps:list command: dokku apps:list =====> My Apps node-js-app python-app Note that you can easily hide extra output from Dokku commands by using the --quiet flag, which makes it easier to parse on the command line. dokku --quiet apps:list node-js-app python-app","title":"Listing applications"},{"location":"deployment/application-management/#checking-if-an-application-exists","text":"For CI/CD pipelines, it may be useful to see if an application exists before creating a \"review\" application for a specific branch. You can do so via the apps:exists command: dokku apps:exists node-js-app App does not exist The apps:exists command will return non-zero if the application does not exist, and zero if it does.","title":"Checking if an application exists"},{"location":"deployment/application-management/#manually-creating-an-application","text":"A common pattern for deploying applications to Dokku is to configure an application before deploying it. You can do so via the apps:create command: dokku apps:create node-js-app Creating node-js-app... done Once created, you can configure the application as normal, and deploy the application whenever ready. This is useful for cases where you may wish to do any of the following kinds of tasks: Configure domain names and SSL certificates. Create and link datastores. Set environment variables.","title":"Manually creating an application"},{"location":"deployment/application-management/#removing-a-deployed-app","text":"In some cases, you may need to destroy an application, whether it is because the application is temporary or because it was misconfigured. In these cases, you can use the apps:destroy command. Performing any destructive actions in Dokku requires confirmation, and this command will ask for the name of the application being deleted before doing so. dokku apps:destroy node-js-app ! WARNING: Potentially Destructive Action ! This command will destroy node-js-app (including all add-ons). ! To proceed, type \"node-js-app\" > node-js-app Destroying node-js-app (including all add-ons) This will prompt you to verify the application's name before destroying it. You may also use the --force flag to circumvent this verification process: dokku --force apps:destroy node-js-app Destroying node-js-app (including all add-ons) Destroying an application will unlink all linked services and destroy any config related to the application. Note that linked services will retain their data for later use (or removal).","title":"Removing a deployed app"},{"location":"deployment/application-management/#renaming-a-deployed-app","text":"New as of 0.4.7 You can rename a deployed app using the apps:rename command. Note that the application must have been deployed at least once, or the rename will not complete successfully: dokku apps:rename node-js-app io-js-app Destroying node-js-app (including all add-ons) -----> Cleaning up... -----> Building io-js-app from herokuish... -----> Adding BUILD_ENV to build environment... -----> Node.js app detected -----> Creating runtime environment ... =====> Application deployed: http://io-js-app.ci.dokku.me Renaming node-js-app to io-js-app... done This will copy all of your app's contents into a new app directory with the name of your choice, delete your old app, then rebuild the new version of the app and deploy it. All of your config variables, including database urls, will be preserved.","title":"Renaming a deployed app"},{"location":"deployment/application-management/#cloning-an-existing-app","text":"New as of 0.11.5 You can clone an existing app using the apps:clone command. Note that the application must have been deployed at least once, or cloning will not complete successfully: dokku apps:clone node-js-app io-js-app Cloning node-js-app to io-js-app... done This will copy all of your app's contents into a new app directory with the name of your choice and then rebuild the new version of the app and deploy it with the following caveats: All of your environment variables, including database urls, will be preserved. Custom domains are not applied to the new app. SSL certificates will not be copied to the new app. Port mappings with the scheme https and host-port 443 will be skipped. Warning: If you have exposed specific ports via docker-options plugin, or performed anything that cannot be done against multiple applications, apps:clone may result in errors. By default, Dokku will deploy this new application, though you can skip the deploy by using the --skip-deploy flag: dokku apps:clone --skip-deploy node-js-app io-js-app Finally, if the application already exists, you may wish to ignore errors resulting from attempting to clone over it. To do so, you can use the --ignore-existing flag. A warning will be emitted, but the command will return 0 . dokku apps:clone --ignore-existing node-js-app io-js-app","title":"Cloning an existing app"},{"location":"deployment/application-management/#locking-app-deploys","text":"New as of 0.11.6 If you wish to disable deploying for a period of time, this can be done via deploy locks. Normally, deploy locks exist only for the duration of a deploy so as to avoid deploys from colliding, but a deploy lock can be created by running the apps:lock command. dokku apps:lock node-js-app -----> Deploy lock created","title":"Locking app deploys"},{"location":"deployment/application-management/#unlocking-app-deploys","text":"New as of 0.11.6 In some cases, it may be necessary to remove an existing deploy lock. This can be performed via the apps:unlock command. Warning: Removing the deploy lock will not stop in progress deploys. At this time, in progress deploys will need to be manually terminated by someone with server access. dokku apps:unlock node-js-app ! A deploy may be in progress. ! Removing the app lock will not stop in progress deploys. -----> Deploy lock removed.","title":"Unlocking app deploys"},{"location":"deployment/application-management/#checking-lock-status","text":"New as of 0.13.0 In some cases, you may wish to inspect the state of an app lock. To do so, you can issue an apps:lock command. This will exit non-zero if there is no app lock in place. dokku apps:locked node-js-app Deploy lock does not exist","title":"Checking lock status"},{"location":"deployment/application-management/#displaying-reports-about-an-app","text":"New as of 0.8.1 You can get a report about the deployed apps using the apps:report command: dokku apps:report =====> node-js-app App dir: /home/dokku/node-js-app Git sha: dbddc3f Deploy source: git Locked: false =====> python-sample not deployed =====> ruby-sample App dir: /home/dokku/ruby-sample Git sha: a2d477c Deploy source: git Locked: false You can run the command for a specific app also. dokku apps:report node-js-app =====> node-js-app App dir: /home/dokku/node-js-app Git sha: dbddc3f Deploy source: git Locked: false You can pass flags which will output only the value of the specific information you want. For example: dokku apps:report node-js-app --git-sha","title":"Displaying reports about an app"},{"location":"deployment/logs/","text":"Log Management logs <app> [-h] [-t] [-n num] [-q] [-p process] # Display recent log output logs:failed [<app>] # Shows the last failed deploy logs Usage Application logs You can easily get logs of an app using the logs command: dokku logs node-js-app Behavioral modifiers Dokku also supports certain command-line arguments that augment the log command's behavior. -n, --num NUM # the number of lines to display -p, --ps PS # only display logs from the given process -t, --tail # continually stream logs -q, --quiet # display raw logs without colors, time and names You can use these modifiers as follows: dokku logs node-js-app -t -p web will show logs continually from the web process. Failed deploy logs Warning: The default docker-local scheduler will \"store\" these until the next deploy or until the old containers are garbage collected - whichever runs first. If you require the logs beyond this point in time, please ship the logs to a centralized log server. In some cases, it may be useful to retrieve the logs from a previously failed deploy. You can retrieve these logs by using the logs:failed command dokku logs:failed node-js-app You can also retrieve the failed logs for each app: dokku logs:failed node-js-app","title":"Log Management"},{"location":"deployment/logs/#log-management","text":"logs <app> [-h] [-t] [-n num] [-q] [-p process] # Display recent log output logs:failed [<app>] # Shows the last failed deploy logs","title":"Log Management"},{"location":"deployment/logs/#usage","text":"","title":"Usage"},{"location":"deployment/logs/#application-logs","text":"You can easily get logs of an app using the logs command: dokku logs node-js-app","title":"Application logs"},{"location":"deployment/logs/#behavioral-modifiers","text":"Dokku also supports certain command-line arguments that augment the log command's behavior. -n, --num NUM # the number of lines to display -p, --ps PS # only display logs from the given process -t, --tail # continually stream logs -q, --quiet # display raw logs without colors, time and names You can use these modifiers as follows: dokku logs node-js-app -t -p web will show logs continually from the web process.","title":"Behavioral modifiers"},{"location":"deployment/logs/#failed-deploy-logs","text":"Warning: The default docker-local scheduler will \"store\" these until the next deploy or until the old containers are garbage collected - whichever runs first. If you require the logs beyond this point in time, please ship the logs to a centralized log server. In some cases, it may be useful to retrieve the logs from a previously failed deploy. You can retrieve these logs by using the logs:failed command dokku logs:failed node-js-app You can also retrieve the failed logs for each app: dokku logs:failed node-js-app","title":"Failed deploy logs"},{"location":"deployment/one-off-processes/","text":"One-off Processes and Cron Sometimes you need to either inspect running containers or run a one-off command under an application. In those cases, Dokku makes it easy to either connect to a running container or run a fresh container. Run a command in an app environment run <app> <cmd> # Run a command in a new container using the current application image The run command can be used to run a one-off process for a specific command. This will start a new container and run the desired command within that container. Note that this container will be stay around even after command completes. The container will be the same container as was used to start the currently deployed application. # runs `ls -lah` in the `/app` directory of the application `node-js-app` dokku run node-js-app ls -lah The run command can also be used to run a command defined in your Procfile: console: bundle exec racksh # runs `bundle exec racksh` in the `/app` directory of the application `my-app` dokku run my-app console If you want to remove the container after a command has started, you can run the following command: # don't keep `run` containers around dokku config:set --global DOKKU_RM_CONTAINER = 1 # revert the above setting and keep containers around dokku config:unset --global DOKKU_RM_CONTAINER You may also use the --rm-container or --rm Dokku flags to remove the containers automatically: dokku --rm-container run node-js-app ls -lah dokku --rm run node-js-app ls -lah Finally, you may wish to run a container in \"detached\" mode via the --detach Dokku flag. Running a process in detached mode will immediately return a CONTAINER_ID . It is up to the user to then further manage this container in whatever manner they see fit, as Dokku will not automatically terminate the container. dokku --detach run node-js-app ls -lah # returns the ID of the new container Note that you may not use the --rm-container or --rm flags when running containers in detached mode, and attempting to do so will result in the --detach flag being ignored. Using run for cron tasks You can always use a one-off container to run an application task: dokku --rm run node-js-app some-command dokku --rm-container run node-js-app some-command For tasks that should not be interrupted, run is the preferred method of handling cron tasks, as the container will continue running even during a deploy or scaling event. The trade-off is that there will be an increase in memory usage if there are multiple concurrent tasks running. Entering existing containers New as of 0.4.0 enter <app> [<container-type> || --container-id <container-id>] # Connect to a specific app container The enter command can be used to enter a running container. The following variations of the command exist: dokku enter node-js-app web dokku enter node-js-app web.1 dokku enter node-js-app --container-id ID Additionally, you can run enter with no <container-type> . If only a single <container-type> is defined in your app, you will be dropped into the only running container. This behavior is not supported when specifying a custom command; as described below. By default, it runs a /bin/bash , but can also be used to run a custom command: # just echo hi dokku enter node-js-app web echo hi # run a long-running command, as one might for a cron task dokku enter node-js-app web python script/background-worker.py Using enter for cron tasks Your Procfile can have the following entry: cron : sleep infinity With the cron process scaled to 1 : dokku ps:scale node-js-app cron = 1 You can now run all your commands in that container: dokku enter node-js-app cron some-command Note that you can also run multiple commands at the same time to reduce memory usage, though that may result in polluting the container environment. For tasks that will properly resume, you should use the above method, as running tasks will be interrupted during deploys and scaling events, and subsequent commands will always run with the latest container. Note that if you scale the cron container down, this may interrupt proper running of the task. General cron recommendations Regularly scheduled tasks can be a bit of a pain with Dokku. The following are general recommendations to follow to help ensure successful task runs. Use the dokku user's crontab. If you do not, the dokku binary will attempt to execute with sudo , and your cron run with fail with sudo: no tty present and no askpass program specified . Add a MAILTO environment variable to ship cron emails to yourself. Add a PATH environment variable or specify the full path to binaries on the host. Add a SHELL environment variable to specify Bash when running commands. Keep your cron tasks in time-sorted order. Keep your server time in UTC so you don't need to translate daylight savings time when reading the cronfile. Run tasks at the lowest traffic times if possible. Use cron to trigger jobs, not run them. Use a real queuing system such as rabbitmq to actually process jobs. Try to keep tasks quiet so that mails only send on errors. Do not silence standard error or standard out. If you silence the former, you will miss failures. Silencing the latter means you should actually make application changes to handle log levels. Use a service such as Dead Man's Snitch to verify that cron tasks completed successfully. Add lots of comments to your cronfile, including what a task is doing, so that you don't spend time deciphering the file later. Place your cronfiles in a pattern such as /etc/cron.d/APP . Do not use non-ASCII characters in your cronfile names. cron is finicky. Remember to have trailing newlines in your cronfile! cron is finicky. The following is a sample cronfile that you can use for your applications: # server cron jobs MAILTO=\"mail@dokku.me\" PATH=/usr/local/bin:/usr/bin:/bin SHELL=/bin/bash # m h dom mon dow username command # * * * * * dokku command to be executed # - - - - - # | | | | | # | | | | +----- day of week (0 - 6) (Sunday=0) # | | | +------- month (1 - 12) # | | +--------- day of month (1 - 31) # | +----------- hour (0 - 23) # +----------- min (0 - 59) ### HIGH TRAFFIC TIME IS B/W 00:00 - 04:00 AND 14:00 - 23:59 ### RUN YOUR TASKS FROM 04:00 - 14:00 ### KEEP SORTED IN TIME ORDER ### PLACE ALL CRON TASKS BELOW # removes unresponsive users from the subscriber list to decrease bounce rates 0 0 * * * dokku dokku --rm run node-js-app some-command # sends out our email alerts to users 0 1 * * * dokku dokku ps:scale node-js-app cron=1 && dokku enter node-js-app cron some-other-command && dokku ps:scale node-js-app cron=0 ### PLACE ALL CRON TASKS ABOVE, DO NOT REMOVE THE WHITESPACE AFTER THIS LINE","title":"One-off Processes and Cron"},{"location":"deployment/one-off-processes/#one-off-processes-and-cron","text":"Sometimes you need to either inspect running containers or run a one-off command under an application. In those cases, Dokku makes it easy to either connect to a running container or run a fresh container.","title":"One-off Processes and Cron"},{"location":"deployment/one-off-processes/#run-a-command-in-an-app-environment","text":"run <app> <cmd> # Run a command in a new container using the current application image The run command can be used to run a one-off process for a specific command. This will start a new container and run the desired command within that container. Note that this container will be stay around even after command completes. The container will be the same container as was used to start the currently deployed application. # runs `ls -lah` in the `/app` directory of the application `node-js-app` dokku run node-js-app ls -lah The run command can also be used to run a command defined in your Procfile: console: bundle exec racksh # runs `bundle exec racksh` in the `/app` directory of the application `my-app` dokku run my-app console If you want to remove the container after a command has started, you can run the following command: # don't keep `run` containers around dokku config:set --global DOKKU_RM_CONTAINER = 1 # revert the above setting and keep containers around dokku config:unset --global DOKKU_RM_CONTAINER You may also use the --rm-container or --rm Dokku flags to remove the containers automatically: dokku --rm-container run node-js-app ls -lah dokku --rm run node-js-app ls -lah Finally, you may wish to run a container in \"detached\" mode via the --detach Dokku flag. Running a process in detached mode will immediately return a CONTAINER_ID . It is up to the user to then further manage this container in whatever manner they see fit, as Dokku will not automatically terminate the container. dokku --detach run node-js-app ls -lah # returns the ID of the new container Note that you may not use the --rm-container or --rm flags when running containers in detached mode, and attempting to do so will result in the --detach flag being ignored.","title":"Run a command in an app environment"},{"location":"deployment/one-off-processes/#using-run-for-cron-tasks","text":"You can always use a one-off container to run an application task: dokku --rm run node-js-app some-command dokku --rm-container run node-js-app some-command For tasks that should not be interrupted, run is the preferred method of handling cron tasks, as the container will continue running even during a deploy or scaling event. The trade-off is that there will be an increase in memory usage if there are multiple concurrent tasks running.","title":"Using run for cron tasks"},{"location":"deployment/one-off-processes/#entering-existing-containers","text":"New as of 0.4.0 enter <app> [<container-type> || --container-id <container-id>] # Connect to a specific app container The enter command can be used to enter a running container. The following variations of the command exist: dokku enter node-js-app web dokku enter node-js-app web.1 dokku enter node-js-app --container-id ID Additionally, you can run enter with no <container-type> . If only a single <container-type> is defined in your app, you will be dropped into the only running container. This behavior is not supported when specifying a custom command; as described below. By default, it runs a /bin/bash , but can also be used to run a custom command: # just echo hi dokku enter node-js-app web echo hi # run a long-running command, as one might for a cron task dokku enter node-js-app web python script/background-worker.py","title":"Entering existing containers"},{"location":"deployment/one-off-processes/#using-enter-for-cron-tasks","text":"Your Procfile can have the following entry: cron : sleep infinity With the cron process scaled to 1 : dokku ps:scale node-js-app cron = 1 You can now run all your commands in that container: dokku enter node-js-app cron some-command Note that you can also run multiple commands at the same time to reduce memory usage, though that may result in polluting the container environment. For tasks that will properly resume, you should use the above method, as running tasks will be interrupted during deploys and scaling events, and subsequent commands will always run with the latest container. Note that if you scale the cron container down, this may interrupt proper running of the task.","title":"Using enter for cron tasks"},{"location":"deployment/one-off-processes/#general-cron-recommendations","text":"Regularly scheduled tasks can be a bit of a pain with Dokku. The following are general recommendations to follow to help ensure successful task runs. Use the dokku user's crontab. If you do not, the dokku binary will attempt to execute with sudo , and your cron run with fail with sudo: no tty present and no askpass program specified . Add a MAILTO environment variable to ship cron emails to yourself. Add a PATH environment variable or specify the full path to binaries on the host. Add a SHELL environment variable to specify Bash when running commands. Keep your cron tasks in time-sorted order. Keep your server time in UTC so you don't need to translate daylight savings time when reading the cronfile. Run tasks at the lowest traffic times if possible. Use cron to trigger jobs, not run them. Use a real queuing system such as rabbitmq to actually process jobs. Try to keep tasks quiet so that mails only send on errors. Do not silence standard error or standard out. If you silence the former, you will miss failures. Silencing the latter means you should actually make application changes to handle log levels. Use a service such as Dead Man's Snitch to verify that cron tasks completed successfully. Add lots of comments to your cronfile, including what a task is doing, so that you don't spend time deciphering the file later. Place your cronfiles in a pattern such as /etc/cron.d/APP . Do not use non-ASCII characters in your cronfile names. cron is finicky. Remember to have trailing newlines in your cronfile! cron is finicky. The following is a sample cronfile that you can use for your applications: # server cron jobs MAILTO=\"mail@dokku.me\" PATH=/usr/local/bin:/usr/bin:/bin SHELL=/bin/bash # m h dom mon dow username command # * * * * * dokku command to be executed # - - - - - # | | | | | # | | | | +----- day of week (0 - 6) (Sunday=0) # | | | +------- month (1 - 12) # | | +--------- day of month (1 - 31) # | +----------- hour (0 - 23) # +----------- min (0 - 59) ### HIGH TRAFFIC TIME IS B/W 00:00 - 04:00 AND 14:00 - 23:59 ### RUN YOUR TASKS FROM 04:00 - 14:00 ### KEEP SORTED IN TIME ORDER ### PLACE ALL CRON TASKS BELOW # removes unresponsive users from the subscriber list to decrease bounce rates 0 0 * * * dokku dokku --rm run node-js-app some-command # sends out our email alerts to users 0 1 * * * dokku dokku ps:scale node-js-app cron=1 && dokku enter node-js-app cron some-other-command && dokku ps:scale node-js-app cron=0 ### PLACE ALL CRON TASKS ABOVE, DO NOT REMOVE THE WHITESPACE AFTER THIS LINE","title":"General cron recommendations"},{"location":"deployment/process-management/","text":"Process and Container Management New as of 0.3.14, Enhanced in 0.7.0 ps <app> # List processes running in app container(s) ps:inspect <app> # Displays a sanitized version of docker inspect for an app ps:rebuild <app> # Rebuild an app from source ps:rebuildall # Rebuild all apps from source ps:report [<app>] [<flag>] # Displays a process report for one or more apps ps:restart <app> # Restart app container(s) ps:restart-policy <app> # Shows the restart-policy for an app ps:restartall # Restart all deployed app containers ps:scale <app> <proc>=<count> [<proc>=<count>] # Get/Set how many instances of a given process to run ps:set-restart-policy <app> <policy> # Sets app restart-policy ps:start <app> # Start app container(s) ps:startall # Start all deployed app containers ps:stop <app> # Stop app container(s) ps:stopall # Stop all app container(s) By default, Dokku will only start a single web process - if defined - though process scaling can be managed by the ps plugin or via a custom DOKKU_SCALE file . The web proctype is the only proctype that will invoke custom checks as defined by a CHECKS file. It is also the only process type that will be launched in a container that is either proxied via nginx or bound to an external port. Usage Listing processes running in an app container To find out if your application's containers are running the commands you expect, simply run the ps command against that application. dokku ps node-js-app Inspecting app containers New as of 0.13.0 A common administrative task to perform is calling docker inspect on the containers that are running for an application. This can be an error-prone task to perform, and may also reveal sensitive environment variables if not done correctly. Dokku provides a wrapper around this command via the ps:inspect command: dokku ps:inspect node-js-app This command will gather all the running container IDs for your application and call docker inspect , sanitizing the output data so it can be copy-pasted elsewhere safely. Rebuilding applications There are some Dokku commands which will not automatically rebuild an application's environment, or which can be told to skip a rebuild. For instance, you may wish to run multiple config:set commands without a restart so as to speed up configuration. In these cases, you can ultimately trigger an application rebuild using ps:rebuild dokku ps:rebuild node-js-app You may also rebuild all applications at once, which is useful when enabling/disabling a plugin that modifies all applications: dokku ps:rebuildall The ps:rebuild and ps:rebuildall commands only work for applications for which there is a source, and thus will only always work deterministically for Git-deployed application. Please see the images documentation and tar documentation in for more information concerning rebuilding those applications. Restarting applications Applications can be restarted, which is functionally identical to calling the release_and_deploy function on an application. Please note that any linked containers must be started before the application in order to have a successful boot. dokku ps:restart node-js-app You may also trigger a restart on all applications at one time: dokku ps:restartall ps:scale command Dokku can also manage scaling itself via the ps:scale command. This command can be used to scale multiple process types at the same time. dokku ps:scale node-js-app web = 1 Multiple process types can be scaled at once: dokku ps:scale node-js-app web = 1 worker = 1 Issuing the ps:scale command with no process type argument will output the current scaling settings for an application: dokku ps:scale node-js-app -----> Scaling for node-js-app -----> proctype qty -----> -------- --- -----> web 1 -----> worker 1 Stopping applications Deployed applications can be stopped using the ps:stop command. This turns off all running containers for an application, and will result in a 502 Bad Gateway response for the default nginx proxy implementation. dokku ps:stop node-js-app You may also stop all applications at once: dokku ps:stopall Starting applications All stopped containers can be started using the ps:start command. This is similar to running ps:restart , except no action will be taken if the application containers are running. dokku ps:start node-js-app Starting all applications In some cases, it may be necessary to start all applications from scratch - e.g. if all Docker containers have been manually stopped. This can be executed via the ps:startall command, which supports parallelism in the same manner ps:rebuildall , ps:restartall , and ps:stopall do. Be aware that no action will be taken if the application containers are running. dokku ps:startall Restart policies New as of 0.7.0 By default, Dokku will automatically restart containers that exit with a non-zero status up to 10 times via the on-failure Docker restart policy . Showing the current restart policy The ps:restart-policy command will show the currently configured restart policy for an application. The default policy is on-failure:10 dokku ps:restart-policy node-js-app =====> node-js-app restart-policy: on-failure:10 Setting the restart policy You can configure this via the ps:set-restart-policy command: # always restart an exited container dokku ps:set-restart-policy node-js-app always -----> Setting restart policy: always # never restart an exited container dokku ps:set-restart-policy node-js-app no -----> Setting restart policy: no # only restart it on Docker restart if it was not manually stopped dokku ps:set-restart-policy node-js-app unless-stopped -----> Setting restart policy: unless-stopped # restart only on non-zero exit status dokku ps:set-restart-policy node-js-app on-failure -----> Setting restart policy: on-failure # restart only on non-zero exit status up to 20 times dokku ps:set-restart-policy node-js-app on-failure:20 -----> Setting restart policy: on-failure:20 Restart policies have no bearing on server reboot, and Dokku will always attempt to restart your applications at that point unless they were manually stopped. Manually managing process scaling You can optionally commit a DOKKU_SCALE file to the root of your repository - not to the /home/dokku/APP directory. Dokku expects this file to contain one line for every process defined in your Procfile. Example: web = 1 worker = 2 If it is not committed to the repository, the DOKKU_SCALE file will otherwise be automatically generated based on your ps:scale settings. NOTE : Dokku will always use the DOKKU_SCALE file that ships with the repo to override any local settings.","title":"Process and Container Management"},{"location":"deployment/process-management/#process-and-container-management","text":"New as of 0.3.14, Enhanced in 0.7.0 ps <app> # List processes running in app container(s) ps:inspect <app> # Displays a sanitized version of docker inspect for an app ps:rebuild <app> # Rebuild an app from source ps:rebuildall # Rebuild all apps from source ps:report [<app>] [<flag>] # Displays a process report for one or more apps ps:restart <app> # Restart app container(s) ps:restart-policy <app> # Shows the restart-policy for an app ps:restartall # Restart all deployed app containers ps:scale <app> <proc>=<count> [<proc>=<count>] # Get/Set how many instances of a given process to run ps:set-restart-policy <app> <policy> # Sets app restart-policy ps:start <app> # Start app container(s) ps:startall # Start all deployed app containers ps:stop <app> # Stop app container(s) ps:stopall # Stop all app container(s) By default, Dokku will only start a single web process - if defined - though process scaling can be managed by the ps plugin or via a custom DOKKU_SCALE file . The web proctype is the only proctype that will invoke custom checks as defined by a CHECKS file. It is also the only process type that will be launched in a container that is either proxied via nginx or bound to an external port.","title":"Process and Container Management"},{"location":"deployment/process-management/#usage","text":"","title":"Usage"},{"location":"deployment/process-management/#listing-processes-running-in-an-app-container","text":"To find out if your application's containers are running the commands you expect, simply run the ps command against that application. dokku ps node-js-app","title":"Listing processes running in an app container"},{"location":"deployment/process-management/#inspecting-app-containers","text":"New as of 0.13.0 A common administrative task to perform is calling docker inspect on the containers that are running for an application. This can be an error-prone task to perform, and may also reveal sensitive environment variables if not done correctly. Dokku provides a wrapper around this command via the ps:inspect command: dokku ps:inspect node-js-app This command will gather all the running container IDs for your application and call docker inspect , sanitizing the output data so it can be copy-pasted elsewhere safely.","title":"Inspecting app containers"},{"location":"deployment/process-management/#rebuilding-applications","text":"There are some Dokku commands which will not automatically rebuild an application's environment, or which can be told to skip a rebuild. For instance, you may wish to run multiple config:set commands without a restart so as to speed up configuration. In these cases, you can ultimately trigger an application rebuild using ps:rebuild dokku ps:rebuild node-js-app You may also rebuild all applications at once, which is useful when enabling/disabling a plugin that modifies all applications: dokku ps:rebuildall The ps:rebuild and ps:rebuildall commands only work for applications for which there is a source, and thus will only always work deterministically for Git-deployed application. Please see the images documentation and tar documentation in for more information concerning rebuilding those applications.","title":"Rebuilding applications"},{"location":"deployment/process-management/#restarting-applications","text":"Applications can be restarted, which is functionally identical to calling the release_and_deploy function on an application. Please note that any linked containers must be started before the application in order to have a successful boot. dokku ps:restart node-js-app You may also trigger a restart on all applications at one time: dokku ps:restartall","title":"Restarting applications"},{"location":"deployment/process-management/#psscale-command","text":"Dokku can also manage scaling itself via the ps:scale command. This command can be used to scale multiple process types at the same time. dokku ps:scale node-js-app web = 1 Multiple process types can be scaled at once: dokku ps:scale node-js-app web = 1 worker = 1 Issuing the ps:scale command with no process type argument will output the current scaling settings for an application: dokku ps:scale node-js-app -----> Scaling for node-js-app -----> proctype qty -----> -------- --- -----> web 1 -----> worker 1","title":"ps:scale command"},{"location":"deployment/process-management/#stopping-applications","text":"Deployed applications can be stopped using the ps:stop command. This turns off all running containers for an application, and will result in a 502 Bad Gateway response for the default nginx proxy implementation. dokku ps:stop node-js-app You may also stop all applications at once: dokku ps:stopall","title":"Stopping applications"},{"location":"deployment/process-management/#starting-applications","text":"All stopped containers can be started using the ps:start command. This is similar to running ps:restart , except no action will be taken if the application containers are running. dokku ps:start node-js-app","title":"Starting applications"},{"location":"deployment/process-management/#starting-all-applications","text":"In some cases, it may be necessary to start all applications from scratch - e.g. if all Docker containers have been manually stopped. This can be executed via the ps:startall command, which supports parallelism in the same manner ps:rebuildall , ps:restartall , and ps:stopall do. Be aware that no action will be taken if the application containers are running. dokku ps:startall","title":"Starting all applications"},{"location":"deployment/process-management/#restart-policies","text":"New as of 0.7.0 By default, Dokku will automatically restart containers that exit with a non-zero status up to 10 times via the on-failure Docker restart policy .","title":"Restart policies"},{"location":"deployment/process-management/#showing-the-current-restart-policy","text":"The ps:restart-policy command will show the currently configured restart policy for an application. The default policy is on-failure:10 dokku ps:restart-policy node-js-app =====> node-js-app restart-policy: on-failure:10","title":"Showing the current restart policy"},{"location":"deployment/process-management/#setting-the-restart-policy","text":"You can configure this via the ps:set-restart-policy command: # always restart an exited container dokku ps:set-restart-policy node-js-app always -----> Setting restart policy: always # never restart an exited container dokku ps:set-restart-policy node-js-app no -----> Setting restart policy: no # only restart it on Docker restart if it was not manually stopped dokku ps:set-restart-policy node-js-app unless-stopped -----> Setting restart policy: unless-stopped # restart only on non-zero exit status dokku ps:set-restart-policy node-js-app on-failure -----> Setting restart policy: on-failure # restart only on non-zero exit status up to 20 times dokku ps:set-restart-policy node-js-app on-failure:20 -----> Setting restart policy: on-failure:20 Restart policies have no bearing on server reboot, and Dokku will always attempt to restart your applications at that point unless they were manually stopped.","title":"Setting the restart policy"},{"location":"deployment/process-management/#manually-managing-process-scaling","text":"You can optionally commit a DOKKU_SCALE file to the root of your repository - not to the /home/dokku/APP directory. Dokku expects this file to contain one line for every process defined in your Procfile. Example: web = 1 worker = 2 If it is not committed to the repository, the DOKKU_SCALE file will otherwise be automatically generated based on your ps:scale settings. NOTE : Dokku will always use the DOKKU_SCALE file that ships with the repo to override any local settings.","title":"Manually managing process scaling"},{"location":"deployment/remote-commands/","text":"Remote Commands Dokku commands can be run over SSH. Anywhere you would run dokku <command> , just run ssh -t dokku@dokku.me <command> The -t is used to request a pty. It is highly recommended to do so. To avoid the need to type the -t option each time, simply create/modify a section in the .ssh/config on the client side, as follows: Host dokku.me RequestTTY yes Behavioral modifiers Dokku also supports certain command line arguments that augment its behavior. If using these over SSH, you must use the form ssh -t dokku@dokku.me -- <command> in order to avoid SSH interpretting Dokku arguments for itself. --quiet suppress output headers --trace enable DOKKU_TRACE for current execution only --rm|--rm-container remove docker container after successful dokku run <app> <command> --force force flag. currently used in apps:destroy and other \":destroy\" commands Clients You may optionally use a client to connect to your Dokku server. Most clients use the configured git remote to locate the Dokku server, though some allow for overriding this via an environment variable or flag. Please refer to the clients list for more details.","title":"Remote Commands"},{"location":"deployment/remote-commands/#remote-commands","text":"Dokku commands can be run over SSH. Anywhere you would run dokku <command> , just run ssh -t dokku@dokku.me <command> The -t is used to request a pty. It is highly recommended to do so. To avoid the need to type the -t option each time, simply create/modify a section in the .ssh/config on the client side, as follows: Host dokku.me RequestTTY yes","title":"Remote Commands"},{"location":"deployment/remote-commands/#behavioral-modifiers","text":"Dokku also supports certain command line arguments that augment its behavior. If using these over SSH, you must use the form ssh -t dokku@dokku.me -- <command> in order to avoid SSH interpretting Dokku arguments for itself. --quiet suppress output headers --trace enable DOKKU_TRACE for current execution only --rm|--rm-container remove docker container after successful dokku run <app> <command> --force force flag. currently used in apps:destroy and other \":destroy\" commands","title":"Behavioral modifiers"},{"location":"deployment/remote-commands/#clients","text":"You may optionally use a client to connect to your Dokku server. Most clients use the configured git remote to locate the Dokku server, though some allow for overriding this via an environment variable or flag. Please refer to the clients list for more details.","title":"Clients"},{"location":"deployment/user-management/","text":"User Management New as of 0.7.0 ssh-keys:add <name> [/path/to/key] # Add a new public key by pipe or path ssh-keys:list # List of all authorized Dokku public ssh keys ssh-keys:remove <name> # Remove SSH public key by name When pushing to Dokku, SSH key-based authorization is the preferred authentication method, for ease of use and increased security. Users in Dokku are managed via the ~/dokku/.ssh/authorized_keys file. It is highly recommended that you follow the steps below to manage users on a Dokku server. Users of older versions of Dokku may use the sshcommand binary to manage keys instead of the ssh-keys plugin. Please refer to the Dokku documentation for your version for more details. Usage Listing SSH keys You can use the ssh-keys:list command to show all configured SSH keys. Any key added via the dokku-installer will be associated with the admin key name. dokku ssh-keys:list 61:21:1f:88:7f:86:d4:3a:68:9f:18:aa:41:4f:bc:3d NAME=\"admin\" SSHCOMMAND_ALLOWED_KEYS=\"no-agent-forwarding,no-user-rc,no-X11-forwarding,no-port-forwarding\" The output contains the following information: SSH Key Fingerprint. The KEY_NAME . A comma separated list of SSH options under the SSHCOMMAND_ALLOWED_KEYS name. Adding SSH keys You can add your public key to Dokku with the ssh-keys:add command. The output will be the fingerprint of the SSH key: dokku ssh-keys:add KEY_NAME path/to/id_rsa.pub b7:76:27:4f:30:90:21:ae:d4:1e:70:20:35:3f:06:d6 KEY_NAME is the name you want to use to refer to this particular key. Including the word admin in the name will grant the user privileges to add additional keys remotely. KEY_NAME is a unique name which is used to identify public keys. Attempting to re-use a key name will result in an error. The SSH (Git) user is always dokku , as this is the system user that the dokku binary uses to perform all its actions. Admin users and root can add keys remotely by specifying the dokku bin on their ssh command: cat ~/.ssh/id_rsa.pub | ssh root@dokku.me dokku ssh-keys:add KEY_NAME If you are using the Vagrant installation, you can also use the make vagrant-acl-add target to add your public key to Dokku (it will use your host username as the USER ): cat ~/.ssh/id_rsa.pub | make vagrant-acl-add Removing SSH keys As key names are unique, they can be used to remove a public SSH key. dokku ssh-keys:remove KEY_NAME Scoping commands to specific users Keys are given unique names, which can be used in conjunction with the user-auth plugin trigger to handle command authorization. Please see the documentation on that trigger for more information. Granting other Unix user accounts Dokku access Any Unix user account which belongs to the sudo Unix group can run Dokku. However, you may want to give them Dokku access but not full sudo privileges. To allow other Unix user accounts to be able to run Dokku commands, without giving them full sudo access, modify your sudoers configuration. Use visudo /etc/sudoers.d/dokku-users , or visudo /etc/sudoers to add the following line: %dokku ALL=(ALL:ALL) NOPASSWD:SETENV: /usr/bin/dokku","title":"User Management"},{"location":"deployment/user-management/#user-management","text":"New as of 0.7.0 ssh-keys:add <name> [/path/to/key] # Add a new public key by pipe or path ssh-keys:list # List of all authorized Dokku public ssh keys ssh-keys:remove <name> # Remove SSH public key by name When pushing to Dokku, SSH key-based authorization is the preferred authentication method, for ease of use and increased security. Users in Dokku are managed via the ~/dokku/.ssh/authorized_keys file. It is highly recommended that you follow the steps below to manage users on a Dokku server. Users of older versions of Dokku may use the sshcommand binary to manage keys instead of the ssh-keys plugin. Please refer to the Dokku documentation for your version for more details.","title":"User Management"},{"location":"deployment/user-management/#usage","text":"","title":"Usage"},{"location":"deployment/user-management/#listing-ssh-keys","text":"You can use the ssh-keys:list command to show all configured SSH keys. Any key added via the dokku-installer will be associated with the admin key name. dokku ssh-keys:list 61:21:1f:88:7f:86:d4:3a:68:9f:18:aa:41:4f:bc:3d NAME=\"admin\" SSHCOMMAND_ALLOWED_KEYS=\"no-agent-forwarding,no-user-rc,no-X11-forwarding,no-port-forwarding\" The output contains the following information: SSH Key Fingerprint. The KEY_NAME . A comma separated list of SSH options under the SSHCOMMAND_ALLOWED_KEYS name.","title":"Listing SSH keys"},{"location":"deployment/user-management/#adding-ssh-keys","text":"You can add your public key to Dokku with the ssh-keys:add command. The output will be the fingerprint of the SSH key: dokku ssh-keys:add KEY_NAME path/to/id_rsa.pub b7:76:27:4f:30:90:21:ae:d4:1e:70:20:35:3f:06:d6 KEY_NAME is the name you want to use to refer to this particular key. Including the word admin in the name will grant the user privileges to add additional keys remotely. KEY_NAME is a unique name which is used to identify public keys. Attempting to re-use a key name will result in an error. The SSH (Git) user is always dokku , as this is the system user that the dokku binary uses to perform all its actions. Admin users and root can add keys remotely by specifying the dokku bin on their ssh command: cat ~/.ssh/id_rsa.pub | ssh root@dokku.me dokku ssh-keys:add KEY_NAME If you are using the Vagrant installation, you can also use the make vagrant-acl-add target to add your public key to Dokku (it will use your host username as the USER ): cat ~/.ssh/id_rsa.pub | make vagrant-acl-add","title":"Adding SSH keys"},{"location":"deployment/user-management/#removing-ssh-keys","text":"As key names are unique, they can be used to remove a public SSH key. dokku ssh-keys:remove KEY_NAME","title":"Removing SSH keys"},{"location":"deployment/user-management/#scoping-commands-to-specific-users","text":"Keys are given unique names, which can be used in conjunction with the user-auth plugin trigger to handle command authorization. Please see the documentation on that trigger for more information.","title":"Scoping commands to specific users"},{"location":"deployment/user-management/#granting-other-unix-user-accounts-dokku-access","text":"Any Unix user account which belongs to the sudo Unix group can run Dokku. However, you may want to give them Dokku access but not full sudo privileges. To allow other Unix user accounts to be able to run Dokku commands, without giving them full sudo access, modify your sudoers configuration. Use visudo /etc/sudoers.d/dokku-users , or visudo /etc/sudoers to add the following line: %dokku ALL=(ALL:ALL) NOPASSWD:SETENV: /usr/bin/dokku","title":"Granting other Unix user accounts Dokku access"},{"location":"deployment/zero-downtime-deploys/","text":"Zero Downtime Deploys New as of 0.5.0 checks <app> Show zero-downtime status checks:disable <app> [process-type(s)] Disable zero-downtime deployment for all processes (or comma-separated process-type list) ***WARNING: this will cause downtime during deployments*** checks:enable <app> [process-type(s)] Enable zero-downtime deployment for all processes (or comma-separated process-type list) checks:report [<app>] [<flag>] Displays a checks report for one or more apps checks:run <app> [process-type(s)] Runs zero-downtime checks for all processes (or comma-separated process-type list) checks:skip <app> [process-type(s)] Skip zero-downtime checks for all processes (or comma-separated process-type list) By default, Dokku will wait 10 seconds after starting each container before assuming it is up and proceeding with the deploy. Once this has occurred for all containers started by for an application, traffic will be switched to point to your new containers. Dokku will also wait a further 60 seconds after the deploy is complete before terminating old containers in order to give time for long running connections to terminate. In either case, you may have more than one container running for a given application. You may both create user-defined checks for web processes using a CHECKS file, as well as customize any and all parts of this experience using the checks plugin. Web checks are performed via curl on Dokku host. Some application code - such as the Django framework - checks for specific hostnames or header values, these checks will fail. To avoid this: Remove such checks from your code: Modify your application to remove the hostname check completely. Allow checks from all hostnames: Modify your application to accept a dynamically provided hostname. Specify the domain within the check: See below for further documentation. Configuring check settings using the config plugin There are certain settings that can be configured via environment variables: DOKKU_DEFAULT_CHECKS_WAIT : (default: 10 ) If no user-defined checks are specified - or if the process being checked is not a web process - this is the period of time Dokku will wait before checking that a container is still running. DOKKU_DOCKER_STOP_TIMEOUT : (default: 10 ) Configurable grace period given to the docker stop command. If a container has not stopped by this time, a kill -9 signal or equivalent is sent in order to force-terminate the container. Both the ps:stop and apps:destroy commands also respect this value. If not specified, the Docker defaults for the docker stop command will be used. DOKKU_WAIT_TO_RETIRE : (default: 60 ) After a successful deploy, the grace period given to old containers before they are stopped/terminated. This is useful for ensuring completion of long-running HTTP connections. The following settings may also be specified in the CHECKS file, though are available as environment variables in order to ease application reuse. DOKKU_CHECKS_WAIT : (default: 5 ) Wait this many seconds for the container to start before running checks. DOKKU_CHECKS_TIMEOUT : (default: 30 ) Wait this many seconds for each response before marking it as a failure. DOKKU_CHECKS_ATTEMPTS : (default: 5 ) Number of retries for to run for a specific check before marking it as a failure Skipping and Disabling Checks Note that checks:disable will now (as of 0.6.0) cause downtime for that process-type during deployments. Previously, it acted as checks:skip currently does. You can choose to skip checks completely on a per-application/per-process basis. Skipping checks will avoid the default 10 second waiting period entirely, as well as any other user-defined checks. # process type specification is optional dokku checks:skip node-js-app worker,web -----> Skipping zero downtime for app's (node-js-app) proctypes (worker,web) -----> Unsetting node-js-app -----> Unsetting DOKKU_CHECKS_DISABLED -----> Setting config vars DOKKU_CHECKS_SKIPPED: worker,web Zero downtime checks can also be disabled completely. This will stop old containers before new ones start, which may result in broken connections and downtime if your application fails to boot properly. dokku checks:disable node-js-app worker -----> Disabling zero downtime for app's (node-js-app) proctypes (worker) -----> Setting config vars DOKKU_CHECKS_DISABLED: worker -----> Setting config vars DOKKU_CHECKS_SKIPPED: web Displaying checks reports about an app New as of 0.8.1 You can get a report about the app's checks status using the checks:report command: dokku checks:report =====> search checks information Checks disabled list: none Checks skipped list: none =====> python-sample checks information Checks disabled list: none Checks skipped list: none =====> ruby-sample checks information Checks disabled list: _all_ Checks skipped list: none You can run the command for a specific app also. dokku checks:report node-js-sample =====> node-js-sample checks information Checks disabled list: none Checks skipped list: none You can pass flags which will output only the value of the specific information you want. For example: dokku checks:report node-js-sample --checks-disabled-list Customizing checks If your application needs a longer period to boot up - perhaps to load data into memory, or because of slow boot time - you may also use Dokku's checks functionality to more precisely check whether an application can serve traffic or not. Checks are run against the detected web process from your application's Procfile . For non-web processes, Dokku will fallback to the aforementioned process uptime check. To specify checks, add a CHECKS file to the root of your project directory. The CHECKS file should be plain text and may contain: check instructions settings (NAME=VALUE) comments (lines starting with #) empty lines For Dockerfile-based deploys, the file must be in /app/CHECKS within the container. /app is used by default as the root container directory for buildpack-based deploys. Check instructions The format of a check instruction is a path or relative URL, optionally followed by the expected content: /about Our Amazing Team The CHECKS file can contain multiple checks: / My Amazing App /stylesheets/index.css .body /scripts/index.js $(function() /images/logo.png To check an application that supports multiple hostnames, use relative URLs that include the hostname: //admin.dokku.me Admin Dashboard //static.dokku.me/logo.png You can also specify the protocol to explicitly check HTTPS requests: https://admin.dokku.me Admin Dashboard https://static.dokku.me/logo.png While a full URL may be used in order to invoke checks, if you are using relative URLs, the port must be omitted. Check settings The default behavior is to wait for 5 seconds before running the checks, to timeout the checks after 30 seconds, and to attempt the checks 5 times. If the checks fail 5 times, the deployment is considered failed and the old container will continue serving traffic. You can change the default behavior by setting WAIT , TIMEOUT , and ATTEMPTS to different values in the CHECKS file: WAIT=30 # Wait 1/2 minute TIMEOUT=60 # Timeout after a minute ATTEMPTS=10 # Attempt checks 10 times / My Amazing App Manually invoking checks Checks can also be manually invoked via the checks:run command. This can be used to check the status of an application via cron to provide integration with external healthchecking software. Checks are run against a specific application: dokku checks:run APP -----> Running pre-flight checks -----> Running checks for app (APP.web.1) For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/checks-examples.md for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! -----> Running checks for app (APP.web.2) For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/checks-examples.md for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! -----> Running checks for app (APP.worker.1) For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/checks-examples.md for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! Checks can be scoped to a particular process type: dokku checks:run node-js-app worker -----> Running pre-flight checks -----> Running checks for app (APP.worker.1) For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/checks-examples.md for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! An app process ID may also be specified: dokku checks:run node-js-app web.2 -----> Running pre-flight checks -----> Running checks for app (APP.web.2) For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/checks-examples.md for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! Non-existent process types will result in an error: dokku checks:run node-js-app non-existent -----> Running pre-flight checks Invalid process type specified (APP.non-existent) Non-existent process IDs will also result in an error dokku checks:run node-js-app web.3 -----> Running pre-flight checks Invalid container id specified (APP.web.3) Example: Successful Rails deployment In this example, a Rails application is successfully deployed to Dokku. The initial round of checks fails while the server is starting, but once it starts they succeed and the deployment is successful. WAIT is set to 10 because our application takes a while to boot up. ATTEMPTS is set to 6 , but the third attempt succeeds. CHECKS file WAIT=10 ATTEMPTS=6 /check.txt simple_check For this check to work, we've added a line to config/routes.rb that simply returns a string: get '/check.txt', to: proc {[200, {}, ['simple_check']]} Deploy output Note: The output has been trimmed for brevity. git push dokku master -----> Cleaning up... -----> Building node-js-app from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... -----> Discovering process types Procfile declares types -> web -----> Releasing node-js-app... -----> Deploying node-js-app... -----> Running pre-flight checks -----> Attempt 1/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" -----> All checks successful! =====> node-js-app container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop =====> end node-js-app container output -----> Running post-deploy -----> Configuring myapp.dokku.me... -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx -----> Shutting down old container in 60 seconds =====> Application deployed: http://myapp.dokku.me Example: Failing Rails deployment In this example, a Rails application fails to deploy. The reason for the failure is that the PostgreSQL database connection fails. The initial checks will fail while we wait for the server to start up, just like in the above example. However, once the server does start accepting connections, we will see an error 500 due to the PostgreSQL database connection failure. Once the attempts have been exceeded, the deployment fails and we see the container output, which shows the PostgreSQL connection errors. CHECKS file WAIT=10 ATTEMPTS=6 / The check to the root url / would normally access the database. Deploy output Note: The output has been trimmed for brevity. git push dokku master -----> Cleaning up... -----> Building node-js-app from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... Discovering process types Procfile declares types -> web Releasing node-js-app... Deploying node-js-app... Running pre-flight checks -----> Attempt 1/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 3/6 failed. -----> Attempt 4/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 4/6 failed. -----> Attempt 5/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 5/6 failed. -----> Attempt 6/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error Could not start due to 1 failed checks. ! Check attempt 6/6 failed. =====> node-js-app container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop Started GET \"/\" for 172.17.42.1 at 2015-03-26 21:36:47 +0000 Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? PG::ConnectionBad (could not connect to server: Connection refused Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? ): vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `connect' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:242:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `postgresql_connection =====> end node-js-app container output /usr/bin/dokku: line 49: 23409 Killed dokku deploy \"$APP\" To dokku@dokku.me:myapp ! [remote rejected] dokku -> master (pre-receive hook declined) error: failed to push some refs to 'dokku@dokku.me:myapp'","title":"Zero Downtime Deploys"},{"location":"deployment/zero-downtime-deploys/#zero-downtime-deploys","text":"New as of 0.5.0 checks <app> Show zero-downtime status checks:disable <app> [process-type(s)] Disable zero-downtime deployment for all processes (or comma-separated process-type list) ***WARNING: this will cause downtime during deployments*** checks:enable <app> [process-type(s)] Enable zero-downtime deployment for all processes (or comma-separated process-type list) checks:report [<app>] [<flag>] Displays a checks report for one or more apps checks:run <app> [process-type(s)] Runs zero-downtime checks for all processes (or comma-separated process-type list) checks:skip <app> [process-type(s)] Skip zero-downtime checks for all processes (or comma-separated process-type list) By default, Dokku will wait 10 seconds after starting each container before assuming it is up and proceeding with the deploy. Once this has occurred for all containers started by for an application, traffic will be switched to point to your new containers. Dokku will also wait a further 60 seconds after the deploy is complete before terminating old containers in order to give time for long running connections to terminate. In either case, you may have more than one container running for a given application. You may both create user-defined checks for web processes using a CHECKS file, as well as customize any and all parts of this experience using the checks plugin. Web checks are performed via curl on Dokku host. Some application code - such as the Django framework - checks for specific hostnames or header values, these checks will fail. To avoid this: Remove such checks from your code: Modify your application to remove the hostname check completely. Allow checks from all hostnames: Modify your application to accept a dynamically provided hostname. Specify the domain within the check: See below for further documentation.","title":"Zero Downtime Deploys"},{"location":"deployment/zero-downtime-deploys/#configuring-check-settings-using-the-config-plugin","text":"There are certain settings that can be configured via environment variables: DOKKU_DEFAULT_CHECKS_WAIT : (default: 10 ) If no user-defined checks are specified - or if the process being checked is not a web process - this is the period of time Dokku will wait before checking that a container is still running. DOKKU_DOCKER_STOP_TIMEOUT : (default: 10 ) Configurable grace period given to the docker stop command. If a container has not stopped by this time, a kill -9 signal or equivalent is sent in order to force-terminate the container. Both the ps:stop and apps:destroy commands also respect this value. If not specified, the Docker defaults for the docker stop command will be used. DOKKU_WAIT_TO_RETIRE : (default: 60 ) After a successful deploy, the grace period given to old containers before they are stopped/terminated. This is useful for ensuring completion of long-running HTTP connections. The following settings may also be specified in the CHECKS file, though are available as environment variables in order to ease application reuse. DOKKU_CHECKS_WAIT : (default: 5 ) Wait this many seconds for the container to start before running checks. DOKKU_CHECKS_TIMEOUT : (default: 30 ) Wait this many seconds for each response before marking it as a failure. DOKKU_CHECKS_ATTEMPTS : (default: 5 ) Number of retries for to run for a specific check before marking it as a failure","title":"Configuring check settings using the config plugin"},{"location":"deployment/zero-downtime-deploys/#skipping-and-disabling-checks","text":"Note that checks:disable will now (as of 0.6.0) cause downtime for that process-type during deployments. Previously, it acted as checks:skip currently does. You can choose to skip checks completely on a per-application/per-process basis. Skipping checks will avoid the default 10 second waiting period entirely, as well as any other user-defined checks. # process type specification is optional dokku checks:skip node-js-app worker,web -----> Skipping zero downtime for app's (node-js-app) proctypes (worker,web) -----> Unsetting node-js-app -----> Unsetting DOKKU_CHECKS_DISABLED -----> Setting config vars DOKKU_CHECKS_SKIPPED: worker,web Zero downtime checks can also be disabled completely. This will stop old containers before new ones start, which may result in broken connections and downtime if your application fails to boot properly. dokku checks:disable node-js-app worker -----> Disabling zero downtime for app's (node-js-app) proctypes (worker) -----> Setting config vars DOKKU_CHECKS_DISABLED: worker -----> Setting config vars DOKKU_CHECKS_SKIPPED: web","title":"Skipping and Disabling Checks"},{"location":"deployment/zero-downtime-deploys/#displaying-checks-reports-about-an-app","text":"New as of 0.8.1 You can get a report about the app's checks status using the checks:report command: dokku checks:report =====> search checks information Checks disabled list: none Checks skipped list: none =====> python-sample checks information Checks disabled list: none Checks skipped list: none =====> ruby-sample checks information Checks disabled list: _all_ Checks skipped list: none You can run the command for a specific app also. dokku checks:report node-js-sample =====> node-js-sample checks information Checks disabled list: none Checks skipped list: none You can pass flags which will output only the value of the specific information you want. For example: dokku checks:report node-js-sample --checks-disabled-list","title":"Displaying checks reports about an app"},{"location":"deployment/zero-downtime-deploys/#customizing-checks","text":"If your application needs a longer period to boot up - perhaps to load data into memory, or because of slow boot time - you may also use Dokku's checks functionality to more precisely check whether an application can serve traffic or not. Checks are run against the detected web process from your application's Procfile . For non-web processes, Dokku will fallback to the aforementioned process uptime check. To specify checks, add a CHECKS file to the root of your project directory. The CHECKS file should be plain text and may contain: check instructions settings (NAME=VALUE) comments (lines starting with #) empty lines For Dockerfile-based deploys, the file must be in /app/CHECKS within the container. /app is used by default as the root container directory for buildpack-based deploys.","title":"Customizing checks"},{"location":"deployment/zero-downtime-deploys/#check-instructions","text":"The format of a check instruction is a path or relative URL, optionally followed by the expected content: /about Our Amazing Team The CHECKS file can contain multiple checks: / My Amazing App /stylesheets/index.css .body /scripts/index.js $(function() /images/logo.png To check an application that supports multiple hostnames, use relative URLs that include the hostname: //admin.dokku.me Admin Dashboard //static.dokku.me/logo.png You can also specify the protocol to explicitly check HTTPS requests: https://admin.dokku.me Admin Dashboard https://static.dokku.me/logo.png While a full URL may be used in order to invoke checks, if you are using relative URLs, the port must be omitted.","title":"Check instructions"},{"location":"deployment/zero-downtime-deploys/#check-settings","text":"The default behavior is to wait for 5 seconds before running the checks, to timeout the checks after 30 seconds, and to attempt the checks 5 times. If the checks fail 5 times, the deployment is considered failed and the old container will continue serving traffic. You can change the default behavior by setting WAIT , TIMEOUT , and ATTEMPTS to different values in the CHECKS file: WAIT=30 # Wait 1/2 minute TIMEOUT=60 # Timeout after a minute ATTEMPTS=10 # Attempt checks 10 times / My Amazing App","title":"Check settings"},{"location":"deployment/zero-downtime-deploys/#manually-invoking-checks","text":"Checks can also be manually invoked via the checks:run command. This can be used to check the status of an application via cron to provide integration with external healthchecking software. Checks are run against a specific application: dokku checks:run APP -----> Running pre-flight checks -----> Running checks for app (APP.web.1) For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/checks-examples.md for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! -----> Running checks for app (APP.web.2) For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/checks-examples.md for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! -----> Running checks for app (APP.worker.1) For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/checks-examples.md for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! Checks can be scoped to a particular process type: dokku checks:run node-js-app worker -----> Running pre-flight checks -----> Running checks for app (APP.worker.1) For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/checks-examples.md for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! An app process ID may also be specified: dokku checks:run node-js-app web.2 -----> Running pre-flight checks -----> Running checks for app (APP.web.2) For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/checks-examples.md for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! Non-existent process types will result in an error: dokku checks:run node-js-app non-existent -----> Running pre-flight checks Invalid process type specified (APP.non-existent) Non-existent process IDs will also result in an error dokku checks:run node-js-app web.3 -----> Running pre-flight checks Invalid container id specified (APP.web.3)","title":"Manually invoking checks"},{"location":"deployment/zero-downtime-deploys/#example-successful-rails-deployment","text":"In this example, a Rails application is successfully deployed to Dokku. The initial round of checks fails while the server is starting, but once it starts they succeed and the deployment is successful. WAIT is set to 10 because our application takes a while to boot up. ATTEMPTS is set to 6 , but the third attempt succeeds.","title":"Example: Successful Rails deployment"},{"location":"deployment/zero-downtime-deploys/#checks-file","text":"WAIT=10 ATTEMPTS=6 /check.txt simple_check For this check to work, we've added a line to config/routes.rb that simply returns a string: get '/check.txt', to: proc {[200, {}, ['simple_check']]}","title":"CHECKS file"},{"location":"deployment/zero-downtime-deploys/#deploy-output","text":"Note: The output has been trimmed for brevity. git push dokku master -----> Cleaning up... -----> Building node-js-app from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... -----> Discovering process types Procfile declares types -> web -----> Releasing node-js-app... -----> Deploying node-js-app... -----> Running pre-flight checks -----> Attempt 1/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" -----> All checks successful! =====> node-js-app container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop =====> end node-js-app container output -----> Running post-deploy -----> Configuring myapp.dokku.me... -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx -----> Shutting down old container in 60 seconds =====> Application deployed: http://myapp.dokku.me","title":"Deploy output"},{"location":"deployment/zero-downtime-deploys/#example-failing-rails-deployment","text":"In this example, a Rails application fails to deploy. The reason for the failure is that the PostgreSQL database connection fails. The initial checks will fail while we wait for the server to start up, just like in the above example. However, once the server does start accepting connections, we will see an error 500 due to the PostgreSQL database connection failure. Once the attempts have been exceeded, the deployment fails and we see the container output, which shows the PostgreSQL connection errors.","title":"Example: Failing Rails deployment"},{"location":"deployment/zero-downtime-deploys/#checks-file_1","text":"WAIT=10 ATTEMPTS=6 / The check to the root url / would normally access the database.","title":"CHECKS file"},{"location":"deployment/zero-downtime-deploys/#deploy-output_1","text":"Note: The output has been trimmed for brevity. git push dokku master -----> Cleaning up... -----> Building node-js-app from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... Discovering process types Procfile declares types -> web Releasing node-js-app... Deploying node-js-app... Running pre-flight checks -----> Attempt 1/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 3/6 failed. -----> Attempt 4/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 4/6 failed. -----> Attempt 5/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 5/6 failed. -----> Attempt 6/6 Waiting for 10 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error Could not start due to 1 failed checks. ! Check attempt 6/6 failed. =====> node-js-app container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop Started GET \"/\" for 172.17.42.1 at 2015-03-26 21:36:47 +0000 Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? PG::ConnectionBad (could not connect to server: Connection refused Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? ): vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `connect' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:242:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `postgresql_connection =====> end node-js-app container output /usr/bin/dokku: line 49: 23409 Killed dokku deploy \"$APP\" To dokku@dokku.me:myapp ! [remote rejected] dokku -> master (pre-receive hook declined) error: failed to push some refs to 'dokku@dokku.me:myapp'","title":"Deploy output"},{"location":"deployment/methods/buildpacks/","text":"Buildpack Deployment Dokku normally defaults to using Heroku buildpacks for deployment, though this may be overridden by committing a valid Dockerfile to the root of your repository and pushing the repository to your Dokku installation. To avoid this automatic Dockerfile deployment detection, you may do one of the following: Use dokku config:set to set the BUILDPACK_URL environment variable. Add BUILDPACK_URL to a committed .env file in the root of your repository. See the environment variable documentation for more details. Create a .buildpacks file in the root of your repository. Switching from Dockerfile deployments If an application was previously deployed via Dockerfile, the following commands should be run before a buildpack deploy will succeed: dokku config:unset --no-restart node-js-app DOKKU_DOCKERFILE_CMD DOKKU_DOCKERFILE_ENTRYPOINT DOKKU_PROXY_PORT_MAP Specifying a custom buildpack In certain cases you may want to specify a custom buildpack. While Dokku uses Herokuish to support all the official Heroku buildpacks , it is possible that the buildpack detection does not work well for your application. As well, you may wish to use a custom buildpack to handle specific application logic. To use a specific buildpack, you can run the following Dokku command: # replace REPOSITORY_URL with your buildpack's url dokku config:set node-js-app BUILDPACK_URL = REPOSITORY_URL # example: using a specific ruby buildpack version dokku config:set node-js-app BUILDPACK_URL = https://github.com/heroku/heroku-buildpack-ruby.git#v142 Please check the documentation for your particular buildpack as you may need to include configuration files (such as a Procfile) in your project root. Using multiple buildpacks You can only set a single buildpack using the BUILDPACK_URL , though there may be times when you wish to use multiple buildpacks. To do so, simply create a .buildpacks file in the base of your repository. This file should list all the buildpacks, one-per-line. For instance, if you wish to use both the nodejs and ruby buildpacks, your .buildpacks file should contain the following: https://github.com/heroku/heroku-buildpack-nodejs.git#v87 https://github.com/heroku/heroku-buildpack-ruby.git#v142 Always remember to pin your buildpack versions when using the multi-buildpacks method, or you may find deploys changing your deployed environment. You may also choose to set just a single buildpack in this file, though that is up to you. Please check the documentation for your particular buildpack(s) as you may need to include configuration files (such as a Procfile) in your project root. Using a specific buildpack version As Dokku pins all buildpacks via Herokuish releases, there may be occasions where a local buildpack version is out of date. If you wish to use a more recent version of the buildpack, you may use any of the above methods to specify a buildpack without the Git SHA attached like so: # using the latest nodejs buildpack dokku config:set node-js-app BUILDPACK_URL = https://github.com/heroku/heroku-buildpack-nodejs You may also wish to use a specific version of a buildpack, which is also simple # using v87 of the nodejs buildpack dokku config:set node-js-app BUILDPACK_URL = https://github.com/heroku/heroku-buildpack-nodejs#v87 Specifying commands via Procfile While many buildpacks have a default command that is run when a detected repository is pushed, it is possible to override this command via a Procfile. A Procfile can also be used to specify multiple commands, each of which is subject to process scaling. See the process scaling documentation for more details around scaling individual processes. A Procfile is a file named Procfile . It should be named Procfile exactly, and not anything else. For example, Procfile.txt is not valid. The file should be a simple text file. The file must be placed in the root directory of your application. It will not function if placed in a subdirectory. If the file exists, it should not be empty, as doing so may result in a failed deploy. The syntax for declaring a Procfile is as follows. Note that the format is one process type per line, with no duplicate process types. <process type>: <command> If, for example, you have multiple queue workers and wish to scale them separately, the following would be a valid way to work around the requirement of not duplicating process types: worker : env QUEUE =* bundle exec rake resque : work importantworker : env QUEUE = important bundle exec rake resque : work The web process type holds some significance in that it is the only process type that is automatically scaled to 1 on the initial application deploy. See the process scaling documentation for more details around scaling individual processes. cURL build timeouts Certain buildpacks may time out in retrieving dependencies via cURL. This can happen when your network connection is poor or if there is significant network congestion. You may see a message similar to gzip: stdin: unexpected end of file after a cURL command. If you see output similar this when deploying , you may need to override the cURL timeouts to increase the length of time allotted to those tasks. You can do so via the config plugin: dokku config:set --global CURL_TIMEOUT = 1200 dokku config:set --global CURL_CONNECT_TIMEOUT = 180 Clearing buildpack cache See the repository management documentation .","title":"Buildpack Deployment"},{"location":"deployment/methods/buildpacks/#buildpack-deployment","text":"Dokku normally defaults to using Heroku buildpacks for deployment, though this may be overridden by committing a valid Dockerfile to the root of your repository and pushing the repository to your Dokku installation. To avoid this automatic Dockerfile deployment detection, you may do one of the following: Use dokku config:set to set the BUILDPACK_URL environment variable. Add BUILDPACK_URL to a committed .env file in the root of your repository. See the environment variable documentation for more details. Create a .buildpacks file in the root of your repository.","title":"Buildpack Deployment"},{"location":"deployment/methods/buildpacks/#switching-from-dockerfile-deployments","text":"If an application was previously deployed via Dockerfile, the following commands should be run before a buildpack deploy will succeed: dokku config:unset --no-restart node-js-app DOKKU_DOCKERFILE_CMD DOKKU_DOCKERFILE_ENTRYPOINT DOKKU_PROXY_PORT_MAP","title":"Switching from Dockerfile deployments"},{"location":"deployment/methods/buildpacks/#specifying-a-custom-buildpack","text":"In certain cases you may want to specify a custom buildpack. While Dokku uses Herokuish to support all the official Heroku buildpacks , it is possible that the buildpack detection does not work well for your application. As well, you may wish to use a custom buildpack to handle specific application logic. To use a specific buildpack, you can run the following Dokku command: # replace REPOSITORY_URL with your buildpack's url dokku config:set node-js-app BUILDPACK_URL = REPOSITORY_URL # example: using a specific ruby buildpack version dokku config:set node-js-app BUILDPACK_URL = https://github.com/heroku/heroku-buildpack-ruby.git#v142 Please check the documentation for your particular buildpack as you may need to include configuration files (such as a Procfile) in your project root.","title":"Specifying a custom buildpack"},{"location":"deployment/methods/buildpacks/#using-multiple-buildpacks","text":"You can only set a single buildpack using the BUILDPACK_URL , though there may be times when you wish to use multiple buildpacks. To do so, simply create a .buildpacks file in the base of your repository. This file should list all the buildpacks, one-per-line. For instance, if you wish to use both the nodejs and ruby buildpacks, your .buildpacks file should contain the following: https://github.com/heroku/heroku-buildpack-nodejs.git#v87 https://github.com/heroku/heroku-buildpack-ruby.git#v142 Always remember to pin your buildpack versions when using the multi-buildpacks method, or you may find deploys changing your deployed environment. You may also choose to set just a single buildpack in this file, though that is up to you. Please check the documentation for your particular buildpack(s) as you may need to include configuration files (such as a Procfile) in your project root.","title":"Using multiple buildpacks"},{"location":"deployment/methods/buildpacks/#using-a-specific-buildpack-version","text":"As Dokku pins all buildpacks via Herokuish releases, there may be occasions where a local buildpack version is out of date. If you wish to use a more recent version of the buildpack, you may use any of the above methods to specify a buildpack without the Git SHA attached like so: # using the latest nodejs buildpack dokku config:set node-js-app BUILDPACK_URL = https://github.com/heroku/heroku-buildpack-nodejs You may also wish to use a specific version of a buildpack, which is also simple # using v87 of the nodejs buildpack dokku config:set node-js-app BUILDPACK_URL = https://github.com/heroku/heroku-buildpack-nodejs#v87","title":"Using a specific buildpack version"},{"location":"deployment/methods/buildpacks/#specifying-commands-via-procfile","text":"While many buildpacks have a default command that is run when a detected repository is pushed, it is possible to override this command via a Procfile. A Procfile can also be used to specify multiple commands, each of which is subject to process scaling. See the process scaling documentation for more details around scaling individual processes. A Procfile is a file named Procfile . It should be named Procfile exactly, and not anything else. For example, Procfile.txt is not valid. The file should be a simple text file. The file must be placed in the root directory of your application. It will not function if placed in a subdirectory. If the file exists, it should not be empty, as doing so may result in a failed deploy. The syntax for declaring a Procfile is as follows. Note that the format is one process type per line, with no duplicate process types. <process type>: <command> If, for example, you have multiple queue workers and wish to scale them separately, the following would be a valid way to work around the requirement of not duplicating process types: worker : env QUEUE =* bundle exec rake resque : work importantworker : env QUEUE = important bundle exec rake resque : work The web process type holds some significance in that it is the only process type that is automatically scaled to 1 on the initial application deploy. See the process scaling documentation for more details around scaling individual processes.","title":"Specifying commands via Procfile"},{"location":"deployment/methods/buildpacks/#curl-build-timeouts","text":"Certain buildpacks may time out in retrieving dependencies via cURL. This can happen when your network connection is poor or if there is significant network congestion. You may see a message similar to gzip: stdin: unexpected end of file after a cURL command. If you see output similar this when deploying , you may need to override the cURL timeouts to increase the length of time allotted to those tasks. You can do so via the config plugin: dokku config:set --global CURL_TIMEOUT = 1200 dokku config:set --global CURL_CONNECT_TIMEOUT = 180","title":"cURL build timeouts"},{"location":"deployment/methods/buildpacks/#clearing-buildpack-cache","text":"See the repository management documentation .","title":"Clearing buildpack cache"},{"location":"deployment/methods/dockerfiles/","text":"Dockerfile Deployment New as of 0.3.15 While Dokku normally defaults to using Heroku buildpacks for deployment, you can also use Docker's native Dockerfile system to define a container. Dockerfile support is considered a power user feature. By using Dockerfile-based deployment, you agree that you will not have the same comfort as that enjoyed by buildpack users, and Dokku features may work differently. Differences between the two systems will be documented here. To use a Dockerfile for deployment, commit a valid Dockerfile to the root of your repository and push the repository to your Dokku installation. If this file is detected, Dokku will default to using it to construct containers except in the following two cases: The application has a BUILDPACK_URL environment variable set via the dokku config:set command or in a committed .env file. In this case, Dokku will use your specified buildpack. The application has a .buildpacks file in the root of the repository. In this case, Dokku will use your specified buildpack(s). Switching from buildpack deployments If an application was previously deployed via buildpacks, the following commands should be run before a Dockerfile deploy will succeed: dokku config:unset --no-restart node-js-app DOKKU_PROXY_PORT_MAP Build-time configuration variables For security reasons - and as per Docker recommendations - Dockerfile-based deploys have variables available only during runtime. For users that require customization in the build phase, you may use build arguments via the docker-options plugin : dokku docker-options:add node-js-app build '--build-arg NODE_ENV=production' Once set, the Dockerfile usage would be as follows: FROM debian:jessie # set the argument default ARG NODE_ENV = production # use the argument RUN echo $NODE_ENV You may also set the argument as an environment variable FROM debian:jessie # set the argument default ARG NODE_ENV = production # assign it to an environment variable # we can wrap the variable in brackets ENV NODE_ENV ${ NODE_ENV } # or omit them completely # use the argument RUN echo $NODE_ENV Customizing the run command By default no arguments are passed to docker run when deploying the container and the CMD or ENTRYPOINT defined in the Dockerfile are executed. You can take advantage of docker ability of overriding the CMD or passing parameters to your ENTRYPOINT setting $DOKKU_DOCKERFILE_START_CMD . Let's say for example you are deploying a base Node.js image, with the following ENTRYPOINT : ENTRYPOINT [ \"node\" ] You can do: dokku config:set node-js-app DOKKU_DOCKERFILE_START_CMD = \"--harmony server.js\" To tell Docker what to run. Setting $DOKKU_DOCKERFILE_CACHE_BUILD to true or false will enable or disable Docker's image layer cache. Lastly, for more granular build control, you may also pass any docker build option to docker , by setting $DOKKU_DOCKER_BUILD_OPTS . Procfiles and multiple processes New as of 0.5.0 You can also customize the run command using a Procfile , much like you would on Heroku or with a buildpack deployed app. The Procfile should contain one or more lines defining process types and associated commands . When you deploy your app, a Docker image will be built. The Procfile will be extracted from the image (it must be in the folder defined in your Dockerfile as WORKDIR or /app ) and the commands in it will be passed to docker run to start your process(es). Here's an example Procfile : web : bin/run-prod.sh worker : bin/run-worker.sh And Dockerfile : FROM debian:jessie WORKDIR /app COPY . ./ CMD [ \"bin/run-dev.sh\" ] When you deploy this app the web process will automatically be scaled to 1 and your Docker container will be started basically using the command docker run bin/run-prod.sh . If you want to also run a worker container for this app, you can run dokku ps:scale worker=1 and a new container will be started by running docker run bin/run-worker.sh (the actual docker run commands are a bit more complex, but this is the basic idea). If you use an ENTRYPOINT in your Dockerfile , the lines in your Procfile will be passed as arguments to the ENTRYPOINT script instead of being executed. Exposed ports See the port management documentation .","title":"Dockerfile Deployment"},{"location":"deployment/methods/dockerfiles/#dockerfile-deployment","text":"New as of 0.3.15 While Dokku normally defaults to using Heroku buildpacks for deployment, you can also use Docker's native Dockerfile system to define a container. Dockerfile support is considered a power user feature. By using Dockerfile-based deployment, you agree that you will not have the same comfort as that enjoyed by buildpack users, and Dokku features may work differently. Differences between the two systems will be documented here. To use a Dockerfile for deployment, commit a valid Dockerfile to the root of your repository and push the repository to your Dokku installation. If this file is detected, Dokku will default to using it to construct containers except in the following two cases: The application has a BUILDPACK_URL environment variable set via the dokku config:set command or in a committed .env file. In this case, Dokku will use your specified buildpack. The application has a .buildpacks file in the root of the repository. In this case, Dokku will use your specified buildpack(s).","title":"Dockerfile Deployment"},{"location":"deployment/methods/dockerfiles/#switching-from-buildpack-deployments","text":"If an application was previously deployed via buildpacks, the following commands should be run before a Dockerfile deploy will succeed: dokku config:unset --no-restart node-js-app DOKKU_PROXY_PORT_MAP","title":"Switching from buildpack deployments"},{"location":"deployment/methods/dockerfiles/#build-time-configuration-variables","text":"For security reasons - and as per Docker recommendations - Dockerfile-based deploys have variables available only during runtime. For users that require customization in the build phase, you may use build arguments via the docker-options plugin : dokku docker-options:add node-js-app build '--build-arg NODE_ENV=production' Once set, the Dockerfile usage would be as follows: FROM debian:jessie # set the argument default ARG NODE_ENV = production # use the argument RUN echo $NODE_ENV You may also set the argument as an environment variable FROM debian:jessie # set the argument default ARG NODE_ENV = production # assign it to an environment variable # we can wrap the variable in brackets ENV NODE_ENV ${ NODE_ENV } # or omit them completely # use the argument RUN echo $NODE_ENV","title":"Build-time configuration variables"},{"location":"deployment/methods/dockerfiles/#customizing-the-run-command","text":"By default no arguments are passed to docker run when deploying the container and the CMD or ENTRYPOINT defined in the Dockerfile are executed. You can take advantage of docker ability of overriding the CMD or passing parameters to your ENTRYPOINT setting $DOKKU_DOCKERFILE_START_CMD . Let's say for example you are deploying a base Node.js image, with the following ENTRYPOINT : ENTRYPOINT [ \"node\" ] You can do: dokku config:set node-js-app DOKKU_DOCKERFILE_START_CMD = \"--harmony server.js\" To tell Docker what to run. Setting $DOKKU_DOCKERFILE_CACHE_BUILD to true or false will enable or disable Docker's image layer cache. Lastly, for more granular build control, you may also pass any docker build option to docker , by setting $DOKKU_DOCKER_BUILD_OPTS .","title":"Customizing the run command"},{"location":"deployment/methods/dockerfiles/#procfiles-and-multiple-processes","text":"New as of 0.5.0 You can also customize the run command using a Procfile , much like you would on Heroku or with a buildpack deployed app. The Procfile should contain one or more lines defining process types and associated commands . When you deploy your app, a Docker image will be built. The Procfile will be extracted from the image (it must be in the folder defined in your Dockerfile as WORKDIR or /app ) and the commands in it will be passed to docker run to start your process(es). Here's an example Procfile : web : bin/run-prod.sh worker : bin/run-worker.sh And Dockerfile : FROM debian:jessie WORKDIR /app COPY . ./ CMD [ \"bin/run-dev.sh\" ] When you deploy this app the web process will automatically be scaled to 1 and your Docker container will be started basically using the command docker run bin/run-prod.sh . If you want to also run a worker container for this app, you can run dokku ps:scale worker=1 and a new container will be started by running docker run bin/run-worker.sh (the actual docker run commands are a bit more complex, but this is the basic idea). If you use an ENTRYPOINT in your Dockerfile , the lines in your Procfile will be passed as arguments to the ENTRYPOINT script instead of being executed.","title":"Procfiles and multiple processes"},{"location":"deployment/methods/dockerfiles/#exposed-ports","text":"See the port management documentation .","title":"Exposed ports"},{"location":"deployment/methods/git/","text":"Git Deployment Subcommands new as of 0.12.0 git:initialize <app> # Initialize a git repository for an app git:report [<app>] [<flag>] # Displays a git report for one or more apps git:set <app> <key> (<value>) # Set or clear a git property for an app Git-based deployment has been the traditional method of deploying applications in Dokku. As of v0.12.0, Dokku introduces a few ways to customize the experience of deploying via git push . A Git-based deployment currently supports building applications via both Buildpack and Dockerfile . Usage Initializing an application When an application is created via git push , Dokku will create the proper pre-receive hook in order to execute the build pipeline. In certain cases - such as when fronting deploys with the git-http-backend - this may not be correctly created. As an alternative, the git:initialize command can be used to trigger this creation: # on the Dokku host # overrides any existing pre-receive hook dokku git:initialize node-js-app In order for the above command to succeed, the application must already exist. Warning: If the pre-receive hook was customized in any way, this will overwrite that hook with the current defaults for Dokku. Changing the deploy branch By default, Dokku will deploy code pushed to the master branch. In order to quickly deploy a different local branch, the following Git command can be used: # on the local machine # where `SOME_BRANCH_NAME` is the name of the branch git push dokku SOME_BRANCH_NAME:master In 0.12.0 , the correct way to change the deploy branch is to use the git:set Dokku command. # on the Dokku host # override for all applications dokku git:set --global deploy-branch SOME_BRANCH_NAME # override for a specific app # where `SOME_BRANCH_NAME` is the name of the branch dokku git:set node-js-app deploy-branch SOME_BRANCH_NAME Pushing multiple branches can also be supported by creating a receive-branch plugin trigger in a custom plugin. Configuring the GIT_REV environment variable New as of 0.12.0 Application deployments will include a special GIT_REV environment variable containing the current deployment sha being deployed. For rebuilds, this SHA will remain the same. To configure the name of the GIT_REV environment variable, run the git:set command as follows: # on the Dokku host # override for a specific app dokku git:set node-js-app rev-env-var DOKKU_GIT_REV This behavior can be disabled entirely on a per-app basis by setting the rev-env-var value to an empty string: # on the Dokku host # override for a specific app dokku git:set node-js-app rev-env-var \"\"","title":"Git Deployment"},{"location":"deployment/methods/git/#git-deployment","text":"Subcommands new as of 0.12.0 git:initialize <app> # Initialize a git repository for an app git:report [<app>] [<flag>] # Displays a git report for one or more apps git:set <app> <key> (<value>) # Set or clear a git property for an app Git-based deployment has been the traditional method of deploying applications in Dokku. As of v0.12.0, Dokku introduces a few ways to customize the experience of deploying via git push . A Git-based deployment currently supports building applications via both Buildpack and Dockerfile .","title":"Git Deployment"},{"location":"deployment/methods/git/#usage","text":"","title":"Usage"},{"location":"deployment/methods/git/#initializing-an-application","text":"When an application is created via git push , Dokku will create the proper pre-receive hook in order to execute the build pipeline. In certain cases - such as when fronting deploys with the git-http-backend - this may not be correctly created. As an alternative, the git:initialize command can be used to trigger this creation: # on the Dokku host # overrides any existing pre-receive hook dokku git:initialize node-js-app In order for the above command to succeed, the application must already exist. Warning: If the pre-receive hook was customized in any way, this will overwrite that hook with the current defaults for Dokku.","title":"Initializing an application"},{"location":"deployment/methods/git/#changing-the-deploy-branch","text":"By default, Dokku will deploy code pushed to the master branch. In order to quickly deploy a different local branch, the following Git command can be used: # on the local machine # where `SOME_BRANCH_NAME` is the name of the branch git push dokku SOME_BRANCH_NAME:master In 0.12.0 , the correct way to change the deploy branch is to use the git:set Dokku command. # on the Dokku host # override for all applications dokku git:set --global deploy-branch SOME_BRANCH_NAME # override for a specific app # where `SOME_BRANCH_NAME` is the name of the branch dokku git:set node-js-app deploy-branch SOME_BRANCH_NAME Pushing multiple branches can also be supported by creating a receive-branch plugin trigger in a custom plugin.","title":"Changing the deploy branch"},{"location":"deployment/methods/git/#configuring-the-git_rev-environment-variable","text":"New as of 0.12.0 Application deployments will include a special GIT_REV environment variable containing the current deployment sha being deployed. For rebuilds, this SHA will remain the same. To configure the name of the GIT_REV environment variable, run the git:set command as follows: # on the Dokku host # override for a specific app dokku git:set node-js-app rev-env-var DOKKU_GIT_REV This behavior can be disabled entirely on a per-app basis by setting the rev-env-var value to an empty string: # on the Dokku host # override for a specific app dokku git:set node-js-app rev-env-var \"\"","title":"Configuring the GIT_REV environment variable"},{"location":"deployment/methods/images/","text":"Docker Image Tag Deployment New as of 0.4.0 tags <app> # List all app image tags tags:create <app> <tag> # Add tag to latest running app image tags:deploy <app> <tag> # Deploy tagged app image tags:destroy <app> <tag> # Remove app image tag The Dokku tags plugin allows you to add Docker image tags to the currently deployed app image for versioning and subsequent deployment. When triggering dokku ps:rebuild APP on an application deployed via the tags plugin, the following may occur: Applications previously deployed via another method ( git / tar ): The application may revert to a state before the latest custom image tag was deployed. Applications that were only ever deployed via the tags plugin: No action will be taken against your application. Please use the tags:deploy command when redeploying an application deployed via Docker image. Usage Exposed ports See the port management documentation . Listing tags for an application For example, you can list all tags for a given application: dokku tags node-js-app =====> Image tags for dokku/node-js-app REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE dokku/node-js-app latest 936a42f25901 About a minute ago 1.025 GB Creating a tag You can also create new tags for that app using the tags:create function. Tags should conform to the Docker tagging specification for your Docker version. As of 1.10, that specification is available here , while users of older versions can check the documentation here . dokku tags:create node-js-app v1 =====> Added v1 tag to dokku/node-js-app Once the tag is created, you can see the output by running the tags command again. dokku tags node-js-app =====> Image tags for dokku/node-js-app REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE dokku/node-js-app latest 936a42f25901 About a minute ago 1.025 GB dokku/node-js-app v1 936a42f25901 About a minute ago 1.025 GB Deploying an image tag Finally, you can also deploy a local image using the tags:deploy command. When specifying a tag that is not latest , the released image will be retagged as the latest image tag for the app. Warning: For images based on Herokuish, using the tags:deploy command will reset environment variables written into the image, causing a retag to occur. This will - on average - add two extra layers to your deployed image. Note that this does not affect Dockerfile-based images, which are the majority of images deployed via the tags command. dokku tags:deploy node-js-app v1 -----> Releasing node-js-app (dokku/node-js-app:v1)... -----> Deploying node-js-app (dokku/node-js-app:v1)... -----> Running pre-flight checks For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/deployment/zero-downtime-deploys/ for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! =====> node-js-app container output: Detected 512 MB available memory, 512 MB limit per process (WEB_MEMORY) Recommending WEB_CONCURRENCY=1 > node-js-app@0.1.0 start /app > node index.js Node app is running at localhost:5000 =====> end node-js-app container output -----> Running post-deploy -----> Configuring node-js-app.dokku.me... -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx -----> Shutting down old containers in 60 seconds =====> 025eec3fa3b442fded90933d58d8ed8422901f0449f5ea0c23d00515af5d3137 =====> Application deployed: http://node-js-app.dokku.me Image workflows Deploying from a Docker registry You can alternatively add image pulled from a Docker registry and deploy from it by using tagging feature. In this example, we are deploying from Docker Hub. Create Dokku app as usual. dokku apps:create test-app Pull image from Docker Hub. docker pull demo-repo/some-image:v12 Retag the image to match the created app. docker tag demo-repo/some-image:v12 dokku/test-app:v12 Deploy tag. dokku tags:deploy test-app v12 Deploying an image from CI To ensure your builds are always reproducible, it's considered bad practice to store build artifacts in your repository. For some projects however, building artifacts during deployment to Dokku may affect the performance of running applications. One solution is to build a finished Docker image on a CI service (or even locally) and deploy it directly to the host running Dokku. Build image on CI (or locally). docker build -t dokku/test-app:v12 . # Note: The image must be tagged `dokku/<app-name>:<version>` Deploy image to Dokku host. docker save dokku/test-app:v12 | ssh my.dokku.host \"docker load | dokku tags:deploy test-app v12\" Note: You can also use a Docker registry to push and pull the image rather than uploading it directly. Here's a more complete example using the above method: # build the image docker build -t dokku/test-app:v12 . # copy the image to the dokku host docker save dokku/test-app:v12 | bzip2 | ssh my.dokku.host \"bunzip2 | docker load\" # tag and deploy the image ssh my.dokku.host \"dokku tags:create test-app previous; dokku tags:deploy test-app v12\" Related articles Setting up persistent storage Defining environment variables Setting up the ports","title":"Docker Image Tag Deployment"},{"location":"deployment/methods/images/#docker-image-tag-deployment","text":"New as of 0.4.0 tags <app> # List all app image tags tags:create <app> <tag> # Add tag to latest running app image tags:deploy <app> <tag> # Deploy tagged app image tags:destroy <app> <tag> # Remove app image tag The Dokku tags plugin allows you to add Docker image tags to the currently deployed app image for versioning and subsequent deployment. When triggering dokku ps:rebuild APP on an application deployed via the tags plugin, the following may occur: Applications previously deployed via another method ( git / tar ): The application may revert to a state before the latest custom image tag was deployed. Applications that were only ever deployed via the tags plugin: No action will be taken against your application. Please use the tags:deploy command when redeploying an application deployed via Docker image.","title":"Docker Image Tag Deployment"},{"location":"deployment/methods/images/#usage","text":"","title":"Usage"},{"location":"deployment/methods/images/#exposed-ports","text":"See the port management documentation .","title":"Exposed ports"},{"location":"deployment/methods/images/#listing-tags-for-an-application","text":"For example, you can list all tags for a given application: dokku tags node-js-app =====> Image tags for dokku/node-js-app REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE dokku/node-js-app latest 936a42f25901 About a minute ago 1.025 GB","title":"Listing tags for an application"},{"location":"deployment/methods/images/#creating-a-tag","text":"You can also create new tags for that app using the tags:create function. Tags should conform to the Docker tagging specification for your Docker version. As of 1.10, that specification is available here , while users of older versions can check the documentation here . dokku tags:create node-js-app v1 =====> Added v1 tag to dokku/node-js-app Once the tag is created, you can see the output by running the tags command again. dokku tags node-js-app =====> Image tags for dokku/node-js-app REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE dokku/node-js-app latest 936a42f25901 About a minute ago 1.025 GB dokku/node-js-app v1 936a42f25901 About a minute ago 1.025 GB","title":"Creating a tag"},{"location":"deployment/methods/images/#deploying-an-image-tag","text":"Finally, you can also deploy a local image using the tags:deploy command. When specifying a tag that is not latest , the released image will be retagged as the latest image tag for the app. Warning: For images based on Herokuish, using the tags:deploy command will reset environment variables written into the image, causing a retag to occur. This will - on average - add two extra layers to your deployed image. Note that this does not affect Dockerfile-based images, which are the majority of images deployed via the tags command. dokku tags:deploy node-js-app v1 -----> Releasing node-js-app (dokku/node-js-app:v1)... -----> Deploying node-js-app (dokku/node-js-app:v1)... -----> Running pre-flight checks For more efficient zero downtime deployments, create a file CHECKS. See http://dokku.viewdocs.io/dokku/deployment/zero-downtime-deploys/ for examples CHECKS file not found in container: Running simple container check... -----> Waiting for 10 seconds ... -----> Default container check successful! =====> node-js-app container output: Detected 512 MB available memory, 512 MB limit per process (WEB_MEMORY) Recommending WEB_CONCURRENCY=1 > node-js-app@0.1.0 start /app > node index.js Node app is running at localhost:5000 =====> end node-js-app container output -----> Running post-deploy -----> Configuring node-js-app.dokku.me... -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx -----> Shutting down old containers in 60 seconds =====> 025eec3fa3b442fded90933d58d8ed8422901f0449f5ea0c23d00515af5d3137 =====> Application deployed: http://node-js-app.dokku.me","title":"Deploying an image tag"},{"location":"deployment/methods/images/#image-workflows","text":"","title":"Image workflows"},{"location":"deployment/methods/images/#deploying-from-a-docker-registry","text":"You can alternatively add image pulled from a Docker registry and deploy from it by using tagging feature. In this example, we are deploying from Docker Hub. Create Dokku app as usual. dokku apps:create test-app Pull image from Docker Hub. docker pull demo-repo/some-image:v12 Retag the image to match the created app. docker tag demo-repo/some-image:v12 dokku/test-app:v12 Deploy tag. dokku tags:deploy test-app v12","title":"Deploying from a Docker registry"},{"location":"deployment/methods/images/#deploying-an-image-from-ci","text":"To ensure your builds are always reproducible, it's considered bad practice to store build artifacts in your repository. For some projects however, building artifacts during deployment to Dokku may affect the performance of running applications. One solution is to build a finished Docker image on a CI service (or even locally) and deploy it directly to the host running Dokku. Build image on CI (or locally). docker build -t dokku/test-app:v12 . # Note: The image must be tagged `dokku/<app-name>:<version>` Deploy image to Dokku host. docker save dokku/test-app:v12 | ssh my.dokku.host \"docker load | dokku tags:deploy test-app v12\" Note: You can also use a Docker registry to push and pull the image rather than uploading it directly. Here's a more complete example using the above method: # build the image docker build -t dokku/test-app:v12 . # copy the image to the dokku host docker save dokku/test-app:v12 | bzip2 | ssh my.dokku.host \"bunzip2 | docker load\" # tag and deploy the image ssh my.dokku.host \"dokku tags:create test-app previous; dokku tags:deploy test-app v12\"","title":"Deploying an image from CI"},{"location":"deployment/methods/images/#related-articles","text":"Setting up persistent storage Defining environment variables Setting up the ports","title":"Related articles"},{"location":"deployment/methods/tar/","text":"Tarball Deployment New as of 0.4.0 tar:from <app> <url> # Loads an app tarball from url tar:in <app> # Reads an tarball containing the app from stdin When triggering dokku ps:rebuild APP on an application deployed via the tar plugin, the following may occur: Applications previously deployed via another method ( git ): The application may revert to a state before the latest custom image tag was deployed. Applications that were only ever deployed via the tar plugin: The application will be properly rebuilt. Please use the appropriate tar command when redeploying an application deployed via tarball. Usage Deploying from a tarball In some cases, it may be useful to deploy an application from a tarball. For instance, if you implemented a non-Git based deployment plugin, tarring the generated artifact may be an easier route to interface with the existing Dokku infrastructure. You can place the tarball on an external webserver and deploy via the tar:from command. dokku tar:from node-js-app https://dokku.me/releases/node-js-app/v1 Deploying via stdin As an alternative, a deploy can be trigged from a tarball read from stdin using the tar:in command: # run from the generated artifact directory tar c . $* | dokku tar:in node-js-app","title":"Tarball Deployment"},{"location":"deployment/methods/tar/#tarball-deployment","text":"New as of 0.4.0 tar:from <app> <url> # Loads an app tarball from url tar:in <app> # Reads an tarball containing the app from stdin When triggering dokku ps:rebuild APP on an application deployed via the tar plugin, the following may occur: Applications previously deployed via another method ( git ): The application may revert to a state before the latest custom image tag was deployed. Applications that were only ever deployed via the tar plugin: The application will be properly rebuilt. Please use the appropriate tar command when redeploying an application deployed via tarball.","title":"Tarball Deployment"},{"location":"deployment/methods/tar/#usage","text":"","title":"Usage"},{"location":"deployment/methods/tar/#deploying-from-a-tarball","text":"In some cases, it may be useful to deploy an application from a tarball. For instance, if you implemented a non-Git based deployment plugin, tarring the generated artifact may be an easier route to interface with the existing Dokku infrastructure. You can place the tarball on an external webserver and deploy via the tar:from command. dokku tar:from node-js-app https://dokku.me/releases/node-js-app/v1","title":"Deploying from a tarball"},{"location":"deployment/methods/tar/#deploying-via-stdin","text":"As an alternative, a deploy can be trigged from a tarball read from stdin using the tar:in command: # run from the generated artifact directory tar c . $* | dokku tar:in node-js-app","title":"Deploying via stdin"},{"location":"development/plugin-creation/","text":"Plugin Creation Plugins can simply be implementations of triggers or they may implement a command structure of their own. Dokku has no restrictions on the language in which a plugin is implemented, it only cares that the plugin implements the appropriate commands or triggers API. NOTE: all files that implement the triggers or commands API must be executable. If you create your own plugin: Take a look at the plugins shipped with Dokku and hack away! Check out the list of triggers your plugin can implement. Upload your plugin to github with a repository name in form of dokku-<name> (e.g. dokku-mariadb ) Edit this page and add a link to it. Subscribe to the dokku development blog to be notified about API changes and releases Compilable Plugins (i.e. golang, java(?), c, etc.) The plugin developer is required to implement the install trigger such that it will output your built executable(s) in the correct directory structure to implement the plugin's desired command and/or trigger API. See smoke-test-plugin for an example. Command API There are 3 main implementation points: commands , subcommands/default , and subcommands/<command-name> commands Primarily used to supply the plugin's usage/help output. (i.e. plugin help ) subcommands/default Implements the plugin's default command behavior. (i.e. dokku plugin ) subcommands/ Implements the additional command interface and will translate to dokku plugin:cmd on the command line. (i.e. dokku plugin:install ) Sample plugin The below plugin is a dummy dokku hello plugin. hello/subcommands/default #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" hello_main_cmd () { declare desc = \"prints Hello \\$APP\" local cmd = \"hello\" # Support --app/$DOKKU_APP_NAME flag # Use the following lines to reorder args into \"$cmd $DOKKU_APP_NAME $@\"\" local argv =( \" $@ \" ) [[ ${ argv [0] } == \" $cmd \" ]] && shift 1 [[ -n $DOKKU_APP_NAME ]] && set -- $DOKKU_APP_NAME $@ set -- $cmd $@ ## [[ -z $2 ]] && dokku_log_fail \"Please specify an app to run the command on\" verify_app_name \" $2 \" local APP = \" $2 \" ; echo \"Hello $APP \" } hello_main_cmd \" $@ \" hello/subcommands/world #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" hello_world_cmd () { declare desc = \"prints Hello World\" local cmd = \"hello:world\" # Support --app/$DOKKU_APP_NAME flag # Use the following lines to reorder args into \"$cmd $DOKKU_APP_NAME $@\"\" local argv =( \" $@ \" ) [[ ${ argv [0] } == \" $cmd \" ]] && shift 1 [[ -n $DOKKU_APP_NAME ]] && set -- $DOKKU_APP_NAME $@ set -- $cmd $@ ## [[ -z $2 ]] && dokku_log_fail \"Please specify an app to run the command on\" verify_app_name \" $2 \" local APP = \" $2 \" ; echo \"Hello world\" } hello_world_cmd \" $@ \" hello/commands #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | hello:help ) help_content_func () { declare desc = \"return help_content string\" cat <<help_content hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" help_content } if [[ $1 = \"hello:help\" ]] ; then echo -e 'Usage: dokku hello[:world] [<app>]' echo '' echo 'Say Hello World.' echo '' echo 'Example:' echo '' echo '$ dokku hello:world' echo 'Hello world' echo '' echo 'Additional commands:' help_content_func | sort | column -c2 -t -s, else help_content_func fi ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac Each plugin requires a plugin.toml descriptor file with the following required fields: [plugin] description = \"dokku hello plugin\" version = \"0.1.0\" [plugin.config] A few notes: Don't forget to chmod +x your executable files. You should always support DOKKU_TRACE as specified on the 2nd line of the plugin. If your command requires that an application exists, ensure you check for it's existence in the manner prescribed above. A help command is required, though it is allowed to be empty. Also, the command syntax will need to separated by , in order to maintain columnar output alignment. Commands should be namespaced. As of 0.3.3, a catch-all should be implemented which exits with a DOKKU_NOT_IMPLEMENTED_EXIT code. This allows Dokku to output a command not found message. Be sure you want the \"set -eo pipefail\" option. Look at the following example : IMAGE = $( docker images | grep \"user/repo\" | awk '{print $3}' ) if [[ -z $IMAGE ]] ; then dokku_log_fail \"user/repo image not found... Did you run 'dokku plugin:install'?\" fi In the case where the \"user/repo\" is not installed, Dokku exits just before the awk command, you will never see the message printed with echo. You just want \"set -e\" in this case. Here is the documentation of the 'set -eo pipefail' option: help set Options: -e Exit immediately if a command exits with a non-zero status. -o option-name pipefail the return value of a pipeline is the status of the last command to exit with a non-zero status, or zero if no command exited with a non-zero status - As some plugins require access to set app config settings and do not want/require the default Heroku-style behavior of a restart, we have the following \"internal\" commands that provide this functionality : dokku config:set --no-restart node-js-app KEY1 = VALUE1 [ KEY2 = VALUE2 ... ] dokku config:unset --no-restart node-js-app KEY1 [ KEY2 ... ] - From time to time you may want to allow other plugins access to (some of) your plugin's functionality. You can expose this by including a functions file in your plugin for others to source. Consider all functions in that file to be publicly accessible by other plugins. Any functions not wished to be made \"public\" should reside within your plugin trigger or commands files. - As of 0.4.0, we allow image tagging and deployment of said tagged images. Therefore, hard-coding of $IMAGE as dokku/$APP is no longer sufficient. Instead, for non pre/post-build-* plugins, use get_running_image_tag() & get_app_image_name() as sourced from common/functions. See the plugin triggers doc for examples. - As of 0.5.0, we use container labels to help cleanup intermediate containers with dokku cleanup . If manually calling docker run , include $DOKKU_GLOBAL_RUN_ARGS . This will ensure you intermediate containers labeled correctly. - As of 0.6.0, we advise you to not call the dokku binary directly from within plugins. Clients using the --app argument are potentially broken, amongst other issues, when doing so. Instead, please source the functions file for a given plugin when attempting to call Dokku internal functions","title":"Plugin Creation"},{"location":"development/plugin-creation/#plugin-creation","text":"Plugins can simply be implementations of triggers or they may implement a command structure of their own. Dokku has no restrictions on the language in which a plugin is implemented, it only cares that the plugin implements the appropriate commands or triggers API. NOTE: all files that implement the triggers or commands API must be executable. If you create your own plugin: Take a look at the plugins shipped with Dokku and hack away! Check out the list of triggers your plugin can implement. Upload your plugin to github with a repository name in form of dokku-<name> (e.g. dokku-mariadb ) Edit this page and add a link to it. Subscribe to the dokku development blog to be notified about API changes and releases","title":"Plugin Creation"},{"location":"development/plugin-creation/#compilable-plugins-ie-golang-java-c-etc","text":"The plugin developer is required to implement the install trigger such that it will output your built executable(s) in the correct directory structure to implement the plugin's desired command and/or trigger API. See smoke-test-plugin for an example.","title":"Compilable Plugins (i.e. golang, java(?), c, etc.)"},{"location":"development/plugin-creation/#command-api","text":"There are 3 main implementation points: commands , subcommands/default , and subcommands/<command-name>","title":"Command API"},{"location":"development/plugin-creation/#commands","text":"Primarily used to supply the plugin's usage/help output. (i.e. plugin help )","title":"commands"},{"location":"development/plugin-creation/#subcommandsdefault","text":"Implements the plugin's default command behavior. (i.e. dokku plugin )","title":"subcommands/default"},{"location":"development/plugin-creation/#subcommands","text":"Implements the additional command interface and will translate to dokku plugin:cmd on the command line. (i.e. dokku plugin:install )","title":"subcommands/"},{"location":"development/plugin-creation/#sample-plugin","text":"The below plugin is a dummy dokku hello plugin. hello/subcommands/default #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" hello_main_cmd () { declare desc = \"prints Hello \\$APP\" local cmd = \"hello\" # Support --app/$DOKKU_APP_NAME flag # Use the following lines to reorder args into \"$cmd $DOKKU_APP_NAME $@\"\" local argv =( \" $@ \" ) [[ ${ argv [0] } == \" $cmd \" ]] && shift 1 [[ -n $DOKKU_APP_NAME ]] && set -- $DOKKU_APP_NAME $@ set -- $cmd $@ ## [[ -z $2 ]] && dokku_log_fail \"Please specify an app to run the command on\" verify_app_name \" $2 \" local APP = \" $2 \" ; echo \"Hello $APP \" } hello_main_cmd \" $@ \" hello/subcommands/world #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" hello_world_cmd () { declare desc = \"prints Hello World\" local cmd = \"hello:world\" # Support --app/$DOKKU_APP_NAME flag # Use the following lines to reorder args into \"$cmd $DOKKU_APP_NAME $@\"\" local argv =( \" $@ \" ) [[ ${ argv [0] } == \" $cmd \" ]] && shift 1 [[ -n $DOKKU_APP_NAME ]] && set -- $DOKKU_APP_NAME $@ set -- $cmd $@ ## [[ -z $2 ]] && dokku_log_fail \"Please specify an app to run the command on\" verify_app_name \" $2 \" local APP = \" $2 \" ; echo \"Hello world\" } hello_world_cmd \" $@ \" hello/commands #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | hello:help ) help_content_func () { declare desc = \"return help_content string\" cat <<help_content hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" help_content } if [[ $1 = \"hello:help\" ]] ; then echo -e 'Usage: dokku hello[:world] [<app>]' echo '' echo 'Say Hello World.' echo '' echo 'Example:' echo '' echo '$ dokku hello:world' echo 'Hello world' echo '' echo 'Additional commands:' help_content_func | sort | column -c2 -t -s, else help_content_func fi ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac Each plugin requires a plugin.toml descriptor file with the following required fields: [plugin] description = \"dokku hello plugin\" version = \"0.1.0\" [plugin.config] A few notes: Don't forget to chmod +x your executable files. You should always support DOKKU_TRACE as specified on the 2nd line of the plugin. If your command requires that an application exists, ensure you check for it's existence in the manner prescribed above. A help command is required, though it is allowed to be empty. Also, the command syntax will need to separated by , in order to maintain columnar output alignment. Commands should be namespaced. As of 0.3.3, a catch-all should be implemented which exits with a DOKKU_NOT_IMPLEMENTED_EXIT code. This allows Dokku to output a command not found message. Be sure you want the \"set -eo pipefail\" option. Look at the following example : IMAGE = $( docker images | grep \"user/repo\" | awk '{print $3}' ) if [[ -z $IMAGE ]] ; then dokku_log_fail \"user/repo image not found... Did you run 'dokku plugin:install'?\" fi In the case where the \"user/repo\" is not installed, Dokku exits just before the awk command, you will never see the message printed with echo. You just want \"set -e\" in this case. Here is the documentation of the 'set -eo pipefail' option: help set Options: -e Exit immediately if a command exits with a non-zero status. -o option-name pipefail the return value of a pipeline is the status of the last command to exit with a non-zero status, or zero if no command exited with a non-zero status - As some plugins require access to set app config settings and do not want/require the default Heroku-style behavior of a restart, we have the following \"internal\" commands that provide this functionality : dokku config:set --no-restart node-js-app KEY1 = VALUE1 [ KEY2 = VALUE2 ... ] dokku config:unset --no-restart node-js-app KEY1 [ KEY2 ... ] - From time to time you may want to allow other plugins access to (some of) your plugin's functionality. You can expose this by including a functions file in your plugin for others to source. Consider all functions in that file to be publicly accessible by other plugins. Any functions not wished to be made \"public\" should reside within your plugin trigger or commands files. - As of 0.4.0, we allow image tagging and deployment of said tagged images. Therefore, hard-coding of $IMAGE as dokku/$APP is no longer sufficient. Instead, for non pre/post-build-* plugins, use get_running_image_tag() & get_app_image_name() as sourced from common/functions. See the plugin triggers doc for examples. - As of 0.5.0, we use container labels to help cleanup intermediate containers with dokku cleanup . If manually calling docker run , include $DOKKU_GLOBAL_RUN_ARGS . This will ensure you intermediate containers labeled correctly. - As of 0.6.0, we advise you to not call the dokku binary directly from within plugins. Clients using the --app argument are potentially broken, amongst other issues, when doing so. Instead, please source the functions file for a given plugin when attempting to call Dokku internal functions","title":"Sample plugin"},{"location":"development/plugin-triggers/","text":"Plugin triggers Plugin triggers (formerly pluginhooks ) are a good way to jack into existing Dokku infrastructure. You can use them to modify the output of various Dokku commands or override internal configuration. Plugin triggers are simply scripts that are executed by the system. You can use any language you want, so long as the script: Is executable Has the proper language requirements installed For instance, if you wanted to write a plugin trigger in PHP, you would need to have php installed and available on the CLI prior to plugin trigger invocation. The following is an example for the nginx-hostname plugin trigger. It reverses the hostname that is provided to nginx during deploys. If you created an executable file named nginx-hostname with the following code in your plugin trigger, it would be invoked by Dokku during the normal app deployment process: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" Available plugin triggers There are a number of plugin-related triggers. These can be optionally implemented by plugins and allow integration into the standard Dokku setup/teardown process. The following plugin triggers describe those available to a Dokku installation. As well, there is an example for each trigger that you can use as templates for your own plugin development. The example plugin trigger code is not guaranteed to be implemented as in within dokku, and are merely simplified examples. Please look at the Dokku source for larger, more in-depth examples. app-urls Description: Allows you to change the urls Dokku reports for an application. Will override any auto-detected urls. Invoked by: dokku deploy , dokku url , and dokku urls Arguments: $APP $URL_TYPE Example: #!/usr/bin/env bash # Sets the domain to `internal.tld` set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; URL_TYPE = \" $2 \" case \" $URL_TYPE \" in url ) echo \"https://internal.tld/ ${ APP } /\" ;; urls ) echo \"https://internal.tld/ ${ APP } /\" echo \"http://internal.tld/ ${ APP } /\" ;; esac check-deploy Description: Allows you to run checks on a deploy before Dokku allows the container to handle requests. Invoked by: dokku deploy Arguments: $APP $CONTAINER_ID $PROC_TYPE $PORT $IP Example: #!/usr/bin/env bash # Disables deploys of containers based on whether the # `DOKKU_DISABLE_DEPLOY` env var is set to `true` for an app set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_AVAILABLE_PATH /config/functions\" APP = \" $1 \" ; CONTAINERID = \" $2 \" ; PROC_TYPE = \" $3 \" ; PORT = \" $4 \" ; IP = \" $5 \" eval \" $( config_export app $APP ) \" DOKKU_DISABLE_DEPLOY = \" ${ DOKKU_DISABLE_DEPLOY :- false } \" if [[ \" $DOKKU_DISABLE_DEPLOY \" = \"true\" ]] ; then echo -e \"\\033[31m\\033[1mDeploys disabled, sorry.\\033[0m\" exit 1 fi commands help and commands <PLUGIN_NAME>:help Description: Your plugin should implement a help command in your commands file to take advantage of this plugin trigger. commands help is used by dokku help to aggregate all plugins abbreviated help output. Implementing <PLUGIN_NAME>:help in your commands file gives users looking for help, a more detailed output. 'commands help' must be implemented inside the commands plugin file. It's recommended that PLUGIN_NAME:help be added to the commands file to ensure consistency among community plugins and give you a new avenue to share rich help content with your user. Invoked by: dokku help and commands <PLUGIN_NAME>:help Arguments: None Example: #!/usr/bin/env bash # Outputs help for the derp plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | hello:help ) help_content_func () { declare desc = \"return help_content string\" cat <<help_content hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" help_content } if [[ $1 = \"hello:help\" ]] ; then echo -e 'Usage: dokku hello[:world] [<app>]' echo '' echo 'Say Hello World.' echo '' echo 'Example:' echo '' echo '$ dokku hello:world' echo 'Hello world' echo '' echo 'Additional commands:' help_content_func | sort | column -c2 -t -s, else help_content_func fi ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac core-post-deploy To avoid issues with community plugins, this plugin trigger should be used only for core plugins. Please avoid using this trigger in your own plugins. Description: Allows running of commands after an app's processes have been scaled up, but before old containers are torn down. Dokku core currently uses this to switch traffic on nginx. Invoked by: dokku deploy Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS $IMAGE_TAG Example: #!/usr/bin/env bash # Notify an external service that a successful deploy has occurred. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x curl \"http://httpstat.us/200\" dependencies Description: Used to install system-level dependencies. Invoked by: dokku plugin:install-dependencies Arguments: None Example: #!/usr/bin/env bash # Installs nginx for the current plugin # Supports both opensuse and ubuntu set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x export DEBIAN_FRONTEND = noninteractive case \" $DOKKU_DISTRO \" in debian | ubuntu ) apt-get install --force-yes -qq -y nginx ;; opensuse ) zypper -q in -y nginx ;; esac deploy-source Description: Used for reporting what the current detected deployment source is. The first detected source should always win. Invoked by: dokku apps:report Arguments: $APP Example: #!/usr/bin/env bash # Checks if the app should be deployed via git set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" STDIN = $( cat ) # bail if another source is detected if [[ -n \" $STDIN \" ]] ; then echo \" $STDIN \" return fi if [[ -d \" $DOKKU_ROOT / $APP /refs\" ]] ; then echo \"git\" fi deployed-app-image-repo Description: Used to manage the full repo of the image being deployed. Useful for deploying from an external registry where the repository name is not dokku/$APP Invoked by: internal function dokku_deploy_cmd() (deploy phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" # change the repo from dokku/APP to dokkupaas/APP echo \"dokkupaas/ $APP \" deployed-app-image-tag Description: Used to manage the tag of the image being deployed. Useful for deploying a specific version of an image, or when deploying from an external registry Invoked by: internal function dokku_deploy_cmd() (deploy phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # customize the tag version echo 'not-latest' deployed-app-repository Description: Used to manage the remote repository of the image being deployed. Invoked by: internal function dokku_deploy_cmd() (deploy phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x echo 'derp.dkr.ecr.us-east-1.amazonaws.com' docker-args-build Description: Invoked by: internal function dokku_build() (build phase) Arguments: $APP $IMAGE_SOURCE_TYPE Example: #!/usr/bin/env bash # Sets a docker build-arg called CACHEBUST which can be used # to bust cache at any arbitrary point in a Dockerfile build set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x STDIN = $( cat ) APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $2 \" output = \"\" if [[ \" $IMAGE_SOURCE_TYPE \" == \"dockerfile\" ]] ; then output = \" --build-arg CACHEBUST= $( date +%s ) \" fi echo -n \" $STDIN$output \" docker-args-deploy Description: Invoked by: dokku deploy Arguments: $APP $IMAGE_TAG [$PROC_TYPE $CONTAINER_INDEX] Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO docker-args-run Description: Invoked by: dokku run Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO git-post-pull Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO git-pre-pull Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO Warning: The git-pre-pull trigger should not be used for authentication since it does not get called for commands that use git-upload-archive such as git archive . Instead, use the user-auth trigger. install Description: Used to setup any files/configuration for a plugin. Invoked by: dokku plugin:install . Arguments: None Example: #!/usr/bin/env bash # Sets the hostname of the Dokku server # based on the output of `hostname -f` set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x if [[ ! -f \" $DOKKU_ROOT /HOSTNAME\" ]] ; then hostname -f > $DOKKU_ROOT /HOSTNAME fi network-build-config Description: Rebuilds network configuration Invoked by: internally triggered by proxy-build-config within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-clear-config Description: Clears network configuration Invoked by: internally triggered by proxy-clear-config within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-compute-ports Description: Computes the ports for a given app container Invoked by: internally triggered by proxy-build-config within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-config-exists Description: Returns whether the network configuration for a given app exists Invoked by: internally triggered by core-post-deploy within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-get-ipaddr Description: Return the ipaddr for a given app container Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_ID Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-get-listeners Description: Return the listeners (host:port combinations) for a given app container Invoked by: internally triggered by a deploy Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-get-port Description: Return the port for a given app container Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_ID $IS_HEROKUISH_CONTAINER Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-get-property Description: Return the network value for an app's property Invoked by: internally triggered by a deploy Arguments: $APP $KEY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-write-ipaddr Description: Write the ipaddr for a given app index Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_INDEX $IP_ADDRESS Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO network-write-port Description: Write the port for a given app index Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_INDEX $PORT Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO nginx-hostname Description: Allows you to customize the hostname for a given app Invoked by: dokku domains:setup Arguments: $APP $SUBDOMAIN $VHOST Example: #!/usr/bin/env bash # Reverses the hostname for the app set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" nginx-pre-reload Description: Run before nginx reloads hosts Invoked by: dokku nginx:build-config Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Runs a check against all nginx conf files # to ensure they are valid set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x nginx -t post-app-clone Description: Allows you to run commands after an app was cloned. Invoked by: dokku apps:clone Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-app-clone-setup Description: Allows you to run commands after an app is setup, and before it is rebuild. This is useful for cleaning up tasks, or ensuring configuration from an old app is copied to the new app Invoked by: dokku apps:clone Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-app-rename Description: Allows you to run commands after an app was renamed. Invoked by: dokku apps:rename Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-build-buildpack Description: Allows you to run commands after the build image is create for a given app. Only applies to apps using buildpacks. Invoked by: internal function dokku_build() (build phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-build-dockerfile Description: Allows you to run commands after the build image is create for a given app. Only applies to apps using a dockerfile. Invoked by: internal function dokku_build() (build phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-certs-remove Description: Allows you to run commands after a cert is removed Invoked by: dokku certs:remove Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; verify_app_name \" $APP \" # TODO post-certs-update Description: Allows you to run commands after a cert is added/updated Invoked by: dokku certs:add , dokku certs:update Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; verify_app_name \" $APP \" # TODO post-config-update Description: Allows you to get notified when one or more configs is added or removed. Action can be set or unset Invoked by: dokku config:set , dokku config:unset Arguments: $APP set|unset key1=VALUE1 key2=VALUE2 Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-create Description: Can be used to run commands after an app is created. Invoked by: dokku apps:create Arguments: $APP Example: #!/usr/bin/env bash # Runs a command to ensure that an app # has a postgres database when it is starting set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; POSTGRES = \" $1 \" dokku postgres:create $POSTGRES dokku postgres:link $POSTGRES $APP post-delete Description: Can be used to run commands after an app is deleted. Invoked by: dokku apps:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Runs a command to ensure that an app's # postgres installation is removed set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku postgres:destroy $APP post-deploy Please see core-post-deploy if contributing a core plugin with the post-deploy hook. Description: Allows running of commands after an app's processes have been scaled up, but before old containers are torn down. Dokku calls this after core-post-deploy . Deployment Tasks are also invoked by this plugin trigger. Invoked by: dokku deploy Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS $IMAGE_TAG Example: #!/usr/bin/env bash # Notify an external service that a successful deploy has occurred. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x curl \"http://httpstat.us/200\" post-domains-update Description: Allows you to run commands once the domain for an app has been updated. It also sends in the command that has been used. This can be \"add\", \"clear\" or \"remove\". The third argument will be the optional list of domains Invoked by: dokku domains:add , dokku domains:clear , dokku domains:remove , dokku domains:set Arguments: $APP action name domains Example: #!/usr/bin/env bash # Reloads haproxy for our imaginary haproxy plugin # that replaces the nginx-vhosts plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x sudo service haproxy reload post-extract Description: Allows you to modify the contents of an app after it has been extracted from git/tarball but before the image source type is detected. Invoked by: dokku tar:in , dokku tar:from and the receive-app plugin trigger Arguments: $APP $TMP_WORK_DIR $REV Example: #!/usr/bin/env bash # Adds a clock process to an app's Procfile set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; verify_app_name \" $APP \" TMP_WORK_DIR = \" $2 \" REV = \" $3 \" # optional, may not be sent for tar-based builds pushd \" $TMP_WORK_DIR \" >/dev/null touch Procfile echo \"clock: some-command\" >> Procfile post-proxy-ports-update Description: Allows you to run commands once the proxy port mappings for an app have been updated. It also sends the invoking command. This can be \"add\", \"clear\" or \"remove\". Invoked by: dokku proxy:ports-add , dokku proxy:ports-clear , dokku proxy:ports-remove Arguments: $APP action name Example: #!/usr/bin/env bash # Rebuilds haproxy config for our imaginary haproxy plugin # that replaces the nginx-vhosts plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" source \" $PLUGIN_AVAILABLE_PATH /haproxy/functions\" APP = \" $1 \" ; verify_app_name \" $APP \" haproxy-build-config \" $APP \" post-release-buildpack Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to apps using buildpacks. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Installs a package specified by the `CONTAINER_PACKAGE` env var set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" dokku_log_info1 \"Installing $CONTAINER_PACKAGE ...\" CMD = \"cat > gm && \\ dpkg -s CONTAINER_PACKAGE >/dev/null 2>&1 || \\ (apt-get update && apt-get install -y CONTAINER_PACKAGE && apt-get clean)\" ID = $( docker run $DOKKU_GLOBAL_RUN_ARGS -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $ID ) -eq 0 docker commit $ID $IMAGE >/dev/null post-release-dockerfile Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to apps using a dockerfile. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO post-stop Description: Can be used to run commands after an app is manually stopped Invoked by: dokku ps:stop and dokku ps:stopall Arguments: $APP Example: #!/usr/bin/env bash # Marks an app as manually stopped set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku config:set --no-restart $APP MANUALLY_STOPPED = 1 pre-build-buildpack Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to apps using buildpacks. Invoked by: internal function dokku_build() (build phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO pre-build-dockerfile Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to apps using a dockerfile. Invoked by: internal function dokku_build() (build phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO pre-delete Description: Can be used to run commands before an app is deleted. Invoked by: dokku apps:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Clears out the gulp asset build cache for apps set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; GULP_CACHE_DIR = \" $DOKKU_ROOT / $APP /gulp\" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" if [[ -d $GULP_CACHE_DIR ]] ; then docker run $DOKKU_GLOBAL_RUN_ARGS --rm -v \" $GULP_CACHE_DIR :/gulp\" \" $IMAGE \" find /gulp -depth -mindepth 1 -maxdepth 1 -exec rm -Rf {} \\; || true fi pre-deploy Description: Allows the running of code before the app's processes are scaled up and after the docker images are prepared. Invoked by: dokku deploy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Runs gulp in our container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" dokku_log_info1 \"Running gulp\" id = $( docker run $DOKKU_GLOBAL_RUN_ARGS -d $IMAGE /bin/bash -c \"cd /app && gulp default\" ) test $( docker wait $id ) -eq 0 docker commit $id $IMAGE >/dev/null dokku_log_info1 \"Building UI Complete\" pre-disable-vhost Description: Allows you to run commands before the VHOST feature is disabled Invoked by: dokku domains:disable Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; verify_app_name \" $APP \" # TODO pre-enable-vhost Description: Allows you to run commands before the VHOST feature is enabled Invoked by: dokku domains:enable Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; verify_app_name \" $APP \" # TODO pre-receive-app Description: Allows you to customize the contents of an app directory before they are processed for deployment. The IMAGE_SOURCE_TYPE can be any of [herokuish, dockerfile] Invoked by: dokku git-hook , dokku tar-build-locked Arguments: $APP $IMAGE_SOURCE_TYPE $TMP_WORK_DIR $REV Example: #!/usr/bin/env bash # Adds a file called `dokku-is-awesome` to the repository # the contents will be the app name set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $2 \" ; TMP_WORK_DIR = \" $3 \" ; REV = \" $4 \" echo \" $APP \" > \" $TMP_WORK_DIR /dokku-is-awesome\" pre-release-buildpack Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to apps using buildpacks. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Installs the graphicsmagick package into the container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" dokku_log_info1 \"Installing GraphicsMagick...\" CMD = \"cat > gm && \\ dpkg -s graphicsmagick >/dev/null 2>&1 || \\ (apt-get update && apt-get install -y graphicsmagick && apt-get clean)\" ID = $( docker run $DOKKU_GLOBAL_RUN_ARGS -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $ID ) -eq 0 docker commit $ID $IMAGE >/dev/null pre-release-dockerfile Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to apps using a dockerfile. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO pre-restore Description: Allows you to run commands before all containers are restored Invoked by: dokku ps:restore Arguments: $DOKKU_SCHEDULER Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" # TODO pre-start Description: Can be used to run commands before an app is started Invoked by: dokku ps:start Arguments: $APP Example: #!/usr/bin/env bash # Notifies an example url that an app is starting set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; curl \"https://dokku.me/starting/ ${ APP } \" || true proxy-build-config Description: Builds the proxy implementation configuration for a given app Invoked by: internally triggered by ps:restore Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO proxy-clear-config Description: Clears the proxy implementation configuration for a given app Invoked by: internally triggered by apps:rename Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO proxy-enable Description: Enables the configured proxy implementation for an app Invoked by: internally triggered by ps:restore Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO proxy-disable Description: Disables the configured proxy implementation for an app Invoked by: internally triggered by ps:restore Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO receive-app Description: Allows you to customize what occurs when an app is received. Normally just triggers an app build. Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV ( $REV may not be included in cases where a repository is not pushed) Example: #!/usr/bin/env bash # For our imaginary mercurial plugin, triggers a rebuild set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; REV = \" $2 \" dokku hg-build $APP $REV receive-branch Description: Allows you to customize what occurs when a specific branch is received. Can be used to add support for specific branch names Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV $REFNAME Example: #!/bin/bash # Gives Dokku the ability to support multiple branches for a given service # Allowing you to have multiple staging environments on a per-branch basis reference_app = $1 refname = $3 newrev = $2 APP = ${ refname /* \\/ / } . $reference_app if [[ ! -d \" $DOKKU_ROOT / $APP \" ]] ; then REFERENCE_REPO = \" $DOKKU_ROOT / $reference_app \" git clone --bare --shared --reference \" $REFERENCE_REPO \" \" $REFERENCE_REPO \" \" $DOKKU_ROOT / $APP \" >/dev/null fi plugn trigger receive-app $APP $newrev retire-container-failed Description: Allows you to run commands if/when retiring old containers has failed Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash # Send an email when a container failed to retire set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; HOSTNAME = $( hostname -s ) mail -s \" $APP containers on $HOSTNAME failed to retire\" ops@dokku.me report Description: Allows you to report on any custom configuration in use by your application Invoked by: dokku report Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; # TODO scheduler-deploy Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when an app is deployed Invoked by: dokku deploy Arguments: $DOKKU_SCHEDULER $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; IMAGE_TAG = \" $3 \" ; # TODO scheduler-docker-cleanup Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when dokku cleanup is invoked Invoked by: dokku deploy, dokku cleanup Arguments: $DOKKU_SCHEDULER $APP $FORCE_CLEANUP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; FORCE_CLEANUP = \" $3 \" ; # TODO scheduler-inspect Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run inspect commands for all containers for a given app Invoked by: dokku ps:inspect Arguments: $DOKKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; # TODO scheduler-logs-failed Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when retrieving failed container logs Invoked by: dokku logs:failed Arguments: $DOKKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; ARGS = \" ${ @: 3 } \" ; # TODO scheduler-run Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when a command is executed for your app Invoked by: dokku run Arguments: $DOKKU_SCHEDULER $APP ...ARGS Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; ARGS = \" ${ @: 3 } \" ; # TODO scheduler-stop Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when a tag is destroyed Invoked by: dokku apps:destroy, dokku ps:stop Arguments: $DOKKU_SCHEDULER $APP $REMOVE_CONTAINERS Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; REMOVE_CONTAINERS = \" $3 \" ; # TODO scheduler-tags-create Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when a tag is created Invoked by: dokku tags:create Arguments: $DOKKU_SCHEDULER $APP $SOURCE_IMAGE $TARGET_IMAGE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" APP = \" $2 \" SOURCE_IMAGE = \" $3 \" TARGET_IMAGE = \" $4 \" # TODO scheduler-tags-destroy Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when a tag is destroyed Invoked by: dokku tags:destroy Arguments: $DOKKU_SCHEDULER $APP $IMAGE_REPO $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; IMAGE_REPO = \" $3 \" ; IMAGE_TAG = \" $4 \" ; # TODO tags-create Description: Allows you to run commands once a tag for an app image has been added Invoked by: dokku tags:create Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Upload an app image to docker hub set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) IMAGE_ID = $( docker inspect --format '{{ .Id }}' $IMAGE ) docker tag -f $IMAGE_ID $DOCKER_HUB_USER / $APP : $IMAGE_TAG docker push $DOCKER_HUB_USER / $APP : $IMAGE_TAG tags-destroy Description: Allows you to run commands once a tag for an app image has been removed Invoked by: dokku tags:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Remove an image tag from docker hub set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_TAG = \" $2 \" # some code to remove a docker hub tag because it's not implemented in the CLI... uninstall Description: Used to cleanup after itself. Invoked by: dokku plugin:uninstall Arguments: $PLUGIN Example: #!/usr/bin/env bash # Cleanup up extra containers created set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x PLUGIN = \" $1 \" [[ \" $PLUGIN \" = \"my-plugin\" ]] && docker rmi -f \" ${ PLUGIN_IMAGE_DEPENDENCY } \" To avoid uninstalling other plugins make sure to check the plugin name like shown in the example. update Description: Can be used to run plugin updates on a regular interval. You can schedule the invoker in a cron-task to ensure your system gets regular updates. Invoked by: dokku plugin:update . Arguments: None Example: #!/usr/bin/env bash # Update the herokuish image from git source set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x cd /root/dokku sudo BUILD_STACK = true make install user-auth This is a special plugin trigger that is executed on every command run. As Dokku sometimes internally invokes the dokku command, special care should be taken to properly handle internal command redirects. Note that the trigger should exit as follows: 0 to continue running as normal 1 to halt execution of the command The SSH_USER is the original ssh user. If you are running remote commands, this user will typically be dokku , and as such should not be trusted when checking permissions. If you are connected via ssh as a different user who then invokes dokku , the value of this variable will be that user's name ( root , myuser , etc.). The SSH_NAME is the NAME variable set via the sshcommand acl-add command. If you have set a user via the dokku-installer , this value will be set to admin . For installs via debian package, this value may be default . For reference, the following command can be run as the root user to specify a specific NAME for a given ssh key: sshcommand acl-add dokku NAME < $PATH_TO_SSH_KEY Note that the NAME value is set at the first ssh key match. If an ssh key is set in the /home/dokku/.ssh/authorized_keys multiple times, the first match will decide the value. Description: Allows you to deny access to a Dokku command by either ssh user or associated ssh-command NAME user. Invoked by: dokku Arguments: $SSH_USER $SSH_NAME $DOKKU_COMMAND Example: #!/usr/bin/env bash # Allow root/admin users to do everything # Deny plugin access to default users # Allow access to all other commands set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x SSH_USER = $1 SSH_NAME = $2 shift 2 [[ \" $SSH_USER \" == \"root\" ]] && exit 0 [[ \" $SSH_NAME \" == \"admin\" ]] && exit 0 [[ \" $SSH_NAME \" == \"default\" && $1 == plugin:* ]] && exit 1 exit 0","title":"Plugin triggers"},{"location":"development/plugin-triggers/#plugin-triggers","text":"Plugin triggers (formerly pluginhooks ) are a good way to jack into existing Dokku infrastructure. You can use them to modify the output of various Dokku commands or override internal configuration. Plugin triggers are simply scripts that are executed by the system. You can use any language you want, so long as the script: Is executable Has the proper language requirements installed For instance, if you wanted to write a plugin trigger in PHP, you would need to have php installed and available on the CLI prior to plugin trigger invocation. The following is an example for the nginx-hostname plugin trigger. It reverses the hostname that is provided to nginx during deploys. If you created an executable file named nginx-hostname with the following code in your plugin trigger, it would be invoked by Dokku during the normal app deployment process: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \"","title":"Plugin triggers"},{"location":"development/plugin-triggers/#available-plugin-triggers","text":"There are a number of plugin-related triggers. These can be optionally implemented by plugins and allow integration into the standard Dokku setup/teardown process. The following plugin triggers describe those available to a Dokku installation. As well, there is an example for each trigger that you can use as templates for your own plugin development. The example plugin trigger code is not guaranteed to be implemented as in within dokku, and are merely simplified examples. Please look at the Dokku source for larger, more in-depth examples.","title":"Available plugin triggers"},{"location":"development/plugin-triggers/#app-urls","text":"Description: Allows you to change the urls Dokku reports for an application. Will override any auto-detected urls. Invoked by: dokku deploy , dokku url , and dokku urls Arguments: $APP $URL_TYPE Example: #!/usr/bin/env bash # Sets the domain to `internal.tld` set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; URL_TYPE = \" $2 \" case \" $URL_TYPE \" in url ) echo \"https://internal.tld/ ${ APP } /\" ;; urls ) echo \"https://internal.tld/ ${ APP } /\" echo \"http://internal.tld/ ${ APP } /\" ;; esac","title":"app-urls"},{"location":"development/plugin-triggers/#check-deploy","text":"Description: Allows you to run checks on a deploy before Dokku allows the container to handle requests. Invoked by: dokku deploy Arguments: $APP $CONTAINER_ID $PROC_TYPE $PORT $IP Example: #!/usr/bin/env bash # Disables deploys of containers based on whether the # `DOKKU_DISABLE_DEPLOY` env var is set to `true` for an app set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_AVAILABLE_PATH /config/functions\" APP = \" $1 \" ; CONTAINERID = \" $2 \" ; PROC_TYPE = \" $3 \" ; PORT = \" $4 \" ; IP = \" $5 \" eval \" $( config_export app $APP ) \" DOKKU_DISABLE_DEPLOY = \" ${ DOKKU_DISABLE_DEPLOY :- false } \" if [[ \" $DOKKU_DISABLE_DEPLOY \" = \"true\" ]] ; then echo -e \"\\033[31m\\033[1mDeploys disabled, sorry.\\033[0m\" exit 1 fi","title":"check-deploy"},{"location":"development/plugin-triggers/#commands-help-and-commands-plugin_namehelp","text":"Description: Your plugin should implement a help command in your commands file to take advantage of this plugin trigger. commands help is used by dokku help to aggregate all plugins abbreviated help output. Implementing <PLUGIN_NAME>:help in your commands file gives users looking for help, a more detailed output. 'commands help' must be implemented inside the commands plugin file. It's recommended that PLUGIN_NAME:help be added to the commands file to ensure consistency among community plugins and give you a new avenue to share rich help content with your user. Invoked by: dokku help and commands <PLUGIN_NAME>:help Arguments: None Example: #!/usr/bin/env bash # Outputs help for the derp plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | hello:help ) help_content_func () { declare desc = \"return help_content string\" cat <<help_content hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" help_content } if [[ $1 = \"hello:help\" ]] ; then echo -e 'Usage: dokku hello[:world] [<app>]' echo '' echo 'Say Hello World.' echo '' echo 'Example:' echo '' echo '$ dokku hello:world' echo 'Hello world' echo '' echo 'Additional commands:' help_content_func | sort | column -c2 -t -s, else help_content_func fi ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac","title":"commands help and commands &lt;PLUGIN_NAME&gt;:help"},{"location":"development/plugin-triggers/#core-post-deploy","text":"To avoid issues with community plugins, this plugin trigger should be used only for core plugins. Please avoid using this trigger in your own plugins. Description: Allows running of commands after an app's processes have been scaled up, but before old containers are torn down. Dokku core currently uses this to switch traffic on nginx. Invoked by: dokku deploy Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS $IMAGE_TAG Example: #!/usr/bin/env bash # Notify an external service that a successful deploy has occurred. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x curl \"http://httpstat.us/200\"","title":"core-post-deploy"},{"location":"development/plugin-triggers/#dependencies","text":"Description: Used to install system-level dependencies. Invoked by: dokku plugin:install-dependencies Arguments: None Example: #!/usr/bin/env bash # Installs nginx for the current plugin # Supports both opensuse and ubuntu set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x export DEBIAN_FRONTEND = noninteractive case \" $DOKKU_DISTRO \" in debian | ubuntu ) apt-get install --force-yes -qq -y nginx ;; opensuse ) zypper -q in -y nginx ;; esac","title":"dependencies"},{"location":"development/plugin-triggers/#deploy-source","text":"Description: Used for reporting what the current detected deployment source is. The first detected source should always win. Invoked by: dokku apps:report Arguments: $APP Example: #!/usr/bin/env bash # Checks if the app should be deployed via git set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" STDIN = $( cat ) # bail if another source is detected if [[ -n \" $STDIN \" ]] ; then echo \" $STDIN \" return fi if [[ -d \" $DOKKU_ROOT / $APP /refs\" ]] ; then echo \"git\" fi","title":"deploy-source"},{"location":"development/plugin-triggers/#deployed-app-image-repo","text":"Description: Used to manage the full repo of the image being deployed. Useful for deploying from an external registry where the repository name is not dokku/$APP Invoked by: internal function dokku_deploy_cmd() (deploy phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" # change the repo from dokku/APP to dokkupaas/APP echo \"dokkupaas/ $APP \"","title":"deployed-app-image-repo"},{"location":"development/plugin-triggers/#deployed-app-image-tag","text":"Description: Used to manage the tag of the image being deployed. Useful for deploying a specific version of an image, or when deploying from an external registry Invoked by: internal function dokku_deploy_cmd() (deploy phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # customize the tag version echo 'not-latest'","title":"deployed-app-image-tag"},{"location":"development/plugin-triggers/#deployed-app-repository","text":"Description: Used to manage the remote repository of the image being deployed. Invoked by: internal function dokku_deploy_cmd() (deploy phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x echo 'derp.dkr.ecr.us-east-1.amazonaws.com'","title":"deployed-app-repository"},{"location":"development/plugin-triggers/#docker-args-build","text":"Description: Invoked by: internal function dokku_build() (build phase) Arguments: $APP $IMAGE_SOURCE_TYPE Example: #!/usr/bin/env bash # Sets a docker build-arg called CACHEBUST which can be used # to bust cache at any arbitrary point in a Dockerfile build set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x STDIN = $( cat ) APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $2 \" output = \"\" if [[ \" $IMAGE_SOURCE_TYPE \" == \"dockerfile\" ]] ; then output = \" --build-arg CACHEBUST= $( date +%s ) \" fi echo -n \" $STDIN$output \"","title":"docker-args-build"},{"location":"development/plugin-triggers/#docker-args-deploy","text":"Description: Invoked by: dokku deploy Arguments: $APP $IMAGE_TAG [$PROC_TYPE $CONTAINER_INDEX] Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO","title":"docker-args-deploy"},{"location":"development/plugin-triggers/#docker-args-run","text":"Description: Invoked by: dokku run Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO","title":"docker-args-run"},{"location":"development/plugin-triggers/#git-post-pull","text":"Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"git-post-pull"},{"location":"development/plugin-triggers/#git-pre-pull","text":"Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO Warning: The git-pre-pull trigger should not be used for authentication since it does not get called for commands that use git-upload-archive such as git archive . Instead, use the user-auth trigger.","title":"git-pre-pull"},{"location":"development/plugin-triggers/#install","text":"Description: Used to setup any files/configuration for a plugin. Invoked by: dokku plugin:install . Arguments: None Example: #!/usr/bin/env bash # Sets the hostname of the Dokku server # based on the output of `hostname -f` set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x if [[ ! -f \" $DOKKU_ROOT /HOSTNAME\" ]] ; then hostname -f > $DOKKU_ROOT /HOSTNAME fi","title":"install"},{"location":"development/plugin-triggers/#network-build-config","text":"Description: Rebuilds network configuration Invoked by: internally triggered by proxy-build-config within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-build-config"},{"location":"development/plugin-triggers/#network-clear-config","text":"Description: Clears network configuration Invoked by: internally triggered by proxy-clear-config within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-clear-config"},{"location":"development/plugin-triggers/#network-compute-ports","text":"Description: Computes the ports for a given app container Invoked by: internally triggered by proxy-build-config within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-compute-ports"},{"location":"development/plugin-triggers/#network-config-exists","text":"Description: Returns whether the network configuration for a given app exists Invoked by: internally triggered by core-post-deploy within proxy implementations Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-config-exists"},{"location":"development/plugin-triggers/#network-get-ipaddr","text":"Description: Return the ipaddr for a given app container Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_ID Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-get-ipaddr"},{"location":"development/plugin-triggers/#network-get-listeners","text":"Description: Return the listeners (host:port combinations) for a given app container Invoked by: internally triggered by a deploy Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-get-listeners"},{"location":"development/plugin-triggers/#network-get-port","text":"Description: Return the port for a given app container Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_ID $IS_HEROKUISH_CONTAINER Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-get-port"},{"location":"development/plugin-triggers/#network-get-property","text":"Description: Return the network value for an app's property Invoked by: internally triggered by a deploy Arguments: $APP $KEY Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-get-property"},{"location":"development/plugin-triggers/#network-write-ipaddr","text":"Description: Write the ipaddr for a given app index Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_INDEX $IP_ADDRESS Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-write-ipaddr"},{"location":"development/plugin-triggers/#network-write-port","text":"Description: Write the port for a given app index Invoked by: internally triggered by a deploy Arguments: $APP $PROC_TYPE $CONTAINER_INDEX $PORT Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"network-write-port"},{"location":"development/plugin-triggers/#nginx-hostname","text":"Description: Allows you to customize the hostname for a given app Invoked by: dokku domains:setup Arguments: $APP $SUBDOMAIN $VHOST Example: #!/usr/bin/env bash # Reverses the hostname for the app set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \"","title":"nginx-hostname"},{"location":"development/plugin-triggers/#nginx-pre-reload","text":"Description: Run before nginx reloads hosts Invoked by: dokku nginx:build-config Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Runs a check against all nginx conf files # to ensure they are valid set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x nginx -t","title":"nginx-pre-reload"},{"location":"development/plugin-triggers/#post-app-clone","text":"Description: Allows you to run commands after an app was cloned. Invoked by: dokku apps:clone Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-app-clone"},{"location":"development/plugin-triggers/#post-app-clone-setup","text":"Description: Allows you to run commands after an app is setup, and before it is rebuild. This is useful for cleaning up tasks, or ensuring configuration from an old app is copied to the new app Invoked by: dokku apps:clone Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-app-clone-setup"},{"location":"development/plugin-triggers/#post-app-rename","text":"Description: Allows you to run commands after an app was renamed. Invoked by: dokku apps:rename Arguments: $OLD_APP_NAME $NEW_APP_NAME Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-app-rename"},{"location":"development/plugin-triggers/#post-build-buildpack","text":"Description: Allows you to run commands after the build image is create for a given app. Only applies to apps using buildpacks. Invoked by: internal function dokku_build() (build phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-build-buildpack"},{"location":"development/plugin-triggers/#post-build-dockerfile","text":"Description: Allows you to run commands after the build image is create for a given app. Only applies to apps using a dockerfile. Invoked by: internal function dokku_build() (build phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-build-dockerfile"},{"location":"development/plugin-triggers/#post-certs-remove","text":"Description: Allows you to run commands after a cert is removed Invoked by: dokku certs:remove Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; verify_app_name \" $APP \" # TODO","title":"post-certs-remove"},{"location":"development/plugin-triggers/#post-certs-update","text":"Description: Allows you to run commands after a cert is added/updated Invoked by: dokku certs:add , dokku certs:update Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; verify_app_name \" $APP \" # TODO","title":"post-certs-update"},{"location":"development/plugin-triggers/#post-config-update","text":"Description: Allows you to get notified when one or more configs is added or removed. Action can be set or unset Invoked by: dokku config:set , dokku config:unset Arguments: $APP set|unset key1=VALUE1 key2=VALUE2 Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-config-update"},{"location":"development/plugin-triggers/#post-create","text":"Description: Can be used to run commands after an app is created. Invoked by: dokku apps:create Arguments: $APP Example: #!/usr/bin/env bash # Runs a command to ensure that an app # has a postgres database when it is starting set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; POSTGRES = \" $1 \" dokku postgres:create $POSTGRES dokku postgres:link $POSTGRES $APP","title":"post-create"},{"location":"development/plugin-triggers/#post-delete","text":"Description: Can be used to run commands after an app is deleted. Invoked by: dokku apps:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Runs a command to ensure that an app's # postgres installation is removed set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku postgres:destroy $APP","title":"post-delete"},{"location":"development/plugin-triggers/#post-deploy","text":"Please see core-post-deploy if contributing a core plugin with the post-deploy hook. Description: Allows running of commands after an app's processes have been scaled up, but before old containers are torn down. Dokku calls this after core-post-deploy . Deployment Tasks are also invoked by this plugin trigger. Invoked by: dokku deploy Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS $IMAGE_TAG Example: #!/usr/bin/env bash # Notify an external service that a successful deploy has occurred. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x curl \"http://httpstat.us/200\"","title":"post-deploy"},{"location":"development/plugin-triggers/#post-domains-update","text":"Description: Allows you to run commands once the domain for an app has been updated. It also sends in the command that has been used. This can be \"add\", \"clear\" or \"remove\". The third argument will be the optional list of domains Invoked by: dokku domains:add , dokku domains:clear , dokku domains:remove , dokku domains:set Arguments: $APP action name domains Example: #!/usr/bin/env bash # Reloads haproxy for our imaginary haproxy plugin # that replaces the nginx-vhosts plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x sudo service haproxy reload","title":"post-domains-update"},{"location":"development/plugin-triggers/#post-extract","text":"Description: Allows you to modify the contents of an app after it has been extracted from git/tarball but before the image source type is detected. Invoked by: dokku tar:in , dokku tar:from and the receive-app plugin trigger Arguments: $APP $TMP_WORK_DIR $REV Example: #!/usr/bin/env bash # Adds a clock process to an app's Procfile set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; verify_app_name \" $APP \" TMP_WORK_DIR = \" $2 \" REV = \" $3 \" # optional, may not be sent for tar-based builds pushd \" $TMP_WORK_DIR \" >/dev/null touch Procfile echo \"clock: some-command\" >> Procfile","title":"post-extract"},{"location":"development/plugin-triggers/#post-proxy-ports-update","text":"Description: Allows you to run commands once the proxy port mappings for an app have been updated. It also sends the invoking command. This can be \"add\", \"clear\" or \"remove\". Invoked by: dokku proxy:ports-add , dokku proxy:ports-clear , dokku proxy:ports-remove Arguments: $APP action name Example: #!/usr/bin/env bash # Rebuilds haproxy config for our imaginary haproxy plugin # that replaces the nginx-vhosts plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" source \" $PLUGIN_AVAILABLE_PATH /haproxy/functions\" APP = \" $1 \" ; verify_app_name \" $APP \" haproxy-build-config \" $APP \"","title":"post-proxy-ports-update"},{"location":"development/plugin-triggers/#post-release-buildpack","text":"Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to apps using buildpacks. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Installs a package specified by the `CONTAINER_PACKAGE` env var set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" dokku_log_info1 \"Installing $CONTAINER_PACKAGE ...\" CMD = \"cat > gm && \\ dpkg -s CONTAINER_PACKAGE >/dev/null 2>&1 || \\ (apt-get update && apt-get install -y CONTAINER_PACKAGE && apt-get clean)\" ID = $( docker run $DOKKU_GLOBAL_RUN_ARGS -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $ID ) -eq 0 docker commit $ID $IMAGE >/dev/null","title":"post-release-buildpack"},{"location":"development/plugin-triggers/#post-release-dockerfile","text":"Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to apps using a dockerfile. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO","title":"post-release-dockerfile"},{"location":"development/plugin-triggers/#post-stop","text":"Description: Can be used to run commands after an app is manually stopped Invoked by: dokku ps:stop and dokku ps:stopall Arguments: $APP Example: #!/usr/bin/env bash # Marks an app as manually stopped set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku config:set --no-restart $APP MANUALLY_STOPPED = 1","title":"post-stop"},{"location":"development/plugin-triggers/#pre-build-buildpack","text":"Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to apps using buildpacks. Invoked by: internal function dokku_build() (build phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"pre-build-buildpack"},{"location":"development/plugin-triggers/#pre-build-dockerfile","text":"Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to apps using a dockerfile. Invoked by: internal function dokku_build() (build phase) Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"pre-build-dockerfile"},{"location":"development/plugin-triggers/#pre-delete","text":"Description: Can be used to run commands before an app is deleted. Invoked by: dokku apps:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Clears out the gulp asset build cache for apps set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; GULP_CACHE_DIR = \" $DOKKU_ROOT / $APP /gulp\" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" if [[ -d $GULP_CACHE_DIR ]] ; then docker run $DOKKU_GLOBAL_RUN_ARGS --rm -v \" $GULP_CACHE_DIR :/gulp\" \" $IMAGE \" find /gulp -depth -mindepth 1 -maxdepth 1 -exec rm -Rf {} \\; || true fi","title":"pre-delete"},{"location":"development/plugin-triggers/#pre-deploy","text":"Description: Allows the running of code before the app's processes are scaled up and after the docker images are prepared. Invoked by: dokku deploy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Runs gulp in our container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" dokku_log_info1 \"Running gulp\" id = $( docker run $DOKKU_GLOBAL_RUN_ARGS -d $IMAGE /bin/bash -c \"cd /app && gulp default\" ) test $( docker wait $id ) -eq 0 docker commit $id $IMAGE >/dev/null dokku_log_info1 \"Building UI Complete\"","title":"pre-deploy"},{"location":"development/plugin-triggers/#pre-disable-vhost","text":"Description: Allows you to run commands before the VHOST feature is disabled Invoked by: dokku domains:disable Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; verify_app_name \" $APP \" # TODO","title":"pre-disable-vhost"},{"location":"development/plugin-triggers/#pre-enable-vhost","text":"Description: Allows you to run commands before the VHOST feature is enabled Invoked by: dokku domains:enable Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; verify_app_name \" $APP \" # TODO","title":"pre-enable-vhost"},{"location":"development/plugin-triggers/#pre-receive-app","text":"Description: Allows you to customize the contents of an app directory before they are processed for deployment. The IMAGE_SOURCE_TYPE can be any of [herokuish, dockerfile] Invoked by: dokku git-hook , dokku tar-build-locked Arguments: $APP $IMAGE_SOURCE_TYPE $TMP_WORK_DIR $REV Example: #!/usr/bin/env bash # Adds a file called `dokku-is-awesome` to the repository # the contents will be the app name set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_SOURCE_TYPE = \" $2 \" ; TMP_WORK_DIR = \" $3 \" ; REV = \" $4 \" echo \" $APP \" > \" $TMP_WORK_DIR /dokku-is-awesome\"","title":"pre-receive-app"},{"location":"development/plugin-triggers/#pre-release-buildpack","text":"Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to apps using buildpacks. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Installs the graphicsmagick package into the container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" dokku_log_info1 \"Installing GraphicsMagick...\" CMD = \"cat > gm && \\ dpkg -s graphicsmagick >/dev/null 2>&1 || \\ (apt-get update && apt-get install -y graphicsmagick && apt-get clean)\" ID = $( docker run $DOKKU_GLOBAL_RUN_ARGS -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $ID ) -eq 0 docker commit $ID $IMAGE >/dev/null","title":"pre-release-buildpack"},{"location":"development/plugin-triggers/#pre-release-dockerfile","text":"Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to apps using a dockerfile. Invoked by: internal function dokku_release() (release phase) Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $PLUGIN_CORE_AVAILABLE_PATH /common/functions\" APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) verify_app_name \" $APP \" # TODO","title":"pre-release-dockerfile"},{"location":"development/plugin-triggers/#pre-restore","text":"Description: Allows you to run commands before all containers are restored Invoked by: dokku ps:restore Arguments: $DOKKU_SCHEDULER Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" # TODO","title":"pre-restore"},{"location":"development/plugin-triggers/#pre-start","text":"Description: Can be used to run commands before an app is started Invoked by: dokku ps:start Arguments: $APP Example: #!/usr/bin/env bash # Notifies an example url that an app is starting set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; curl \"https://dokku.me/starting/ ${ APP } \" || true","title":"pre-start"},{"location":"development/plugin-triggers/#proxy-build-config","text":"Description: Builds the proxy implementation configuration for a given app Invoked by: internally triggered by ps:restore Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"proxy-build-config"},{"location":"development/plugin-triggers/#proxy-clear-config","text":"Description: Clears the proxy implementation configuration for a given app Invoked by: internally triggered by apps:rename Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"proxy-clear-config"},{"location":"development/plugin-triggers/#proxy-enable","text":"Description: Enables the configured proxy implementation for an app Invoked by: internally triggered by ps:restore Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"proxy-enable"},{"location":"development/plugin-triggers/#proxy-disable","text":"Description: Disables the configured proxy implementation for an app Invoked by: internally triggered by ps:restore Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"proxy-disable"},{"location":"development/plugin-triggers/#receive-app","text":"Description: Allows you to customize what occurs when an app is received. Normally just triggers an app build. Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV ( $REV may not be included in cases where a repository is not pushed) Example: #!/usr/bin/env bash # For our imaginary mercurial plugin, triggers a rebuild set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; REV = \" $2 \" dokku hg-build $APP $REV","title":"receive-app"},{"location":"development/plugin-triggers/#receive-branch","text":"Description: Allows you to customize what occurs when a specific branch is received. Can be used to add support for specific branch names Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV $REFNAME Example: #!/bin/bash # Gives Dokku the ability to support multiple branches for a given service # Allowing you to have multiple staging environments on a per-branch basis reference_app = $1 refname = $3 newrev = $2 APP = ${ refname /* \\/ / } . $reference_app if [[ ! -d \" $DOKKU_ROOT / $APP \" ]] ; then REFERENCE_REPO = \" $DOKKU_ROOT / $reference_app \" git clone --bare --shared --reference \" $REFERENCE_REPO \" \" $REFERENCE_REPO \" \" $DOKKU_ROOT / $APP \" >/dev/null fi plugn trigger receive-app $APP $newrev","title":"receive-branch"},{"location":"development/plugin-triggers/#retire-container-failed","text":"Description: Allows you to run commands if/when retiring old containers has failed Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash # Send an email when a container failed to retire set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; HOSTNAME = $( hostname -s ) mail -s \" $APP containers on $HOSTNAME failed to retire\" ops@dokku.me","title":"retire-container-failed"},{"location":"development/plugin-triggers/#report","text":"Description: Allows you to report on any custom configuration in use by your application Invoked by: dokku report Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; # TODO","title":"report"},{"location":"development/plugin-triggers/#scheduler-deploy","text":"Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when an app is deployed Invoked by: dokku deploy Arguments: $DOKKU_SCHEDULER $APP $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; IMAGE_TAG = \" $3 \" ; # TODO","title":"scheduler-deploy"},{"location":"development/plugin-triggers/#scheduler-docker-cleanup","text":"Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when dokku cleanup is invoked Invoked by: dokku deploy, dokku cleanup Arguments: $DOKKU_SCHEDULER $APP $FORCE_CLEANUP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; FORCE_CLEANUP = \" $3 \" ; # TODO","title":"scheduler-docker-cleanup"},{"location":"development/plugin-triggers/#scheduler-inspect","text":"Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run inspect commands for all containers for a given app Invoked by: dokku ps:inspect Arguments: $DOKKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; # TODO","title":"scheduler-inspect"},{"location":"development/plugin-triggers/#scheduler-logs-failed","text":"Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when retrieving failed container logs Invoked by: dokku logs:failed Arguments: $DOKKU_SCHEDULER $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; ARGS = \" ${ @: 3 } \" ; # TODO","title":"scheduler-logs-failed"},{"location":"development/plugin-triggers/#scheduler-run","text":"Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when a command is executed for your app Invoked by: dokku run Arguments: $DOKKU_SCHEDULER $APP ...ARGS Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; ARGS = \" ${ @: 3 } \" ; # TODO","title":"scheduler-run"},{"location":"development/plugin-triggers/#scheduler-stop","text":"Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when a tag is destroyed Invoked by: dokku apps:destroy, dokku ps:stop Arguments: $DOKKU_SCHEDULER $APP $REMOVE_CONTAINERS Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; REMOVE_CONTAINERS = \" $3 \" ; # TODO","title":"scheduler-stop"},{"location":"development/plugin-triggers/#scheduler-tags-create","text":"Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when a tag is created Invoked by: dokku tags:create Arguments: $DOKKU_SCHEDULER $APP $SOURCE_IMAGE $TARGET_IMAGE Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" APP = \" $2 \" SOURCE_IMAGE = \" $3 \" TARGET_IMAGE = \" $4 \" # TODO","title":"scheduler-tags-create"},{"location":"development/plugin-triggers/#scheduler-tags-destroy","text":"Warning: The scheduler plugin trigger apis are under development and may change between minor releases until the 1.0 release. Description: Allows you to run scheduler commands when a tag is destroyed Invoked by: dokku tags:destroy Arguments: $DOKKU_SCHEDULER $APP $IMAGE_REPO $IMAGE_TAG Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x DOKKU_SCHEDULER = \" $1 \" ; APP = \" $2 \" ; IMAGE_REPO = \" $3 \" ; IMAGE_TAG = \" $4 \" ; # TODO","title":"scheduler-tags-destroy"},{"location":"development/plugin-triggers/#tags-create","text":"Description: Allows you to run commands once a tag for an app image has been added Invoked by: dokku tags:create Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Upload an app image to docker hub set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_TAG = \" $2 \" ; IMAGE = $( get_app_image_name $APP $IMAGE_TAG ) IMAGE_ID = $( docker inspect --format '{{ .Id }}' $IMAGE ) docker tag -f $IMAGE_ID $DOCKER_HUB_USER / $APP : $IMAGE_TAG docker push $DOCKER_HUB_USER / $APP : $IMAGE_TAG","title":"tags-create"},{"location":"development/plugin-triggers/#tags-destroy","text":"Description: Allows you to run commands once a tag for an app image has been removed Invoked by: dokku tags:destroy Arguments: $APP $IMAGE_TAG Example: #!/usr/bin/env bash # Remove an image tag from docker hub set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE_TAG = \" $2 \" # some code to remove a docker hub tag because it's not implemented in the CLI...","title":"tags-destroy"},{"location":"development/plugin-triggers/#uninstall","text":"Description: Used to cleanup after itself. Invoked by: dokku plugin:uninstall Arguments: $PLUGIN Example: #!/usr/bin/env bash # Cleanup up extra containers created set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x PLUGIN = \" $1 \" [[ \" $PLUGIN \" = \"my-plugin\" ]] && docker rmi -f \" ${ PLUGIN_IMAGE_DEPENDENCY } \" To avoid uninstalling other plugins make sure to check the plugin name like shown in the example.","title":"uninstall"},{"location":"development/plugin-triggers/#update","text":"Description: Can be used to run plugin updates on a regular interval. You can schedule the invoker in a cron-task to ensure your system gets regular updates. Invoked by: dokku plugin:update . Arguments: None Example: #!/usr/bin/env bash # Update the herokuish image from git source set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x cd /root/dokku sudo BUILD_STACK = true make install","title":"update"},{"location":"development/plugin-triggers/#user-auth","text":"This is a special plugin trigger that is executed on every command run. As Dokku sometimes internally invokes the dokku command, special care should be taken to properly handle internal command redirects. Note that the trigger should exit as follows: 0 to continue running as normal 1 to halt execution of the command The SSH_USER is the original ssh user. If you are running remote commands, this user will typically be dokku , and as such should not be trusted when checking permissions. If you are connected via ssh as a different user who then invokes dokku , the value of this variable will be that user's name ( root , myuser , etc.). The SSH_NAME is the NAME variable set via the sshcommand acl-add command. If you have set a user via the dokku-installer , this value will be set to admin . For installs via debian package, this value may be default . For reference, the following command can be run as the root user to specify a specific NAME for a given ssh key: sshcommand acl-add dokku NAME < $PATH_TO_SSH_KEY Note that the NAME value is set at the first ssh key match. If an ssh key is set in the /home/dokku/.ssh/authorized_keys multiple times, the first match will decide the value. Description: Allows you to deny access to a Dokku command by either ssh user or associated ssh-command NAME user. Invoked by: dokku Arguments: $SSH_USER $SSH_NAME $DOKKU_COMMAND Example: #!/usr/bin/env bash # Allow root/admin users to do everything # Deny plugin access to default users # Allow access to all other commands set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x SSH_USER = $1 SSH_NAME = $2 shift 2 [[ \" $SSH_USER \" == \"root\" ]] && exit 0 [[ \" $SSH_NAME \" == \"admin\" ]] && exit 0 [[ \" $SSH_NAME \" == \"default\" && $1 == plugin:* ]] && exit 1 exit 0","title":"user-auth"},{"location":"development/release-process/","text":"Release Process Dokku is released in intervals at most three weeks apart, though may be released much quicker. To propose a release, the following tasks need to be performed: export PACKAGECLOUD_TOKEN = SOME_TOKEN # supports major/minor/patch/betafish contrib/release-dokku If you are a maintainer and need the PACKAGECLOUD_TOKEN in order to make a release, please contact @josegonzalez to get this information. As well, the ArchLinux package description must be updated via vagrant up build-arch (needs to be done after the tag is pushed to GitHub, because it is based on that) Versioning Dokku follows semver standards. As we are not yet at a stable release, breaking changes will require only a minor release, while all other changes only require a patch release. Once we hit stable, breaking changes will require a major release. At the moment, tags need not be signed, though that may change in the future. ArchLinux Packages ArchLinux packages are not really build, because all that is needed for an Arch User Repo (AUR) package is the description of how to build the package. To make this process as easy as possible there is a vagrant box called build-arch that updates the version of this build description (a file called PKGBUILD ), then runs some helper scripts to fill all additional information and does test if the package could be build. Then only those changes need to be pushed to the AUR repo and an updated version of the package is ready for usage for our ArchLinux users. For detailed information see the section below. The workflow looks like this: # having dokku-arch in ../dokku-arch vagrant up build-arch # wait for \"==> build-arch: ==> Finished making: dokku 0.14.6-2 (Mon Feb 22 23:20:37 CET 2016)\" cd ../dokku-arch git add PKGBUILD .SRCINFO git commit -m 'Update to dokku 0.9.9' git push aur master If you are a maintainer and need access to the AUR repositories in order to make a release, please contact @morrisjobke or @josegonzalez to get this co-maintainership. Detailed information for ArchLinux packages All of the information to build the ArchLinux package is in the AUR git repository (see dokku AUR page ). The release of a AUR package only consists of pushing the package information into the AUR git repo. Then users could use that information to build the package on their machines. To update the package clone the repository and adjust the files in the repository. Then a helper script - updpkgsums - to update the SHA sum could be called (check against the original SHA sum). Another helper script - mksrcinfo - needs to be called to update the meta information of the package in a file called .SRCINFO . The next step builds the package locally for verification - makepkg . As last step commit your changes and push the commit. dependencies are defined in the depends attribute in PKGBUILD build steps during package build time are defined in the package() method in PKGBUILD steps that should be executed during install/update/remove time are defined in the file dokku.install detailed information about all attributes in PKGBUILD could be found in the ArchLinux wiki detailed information about the AUR workflow could be found in the AUR article in the ArchLinux wiki That is the usual workflow: updpkgsums # update sha sums - compare them with the original ones mksrcinfo # update package metadata for AUR makepkg # test package builds git add PKGBUILD .SRCINFO git commit -m 'Update to dokku 0.9.9' git push If there is something unclear simply ask @morrisjobke for help.","title":"Release Process"},{"location":"development/release-process/#release-process","text":"Dokku is released in intervals at most three weeks apart, though may be released much quicker. To propose a release, the following tasks need to be performed: export PACKAGECLOUD_TOKEN = SOME_TOKEN # supports major/minor/patch/betafish contrib/release-dokku If you are a maintainer and need the PACKAGECLOUD_TOKEN in order to make a release, please contact @josegonzalez to get this information. As well, the ArchLinux package description must be updated via vagrant up build-arch (needs to be done after the tag is pushed to GitHub, because it is based on that)","title":"Release Process"},{"location":"development/release-process/#versioning","text":"Dokku follows semver standards. As we are not yet at a stable release, breaking changes will require only a minor release, while all other changes only require a patch release. Once we hit stable, breaking changes will require a major release. At the moment, tags need not be signed, though that may change in the future.","title":"Versioning"},{"location":"development/release-process/#archlinux-packages","text":"ArchLinux packages are not really build, because all that is needed for an Arch User Repo (AUR) package is the description of how to build the package. To make this process as easy as possible there is a vagrant box called build-arch that updates the version of this build description (a file called PKGBUILD ), then runs some helper scripts to fill all additional information and does test if the package could be build. Then only those changes need to be pushed to the AUR repo and an updated version of the package is ready for usage for our ArchLinux users. For detailed information see the section below. The workflow looks like this: # having dokku-arch in ../dokku-arch vagrant up build-arch # wait for \"==> build-arch: ==> Finished making: dokku 0.14.6-2 (Mon Feb 22 23:20:37 CET 2016)\" cd ../dokku-arch git add PKGBUILD .SRCINFO git commit -m 'Update to dokku 0.9.9' git push aur master If you are a maintainer and need access to the AUR repositories in order to make a release, please contact @morrisjobke or @josegonzalez to get this co-maintainership.","title":"ArchLinux Packages"},{"location":"development/release-process/#detailed-information-for-archlinux-packages","text":"All of the information to build the ArchLinux package is in the AUR git repository (see dokku AUR page ). The release of a AUR package only consists of pushing the package information into the AUR git repo. Then users could use that information to build the package on their machines. To update the package clone the repository and adjust the files in the repository. Then a helper script - updpkgsums - to update the SHA sum could be called (check against the original SHA sum). Another helper script - mksrcinfo - needs to be called to update the meta information of the package in a file called .SRCINFO . The next step builds the package locally for verification - makepkg . As last step commit your changes and push the commit. dependencies are defined in the depends attribute in PKGBUILD build steps during package build time are defined in the package() method in PKGBUILD steps that should be executed during install/update/remove time are defined in the file dokku.install detailed information about all attributes in PKGBUILD could be found in the ArchLinux wiki detailed information about the AUR workflow could be found in the AUR article in the ArchLinux wiki That is the usual workflow: updpkgsums # update sha sums - compare them with the original ones mksrcinfo # update package metadata for AUR makepkg # test package builds git add PKGBUILD .SRCINFO git commit -m 'Update to dokku 0.9.9' git push If there is something unclear simply ask @morrisjobke for help.","title":"Detailed information for ArchLinux packages"},{"location":"development/testing/","text":"Dokku test suite Dokku has a full test suite to assist in quick iterating development. These tests include a linter using shellcheck , functional unit tests using the bats testing framework , and a deployment suite of example apps that use the most popular languages and frameworks. We maintain the Dokku test harness within the tests directory: tests/unit/*.bats : Bats tests tests/apps/ : Example applications that can be used for tests Continuous Integration All pull requests have tests run against them on CircleCI , a continuous integration platform that provides Docker support for Ubuntu Trusty 14.04. If you wish to skip tests for a particular commit - e.g. Documentation changes - you may add the [ci skip] designator to your commit message. Commits that should be tested but have the above designator will not be merged. While we do provide official packages for a variety of platforms, as our test suite currently runs on Ubuntu Trusty 14.04, we only provide official installation support for that platform. Local Test Execution Setup Dokku in a vagrant vm Run the following to setup tests and execute them: vagrant ssh sudo su - cd ~/dokku make ci-dependencies setup-deploy-tests # execute the entire test suite (linter, bats tests, and app deployment tests) make test # run linter & update vagrant Dokku install from local git clone make lint copyfiles # execute all bats tests make unit-tests # execute all app deployment tests make deploy-tests Additionally you may run a specific app deployment tests with a target similar to: make deploy-test-nodejs-express For a full list of test make targets check out tests.mk in the root of the Dokku repository. Executing a single test suite When working on a particular plugin, it may be useful to run only a particular test suite. This can be done by specifying the test suite path: bats tests/unit/10_apps.bats It is also possible to target multiple test suites at a time. bats tests/unit/10_apps.bats tests/unit/10_certs.bats Executing a single test In order to increase testing velocity, a wrapper script around bats is available that can be used to run a single testcase within a suite. Tests within a suite may be listed by specifying the suite as a parameter to the tests/bats-exec-test-single script. tests/bats-exec-test-single tests/unit/10_apps.bats A single test can be specified as a second parameter. The test is selected by fuzzy-match, and only the first match is executed. tests/bats-exec-test-single tests/unit/10_apps.bats clone Some special characters are translated in the test listing - specifically the characters ( ) : - while others are not. The fuzzy matching happens on the test names listed when no second character is invoked, so executing a test with a more specific name will work as expected. tests/bats-exec-test-single tests/unit/10_apps.bats clone_-2d-2dskip-2ddeploy","title":"Dokku test suite"},{"location":"development/testing/#dokku-test-suite","text":"Dokku has a full test suite to assist in quick iterating development. These tests include a linter using shellcheck , functional unit tests using the bats testing framework , and a deployment suite of example apps that use the most popular languages and frameworks. We maintain the Dokku test harness within the tests directory: tests/unit/*.bats : Bats tests tests/apps/ : Example applications that can be used for tests","title":"Dokku test suite"},{"location":"development/testing/#continuous-integration","text":"All pull requests have tests run against them on CircleCI , a continuous integration platform that provides Docker support for Ubuntu Trusty 14.04. If you wish to skip tests for a particular commit - e.g. Documentation changes - you may add the [ci skip] designator to your commit message. Commits that should be tested but have the above designator will not be merged. While we do provide official packages for a variety of platforms, as our test suite currently runs on Ubuntu Trusty 14.04, we only provide official installation support for that platform.","title":"Continuous Integration"},{"location":"development/testing/#local-test-execution","text":"Setup Dokku in a vagrant vm Run the following to setup tests and execute them: vagrant ssh sudo su - cd ~/dokku make ci-dependencies setup-deploy-tests # execute the entire test suite (linter, bats tests, and app deployment tests) make test # run linter & update vagrant Dokku install from local git clone make lint copyfiles # execute all bats tests make unit-tests # execute all app deployment tests make deploy-tests Additionally you may run a specific app deployment tests with a target similar to: make deploy-test-nodejs-express For a full list of test make targets check out tests.mk in the root of the Dokku repository.","title":"Local Test Execution"},{"location":"development/testing/#executing-a-single-test-suite","text":"When working on a particular plugin, it may be useful to run only a particular test suite. This can be done by specifying the test suite path: bats tests/unit/10_apps.bats It is also possible to target multiple test suites at a time. bats tests/unit/10_apps.bats tests/unit/10_certs.bats","title":"Executing a single test suite"},{"location":"development/testing/#executing-a-single-test","text":"In order to increase testing velocity, a wrapper script around bats is available that can be used to run a single testcase within a suite. Tests within a suite may be listed by specifying the suite as a parameter to the tests/bats-exec-test-single script. tests/bats-exec-test-single tests/unit/10_apps.bats A single test can be specified as a second parameter. The test is selected by fuzzy-match, and only the first match is executed. tests/bats-exec-test-single tests/unit/10_apps.bats clone Some special characters are translated in the test listing - specifically the characters ( ) : - while others are not. The fuzzy matching happens on the test names listed when no second character is invoked, so executing a test with a more specific name will work as expected. tests/bats-exec-test-single tests/unit/10_apps.bats clone_-2d-2dskip-2ddeploy","title":"Executing a single test"},{"location":"getting-started/advanced-installation/","text":"Advanced installation You can always install Dokku straight from the latest - potentially unstable - master branch via the following Bash command: # using a branch results in installing from source wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh ; sudo DOKKU_BRANCH = master bash bootstrap.sh Development If you plan on developing Dokku, the easiest way to install from your own repository is cloning the repository and calling the install script. Example: git clone https://github.com/yourusername/dokku.git cd dokku sudo make install The Makefile allows source URLs to be overridden to include customizations from your own repositories. The DOCKER_URL , PLUGN_URL , SSHCOMMAND_URL and STACK_URL environment variables may be set to override the defaults (see the Makefile for how these apply). Example: sudo SSHCOMMAND_URL = https://raw.githubusercontent.com/yourusername/sshcommand/master/sshcommand make install Bootstrap a server from your own repository The bootstrap script allows the Dokku repository URL to be overridden to bootstrap a host from your own clone of Dokku using the DOKKU_REPO environment variable. Example: wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh ; chmod +x bootstrap.sh sudo DOKKU_REPO = https://github.com/yourusername/dokku.git DOKKU_BRANCH = master ./bootstrap.sh Custom Herokuish build Dokku ships with a pre-built version of version of the Herokuish component by default. If you want to build your own version you can specify that with an environment variable. git clone https://github.com/dokku/dokku.git cd dokku sudo BUILD_STACK = true STACK_URL = https://github.com/gliderlabs/herokuish.git make install Skipping Herokuish installation The Herokuish package is recommended but not required if not using Heroku buildpacks for deployment. Debian-based OS users can run the bootstrap installer via sudo DOKKU_NO_INSTALL_RECOMMENDS=true bash bootstrap.sh to skip the dependency. Please note that this will also skip installation of other recommended dependencies. Configuring an unattended installation Once Dokku is installed, if you are not using the web-installer, you'll want to configure the virtualhost setup as well as the push user. If you do not, your installation will be considered incomplete and you will not be able to deploy applications. For Debian, unattended installation is described Debian installation guide . You should also stop and disable the dokku-installer service to remove public access to adding SSH keys. Set up a domain using your preferred vendor and a wildcard domain pointing to the host running Dokku. You can manage this global domain using the domains plugin . Follow the user management documentation in order to add SSH keys for users to Dokku, or to give other Unix accounts access to Dokku. VMs with less than 1 GB of memory Having less than 1 GB of system memory available for Dokku and its containers may result in unexpected errors, such as ! [remote rejected] master -> master (pre-receive hook declined) during installation of NPM dependencies (https://github.com/npm/npm/issues/3867). To work around this issue, it might suffice to augment the Linux swap file size to a maximum of twice the physical memory size. To resize the swap file of a 512 MB machine to 1 GB, follow these steps while in SSH within your machine: cd /var touch swap.img chmod 600 swap.img dd if = /dev/zero of = /var/swap.img bs = 1024k count = 1000 mkswap /var/swap.img swapon /var/swap.img free echo \"/var/swap.img none swap sw 0 0\" >> /etc/fstab Reference","title":"Advanced installation"},{"location":"getting-started/advanced-installation/#advanced-installation","text":"You can always install Dokku straight from the latest - potentially unstable - master branch via the following Bash command: # using a branch results in installing from source wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh ; sudo DOKKU_BRANCH = master bash bootstrap.sh","title":"Advanced installation"},{"location":"getting-started/advanced-installation/#development","text":"If you plan on developing Dokku, the easiest way to install from your own repository is cloning the repository and calling the install script. Example: git clone https://github.com/yourusername/dokku.git cd dokku sudo make install The Makefile allows source URLs to be overridden to include customizations from your own repositories. The DOCKER_URL , PLUGN_URL , SSHCOMMAND_URL and STACK_URL environment variables may be set to override the defaults (see the Makefile for how these apply). Example: sudo SSHCOMMAND_URL = https://raw.githubusercontent.com/yourusername/sshcommand/master/sshcommand make install","title":"Development"},{"location":"getting-started/advanced-installation/#bootstrap-a-server-from-your-own-repository","text":"The bootstrap script allows the Dokku repository URL to be overridden to bootstrap a host from your own clone of Dokku using the DOKKU_REPO environment variable. Example: wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh ; chmod +x bootstrap.sh sudo DOKKU_REPO = https://github.com/yourusername/dokku.git DOKKU_BRANCH = master ./bootstrap.sh","title":"Bootstrap a server from your own repository"},{"location":"getting-started/advanced-installation/#custom-herokuish-build","text":"Dokku ships with a pre-built version of version of the Herokuish component by default. If you want to build your own version you can specify that with an environment variable. git clone https://github.com/dokku/dokku.git cd dokku sudo BUILD_STACK = true STACK_URL = https://github.com/gliderlabs/herokuish.git make install","title":"Custom Herokuish build"},{"location":"getting-started/advanced-installation/#skipping-herokuish-installation","text":"The Herokuish package is recommended but not required if not using Heroku buildpacks for deployment. Debian-based OS users can run the bootstrap installer via sudo DOKKU_NO_INSTALL_RECOMMENDS=true bash bootstrap.sh to skip the dependency. Please note that this will also skip installation of other recommended dependencies.","title":"Skipping Herokuish installation"},{"location":"getting-started/advanced-installation/#configuring-an-unattended-installation","text":"Once Dokku is installed, if you are not using the web-installer, you'll want to configure the virtualhost setup as well as the push user. If you do not, your installation will be considered incomplete and you will not be able to deploy applications. For Debian, unattended installation is described Debian installation guide . You should also stop and disable the dokku-installer service to remove public access to adding SSH keys. Set up a domain using your preferred vendor and a wildcard domain pointing to the host running Dokku. You can manage this global domain using the domains plugin . Follow the user management documentation in order to add SSH keys for users to Dokku, or to give other Unix accounts access to Dokku.","title":"Configuring an unattended installation"},{"location":"getting-started/advanced-installation/#vms-with-less-than-1-gb-of-memory","text":"Having less than 1 GB of system memory available for Dokku and its containers may result in unexpected errors, such as ! [remote rejected] master -> master (pre-receive hook declined) during installation of NPM dependencies (https://github.com/npm/npm/issues/3867). To work around this issue, it might suffice to augment the Linux swap file size to a maximum of twice the physical memory size. To resize the swap file of a 512 MB machine to 1 GB, follow these steps while in SSH within your machine: cd /var touch swap.img chmod 600 swap.img dd if = /dev/zero of = /var/swap.img bs = 1024k count = 1000 mkswap /var/swap.img swapon /var/swap.img free echo \"/var/swap.img none swap sw 0 0\" >> /etc/fstab Reference","title":"VMs with less than 1 GB of memory"},{"location":"getting-started/installation/","text":"Getting Started with Dokku What is Dokku? Dokku is an extensible, open source Platform as a Service that runs on a single server of your choice. To start using Dokku, you'll need a system that meets the following minimum requirements: A fresh installation of Ubuntu 16.04 x64 , Ubuntu 14.04 x64 , Debian 8.2 x64 or CentOS 7 x64 (experimental) with the FQDN set [1] At least 1 GB of system memory [2] You can optionally have a domain name pointed at the host's IP, though this is not necessary. Dokku is designed for usage on a fresh VM installation, and should install all necessary dependencies if installing via the bootstrap method. Installing the latest stable version 1. Install Dokku To install the latest stable version of Dokku, you can run the following shell commands: # for debian systems, installs Dokku via apt-get wget https://raw.githubusercontent.com/dokku/dokku/v0.14.6/bootstrap.sh ; sudo DOKKU_TAG = v0.14.6 bash bootstrap.sh The installation process takes about 5-10 minutes, depending upon internet connection speed. If you're using Debian 8 or Ubuntu 14.04, make sure your package manager is configured to install a sufficiently recent version of nginx [3] , otherwise, the installation may fail due to unmet dependencies relating nginx. 2. Setup SSH key and Virtualhost Settings Once the installation is complete, you can open a browser to setup your SSH key and virtualhost settings. Open your browser of choice and navigate to the host's IP address - or the domain you assigned to that IP previously - and configure Dokku via the web admin. Alternatively, instructions to skip the web installer with an unattended installation are available in the advanced install guide . Warning: If you don't complete setup via the web installer (even if you set up SSH keys and virtual hosts otherwise) your Dokku installation will remain vulnerable to anyone finding the setup page and inserting their key. You can check if it is still running via ps auxf | grep dokku-installer , and it may be stopped via your server's init system - usually either service dokku-installer stop or stop dokku-installer . Warning: Web installer is not available on CentOS and Arch Linux. You will need to configure SSH keys and virtual hosts using dokku command line interface - see unattended installation linked above. 3. Deploy your first application Once you save your settings, the web admin will self-terminate and you should be able to run or deploy to the Dokku installation . Installing via other methods For various reasons, certain hosting providers may have other steps that should be preferred to the above. If hosted on any of the following popular hosts, please follow the linked to instructions: DigitalOcean Installation Notes DreamHost Cloud Installation Notes Microsoft Azure Installation Notes As well, you may wish to customize your installation in some other fashion. or experiment with Vagrant. The guides below should get you started: Debian Package Installation Notes RPM Package Installation Notes Vagrant Installation Notes Advanced Install Customization [1]: To check whether your system has an fqdn set, run sudo hostname -f [2]: If your system has less than 1GB of memory, you can use this workaround . [3]: nginx >= 1.8.0 can be installed via the nginx repositories , or by adding this PPA if you're using Ubuntu. nginx >= 1.11.5 is necessary for HTTP/2 support","title":"Getting Started with Dokku"},{"location":"getting-started/installation/#getting-started-with-dokku","text":"","title":"Getting Started with Dokku"},{"location":"getting-started/installation/#what-is-dokku","text":"Dokku is an extensible, open source Platform as a Service that runs on a single server of your choice. To start using Dokku, you'll need a system that meets the following minimum requirements: A fresh installation of Ubuntu 16.04 x64 , Ubuntu 14.04 x64 , Debian 8.2 x64 or CentOS 7 x64 (experimental) with the FQDN set [1] At least 1 GB of system memory [2] You can optionally have a domain name pointed at the host's IP, though this is not necessary. Dokku is designed for usage on a fresh VM installation, and should install all necessary dependencies if installing via the bootstrap method.","title":"What is Dokku?"},{"location":"getting-started/installation/#installing-the-latest-stable-version","text":"","title":"Installing the latest stable version"},{"location":"getting-started/installation/#1-install-dokku","text":"To install the latest stable version of Dokku, you can run the following shell commands: # for debian systems, installs Dokku via apt-get wget https://raw.githubusercontent.com/dokku/dokku/v0.14.6/bootstrap.sh ; sudo DOKKU_TAG = v0.14.6 bash bootstrap.sh The installation process takes about 5-10 minutes, depending upon internet connection speed. If you're using Debian 8 or Ubuntu 14.04, make sure your package manager is configured to install a sufficiently recent version of nginx [3] , otherwise, the installation may fail due to unmet dependencies relating nginx.","title":"1. Install Dokku"},{"location":"getting-started/installation/#2-setup-ssh-key-and-virtualhost-settings","text":"Once the installation is complete, you can open a browser to setup your SSH key and virtualhost settings. Open your browser of choice and navigate to the host's IP address - or the domain you assigned to that IP previously - and configure Dokku via the web admin. Alternatively, instructions to skip the web installer with an unattended installation are available in the advanced install guide . Warning: If you don't complete setup via the web installer (even if you set up SSH keys and virtual hosts otherwise) your Dokku installation will remain vulnerable to anyone finding the setup page and inserting their key. You can check if it is still running via ps auxf | grep dokku-installer , and it may be stopped via your server's init system - usually either service dokku-installer stop or stop dokku-installer . Warning: Web installer is not available on CentOS and Arch Linux. You will need to configure SSH keys and virtual hosts using dokku command line interface - see unattended installation linked above.","title":"2. Setup SSH key and Virtualhost Settings"},{"location":"getting-started/installation/#3-deploy-your-first-application","text":"Once you save your settings, the web admin will self-terminate and you should be able to run or deploy to the Dokku installation .","title":"3. Deploy your first application"},{"location":"getting-started/installation/#installing-via-other-methods","text":"For various reasons, certain hosting providers may have other steps that should be preferred to the above. If hosted on any of the following popular hosts, please follow the linked to instructions: DigitalOcean Installation Notes DreamHost Cloud Installation Notes Microsoft Azure Installation Notes As well, you may wish to customize your installation in some other fashion. or experiment with Vagrant. The guides below should get you started: Debian Package Installation Notes RPM Package Installation Notes Vagrant Installation Notes Advanced Install Customization [1]: To check whether your system has an fqdn set, run sudo hostname -f [2]: If your system has less than 1GB of memory, you can use this workaround . [3]: nginx >= 1.8.0 can be installed via the nginx repositories , or by adding this PPA if you're using Ubuntu. nginx >= 1.11.5 is necessary for HTTP/2 support","title":"Installing via other methods"},{"location":"getting-started/troubleshooting/","text":"Troubleshooting Symptom: I deployed my app but I am getting the default nginx page. Solution: Most of the time it's caused by some defaults newer versions of nginx set. To make sure that's the issue you're having run the following: nginx -t ## nginx: [emerg] could not build the server_names_hash, you should increase server_names_hash_bucket_size: 32 If you get a similar error just edit /etc/nginx/nginx.conf and add the following line to your http section: http { (... existing content ...) server_names_hash_bucket_size 64 ; (...) } Note that the server_names_hash_bucket_size setting defines the maximum domain name length. A value of 64 would allow domains with up to 64 characters. Set it to 128 if you need longer ones. Save the file and try stopping nginx and starting it again: /etc/init.d/nginx stop ## * Stopping nginx nginx [ OK ] /etc/init.d/nginx start ## * Starting nginx nginx [ OK ] Symptom: I want to deploy my app, but while pushing I get the following error. ! [remote rejected] master -> master (pre-receive hook declined) Solution: The remote rejected error does not give enough information. Anything could have failed. To enable Dokku tracing, simply run the following command: # since 0.3.9 dokku trace on In versions older than 0.3.9, you can create a /home/dokku/dokkurc file containing the following: export DOKKU_TRACE = 1 This will trace all of Dokku's activity. If this does not help you, create a gist containing the full log, and create an issue. Symptom: I get the aforementioned error in the build phase (after turning on Dokku tracing). Most errors that happen in this phase are due to transient network issues (either locally or remotely) buildpack bugs. Solution (Less solution, more helpful troubleshooting steps): Find the failed phase's container image ( 077581956a92 in this example). docker ps -a | grep build ## 94d9515e6d93 077581956a92 \"/build\" 29 minutes ago Exited (0) 25 minutes ago cocky_bell Start a new container with the failed image and poke around (i.e. ensure you can access the internet from within the container or attempt the failed command, if known). docker run -ti 077581956a92 /bin/bash curl -s -S icanhazip.com ## 192.168.0.1 curl http://s3pository.heroku.com/node/v0.10.30/node-v0.10.30-linux-x64.tar.gz -o node-v0.10.30-linux-x64.tar.gz tar tzf node-v0.10.30-linux-x64.tar.gz ## ... Sometimes (especially on DigitalOcean) deploying again seems to get past these seemingly transient issues. Additionally we've seen issues if changing networks that have different DNS resolvers. In this case, you can run the following to update your resolv.conf . resolvconf -u Please see https://github.com/dokku/dokku/issues/841 and https://github.com/dokku/dokku/issues/649. Symptom: I want to deploy my app but I am getting asked for the password of the Git user and the error message. fatal: 'NAME' does not appear to be a git repository fatal: Could not read from remote repository. Solution: You get asked for a password because your SSH secret key can't be found. This may happen if the private key corresponding to the public key you added with sshcommand acl-add is not located in the default location ~/.ssh/id_rsa . You have to point SSH to the correct secret key for your domain name. Add the following to your ~/.ssh/config : Host DOKKU_HOSTNAME IdentityFile \"~/.ssh/KEYNAME\" Also see issue #116 . Symptom: I successfully deployed my application with no deployment errors and receiving Bad Gateway when attempting to access the application. Solution: In many cases the application will require the a process.env.PORT port opposed to a specified port. When specifying your port you may want to use something similar to: var port = process . env . PORT || 3000 Please see https://github.com/dokku/dokku/issues/282. Symptom: Deployment fails because of slow internet connection, messages shows gzip: stdin: unexpected end of file . Solution: If you see output similar this when deploying: Command: 'set -o pipefail; curl --fail --retry 3 --retry-delay 1 --connect-timeout 3 --max-time 30 https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/ruby-2.0.0-p451-default-cache.tgz -s -o - | tar zxf -' failed unexpectedly: ! ! gzip: stdin: unexpected end of file ! tar: Unexpected EOF in archive ! tar: Unexpected EOF in archive ! tar: Error is not recoverable: exiting now it might that the cURL command that is supposed to fetch the buildpack (anything in the low megabyte file size range) takes too long to finish, due to slowish connection. To overwrite the default values (connection timeout: 90 seconds, total maximum time for operation: 600 seconds), set the following environment variables: dokku config:set --global CURL_TIMEOUT = 1200 dokku config:set --global CURL_CONNECT_TIMEOUT = 180 Please see https://github.com/dokku/dokku/issues/509. Another reason for this error (although it may respond immediately ruling out a timeout issue) may be because you've set the config setting SSL_CERT_FILE . Using a config setting with this key interferes with the buildpack's ability to download its dependencies, so you must rename the config setting to something else, e.g. MY_APP_SSL_CERT_FILE . Symptom: Build fails with Killed message. Solution: This generally occurs when the server runs out of memory. You can either add more RAM to your server or setup swap space. The follow script will create 2 GB of swap space. sudo install -o root -g root -m 0600 /dev/null /swapfile dd if = /dev/zero of = /swapfile bs = 1k count = 2048k mkswap /swapfile swapon /swapfile echo \"/swapfile swap swap auto 0 0\" | sudo tee -a /etc/fstab sudo sysctl -w vm.swappiness = 10 echo vm.swappiness = 10 | sudo tee -a /etc/sysctl.conf Symptom: I successfully deployed my application with no deployment errors but I'm receiving Connection Timeout when attempting to access the application. Solution: This can occur if Dokku is running on a system with a firewall like UFW enabled (some OS versions like Ubuntu 16.04 have this enabled by default). You can check if this is your case by running the following script: sudo ufw status If the previous script returned Status: active and a list of ports, UFW is enabled and is probably the cause of the symptom described above. To disable it, run: sudo ufw disable Symptom: I can't connect to my application because the server is sending an invalid response, or can't provide a secure connection. Solution: This isn't usually an issue with Dokku, but rather an app config problem. This can happen when your application is configured to enforce secure connections/HSTS, but you don't have SSL set up for the app. In Rails at least, if your application.rb or environmnents/production.rb include the line configure.force_ssl = true which includes HSTS, try commenting that out and redeploying. If this solves the issue temporarily, longer term you should consider configuring SSL .","title":"Troubleshooting"},{"location":"getting-started/troubleshooting/#troubleshooting","text":"Symptom: I deployed my app but I am getting the default nginx page. Solution: Most of the time it's caused by some defaults newer versions of nginx set. To make sure that's the issue you're having run the following: nginx -t ## nginx: [emerg] could not build the server_names_hash, you should increase server_names_hash_bucket_size: 32 If you get a similar error just edit /etc/nginx/nginx.conf and add the following line to your http section: http { (... existing content ...) server_names_hash_bucket_size 64 ; (...) } Note that the server_names_hash_bucket_size setting defines the maximum domain name length. A value of 64 would allow domains with up to 64 characters. Set it to 128 if you need longer ones. Save the file and try stopping nginx and starting it again: /etc/init.d/nginx stop ## * Stopping nginx nginx [ OK ] /etc/init.d/nginx start ## * Starting nginx nginx [ OK ] Symptom: I want to deploy my app, but while pushing I get the following error. ! [remote rejected] master -> master (pre-receive hook declined) Solution: The remote rejected error does not give enough information. Anything could have failed. To enable Dokku tracing, simply run the following command: # since 0.3.9 dokku trace on In versions older than 0.3.9, you can create a /home/dokku/dokkurc file containing the following: export DOKKU_TRACE = 1 This will trace all of Dokku's activity. If this does not help you, create a gist containing the full log, and create an issue. Symptom: I get the aforementioned error in the build phase (after turning on Dokku tracing). Most errors that happen in this phase are due to transient network issues (either locally or remotely) buildpack bugs. Solution (Less solution, more helpful troubleshooting steps): Find the failed phase's container image ( 077581956a92 in this example). docker ps -a | grep build ## 94d9515e6d93 077581956a92 \"/build\" 29 minutes ago Exited (0) 25 minutes ago cocky_bell Start a new container with the failed image and poke around (i.e. ensure you can access the internet from within the container or attempt the failed command, if known). docker run -ti 077581956a92 /bin/bash curl -s -S icanhazip.com ## 192.168.0.1 curl http://s3pository.heroku.com/node/v0.10.30/node-v0.10.30-linux-x64.tar.gz -o node-v0.10.30-linux-x64.tar.gz tar tzf node-v0.10.30-linux-x64.tar.gz ## ... Sometimes (especially on DigitalOcean) deploying again seems to get past these seemingly transient issues. Additionally we've seen issues if changing networks that have different DNS resolvers. In this case, you can run the following to update your resolv.conf . resolvconf -u Please see https://github.com/dokku/dokku/issues/841 and https://github.com/dokku/dokku/issues/649. Symptom: I want to deploy my app but I am getting asked for the password of the Git user and the error message. fatal: 'NAME' does not appear to be a git repository fatal: Could not read from remote repository. Solution: You get asked for a password because your SSH secret key can't be found. This may happen if the private key corresponding to the public key you added with sshcommand acl-add is not located in the default location ~/.ssh/id_rsa . You have to point SSH to the correct secret key for your domain name. Add the following to your ~/.ssh/config : Host DOKKU_HOSTNAME IdentityFile \"~/.ssh/KEYNAME\" Also see issue #116 . Symptom: I successfully deployed my application with no deployment errors and receiving Bad Gateway when attempting to access the application. Solution: In many cases the application will require the a process.env.PORT port opposed to a specified port. When specifying your port you may want to use something similar to: var port = process . env . PORT || 3000 Please see https://github.com/dokku/dokku/issues/282. Symptom: Deployment fails because of slow internet connection, messages shows gzip: stdin: unexpected end of file . Solution: If you see output similar this when deploying: Command: 'set -o pipefail; curl --fail --retry 3 --retry-delay 1 --connect-timeout 3 --max-time 30 https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/ruby-2.0.0-p451-default-cache.tgz -s -o - | tar zxf -' failed unexpectedly: ! ! gzip: stdin: unexpected end of file ! tar: Unexpected EOF in archive ! tar: Unexpected EOF in archive ! tar: Error is not recoverable: exiting now it might that the cURL command that is supposed to fetch the buildpack (anything in the low megabyte file size range) takes too long to finish, due to slowish connection. To overwrite the default values (connection timeout: 90 seconds, total maximum time for operation: 600 seconds), set the following environment variables: dokku config:set --global CURL_TIMEOUT = 1200 dokku config:set --global CURL_CONNECT_TIMEOUT = 180 Please see https://github.com/dokku/dokku/issues/509. Another reason for this error (although it may respond immediately ruling out a timeout issue) may be because you've set the config setting SSL_CERT_FILE . Using a config setting with this key interferes with the buildpack's ability to download its dependencies, so you must rename the config setting to something else, e.g. MY_APP_SSL_CERT_FILE . Symptom: Build fails with Killed message. Solution: This generally occurs when the server runs out of memory. You can either add more RAM to your server or setup swap space. The follow script will create 2 GB of swap space. sudo install -o root -g root -m 0600 /dev/null /swapfile dd if = /dev/zero of = /swapfile bs = 1k count = 2048k mkswap /swapfile swapon /swapfile echo \"/swapfile swap swap auto 0 0\" | sudo tee -a /etc/fstab sudo sysctl -w vm.swappiness = 10 echo vm.swappiness = 10 | sudo tee -a /etc/sysctl.conf Symptom: I successfully deployed my application with no deployment errors but I'm receiving Connection Timeout when attempting to access the application. Solution: This can occur if Dokku is running on a system with a firewall like UFW enabled (some OS versions like Ubuntu 16.04 have this enabled by default). You can check if this is your case by running the following script: sudo ufw status If the previous script returned Status: active and a list of ports, UFW is enabled and is probably the cause of the symptom described above. To disable it, run: sudo ufw disable Symptom: I can't connect to my application because the server is sending an invalid response, or can't provide a secure connection. Solution: This isn't usually an issue with Dokku, but rather an app config problem. This can happen when your application is configured to enforce secure connections/HSTS, but you don't have SSL set up for the app. In Rails at least, if your application.rb or environmnents/production.rb include the line configure.force_ssl = true which includes HSTS, try commenting that out and redeploying. If this solves the issue temporarily, longer term you should consider configuring SSL .","title":"Troubleshooting"},{"location":"getting-started/uninstalling/","text":"Uninstalling While we hate to see you go, if you need to uninstall Dokku, the following may help you out: Arch Installation # purge dokku from your system yaourt -Rsn dokku CentOS Installation # uninstall dokku yum remove dokku herokuish Debian Installation # purge dokku from your system apt-get purge -y --force-yes dokku herokuish # remove any dependencies that are no longer necessary apt-get -y --force-yes autoremove Makefile Installation This is a manual deletion process, and as it is not a recommended installation method, there is currently no automated uninstallation. All service plugins should be unlinked from applications, stopped, and destroyed. All applications should be stopped, and all docker containers and images deleted: # stop all applications dokku ps:stopall # cleanup containers and images dokku cleanup The following user/group must be deleted: user: dokku group: dokku The following directories must be deleted: ~dokku /var/lib/dokku /var/log/dokku","title":"Uninstalling"},{"location":"getting-started/uninstalling/#uninstalling","text":"While we hate to see you go, if you need to uninstall Dokku, the following may help you out:","title":"Uninstalling"},{"location":"getting-started/uninstalling/#arch-installation","text":"# purge dokku from your system yaourt -Rsn dokku","title":"Arch Installation"},{"location":"getting-started/uninstalling/#centos-installation","text":"# uninstall dokku yum remove dokku herokuish","title":"CentOS Installation"},{"location":"getting-started/uninstalling/#debian-installation","text":"# purge dokku from your system apt-get purge -y --force-yes dokku herokuish # remove any dependencies that are no longer necessary apt-get -y --force-yes autoremove","title":"Debian Installation"},{"location":"getting-started/uninstalling/#makefile-installation","text":"This is a manual deletion process, and as it is not a recommended installation method, there is currently no automated uninstallation. All service plugins should be unlinked from applications, stopped, and destroyed. All applications should be stopped, and all docker containers and images deleted: # stop all applications dokku ps:stopall # cleanup containers and images dokku cleanup The following user/group must be deleted: user: dokku group: dokku The following directories must be deleted: ~dokku /var/lib/dokku /var/log/dokku","title":"Makefile Installation"},{"location":"getting-started/upgrading/","text":"Upgrading If your version of Dokku is pre 0.3.0 (check with dokku version ), we recommend a fresh install on a new server. Security Updates For any security related updates, please follow our Twitter account . As Dokku does not run any daemons, the security risk introduced by our software is minimal. Your operating system may occasionally provide security updates. We recommend setting unattended upgrades for your operating system. Here are some helpful links: Arch Linux System Maintenance Centos Automatic Security Updates Debian Unattended Upgrades Ubuntu Unattended Upgrades Docker releases updates periodically to their engine. We recommend reading their release notes and upgrading accordingly. Please see the Docker documentation for more details. Finally, we provide a helpful binary called dokku-update . This is a recommended package that: Can be installed separately, so upgrading Dokku will not affect the running of this package. Automates many of the upgrade instructions for you. Provides a clean way for us to further enhance the upgrade process in the future. When installing from source, this is available from contrib/dokku-update , and is also available on Debian and RPM-based systems from our package repositories under the name dokku-update . Migration Guides Before upgrading, check the migration guides to get comfortable with new features and prepare your deployment to be upgraded. 0.5 Migration Guide 0.5 Migration Guide 0.6 Migration Guide 0.6 Migration Guide 0.7 Migration Guide 0.7 Migration Guide 0.8 Migration Guide 0.8 Migration Guide 0.9 Migration Guide 0.9 Migration Guide 0.10 Migration Guide 0.10 Migration Guide Upgrade Instructions If Dokku was installed via apt-get install dokku or bootstrap.sh (most common), upgrade with: # update your local apt cache sudo apt-get update # stop each running app # for 0.11.4 and newer versions, use dokku ps:stopall # for versions between 0.8.1 and 0.11.3, use dokku --quiet apps:list | xargs -L1 dokku ps:stop # for versions versions older than 0.8.1, use dokku --quiet apps | xargs -L1 dokku ps:stop # update dokku and its dependencies sudo apt-get install -qq -y dokku herokuish sshcommand plugn # rebuild all of your applications dokku ps:rebuildall # rebuilds all applications If you have any applications deployed via the tags or tar commands, do not run the ps:rebuildall command, and instead trigger ps:rebuild manually for each git -deployed application: dokku ps:rebuild APP Please see the images documentation and tar documentation for instructions on rebuilding applications deployed by those plugins. Upgrade From Source If you installed Dokku from source (less common), upgrade with: dokku --quiet apps | xargs -L1 dokku ps:stop # stops each running app cd ~/dokku git pull --tags origin master # continue to install from source sudo DOKKU_BRANCH = master make install # upgrade to debian package-based installation sudo make install dokku ps:rebuildall # rebuilds all applications To upgrade Herokuish from source, upgrade with: cd /tmp git clone https://github.com/gliderlabs/herokuish.git cd herokuish git pull origin master IMAGE_NAME = gliderlabs/herokuish BUILD_TAG = latest VERSION = master make -e build-in-docker","title":"Upgrading"},{"location":"getting-started/upgrading/#upgrading","text":"If your version of Dokku is pre 0.3.0 (check with dokku version ), we recommend a fresh install on a new server.","title":"Upgrading"},{"location":"getting-started/upgrading/#security-updates","text":"For any security related updates, please follow our Twitter account . As Dokku does not run any daemons, the security risk introduced by our software is minimal. Your operating system may occasionally provide security updates. We recommend setting unattended upgrades for your operating system. Here are some helpful links: Arch Linux System Maintenance Centos Automatic Security Updates Debian Unattended Upgrades Ubuntu Unattended Upgrades Docker releases updates periodically to their engine. We recommend reading their release notes and upgrading accordingly. Please see the Docker documentation for more details. Finally, we provide a helpful binary called dokku-update . This is a recommended package that: Can be installed separately, so upgrading Dokku will not affect the running of this package. Automates many of the upgrade instructions for you. Provides a clean way for us to further enhance the upgrade process in the future. When installing from source, this is available from contrib/dokku-update , and is also available on Debian and RPM-based systems from our package repositories under the name dokku-update .","title":"Security Updates"},{"location":"getting-started/upgrading/#migration-guides","text":"Before upgrading, check the migration guides to get comfortable with new features and prepare your deployment to be upgraded.","title":"Migration Guides"},{"location":"getting-started/upgrading/#05-migration-guide","text":"0.5 Migration Guide","title":"0.5 Migration Guide"},{"location":"getting-started/upgrading/#06-migration-guide","text":"0.6 Migration Guide","title":"0.6 Migration Guide"},{"location":"getting-started/upgrading/#07-migration-guide","text":"0.7 Migration Guide","title":"0.7 Migration Guide"},{"location":"getting-started/upgrading/#08-migration-guide","text":"0.8 Migration Guide","title":"0.8 Migration Guide"},{"location":"getting-started/upgrading/#09-migration-guide","text":"0.9 Migration Guide","title":"0.9 Migration Guide"},{"location":"getting-started/upgrading/#010-migration-guide","text":"0.10 Migration Guide","title":"0.10 Migration Guide"},{"location":"getting-started/upgrading/#upgrade-instructions","text":"If Dokku was installed via apt-get install dokku or bootstrap.sh (most common), upgrade with: # update your local apt cache sudo apt-get update # stop each running app # for 0.11.4 and newer versions, use dokku ps:stopall # for versions between 0.8.1 and 0.11.3, use dokku --quiet apps:list | xargs -L1 dokku ps:stop # for versions versions older than 0.8.1, use dokku --quiet apps | xargs -L1 dokku ps:stop # update dokku and its dependencies sudo apt-get install -qq -y dokku herokuish sshcommand plugn # rebuild all of your applications dokku ps:rebuildall # rebuilds all applications If you have any applications deployed via the tags or tar commands, do not run the ps:rebuildall command, and instead trigger ps:rebuild manually for each git -deployed application: dokku ps:rebuild APP Please see the images documentation and tar documentation for instructions on rebuilding applications deployed by those plugins.","title":"Upgrade Instructions"},{"location":"getting-started/upgrading/#upgrade-from-source","text":"If you installed Dokku from source (less common), upgrade with: dokku --quiet apps | xargs -L1 dokku ps:stop # stops each running app cd ~/dokku git pull --tags origin master # continue to install from source sudo DOKKU_BRANCH = master make install # upgrade to debian package-based installation sudo make install dokku ps:rebuildall # rebuilds all applications To upgrade Herokuish from source, upgrade with: cd /tmp git clone https://github.com/gliderlabs/herokuish.git cd herokuish git pull origin master IMAGE_NAME = gliderlabs/herokuish BUILD_TAG = latest VERSION = master make -e build-in-docker","title":"Upgrade From Source"},{"location":"getting-started/where-to-get-help/","text":"Where to Get Help If you\u2019re stuck, there are a number of places you can get help: The Official Dokku Website http://dokku.viewdocs.io/dokku/ The Official Dokku website is always a great place to visit. It features links to oft-used developer tools, community plugins, and guides on using Dokku. The IRC and Slack Channels irc.freenode.net/#dokku Gliderlabs Slack If you\u2019re stumped, give us a holler in the Dokku IRC or Slack channels. Someone from the development team is usually there, especially during the daylight hours for North and South America users. We\u2019d love to hear from you, whether you need some help, want to find users in your area, or would like to donate your brand new sports car. Stack Overflow https://stackoverflow.com/questions/tagged/dokku Tag your questions with dokku to enable existing users of Stack Overflow to find your questions.","title":"Where to Get Help"},{"location":"getting-started/where-to-get-help/#where-to-get-help","text":"If you\u2019re stuck, there are a number of places you can get help:","title":"Where to Get Help"},{"location":"getting-started/where-to-get-help/#the-official-dokku-website","text":"http://dokku.viewdocs.io/dokku/ The Official Dokku website is always a great place to visit. It features links to oft-used developer tools, community plugins, and guides on using Dokku.","title":"The Official Dokku Website"},{"location":"getting-started/where-to-get-help/#the-irc-and-slack-channels","text":"irc.freenode.net/#dokku Gliderlabs Slack If you\u2019re stumped, give us a holler in the Dokku IRC or Slack channels. Someone from the development team is usually there, especially during the daylight hours for North and South America users. We\u2019d love to hear from you, whether you need some help, want to find users in your area, or would like to donate your brand new sports car.","title":"The IRC and Slack Channels"},{"location":"getting-started/where-to-get-help/#stack-overflow","text":"https://stackoverflow.com/questions/tagged/dokku Tag your questions with dokku to enable existing users of Stack Overflow to find your questions.","title":"Stack Overflow"},{"location":"getting-started/install/azure/","text":"Microsoft Azure If you don't already have one generate an SSH key pair . Go to the Dokku on Azure deployment page and click Deploy to Azure . You'll be prompted to enter a few parameters, including a unique storage account name and a unique name for the subdomain used for your public IP address. For the sshKeyData parameter, copy and paste the contents of the public key file you just created. After a few minutes the Dokku instance will be deployed. In your browser of choice, navigate to http://[dnsNameForPublicIP].[location].cloudapp.azure.com . Where [dnsNameForPublicIP] and [location] are template parameters you used to deploy the template. Finish your Dokku setup like you normally would by creating a new public/private key pair for your deployments using ssh-keygen (don't use the same one as you created in the first step). You should select Use Virtual Host Naming and set the Hostname to a public DNS name that you own such as one you would purchase from Namecheap . Alternatively thanks to xip.io you can just use [yourAzurePublicIP].xip.io for free. For example, if your public IP is 44.44.44.44 then you would set it to 44.44.44.44.xip.io .","title":"Microsoft Azure"},{"location":"getting-started/install/azure/#microsoft-azure","text":"If you don't already have one generate an SSH key pair . Go to the Dokku on Azure deployment page and click Deploy to Azure . You'll be prompted to enter a few parameters, including a unique storage account name and a unique name for the subdomain used for your public IP address. For the sshKeyData parameter, copy and paste the contents of the public key file you just created. After a few minutes the Dokku instance will be deployed. In your browser of choice, navigate to http://[dnsNameForPublicIP].[location].cloudapp.azure.com . Where [dnsNameForPublicIP] and [location] are template parameters you used to deploy the template. Finish your Dokku setup like you normally would by creating a new public/private key pair for your deployments using ssh-keygen (don't use the same one as you created in the first step). You should select Use Virtual Host Naming and set the Hostname to a public DNS name that you own such as one you would purchase from Namecheap . Alternatively thanks to xip.io you can just use [yourAzurePublicIP].xip.io for free. For example, if your public IP is 44.44.44.44 then you would set it to 44.44.44.44.xip.io .","title":"Microsoft Azure"},{"location":"getting-started/install/debian/","text":"Debian Package Installation Notes As of 0.3.18, Dokku defaults to being installed via Debian package. While certain hosts may require extra work to get running, you may optionally wish to automate the installation of Dokku without the use of our bootstrap.sh Bash script. The following are the steps run by said script: # install prerequisites sudo apt-get update -qq >/dev/null sudo apt-get install -qq -y apt-transport-https # install docker wget -nv -O - https://get.docker.com/ | sh # install dokku wget -nv -O - https://packagecloud.io/dokku/dokku/gpgkey | apt-key add - OS_ID = \" $( lsb_release -cs 2 >/dev/null || echo \"trusty\" ) \" echo \"trusty utopic vivid wily xenial yakkety zesty artful bionic\" | grep -q \" $OS_ID \" || OS_ID = \"trusty\" echo \"deb https://packagecloud.io/dokku/dokku/ubuntu/ ${ OS_ID } main\" | sudo tee /etc/apt/sources.list.d/dokku.list sudo apt-get update -qq >/dev/null sudo apt-get install -qq -y dokku sudo dokku plugin:install-dependencies --core Unattended installation In case you want to perform an unattended installation of Dokku, this is made possible through debconf , which allows you to configure a package before installing it. You can set any of the below options through the debconf-set-selections command, for example to enable vhost-based deployments: echo \"dokku dokku/vhost_enable boolean true\" | sudo debconf-set-selections After setting the desired options, proceed with the installation as described above. debconf options Name Type Default Description dokku/web_config boolean true Use web-based config for below options dokku/vhost_enable boolean false Use vhost-based deployments (e.g. [yourapp].dokku.me ) dokku/hostname string dokku.me Hostname, used as vhost domain and for showing app URL after deploy dokku/skip_key_file boolean false Don't check for the existence of the dokku/key_file. Warning: Setting this to true, will require you to manually add an SSH key later on. dokku/key_file string /root/.ssh/id_rsa.pub Path on disk to an SSH key to add to the Dokku user (Will be ignored on dpkg-reconfigure ) dokku/nginx_enable boolean true Enable nginx-vhosts plugin","title":"Debian Package Installation Notes"},{"location":"getting-started/install/debian/#debian-package-installation-notes","text":"As of 0.3.18, Dokku defaults to being installed via Debian package. While certain hosts may require extra work to get running, you may optionally wish to automate the installation of Dokku without the use of our bootstrap.sh Bash script. The following are the steps run by said script: # install prerequisites sudo apt-get update -qq >/dev/null sudo apt-get install -qq -y apt-transport-https # install docker wget -nv -O - https://get.docker.com/ | sh # install dokku wget -nv -O - https://packagecloud.io/dokku/dokku/gpgkey | apt-key add - OS_ID = \" $( lsb_release -cs 2 >/dev/null || echo \"trusty\" ) \" echo \"trusty utopic vivid wily xenial yakkety zesty artful bionic\" | grep -q \" $OS_ID \" || OS_ID = \"trusty\" echo \"deb https://packagecloud.io/dokku/dokku/ubuntu/ ${ OS_ID } main\" | sudo tee /etc/apt/sources.list.d/dokku.list sudo apt-get update -qq >/dev/null sudo apt-get install -qq -y dokku sudo dokku plugin:install-dependencies --core","title":"Debian Package Installation Notes"},{"location":"getting-started/install/debian/#unattended-installation","text":"In case you want to perform an unattended installation of Dokku, this is made possible through debconf , which allows you to configure a package before installing it. You can set any of the below options through the debconf-set-selections command, for example to enable vhost-based deployments: echo \"dokku dokku/vhost_enable boolean true\" | sudo debconf-set-selections After setting the desired options, proceed with the installation as described above.","title":"Unattended installation"},{"location":"getting-started/install/debian/#debconf-options","text":"Name Type Default Description dokku/web_config boolean true Use web-based config for below options dokku/vhost_enable boolean false Use vhost-based deployments (e.g. [yourapp].dokku.me ) dokku/hostname string dokku.me Hostname, used as vhost domain and for showing app URL after deploy dokku/skip_key_file boolean false Don't check for the existence of the dokku/key_file. Warning: Setting this to true, will require you to manually add an SSH key later on. dokku/key_file string /root/.ssh/id_rsa.pub Path on disk to an SSH key to add to the Dokku user (Will be ignored on dpkg-reconfigure ) dokku/nginx_enable boolean true Enable nginx-vhosts plugin","title":"debconf options"},{"location":"getting-started/install/digitalocean/","text":"DigitalOcean Droplet DigitalOcean offers a pre-installed Dokku image. You can run this image on any sized Droplet, although larger Droplets will allow you to run larger applications. Please disable IPv6 . There are known issues with IPv6 on DigitalOcean and Docker. If you would like to run Dokku on an IPv6 DigitalOcean Droplet, please consult this guide . Login to your DigitalOcean account. Click Create a Droplet . Under Choose an image > One-click apps , choose the latest Dokku release for 16.04 (version numbers may vary) . Under Choose a size , select your machine spec. Under Choose a datacenter region , select your region. Add an SSH Key. New Keys Under Add your SSH keys click New SSH Key (this opens a dialog) . From your terminal, execute cat $HOME/.ssh/id_rsa.pub . Copy the output and paste it into the New SSH Key dialog, provide a name and click Add SSH Key . Existing Keys Simply add a checkmark next to the existing keys you'd like to add. Under Finalize and create , give your Droplet a hostname (not required) and click Create . Once created, copy the IP address to your clipboard. In a browser, go to the IP address you copied above and fill out the presented form to complete configuration. Failure to do so may allow others to reconfigure SSH access on your server. Once the web UI has been submitted, you will be redirected to our application deployment tutorial , which will guide you through deploying a sample application to your Dokku server.","title":"DigitalOcean Droplet"},{"location":"getting-started/install/digitalocean/#digitalocean-droplet","text":"DigitalOcean offers a pre-installed Dokku image. You can run this image on any sized Droplet, although larger Droplets will allow you to run larger applications. Please disable IPv6 . There are known issues with IPv6 on DigitalOcean and Docker. If you would like to run Dokku on an IPv6 DigitalOcean Droplet, please consult this guide . Login to your DigitalOcean account. Click Create a Droplet . Under Choose an image > One-click apps , choose the latest Dokku release for 16.04 (version numbers may vary) . Under Choose a size , select your machine spec. Under Choose a datacenter region , select your region. Add an SSH Key. New Keys Under Add your SSH keys click New SSH Key (this opens a dialog) . From your terminal, execute cat $HOME/.ssh/id_rsa.pub . Copy the output and paste it into the New SSH Key dialog, provide a name and click Add SSH Key . Existing Keys Simply add a checkmark next to the existing keys you'd like to add. Under Finalize and create , give your Droplet a hostname (not required) and click Create . Once created, copy the IP address to your clipboard. In a browser, go to the IP address you copied above and fill out the presented form to complete configuration. Failure to do so may allow others to reconfigure SSH access on your server. Once the web UI has been submitted, you will be redirected to our application deployment tutorial , which will guide you through deploying a sample application to your Dokku server.","title":"DigitalOcean Droplet"},{"location":"getting-started/install/dreamhost/","text":"Install Dokku on DreamHost Cloud Server with cloud-init Cloud-init script can be used to automate installation of Dokku on Dreamhost (or any other OpenStack-compatible cloud with minimal changes). A new server instance can be created on DreamHost Cloud from the command line using OpenStack client or from the web UI and with the same command use a cloud-init script to install Dokku. Install the OpenStack CLI , download the DreamHost Cloud credentials file before proceeding and make sure your public SSH key is added to the cloud. source openrc.sh # Set the environment variables for DreamHost Cloud This allows OpenStack client to connect to DreamHost API endpoints. The command below creates a new server instance named my-dokku-instance based on Ubuntu 14.04, with 2 GB RAM and 1 CPU (the flavor called supersonic ), opening network port access to HTTP and SSH (the default security group), and the name of the chosen SSH key. This key will be automatically added to the new server in the authorized_keys for the default SSH user ( ubuntu ), and it will be reused by Dokku. openstack server create \\ --image Ubuntu-14.04 \\ --flavor gp1.supersonic \\ --security-group default \\ --key-name $YOUR_SSH_KEYNAME \\ --user-data dokku-cloudinit.sh \\ my-dokku-instance The content of dokku-cloudinit.sh script contains instructions to add Docker and Dokku's apt repositories and install Dokku with the proper debconf options set. Don't forget to add the FQDN for your application server: #cloud-config apt_upgrade : true apt_sources : - source : \"deb https://packagecloud.io/dokku/dokku/ubuntu/ trusty main\" key : | -----BEGIN PGP PUBLIC KEY BLOCK----- Version: SKS 1.1.5 Comment: Hostname: pgpkeys.eu mQINBFLUbogBEADceEoxBDoE6QM5xV/13qiELbFIkQgy/eEi3UesXmJblFdU7wcDLOW3NuOI x/dgbZljeMEerj6N1cR7r7X5sVoFVEZiK4RLkC3Cpdns0d90ud2f3VyKK7PXRBstdLm3JlW9 OWZoe4VSADSMGWm1mIhT601qLKKAuWJoBIhnKY/RhA/RBXt7z22g4ta9bT67PlliTo1a8y6D hUA7gd+5TsVHaxDRrzc3mKObdyS5LOT/gf8Ti2tYBY5MBbQ8NUGExls4dXKlieePhKutFbde 7sq3n5sdp1Ndoran1u0LsWnaSDx11R3xiYfXJ6xGukAc6pYlUD1yYjU4oRGhD2fPyuewqhHN UVwqupTBQtEGULrtdwK04kgIH93ssGRsLqUKe88uZeeBczVuupv8ZLd1YcQ29AfJHe6nsevs gjF+eajYlzsvC8BNq3nOvvedcuI6BW4WWFjraH06GNTyMAZi0HibTg65guZXpLcpPW9hTzXM oUrZz8MvJ9yUBcFPKuFOLDpRP6uaIbxJsYqiituoltl0vgS/vJcpIVVRwSaqPHa6S63dmKm2 6gq18v4l05mVcInPn+ciHtcSlZgQkCsRTSvfUrK+7nzyWtNQMGKstAZ7AHCoA8Pbc3i7wyOt nTgfPFHVpHg3JHsPXKk9/71YogtoNFoETMFeKL1K+O+GMQddYQARAQABtDdwYWNrYWdlY2xv dWQgb3BzIChwcm9kdWN0aW9uIGtleSkgPG9wc0BwYWNrYWdlY2xvdWQuaW8+iQI+BBMBAgAo BQJS1G6IAhsvBQkJZgGABgsJCAcDAgYVCAIJCgsEFgIDAQIeAQIXgAAKCRDC5zQk1ZCXq13K D/wNzAi6rEzRyx6NH61Hc19s2QAgcU1p1mX1Tw0fU7CThx1nr8JrG63465c9dzUpVzNTYvMs USBJwbb1phahCMNGbJpZRQ5bvW/i3azmk/EHKL7wgMV8wu1atu6crrxGoDEfWUa4aIwbxZGk oxDZKZeKaLxz2ZChuKzjvkGUk4PUoOxxPn9XeFmJQ68ys4Z0CgIGfx2i64apqfsjVEdWEEBL oxHFIPy7FgFafRL0bgsquwPkb5q/dihIzJEZ2EMOGwXuUaKI/UAhgRIUGizuW7ECEjX4FG92 8RsizHBjYL5Gl7DMt1KcPFe/YU/AdWEirs9pLQUr9eyGZN7HYJ03Aiy8R5aMBoeYsfxjifkb WCpbN+SEATaB8YY6Zy2LK/5TiUYNUYb/VHP//ZEv0+uPgkoro6gWVkvGDdXqH2d9svwfrQKf GSEQYXlLytZKvQSDLAqclSANs/y5HDjUxgtWKdsL3xNPCmffjpyiqS4pvoTiUwS4FwBsIR2s BDToIEHDvTNk1imeSmxCUgDxFzWkmB70FBmwz7zs9FzuoegrAxXonVit0+f3CxquN7tS0mHa WrZfhHxEIt65edkIz1wETOch3LIg6RaFwsXgrZCNTB/zjKGAFEzxOSBkjhyJCY2g74QNObKg TSeGNFqG0ZBHe2/JQ33UxrDtpeKvCYTbjuWlyrkCDQRS1G6IARAArtNBXq+CNU9DR2YCi759 fLR9F62Ec/QLWY3c/D26OqjTgjxAzGKbu1aLzphP8tq1GDCbWQ2BMMZI+L0Ed502u6kC0fzv bppRRXrVaxBrwxY9XhnzvkXXzwNwnBalkrJ5Yk0lN8ocwCuUJohms7V14nEDyHgAB8yqCEWz Qm/SIZw35N/insTXshcdiUGeyufo85SFhCUqZ1x1TkSC/FyDG+BCwArfj8Qwdab3UlUEkF6c zTjwWIO+5vYuR8bsCGYKCSrGRh5nxw0tuGXWXWFlBMSZP6mFcCDRQDGcKOuGTjiWzLJcgsEc BoIX4WpHJYgl6ovex7HkfQsWPYL5V1FIHMlw34ALx4aQDH0dPJpC+FxynrfTfsIzPnmm2huX PGGYul/TmOp00CsJEcKOjqcrYOgraYkCGVXbd4ri6Pf7wJNiJ8V1iKTzQIrNpqGDk306Fww1 VsYBLOnrSxNPYOOu1s8c8c9N5qbEbOCtQdFf5pfuqsr5nJ0G4mhjQ/eLtDA4E7GPrdtUoceO kYKcQFt/yqnL1Sj9Ojeht3ENPyVSgE8NiWxNIEM0YxPyJEPQawejT66JUnTjzLfGaDUxHfse RcyMMTbTrZ0fLJSRaIH1AubPxhiYy+IcWOVMyLiUwjBBpKMStej2XILEpIJXP6Pn96KjMcB1 grd0J2vMw2Kg3E8AEQEAAYkERAQYAQIADwUCUtRuiAIbLgUJCWYBgAIpCRDC5zQk1ZCXq8Fd IAQZAQIABgUCUtRuiAAKCRA3u+4/etlbPwI5D/4idr7VHQpou6c/YLnK1lmz3hEikdxUxjC4 ymOyeODsGRlaxXfjvjOCdocMzuCY3C+ZfNFKOTtVY4fV5Pd82MuY1H8lnuzqLxT6UwpIwo+y Ev6xSK0mqm2FhT0JSQ7E7MnoHqsU0aikHegyEucGIFzew6BJUD2xBu/qmVP/YEPUzhW4g8uD +oRMxdAHXqvtThvFySY/rakLQRMRVwYdTFHrvu3zHP+6hpZt25llJb3DiO+dTsv+ptLmlUr5 JXLSSw2DfLxQa0kD5PGWpFPVJcxraS2pNDK9KTi2nr1ZqDxeKjDBT6zZOs9+4JQ9fepn1S26 AmHWHhyzvpjKxVm4sOilKysi84CYluNrlEnidNf9wQa3NlLmtvxXQfm1py5tlwL5rE+ek1fw leaKXRcNNmm+T+vDdIw+JcHy8a53nK1JEfBqEuY6IqEPKDke0wDIsDLSwI1OgtQoe7Cm1PBu jfJu4rYQE+wwgWILTAgIy8WZXAloTcwVMtgfSsgHia++LqKfLDZ3JuwpaUAHAtguPy0QddvF I4R7eFDVwHT0sS3AsG0HAOCY/1FRe8cAw/+9Vp0oDtOvBWAXycnCbdQeHvwh2+Uj2u2f7K3C DMoevcBl4L5fkFkYTkmixCDy5nst1VM5nINueUIkUAJJbOGpd6yFdif7mQR0JWcPLudb+fwu sJ4UEACYWhPa8Gxa7eYopRsydlcdEzwpmo6E+V8GIdLFRFFpKHQEzbSW5coxzU6oOiPbTurC ZorIMHTA9cpAZoMUGKaSt19UKIMvSqtcDayhgf4cZ2ay1z0fdJ2PuLeNnWeiGyfq78q6wqSa Jq/h6JdAiwXplFd3gqJZTrFZz7A6Q6Pd7B+9PZ/DUdEO3JeZlHJDfRmfU2XPoyPUoq79+whP 5Tl3WwHUv7Fg357kRSdzKv9DbgmhqRHlgVeKn9pwN4cpVBN+idzwPefQksSKH4lBDvVr/9j+ V9mmrOx7QmQ5LCc/1on+L0dqo6suoajADhKy+lDQbzs2mVb4CLpPKncDup/9iJbjiR17DDFM wgyCoy5OHJICQ5lckNNgkHTS6Xiogkt28YfK4P3S0GaZgIrhKQ7AmO3O+hB12Zr+olpeyhGB OpBD80URntdEcenvfnXBY/BsuAVbTGXiBzrlBEyQxg656jUeqAdXg+nzCvP0yJlBUOjEcwyh K/U2nw9nGyaR3u0a9r24LgijGpdGabIeJm6O9vuuqFHHGI72pWUEs355lt8q1pAoJUv8NehQ mlaR0h5wcwhEtwM6fiSIUTnuJnyHT053GjsUD7ef5fY1KEFmaZeW04kRtFDOPinz0faE8hvs xzsVgkKye1c2vkXKdOXvA3x+pZzlTHtcgMOhjKQAsA== =H60S -----END PGP PUBLIC KEY BLOCK----- filename : dokku.list - source : \"deb https://apt.dockerproject.org/repo ubuntu-trusty main\" key : | -----BEGIN PGP PUBLIC KEY BLOCK----- Version: SKS 1.1.5 Comment: Hostname: pgpkeys.co.uk mQINBFWln24BEADrBl5p99uKh8+rpvqJ48u4eTtjeXAWbslJotmC/CakbNSqOb9oddfzRvGV eJVERt/Q/mlvEqgnyTQy+e6oEYN2Y2kqXceUhXagThnqCoxcEJ3+KM4RmYdoe/BJ/J/6rHOj q7Omk24z2qB3RU1uAv57iY5VGw5p45uZB4C4pNNsBJXoCvPnTGAs/7IrekFZDDgVraPx/hdi wopQ8NltSfZCyu/jPpWFK28TR8yfVlzYFwibj5WKdHM7ZTqlA1tHIG+agyPf3Rae0jPMsHR6 q+arXVwMccyOi+ULU0z8mHUJ3iEMIrpTX+80KaN/ZjibfsBOCjcfiJSB/acn4nxQQgNZigna 32velafhQivsNREFeJpzENiGHOoyC6qVeOgKrRiKxzymj0FIMLru/iFF5pSWcBQB7PYlt8J0 G80lAcPr6VCiN+4cNKv03SdvA69dCOj79PuO9IIvQsJXsSq96HB+TeEmmL+xSdpGtGdCJHHM 1fDeCqkZhT+RtBGQL2SEdWjxbF43oQopocT8cHvyX6Zaltn0svoGs+wX3Z/H6/8P5anog43U 65c0A+64Jj00rNDr8j31izhtQMRo892kGeQAaaxg4Pz6HnS7hRC+cOMHUU4HA7iMzHrouAdY eTZeZEQOA7SxtCME9ZnGwe2grxPXh/U/80WJGkzLFNcTKdv+rwARAQABtDdEb2NrZXIgUmVs ZWFzZSBUb29sIChyZWxlYXNlZG9ja2VyKSA8ZG9ja2VyQGRvY2tlci5jb20+iQIcBBABCgAG BQJWw7vdAAoJEFyzYeVS+w0QHysP/i37m4SyoOCVcnybl18vzwBEcp4VCRbXvHvOXty1gccV IV8/aJqNKgBV97lY3vrpOyiIeB8ETQegsrxFE7t/Gz0rsLObqfLEHdmn5iBJRkhLfCpzjeOn yB3Z0IJB6UogO/msQVYe5CXJl6uwr0AmoiCBLrVlDAktxVh9RWch0l0KZRX2FpHu8h+uM0/z ySqIidlYfLa3y5oHscU+nGU1i6ImwDTD3ysZC5jp9aVfvUmcESyAb4vvdcAHR+bXhA/RW8QH eeMFliWw7Z2jYHyuHmDnWG2yUrnCqAJTrWV+OfKRIzzJFBs4e88ru5h2ZIXdRepw/+COYj34 LyzxR2cxr2u/xvxwXCkSMe7F4KZAphD+1ws61FhnUMi/PERMYfTFuvPrCkq4gyBjt3fFpZ2N R/fKW87QOeVcn1ivXl9id3MMs9KXJsg7QasT7mCsee2VIFsxrkFQ2jNpD+JAERRn9Fj4ArHL 5TbwkkFbZZvSi6fr5h2GbCAXIGhIXKnjjorPY/YDX6X8AaHOW1zblWy/CFr6VFl963jrjJga g0G6tNtBZLrclZgWhOQpeZZ5Lbvz2ZA5CqRrfAVcwPNW1fObFIRtqV6vuVluFOPCMAAnOnqR 02w9t17iVQjO3oVN0mbQi9vjuExXh1YoScVetiO6LSmlQfVEVRTqHLMgXyR/EMo7iQIcBBAB CgAGBQJXSWBlAAoJEFyzYeVS+w0QeH0QAI6btAfYwYPuAjfRUy9qlnPhZ+xt1rnwsUzsbmo8 K3XTNh+l/R08nu0dsczw30Q1wju28fh1N8ay223+69f0+yICaXqR18AbGgFGKX7vo0gfEVax dItUN3eHNydGFzmeOKbAlrxIMECnSTG/TkFVYO9Ntlv9vSN2BupmTagTRErxLZKnVsWRzp+X elwlgU5BCZ6U6Ze8+bIc6F1bZstf17X8i6XNV/rOCLx2yP0hn1osoljoLPpW8nzkwvqYsYbC A28lMt1aqe0UWvRCqR0zxlKn17NZQqjbxcajEMCajoQ01MshmO5GWePViv2abCZ/iaC5zKqV T3deMJHLq7lum6qhA41E9gJH9QoqT+qgadheeFfoC1QP7cke+tXmYg2R39p3l5Hmm+JQbP4f 9V5mpWExvHGCSbcatr35tnakIJZugq2ogzsm1djCSz9222RXl9OoFqsm1bNzA78+/cOt5N2c yhU0bM2T/zgh42YbDD+JDU/HSmxUIpU+wrGvZGM2FU/up0DRxOC4U1fL6HHlj8liNJWfEg3v hougOh66gGF9ik5j4eIlNoz6lst+gmvlZQ9/9hRDeoG+AbhZeIlQ4CCw+Y1j/+fUxIzKHPVK +aFJd+oJVNvbojJW/SgDdSMtFwqOvXyYcHl30Ws0gZUeDyAmNGZeJ3kFklnApDmeKK+OiQIi BBABCgAMBQJXe5zTBYMHhh+AAAoJEDG4FaMBBnSp7YMQAJqrXoBonZAq07B6qUaT3aBCgnY4 JshbXmFb/XrrS75f7YJDPx2fJJdqrbYDIHHgOjzxvp3ngPpOpJzI5sYmkaugeoCO/KHu/+39 XqgTB7fguzapRfbvuWp+qzPcHSdb9opnagfzKAze3DQnnLiwCPlsyvGpzC4KzXgV2ze/4raa Oye1kK7O0cHyapmn/q/TR3S8YapyXq5VpLThwJAw1SRDu0YxeXIAQiIfaSxT79EktoioW2CS V8/djt+gBjXnKYJJA8P1zzX7GNt/Rc2YG0Ot4v6tBW16xqFTg+n5JzbeK5cZ1jbIXXfCcaZJ yiM2MzYGhSJ9+EV7JYF05OAIWE4SGTRjXMquQ2oMLSwMCPQHm+FCD9PXQ0tHYx6tKT34wksd moWsdejl/n3NS+178mG1WI/lN079h3im2gRwOykMou/QWs3vGw/xDoOYHPV2gJ7To9BLVnVK /hROgdFLZFeyRScNzwKm57HmYMFA74tX601OiHhk1ymP2UUc25oDWpLXlfcRULJJlo/KfZZF 3pmKwIq3CilGayFUi1NNwuavG76EcAVtVFUVFFIITwkhkuRbBHIytzEHYosFgD5/acK0Pauq JnwrwKv0nWq3aK7nKiALAD+iZvPNjFZau3/APqLEmvmRnAElmugcHsWREFxMMjMMVgYFiYKU AJO8u46eiQI4BBMBAgAiBQJVpZ9uAhsvBgsJCAcDAgYVCAIJCgsEFgIDAQIeAQIXgAAKCRD3 YiFXLFJgnbRfEAC9Uai7Rv20QIDlDogRzd+Vebg4ahyoUdj0CH+nAk40RIoq6G26u1e+sdgj pCa8jF6vrx+smpgd1HeJdmpahUX0XN3X9f9qU9oj9A4I1WDalRWJh+tP5WNv2ySy6AwcP9Qn juBMRTnTK27pk1sEMg9oJHK5p+ts8hlSC4SluyMKH5NMVy9c+A9yqq9NF6M6d6/ehKfBFFLG 9BX+XLBATvf1ZemGVHQusCQebTGv0C0V9yqtdPdRWVIEhHxyNHATaVYOafTj/EF0lDxLl6zD T6trRV5n9F1VCEh4Aal8L5MxVPcIZVO7NHT2EkQgn8CvWjV3oKl2GopZF8V4XdJRl90U/WDv /6cmfI08GkzDYBHhS8ULWRFwGKobsSTyIvnbk4NtKdnTGyTJCQ8+6i52s+C54PiNgfj2ieNn 6oOR7d+bNCcG1CdOYY+ZXVOcsjl73UYvtJrO0Rl/NpYERkZ5d/tzw4jZ6FCXgggA/Zxcjk6Y 1ZvIm8Mt8wLRFH9Nww+FVsCtaCXJLP8DlJLASMD9rl5QS9Ku3u7ZNrr5HWXPHXITX660jgly shch6CWeiUATqjIAzkEQom/kEnOrvJAtkypRJ59vYQOedZ1sFVELMXg2UCkD/FwojfnVtjzY aTCeGwFQeqzHmM241iuOmBYPeyTY5veF49aBJA1gEJOQTvBR8Q== =Yhur -----END PGP PUBLIC KEY BLOCK----- filename : docker.list package_upgrade : true debconf_selections : | dokku dokku/web_config boolean false dokku dokku/vhost_enable boolean true # set the domain name of the new Dokku server dokku dokku/hostname string $YOUR_FULL_QUALIFIED_DOMAIN # this copies over the public SSH key assigned to the server dokku dokku/key_file string /home/ubuntu/.ssh/authorized_keys packages : - dokku Shortly after running the create command you will get a confirmation that the instance has been created, and after about a minute it should be ready to login. Check the IP of the instance through the web UI or by running: nova list SSH with the ubuntu username and the public key previously added. Keep in mind that if you logged in quick enough Dokku might still be installing in the background, and not be ready. The installation takes a few minutes.","title":"Install Dokku on DreamHost Cloud Server with cloud-init"},{"location":"getting-started/install/dreamhost/#install-dokku-on-dreamhost-cloud-server-with-cloud-init","text":"Cloud-init script can be used to automate installation of Dokku on Dreamhost (or any other OpenStack-compatible cloud with minimal changes). A new server instance can be created on DreamHost Cloud from the command line using OpenStack client or from the web UI and with the same command use a cloud-init script to install Dokku. Install the OpenStack CLI , download the DreamHost Cloud credentials file before proceeding and make sure your public SSH key is added to the cloud. source openrc.sh # Set the environment variables for DreamHost Cloud This allows OpenStack client to connect to DreamHost API endpoints. The command below creates a new server instance named my-dokku-instance based on Ubuntu 14.04, with 2 GB RAM and 1 CPU (the flavor called supersonic ), opening network port access to HTTP and SSH (the default security group), and the name of the chosen SSH key. This key will be automatically added to the new server in the authorized_keys for the default SSH user ( ubuntu ), and it will be reused by Dokku. openstack server create \\ --image Ubuntu-14.04 \\ --flavor gp1.supersonic \\ --security-group default \\ --key-name $YOUR_SSH_KEYNAME \\ --user-data dokku-cloudinit.sh \\ my-dokku-instance The content of dokku-cloudinit.sh script contains instructions to add Docker and Dokku's apt repositories and install Dokku with the proper debconf options set. Don't forget to add the FQDN for your application server: #cloud-config apt_upgrade : true apt_sources : - source : \"deb https://packagecloud.io/dokku/dokku/ubuntu/ trusty main\" key : | -----BEGIN PGP PUBLIC KEY BLOCK----- Version: SKS 1.1.5 Comment: Hostname: pgpkeys.eu mQINBFLUbogBEADceEoxBDoE6QM5xV/13qiELbFIkQgy/eEi3UesXmJblFdU7wcDLOW3NuOI x/dgbZljeMEerj6N1cR7r7X5sVoFVEZiK4RLkC3Cpdns0d90ud2f3VyKK7PXRBstdLm3JlW9 OWZoe4VSADSMGWm1mIhT601qLKKAuWJoBIhnKY/RhA/RBXt7z22g4ta9bT67PlliTo1a8y6D hUA7gd+5TsVHaxDRrzc3mKObdyS5LOT/gf8Ti2tYBY5MBbQ8NUGExls4dXKlieePhKutFbde 7sq3n5sdp1Ndoran1u0LsWnaSDx11R3xiYfXJ6xGukAc6pYlUD1yYjU4oRGhD2fPyuewqhHN UVwqupTBQtEGULrtdwK04kgIH93ssGRsLqUKe88uZeeBczVuupv8ZLd1YcQ29AfJHe6nsevs gjF+eajYlzsvC8BNq3nOvvedcuI6BW4WWFjraH06GNTyMAZi0HibTg65guZXpLcpPW9hTzXM oUrZz8MvJ9yUBcFPKuFOLDpRP6uaIbxJsYqiituoltl0vgS/vJcpIVVRwSaqPHa6S63dmKm2 6gq18v4l05mVcInPn+ciHtcSlZgQkCsRTSvfUrK+7nzyWtNQMGKstAZ7AHCoA8Pbc3i7wyOt nTgfPFHVpHg3JHsPXKk9/71YogtoNFoETMFeKL1K+O+GMQddYQARAQABtDdwYWNrYWdlY2xv dWQgb3BzIChwcm9kdWN0aW9uIGtleSkgPG9wc0BwYWNrYWdlY2xvdWQuaW8+iQI+BBMBAgAo BQJS1G6IAhsvBQkJZgGABgsJCAcDAgYVCAIJCgsEFgIDAQIeAQIXgAAKCRDC5zQk1ZCXq13K D/wNzAi6rEzRyx6NH61Hc19s2QAgcU1p1mX1Tw0fU7CThx1nr8JrG63465c9dzUpVzNTYvMs USBJwbb1phahCMNGbJpZRQ5bvW/i3azmk/EHKL7wgMV8wu1atu6crrxGoDEfWUa4aIwbxZGk oxDZKZeKaLxz2ZChuKzjvkGUk4PUoOxxPn9XeFmJQ68ys4Z0CgIGfx2i64apqfsjVEdWEEBL oxHFIPy7FgFafRL0bgsquwPkb5q/dihIzJEZ2EMOGwXuUaKI/UAhgRIUGizuW7ECEjX4FG92 8RsizHBjYL5Gl7DMt1KcPFe/YU/AdWEirs9pLQUr9eyGZN7HYJ03Aiy8R5aMBoeYsfxjifkb WCpbN+SEATaB8YY6Zy2LK/5TiUYNUYb/VHP//ZEv0+uPgkoro6gWVkvGDdXqH2d9svwfrQKf GSEQYXlLytZKvQSDLAqclSANs/y5HDjUxgtWKdsL3xNPCmffjpyiqS4pvoTiUwS4FwBsIR2s BDToIEHDvTNk1imeSmxCUgDxFzWkmB70FBmwz7zs9FzuoegrAxXonVit0+f3CxquN7tS0mHa WrZfhHxEIt65edkIz1wETOch3LIg6RaFwsXgrZCNTB/zjKGAFEzxOSBkjhyJCY2g74QNObKg TSeGNFqG0ZBHe2/JQ33UxrDtpeKvCYTbjuWlyrkCDQRS1G6IARAArtNBXq+CNU9DR2YCi759 fLR9F62Ec/QLWY3c/D26OqjTgjxAzGKbu1aLzphP8tq1GDCbWQ2BMMZI+L0Ed502u6kC0fzv bppRRXrVaxBrwxY9XhnzvkXXzwNwnBalkrJ5Yk0lN8ocwCuUJohms7V14nEDyHgAB8yqCEWz Qm/SIZw35N/insTXshcdiUGeyufo85SFhCUqZ1x1TkSC/FyDG+BCwArfj8Qwdab3UlUEkF6c zTjwWIO+5vYuR8bsCGYKCSrGRh5nxw0tuGXWXWFlBMSZP6mFcCDRQDGcKOuGTjiWzLJcgsEc BoIX4WpHJYgl6ovex7HkfQsWPYL5V1FIHMlw34ALx4aQDH0dPJpC+FxynrfTfsIzPnmm2huX PGGYul/TmOp00CsJEcKOjqcrYOgraYkCGVXbd4ri6Pf7wJNiJ8V1iKTzQIrNpqGDk306Fww1 VsYBLOnrSxNPYOOu1s8c8c9N5qbEbOCtQdFf5pfuqsr5nJ0G4mhjQ/eLtDA4E7GPrdtUoceO kYKcQFt/yqnL1Sj9Ojeht3ENPyVSgE8NiWxNIEM0YxPyJEPQawejT66JUnTjzLfGaDUxHfse RcyMMTbTrZ0fLJSRaIH1AubPxhiYy+IcWOVMyLiUwjBBpKMStej2XILEpIJXP6Pn96KjMcB1 grd0J2vMw2Kg3E8AEQEAAYkERAQYAQIADwUCUtRuiAIbLgUJCWYBgAIpCRDC5zQk1ZCXq8Fd IAQZAQIABgUCUtRuiAAKCRA3u+4/etlbPwI5D/4idr7VHQpou6c/YLnK1lmz3hEikdxUxjC4 ymOyeODsGRlaxXfjvjOCdocMzuCY3C+ZfNFKOTtVY4fV5Pd82MuY1H8lnuzqLxT6UwpIwo+y Ev6xSK0mqm2FhT0JSQ7E7MnoHqsU0aikHegyEucGIFzew6BJUD2xBu/qmVP/YEPUzhW4g8uD +oRMxdAHXqvtThvFySY/rakLQRMRVwYdTFHrvu3zHP+6hpZt25llJb3DiO+dTsv+ptLmlUr5 JXLSSw2DfLxQa0kD5PGWpFPVJcxraS2pNDK9KTi2nr1ZqDxeKjDBT6zZOs9+4JQ9fepn1S26 AmHWHhyzvpjKxVm4sOilKysi84CYluNrlEnidNf9wQa3NlLmtvxXQfm1py5tlwL5rE+ek1fw leaKXRcNNmm+T+vDdIw+JcHy8a53nK1JEfBqEuY6IqEPKDke0wDIsDLSwI1OgtQoe7Cm1PBu jfJu4rYQE+wwgWILTAgIy8WZXAloTcwVMtgfSsgHia++LqKfLDZ3JuwpaUAHAtguPy0QddvF I4R7eFDVwHT0sS3AsG0HAOCY/1FRe8cAw/+9Vp0oDtOvBWAXycnCbdQeHvwh2+Uj2u2f7K3C DMoevcBl4L5fkFkYTkmixCDy5nst1VM5nINueUIkUAJJbOGpd6yFdif7mQR0JWcPLudb+fwu sJ4UEACYWhPa8Gxa7eYopRsydlcdEzwpmo6E+V8GIdLFRFFpKHQEzbSW5coxzU6oOiPbTurC ZorIMHTA9cpAZoMUGKaSt19UKIMvSqtcDayhgf4cZ2ay1z0fdJ2PuLeNnWeiGyfq78q6wqSa Jq/h6JdAiwXplFd3gqJZTrFZz7A6Q6Pd7B+9PZ/DUdEO3JeZlHJDfRmfU2XPoyPUoq79+whP 5Tl3WwHUv7Fg357kRSdzKv9DbgmhqRHlgVeKn9pwN4cpVBN+idzwPefQksSKH4lBDvVr/9j+ V9mmrOx7QmQ5LCc/1on+L0dqo6suoajADhKy+lDQbzs2mVb4CLpPKncDup/9iJbjiR17DDFM wgyCoy5OHJICQ5lckNNgkHTS6Xiogkt28YfK4P3S0GaZgIrhKQ7AmO3O+hB12Zr+olpeyhGB OpBD80URntdEcenvfnXBY/BsuAVbTGXiBzrlBEyQxg656jUeqAdXg+nzCvP0yJlBUOjEcwyh K/U2nw9nGyaR3u0a9r24LgijGpdGabIeJm6O9vuuqFHHGI72pWUEs355lt8q1pAoJUv8NehQ mlaR0h5wcwhEtwM6fiSIUTnuJnyHT053GjsUD7ef5fY1KEFmaZeW04kRtFDOPinz0faE8hvs xzsVgkKye1c2vkXKdOXvA3x+pZzlTHtcgMOhjKQAsA== =H60S -----END PGP PUBLIC KEY BLOCK----- filename : dokku.list - source : \"deb https://apt.dockerproject.org/repo ubuntu-trusty main\" key : | -----BEGIN PGP PUBLIC KEY BLOCK----- Version: SKS 1.1.5 Comment: Hostname: pgpkeys.co.uk mQINBFWln24BEADrBl5p99uKh8+rpvqJ48u4eTtjeXAWbslJotmC/CakbNSqOb9oddfzRvGV eJVERt/Q/mlvEqgnyTQy+e6oEYN2Y2kqXceUhXagThnqCoxcEJ3+KM4RmYdoe/BJ/J/6rHOj q7Omk24z2qB3RU1uAv57iY5VGw5p45uZB4C4pNNsBJXoCvPnTGAs/7IrekFZDDgVraPx/hdi wopQ8NltSfZCyu/jPpWFK28TR8yfVlzYFwibj5WKdHM7ZTqlA1tHIG+agyPf3Rae0jPMsHR6 q+arXVwMccyOi+ULU0z8mHUJ3iEMIrpTX+80KaN/ZjibfsBOCjcfiJSB/acn4nxQQgNZigna 32velafhQivsNREFeJpzENiGHOoyC6qVeOgKrRiKxzymj0FIMLru/iFF5pSWcBQB7PYlt8J0 G80lAcPr6VCiN+4cNKv03SdvA69dCOj79PuO9IIvQsJXsSq96HB+TeEmmL+xSdpGtGdCJHHM 1fDeCqkZhT+RtBGQL2SEdWjxbF43oQopocT8cHvyX6Zaltn0svoGs+wX3Z/H6/8P5anog43U 65c0A+64Jj00rNDr8j31izhtQMRo892kGeQAaaxg4Pz6HnS7hRC+cOMHUU4HA7iMzHrouAdY eTZeZEQOA7SxtCME9ZnGwe2grxPXh/U/80WJGkzLFNcTKdv+rwARAQABtDdEb2NrZXIgUmVs ZWFzZSBUb29sIChyZWxlYXNlZG9ja2VyKSA8ZG9ja2VyQGRvY2tlci5jb20+iQIcBBABCgAG BQJWw7vdAAoJEFyzYeVS+w0QHysP/i37m4SyoOCVcnybl18vzwBEcp4VCRbXvHvOXty1gccV IV8/aJqNKgBV97lY3vrpOyiIeB8ETQegsrxFE7t/Gz0rsLObqfLEHdmn5iBJRkhLfCpzjeOn yB3Z0IJB6UogO/msQVYe5CXJl6uwr0AmoiCBLrVlDAktxVh9RWch0l0KZRX2FpHu8h+uM0/z ySqIidlYfLa3y5oHscU+nGU1i6ImwDTD3ysZC5jp9aVfvUmcESyAb4vvdcAHR+bXhA/RW8QH eeMFliWw7Z2jYHyuHmDnWG2yUrnCqAJTrWV+OfKRIzzJFBs4e88ru5h2ZIXdRepw/+COYj34 LyzxR2cxr2u/xvxwXCkSMe7F4KZAphD+1ws61FhnUMi/PERMYfTFuvPrCkq4gyBjt3fFpZ2N R/fKW87QOeVcn1ivXl9id3MMs9KXJsg7QasT7mCsee2VIFsxrkFQ2jNpD+JAERRn9Fj4ArHL 5TbwkkFbZZvSi6fr5h2GbCAXIGhIXKnjjorPY/YDX6X8AaHOW1zblWy/CFr6VFl963jrjJga g0G6tNtBZLrclZgWhOQpeZZ5Lbvz2ZA5CqRrfAVcwPNW1fObFIRtqV6vuVluFOPCMAAnOnqR 02w9t17iVQjO3oVN0mbQi9vjuExXh1YoScVetiO6LSmlQfVEVRTqHLMgXyR/EMo7iQIcBBAB CgAGBQJXSWBlAAoJEFyzYeVS+w0QeH0QAI6btAfYwYPuAjfRUy9qlnPhZ+xt1rnwsUzsbmo8 K3XTNh+l/R08nu0dsczw30Q1wju28fh1N8ay223+69f0+yICaXqR18AbGgFGKX7vo0gfEVax dItUN3eHNydGFzmeOKbAlrxIMECnSTG/TkFVYO9Ntlv9vSN2BupmTagTRErxLZKnVsWRzp+X elwlgU5BCZ6U6Ze8+bIc6F1bZstf17X8i6XNV/rOCLx2yP0hn1osoljoLPpW8nzkwvqYsYbC A28lMt1aqe0UWvRCqR0zxlKn17NZQqjbxcajEMCajoQ01MshmO5GWePViv2abCZ/iaC5zKqV T3deMJHLq7lum6qhA41E9gJH9QoqT+qgadheeFfoC1QP7cke+tXmYg2R39p3l5Hmm+JQbP4f 9V5mpWExvHGCSbcatr35tnakIJZugq2ogzsm1djCSz9222RXl9OoFqsm1bNzA78+/cOt5N2c yhU0bM2T/zgh42YbDD+JDU/HSmxUIpU+wrGvZGM2FU/up0DRxOC4U1fL6HHlj8liNJWfEg3v hougOh66gGF9ik5j4eIlNoz6lst+gmvlZQ9/9hRDeoG+AbhZeIlQ4CCw+Y1j/+fUxIzKHPVK +aFJd+oJVNvbojJW/SgDdSMtFwqOvXyYcHl30Ws0gZUeDyAmNGZeJ3kFklnApDmeKK+OiQIi BBABCgAMBQJXe5zTBYMHhh+AAAoJEDG4FaMBBnSp7YMQAJqrXoBonZAq07B6qUaT3aBCgnY4 JshbXmFb/XrrS75f7YJDPx2fJJdqrbYDIHHgOjzxvp3ngPpOpJzI5sYmkaugeoCO/KHu/+39 XqgTB7fguzapRfbvuWp+qzPcHSdb9opnagfzKAze3DQnnLiwCPlsyvGpzC4KzXgV2ze/4raa Oye1kK7O0cHyapmn/q/TR3S8YapyXq5VpLThwJAw1SRDu0YxeXIAQiIfaSxT79EktoioW2CS V8/djt+gBjXnKYJJA8P1zzX7GNt/Rc2YG0Ot4v6tBW16xqFTg+n5JzbeK5cZ1jbIXXfCcaZJ yiM2MzYGhSJ9+EV7JYF05OAIWE4SGTRjXMquQ2oMLSwMCPQHm+FCD9PXQ0tHYx6tKT34wksd moWsdejl/n3NS+178mG1WI/lN079h3im2gRwOykMou/QWs3vGw/xDoOYHPV2gJ7To9BLVnVK /hROgdFLZFeyRScNzwKm57HmYMFA74tX601OiHhk1ymP2UUc25oDWpLXlfcRULJJlo/KfZZF 3pmKwIq3CilGayFUi1NNwuavG76EcAVtVFUVFFIITwkhkuRbBHIytzEHYosFgD5/acK0Pauq JnwrwKv0nWq3aK7nKiALAD+iZvPNjFZau3/APqLEmvmRnAElmugcHsWREFxMMjMMVgYFiYKU AJO8u46eiQI4BBMBAgAiBQJVpZ9uAhsvBgsJCAcDAgYVCAIJCgsEFgIDAQIeAQIXgAAKCRD3 YiFXLFJgnbRfEAC9Uai7Rv20QIDlDogRzd+Vebg4ahyoUdj0CH+nAk40RIoq6G26u1e+sdgj pCa8jF6vrx+smpgd1HeJdmpahUX0XN3X9f9qU9oj9A4I1WDalRWJh+tP5WNv2ySy6AwcP9Qn juBMRTnTK27pk1sEMg9oJHK5p+ts8hlSC4SluyMKH5NMVy9c+A9yqq9NF6M6d6/ehKfBFFLG 9BX+XLBATvf1ZemGVHQusCQebTGv0C0V9yqtdPdRWVIEhHxyNHATaVYOafTj/EF0lDxLl6zD T6trRV5n9F1VCEh4Aal8L5MxVPcIZVO7NHT2EkQgn8CvWjV3oKl2GopZF8V4XdJRl90U/WDv /6cmfI08GkzDYBHhS8ULWRFwGKobsSTyIvnbk4NtKdnTGyTJCQ8+6i52s+C54PiNgfj2ieNn 6oOR7d+bNCcG1CdOYY+ZXVOcsjl73UYvtJrO0Rl/NpYERkZ5d/tzw4jZ6FCXgggA/Zxcjk6Y 1ZvIm8Mt8wLRFH9Nww+FVsCtaCXJLP8DlJLASMD9rl5QS9Ku3u7ZNrr5HWXPHXITX660jgly shch6CWeiUATqjIAzkEQom/kEnOrvJAtkypRJ59vYQOedZ1sFVELMXg2UCkD/FwojfnVtjzY aTCeGwFQeqzHmM241iuOmBYPeyTY5veF49aBJA1gEJOQTvBR8Q== =Yhur -----END PGP PUBLIC KEY BLOCK----- filename : docker.list package_upgrade : true debconf_selections : | dokku dokku/web_config boolean false dokku dokku/vhost_enable boolean true # set the domain name of the new Dokku server dokku dokku/hostname string $YOUR_FULL_QUALIFIED_DOMAIN # this copies over the public SSH key assigned to the server dokku dokku/key_file string /home/ubuntu/.ssh/authorized_keys packages : - dokku Shortly after running the create command you will get a confirmation that the instance has been created, and after about a minute it should be ready to login. Check the IP of the instance through the web UI or by running: nova list SSH with the ubuntu username and the public key previously added. Keep in mind that if you logged in quick enough Dokku might still be installing in the background, and not be ready. The installation takes a few minutes.","title":"Install Dokku on DreamHost Cloud Server with cloud-init"},{"location":"getting-started/install/rpm/","text":"RPM Package Installation Notes New as of 0.8.0 (experimental) Warning: Web installer is not available on CentOS. You will need to configure SSH keys and virtual hosts using dokku command line interface. Dokku defaults to being installed via RPM package on CentOS 7. While certain hosts may require extra work to get running, you may optionally wish to automate the installation of Dokku without the use of our bootstrap.sh Bash script. The following are the steps run by said script: # Install docker curl -fsSL https://get.docker.com/ | sh # Install epel for nginx packages to be available sudo yum install -y epel-release # Install dokku curl -s https://packagecloud.io/install/repositories/dokku/dokku/script.rpm.sh | sudo bash sudo yum install -y herokuish dokku sudo dokku plugin:install-dependencies --core systemctl start nginx # Enable docker and nginx on system startup systemctl enable docker systemctl enable nginx The devicemapper is the default Docker storage driver on CentOS 7 and defaults to a configuration mode known as loop-lvm . This mode is designed to work out-of-the-box with no additional configuration. However, production deployments should not run under loop-lvm mode. The preferred configuration for production deployments is direct-lvm .","title":"RPM Package Installation Notes"},{"location":"getting-started/install/rpm/#rpm-package-installation-notes","text":"New as of 0.8.0 (experimental) Warning: Web installer is not available on CentOS. You will need to configure SSH keys and virtual hosts using dokku command line interface. Dokku defaults to being installed via RPM package on CentOS 7. While certain hosts may require extra work to get running, you may optionally wish to automate the installation of Dokku without the use of our bootstrap.sh Bash script. The following are the steps run by said script: # Install docker curl -fsSL https://get.docker.com/ | sh # Install epel for nginx packages to be available sudo yum install -y epel-release # Install dokku curl -s https://packagecloud.io/install/repositories/dokku/dokku/script.rpm.sh | sudo bash sudo yum install -y herokuish dokku sudo dokku plugin:install-dependencies --core systemctl start nginx # Enable docker and nginx on system startup systemctl enable docker systemctl enable nginx The devicemapper is the default Docker storage driver on CentOS 7 and defaults to a configuration mode known as loop-lvm . This mode is designed to work out-of-the-box with no additional configuration. However, production deployments should not run under loop-lvm mode. The preferred configuration for production deployments is direct-lvm .","title":"RPM Package Installation Notes"},{"location":"getting-started/install/vagrant/","text":"Install Dokku using Vagrant Download and install VirtualBox . Download and install Vagrant . Clone Dokku. git clone https://github.com/dokku/dokku.git Create VM. # Optional ENV arguments: # - `BOX_NAME` # - `BOX_URI` # - `BOX_MEMORY` # - `DOKKU_DOMAIN` # - `DOKKU_IP` # - `FORWARDED_PORT`. cd path/to/dokku # for most users vagrant up # windows users must instead use the following in an elevated command prompt vagrant up dokku-windows Setup SSH Config in ~/.ssh/config . Host dokku.me Port 22 For users that have customized the IP address of their VM - either in a custom Vagrantfile or via the DOKKU_IP environment variable - and are not using 10.0.0.2 for the Vagrant IP, you'll need to instead use the output of vagrant ssh-config dokku for your ~/.ssh/config entry. Copy your SSH key via cat ~/.ssh/id_rsa.pub | pbcopy and paste it into the dokku-installer at http://dokku.me . Change the Hostname field on the Dokku Setup screen to your domain and then check the box that says Use virtualhost naming . Then click Finish Setup to install your key. You'll be directed to application deployment instructions from here. Please note, the dokku.me domain is setup to point to 10.0.0.2 along with all subdomains (i.e. yourapp.dokku.me ). If you change the DOKKU_IP in your Vagrant setup you'll need to update your /etc/hosts file to point your reconfigured IP address. You are now ready to deploy an app or install plugins.","title":"Install Dokku using Vagrant"},{"location":"getting-started/install/vagrant/#install-dokku-using-vagrant","text":"Download and install VirtualBox . Download and install Vagrant . Clone Dokku. git clone https://github.com/dokku/dokku.git Create VM. # Optional ENV arguments: # - `BOX_NAME` # - `BOX_URI` # - `BOX_MEMORY` # - `DOKKU_DOMAIN` # - `DOKKU_IP` # - `FORWARDED_PORT`. cd path/to/dokku # for most users vagrant up # windows users must instead use the following in an elevated command prompt vagrant up dokku-windows Setup SSH Config in ~/.ssh/config . Host dokku.me Port 22 For users that have customized the IP address of their VM - either in a custom Vagrantfile or via the DOKKU_IP environment variable - and are not using 10.0.0.2 for the Vagrant IP, you'll need to instead use the output of vagrant ssh-config dokku for your ~/.ssh/config entry. Copy your SSH key via cat ~/.ssh/id_rsa.pub | pbcopy and paste it into the dokku-installer at http://dokku.me . Change the Hostname field on the Dokku Setup screen to your domain and then check the box that says Use virtualhost naming . Then click Finish Setup to install your key. You'll be directed to application deployment instructions from here. Please note, the dokku.me domain is setup to point to 10.0.0.2 along with all subdomains (i.e. yourapp.dokku.me ). If you change the DOKKU_IP in your Vagrant setup you'll need to update your /etc/hosts file to point your reconfigured IP address. You are now ready to deploy an app or install plugins.","title":"Install Dokku using Vagrant"},{"location":"networking/dns/","text":"DNS Configuration Note: This is a work in progress. DNS Versions There are many different DNS servers 'in the wild'. Some of the popular ones on Linux are BIND, dnsmasq, and pdns. Windows has its own built-in DNS server as well as Unbound, Posadis, and more. A full list of DNS packages can be found on Wikipedia under Comparison of DNS Server Software . In addition to the various DNS packages, there are tens of thousands of Managed DNS Providers out that all have different DNS interfaces. Focus Because there are so many different DNS server packages out there as well as a tremendous number of Managed DNS Providers, we will focus on the concepts of DNS as well as providing examples in the 'BIND' format so you can adapt the information to your own server package or managed DNS provider. Assumptions We assume you have a passing familiarity with DNS. If not, you can read an in-depth article on DNS. But basically you need to know that DNS changes names (like example.tld) into addresses (like 127.0.0.1) We assume you already have a domain name registered and pointed to your favorite Managed DNS Provider or have your own BIND DNS server running. You have a server on the internet and are about to follow the instructions in the README to get Dokku installed. Don't do the install just yet though. Caching Please remember that DNS relies heavily on caching . Changes you make to DNS could take anywhere from a few seconds to a few days to propagate. If you tried surfing to example.tld, then changed the IP address in DNS, it could be a while before your computer picks up on the changes. HELP! Don't be afraid to ask if you need help. Create a new issue and someone will be glad to assist you. Getting started For the examples, we will use the domain name example.tld and the IP address 127.0.0.1 . Dokku uses DNS to differentiate between apps on your dokku-powered server. If you are using the domain example.tld , and you have two apps node-js-app1 and node-js-app2 , Dokku will make them available at node-js-app1.example.tld and node-js-app2.example.tld . To get started, you need to know the IP address of your Dokku server. Connect to it and run ifconfig or ip addr to see the IP address. Now you have to make a decision about your domain. Do you want everything and anything at example.tld to go to your Dokku server, or would you rather use a 'sub domain' for your Dokku server? In other words, do you want your applications on your Dokku server accessible via node-js-app.example.tld or via node-js-app.myserver.example.tld ? Using a sub-domain (node-js-app.myserver.example.tld) Using a sub-domain is easy. When you set up your server, you probably gave it a name like myserver.example.tld . Go in to your Managed DNS provider and create an A record named myserver and put in the IP address you got from your server a few moments ago. Hopefully your managed DNS provider also supports wildcards. Create a second A record named *.myserver along with the IP address you got from your server a few moments ago. If you are using BIND, your zone file will look similar to this: $ORIGIN example.tld $TTL 5m myserver IN A 127.0.0.1 *.myserver IN A 127.0.0.1 You can verify your changes in Linux by trying one or more of the following commands: host myserver.example.tld dig -t A myserver.example.tld nslookup myserver.example.tld Now is a good time to remind you that the answers you get MAY BE CACHED. If everything is working correctly, you should also be able to query for any other name under myserver.example.tld and get back the IP address of your server. Try: host test.myserver.example.tld host xyzzy.myserver.example.tld If they all return your IP address, you have set DNS up properly for dokku. You should also be able to ssh root@myserver.example.tld and access your server. Proceed with the setup instructions in the installation documentation Using the root of your domain (node-js-app.example.tld) This section is a work in progress. It is incomplete. Using the 'root' of your domain is nearly identical to the previous example. hostname is under example.tld , still needs A record. Update your global domain using the domains plugin .","title":"DNS Configuration"},{"location":"networking/dns/#dns-configuration","text":"Note: This is a work in progress.","title":"DNS Configuration"},{"location":"networking/dns/#dns-versions","text":"There are many different DNS servers 'in the wild'. Some of the popular ones on Linux are BIND, dnsmasq, and pdns. Windows has its own built-in DNS server as well as Unbound, Posadis, and more. A full list of DNS packages can be found on Wikipedia under Comparison of DNS Server Software . In addition to the various DNS packages, there are tens of thousands of Managed DNS Providers out that all have different DNS interfaces.","title":"DNS Versions"},{"location":"networking/dns/#focus","text":"Because there are so many different DNS server packages out there as well as a tremendous number of Managed DNS Providers, we will focus on the concepts of DNS as well as providing examples in the 'BIND' format so you can adapt the information to your own server package or managed DNS provider.","title":"Focus"},{"location":"networking/dns/#assumptions","text":"We assume you have a passing familiarity with DNS. If not, you can read an in-depth article on DNS. But basically you need to know that DNS changes names (like example.tld) into addresses (like 127.0.0.1) We assume you already have a domain name registered and pointed to your favorite Managed DNS Provider or have your own BIND DNS server running. You have a server on the internet and are about to follow the instructions in the README to get Dokku installed. Don't do the install just yet though.","title":"Assumptions"},{"location":"networking/dns/#caching","text":"Please remember that DNS relies heavily on caching . Changes you make to DNS could take anywhere from a few seconds to a few days to propagate. If you tried surfing to example.tld, then changed the IP address in DNS, it could be a while before your computer picks up on the changes.","title":"Caching"},{"location":"networking/dns/#help","text":"Don't be afraid to ask if you need help. Create a new issue and someone will be glad to assist you.","title":"HELP!"},{"location":"networking/dns/#getting-started","text":"For the examples, we will use the domain name example.tld and the IP address 127.0.0.1 . Dokku uses DNS to differentiate between apps on your dokku-powered server. If you are using the domain example.tld , and you have two apps node-js-app1 and node-js-app2 , Dokku will make them available at node-js-app1.example.tld and node-js-app2.example.tld . To get started, you need to know the IP address of your Dokku server. Connect to it and run ifconfig or ip addr to see the IP address. Now you have to make a decision about your domain. Do you want everything and anything at example.tld to go to your Dokku server, or would you rather use a 'sub domain' for your Dokku server? In other words, do you want your applications on your Dokku server accessible via node-js-app.example.tld or via node-js-app.myserver.example.tld ?","title":"Getting started"},{"location":"networking/dns/#using-a-sub-domain-node-js-appmyserverexampletld","text":"Using a sub-domain is easy. When you set up your server, you probably gave it a name like myserver.example.tld . Go in to your Managed DNS provider and create an A record named myserver and put in the IP address you got from your server a few moments ago. Hopefully your managed DNS provider also supports wildcards. Create a second A record named *.myserver along with the IP address you got from your server a few moments ago. If you are using BIND, your zone file will look similar to this: $ORIGIN example.tld $TTL 5m myserver IN A 127.0.0.1 *.myserver IN A 127.0.0.1 You can verify your changes in Linux by trying one or more of the following commands: host myserver.example.tld dig -t A myserver.example.tld nslookup myserver.example.tld Now is a good time to remind you that the answers you get MAY BE CACHED. If everything is working correctly, you should also be able to query for any other name under myserver.example.tld and get back the IP address of your server. Try: host test.myserver.example.tld host xyzzy.myserver.example.tld If they all return your IP address, you have set DNS up properly for dokku. You should also be able to ssh root@myserver.example.tld and access your server. Proceed with the setup instructions in the installation documentation","title":"Using a sub-domain (node-js-app.myserver.example.tld)"},{"location":"networking/dns/#using-the-root-of-your-domain-node-js-appexampletld","text":"This section is a work in progress. It is incomplete. Using the 'root' of your domain is nearly identical to the previous example. hostname is under example.tld , still needs A record. Update your global domain using the domains plugin .","title":"Using the root of your domain (node-js-app.example.tld)"},{"location":"networking/network/","text":"Network Management New as of 0.11.0 network:report [<app>] [<flag>] # Displays a network report for one or more apps network:rebuild <app> # Rebuilds network settings for an app network:rebuildall # Rebuild network settings for all apps network:set <app> <key> (<value>) # Set or clear a network property for an app The Network plugin allows developers to abstract the concept of container network management, allowing developers to both change what networks a given container is attached to as well as rebuild the configuration on the fly. Usage Rebuilding network settings There are cases where you may need to rebuild the network configuration for an app, such as on app boot or container restart. In these cases, you can use the network:rebuild command: dokku network:rebuild node-js-app This command will exit a non-zero number that depends on the number of containers for which configuration could not be built Rebuilding all network settings In some cases, a docker upgrade may reset container IPs or Ports. In both cases, you can quickly rewrite those files by using the network:rebuildall command: dokku network:rebuildall This command will exit a non-zero number that depends on the number of containers for which configuration could not be built Container network interface binding This functionality does not control the --network docker flag. Please use the docker-options plugin to manage this flag. By default, an application will only bind to the internal interface. This behavior can be modified per app by changing the bind-all-interfaces network property. # bind to the default docker interface (`docker0`) with a random internal ip # this is the default behavior dokku network:set node-js-app bind-all-interfaces false # bind to all interfaces (`0.0.0.0`) on a random port for each upstream port # this will make the app container directly accessible by other hosts on your network # ports are randomized for every deploy, e.g. `0.0.0.0:32771->5000/tcp`. dokku network:set node-js-app bind-all-interfaces true By way of example, in the default case, each container is bound to the docker interface: docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b88d8aec3d1 dokku/node-js-app:latest \"/bin/bash -c '/star About a minute ago Up About a minute node-js-app.web.1 As such, the container's IP address will be an internal IP, and thus it is only accessible on the host itself: docker inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' node-js-app.web.1 172.17.0.6 However, you can disable the internal proxying via the network:set command so that it will listen on the host's IP address: dokku network:set node-js-app bind-all-interfaces true # container bound to all interfaces docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d6499edb0edb dokku/node-js-app:latest \"/bin/bash -c '/star About a minute ago Up About a minute 0.0.0.0:49153->5000/tcp node-js-app.web.1 Displaying network reports about an app You can get a report about the app's network status using the network:report command: dokku network:report =====> node-js-app network information Network bind all interfaces: false Network listeners: 172.17.0.1:5000 =====> python-sample network information Network bind all interfaces: false Network listeners: 172.17.0.2:5000 =====> ruby-sample network information Network bind all interfaces: true Network listeners: You can run the command for a specific app also. dokku network:report node-js-app =====> node-js-app network information Network bind all interfaces: false Network listeners: 172.17.0.1:5000 You can pass flags which will output only the value of the specific information you want. For example: dokku network:report node-js-app --network-bind-all-interfaces","title":"Network Management"},{"location":"networking/network/#network-management","text":"New as of 0.11.0 network:report [<app>] [<flag>] # Displays a network report for one or more apps network:rebuild <app> # Rebuilds network settings for an app network:rebuildall # Rebuild network settings for all apps network:set <app> <key> (<value>) # Set or clear a network property for an app The Network plugin allows developers to abstract the concept of container network management, allowing developers to both change what networks a given container is attached to as well as rebuild the configuration on the fly.","title":"Network Management"},{"location":"networking/network/#usage","text":"","title":"Usage"},{"location":"networking/network/#rebuilding-network-settings","text":"There are cases where you may need to rebuild the network configuration for an app, such as on app boot or container restart. In these cases, you can use the network:rebuild command: dokku network:rebuild node-js-app This command will exit a non-zero number that depends on the number of containers for which configuration could not be built","title":"Rebuilding network settings"},{"location":"networking/network/#rebuilding-all-network-settings","text":"In some cases, a docker upgrade may reset container IPs or Ports. In both cases, you can quickly rewrite those files by using the network:rebuildall command: dokku network:rebuildall This command will exit a non-zero number that depends on the number of containers for which configuration could not be built","title":"Rebuilding all network settings"},{"location":"networking/network/#container-network-interface-binding","text":"This functionality does not control the --network docker flag. Please use the docker-options plugin to manage this flag. By default, an application will only bind to the internal interface. This behavior can be modified per app by changing the bind-all-interfaces network property. # bind to the default docker interface (`docker0`) with a random internal ip # this is the default behavior dokku network:set node-js-app bind-all-interfaces false # bind to all interfaces (`0.0.0.0`) on a random port for each upstream port # this will make the app container directly accessible by other hosts on your network # ports are randomized for every deploy, e.g. `0.0.0.0:32771->5000/tcp`. dokku network:set node-js-app bind-all-interfaces true By way of example, in the default case, each container is bound to the docker interface: docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b88d8aec3d1 dokku/node-js-app:latest \"/bin/bash -c '/star About a minute ago Up About a minute node-js-app.web.1 As such, the container's IP address will be an internal IP, and thus it is only accessible on the host itself: docker inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' node-js-app.web.1 172.17.0.6 However, you can disable the internal proxying via the network:set command so that it will listen on the host's IP address: dokku network:set node-js-app bind-all-interfaces true # container bound to all interfaces docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d6499edb0edb dokku/node-js-app:latest \"/bin/bash -c '/star About a minute ago Up About a minute 0.0.0.0:49153->5000/tcp node-js-app.web.1","title":"Container network interface binding"},{"location":"networking/network/#displaying-network-reports-about-an-app","text":"You can get a report about the app's network status using the network:report command: dokku network:report =====> node-js-app network information Network bind all interfaces: false Network listeners: 172.17.0.1:5000 =====> python-sample network information Network bind all interfaces: false Network listeners: 172.17.0.2:5000 =====> ruby-sample network information Network bind all interfaces: true Network listeners: You can run the command for a specific app also. dokku network:report node-js-app =====> node-js-app network information Network bind all interfaces: false Network listeners: 172.17.0.1:5000 You can pass flags which will output only the value of the specific information you want. For example: dokku network:report node-js-app --network-bind-all-interfaces","title":"Displaying network reports about an app"},{"location":"networking/port-management/","text":"Port Management New as of 0.5.0, Enhanced in 0.6.0 proxy:ports <app> # List proxy port mappings for app proxy:ports-set <app> <scheme>:<host-port>:<container-port> [<scheme>:<host-port>:<container-port>...] # Set proxy port mappings for app proxy:ports-add <app> <scheme>:<host-port>:<container-port> [<scheme>:<host-port>:<container-port>...] # Add proxy port mappings for app proxy:ports-clear <app> # Clear all proxy port mappings for app proxy:ports-remove <app> <host-port> [<host-port>|<scheme>:<host-port>:<container-port>...] # Unset proxy port mappings for app In Dokku 0.5.0, port proxying was decoupled from the nginx-vhosts plugin into the proxy plugin. Dokku 0.6.0 introduced the ability to map host ports to specific container ports. In the future this will allow other proxy software - such as HAProxy or Caddy - to be used in place of nginx. Usage Proxy port mapping New as of 0.6.0 You can now configure host -> container port mappings with the proxy:ports-* commands. This mapping is currently supported by the built-in nginx-vhosts plugin. To inspect the port mapping for a given application, use the proxy:ports command: dokku proxy:ports node-js-app -----> Port mappings for node-js-app -----> scheme host port container port http 80 5000 The above application is listening on the host's port 80 , which we can test via curl: curl http://node-js-app.dokku.me Hello World! There are cases where we may wish for the service to be listening on more than one port, such as port 8080. Normally, this would not be possible: curl http://node-js-app.dokku.me:8080 curl: (7) Failed to connect to node-js-app.dokku.me port 8080: Connection refused However, we can use the proxy:ports-add command to add a second external port mapping - 8080 - to our application's port 5000 . dokku proxy:ports-add node-js-app http:8080:5000 -----> Setting config vars DOKKU_PROXY_PORT_MAP: http:80:5000 http:8080:5000 -----> Configuring node-js-app.dokku.me...(using built-in template) -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx We can now test that port 80 still responds properly: curl http://node-js-app.dokku.me Hello World! And our new listening port of 8080 also works: curl http://node-js-app.dokku.me:8080 Hello World! Port mappings can also be force set using the proxy:ports-set command. dokku proxy:ports-set node-js-app http:8080:5000 -----> Setting config vars DOKKU_PROXY_PORT_MAP: http:80:5000 http:8080:5000 -----> Configuring node-js-app.dokku.me...(using built-in template) -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx A port mapping can be removed using the proxy:ports-remove command if it no longer necessary: dokku proxy:ports-remove node-js-app http:80:5000 By default, buildpack apps and dockerfile apps without explicitly exposed ports (i.e. using the EXPOSE directive) will be configured with a listener on port 80 (and additionally a listener on 443 if ssl is enabled) that will proxy to the application container on port 5000 . Dockerfile apps with explicitly exposed ports will be configured with a listener on each exposed port and will proxy to that same port of the deployed application container. Note: This default behavior will not be automatically changed on subsequent pushes and must be manipulated with the proxy:ports-* syntax detailed above. Port management by Deployment Method Warning: If you set a proxy port map but do not have a global domain set , Dokku will reset that map upon first deployment. Buildpacks For buildpack deployments, your application must respect the PORT environment variable. We will typically set this to port 5000 , but this is not guaranteed. If you do not respect the PORT environment variable, your containers may start but your services will not be accessible outside of that container. Dockerfile Changed as of 0.5.0 Dokku's default proxy implementation - nginx - only supports HTTP request proxying. At this time, we do not support proxying plain TCP or UDP ports. UDP ports can be exposed by disabling the nginx proxy with dokku proxy:disable myapp . If you would like to investigate alternative proxy methods, please refer to our proxy management documentation . Applications using EXPOSE Dokku will extract all tcp ports exposed using the EXPOSE directive (one port per line) and setup nginx to proxy the same port numbers to listen publicly. If you would like to change the exposed port, you should do so within your Dockerfile . For example, if the Dokku installation is configured with the domain dokku.me and an application named node-js-app is deployed with following Dockerfile: FROM ubuntu:14.04 EXPOSE 1234 RUN python -m SimpleHTTPServer 1234 The application would be exposed to the user at node-js-app.dokku.me:1234 . If this is not desired, the following application configuration may be applied: # add a port mapping to port 80 dokku proxy:ports-add node-js-app http:80:1234 # remove the incorrect port mapping dokku proxy:ports-remove node-js-app http:1234:1234 Applications not using EXPOSE Any application that does not use an EXPOSE directive will result in Dokku defaulting to port 5000 . This behavior mimics the behavior of a Buildpack deploy. If your application does not support the PORT environment variable, then you will either need to: modify your application to support the PORT environment variable. switch to using an EXPOSE directive in your Dockerfile. Switching between EXPOSE usage modes When switching between EXPOSE usage modes, it is important to reset your port management. The following two commands can be used to reset your state and redeploy your application. # assuming your application is called `node-js-app` dokku config:unset --no-restart node-js-app DOKKU_DOCKERFILE_PORTS PORT dokku proxy:ports-clear node-js-app Docker Image When deploying an image, we will use docker inspect to extract the ExposedPorts configuration and if defined, use that to populate port mapping. If this behavior is not desired, you can override that configuration variable with the following commands. # assuming your application is called `node-js-app` dokku config:set node-js-app DOKKU_DOCKERFILE_PORTS = \"1234/tcp 80/tcp\" dokku proxy:ports-clear node-js-app All other port-related behavior is the same as when deploying via Dockerfile.","title":"Port Management"},{"location":"networking/port-management/#port-management","text":"New as of 0.5.0, Enhanced in 0.6.0 proxy:ports <app> # List proxy port mappings for app proxy:ports-set <app> <scheme>:<host-port>:<container-port> [<scheme>:<host-port>:<container-port>...] # Set proxy port mappings for app proxy:ports-add <app> <scheme>:<host-port>:<container-port> [<scheme>:<host-port>:<container-port>...] # Add proxy port mappings for app proxy:ports-clear <app> # Clear all proxy port mappings for app proxy:ports-remove <app> <host-port> [<host-port>|<scheme>:<host-port>:<container-port>...] # Unset proxy port mappings for app In Dokku 0.5.0, port proxying was decoupled from the nginx-vhosts plugin into the proxy plugin. Dokku 0.6.0 introduced the ability to map host ports to specific container ports. In the future this will allow other proxy software - such as HAProxy or Caddy - to be used in place of nginx.","title":"Port Management"},{"location":"networking/port-management/#usage","text":"","title":"Usage"},{"location":"networking/port-management/#proxy-port-mapping","text":"New as of 0.6.0 You can now configure host -> container port mappings with the proxy:ports-* commands. This mapping is currently supported by the built-in nginx-vhosts plugin. To inspect the port mapping for a given application, use the proxy:ports command: dokku proxy:ports node-js-app -----> Port mappings for node-js-app -----> scheme host port container port http 80 5000 The above application is listening on the host's port 80 , which we can test via curl: curl http://node-js-app.dokku.me Hello World! There are cases where we may wish for the service to be listening on more than one port, such as port 8080. Normally, this would not be possible: curl http://node-js-app.dokku.me:8080 curl: (7) Failed to connect to node-js-app.dokku.me port 8080: Connection refused However, we can use the proxy:ports-add command to add a second external port mapping - 8080 - to our application's port 5000 . dokku proxy:ports-add node-js-app http:8080:5000 -----> Setting config vars DOKKU_PROXY_PORT_MAP: http:80:5000 http:8080:5000 -----> Configuring node-js-app.dokku.me...(using built-in template) -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx We can now test that port 80 still responds properly: curl http://node-js-app.dokku.me Hello World! And our new listening port of 8080 also works: curl http://node-js-app.dokku.me:8080 Hello World! Port mappings can also be force set using the proxy:ports-set command. dokku proxy:ports-set node-js-app http:8080:5000 -----> Setting config vars DOKKU_PROXY_PORT_MAP: http:80:5000 http:8080:5000 -----> Configuring node-js-app.dokku.me...(using built-in template) -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx A port mapping can be removed using the proxy:ports-remove command if it no longer necessary: dokku proxy:ports-remove node-js-app http:80:5000 By default, buildpack apps and dockerfile apps without explicitly exposed ports (i.e. using the EXPOSE directive) will be configured with a listener on port 80 (and additionally a listener on 443 if ssl is enabled) that will proxy to the application container on port 5000 . Dockerfile apps with explicitly exposed ports will be configured with a listener on each exposed port and will proxy to that same port of the deployed application container. Note: This default behavior will not be automatically changed on subsequent pushes and must be manipulated with the proxy:ports-* syntax detailed above.","title":"Proxy port mapping"},{"location":"networking/port-management/#port-management-by-deployment-method","text":"Warning: If you set a proxy port map but do not have a global domain set , Dokku will reset that map upon first deployment.","title":"Port management by Deployment Method"},{"location":"networking/port-management/#buildpacks","text":"For buildpack deployments, your application must respect the PORT environment variable. We will typically set this to port 5000 , but this is not guaranteed. If you do not respect the PORT environment variable, your containers may start but your services will not be accessible outside of that container.","title":"Buildpacks"},{"location":"networking/port-management/#dockerfile","text":"Changed as of 0.5.0 Dokku's default proxy implementation - nginx - only supports HTTP request proxying. At this time, we do not support proxying plain TCP or UDP ports. UDP ports can be exposed by disabling the nginx proxy with dokku proxy:disable myapp . If you would like to investigate alternative proxy methods, please refer to our proxy management documentation .","title":"Dockerfile"},{"location":"networking/port-management/#applications-using-expose","text":"Dokku will extract all tcp ports exposed using the EXPOSE directive (one port per line) and setup nginx to proxy the same port numbers to listen publicly. If you would like to change the exposed port, you should do so within your Dockerfile . For example, if the Dokku installation is configured with the domain dokku.me and an application named node-js-app is deployed with following Dockerfile: FROM ubuntu:14.04 EXPOSE 1234 RUN python -m SimpleHTTPServer 1234 The application would be exposed to the user at node-js-app.dokku.me:1234 . If this is not desired, the following application configuration may be applied: # add a port mapping to port 80 dokku proxy:ports-add node-js-app http:80:1234 # remove the incorrect port mapping dokku proxy:ports-remove node-js-app http:1234:1234","title":"Applications using EXPOSE"},{"location":"networking/port-management/#applications-not-using-expose","text":"Any application that does not use an EXPOSE directive will result in Dokku defaulting to port 5000 . This behavior mimics the behavior of a Buildpack deploy. If your application does not support the PORT environment variable, then you will either need to: modify your application to support the PORT environment variable. switch to using an EXPOSE directive in your Dockerfile.","title":"Applications not using EXPOSE"},{"location":"networking/port-management/#switching-between-expose-usage-modes","text":"When switching between EXPOSE usage modes, it is important to reset your port management. The following two commands can be used to reset your state and redeploy your application. # assuming your application is called `node-js-app` dokku config:unset --no-restart node-js-app DOKKU_DOCKERFILE_PORTS PORT dokku proxy:ports-clear node-js-app","title":"Switching between EXPOSE usage modes"},{"location":"networking/port-management/#docker-image","text":"When deploying an image, we will use docker inspect to extract the ExposedPorts configuration and if defined, use that to populate port mapping. If this behavior is not desired, you can override that configuration variable with the following commands. # assuming your application is called `node-js-app` dokku config:set node-js-app DOKKU_DOCKERFILE_PORTS = \"1234/tcp 80/tcp\" dokku proxy:ports-clear node-js-app All other port-related behavior is the same as when deploying via Dockerfile.","title":"Docker Image"},{"location":"networking/proxy-management/","text":"Proxy Management New as of 0.5.0, Enhanced in 0.6.0 proxy:disable <app> # Disable proxy for app proxy:enable <app> # Enable proxy for app proxy:report [<app>] [<flag>] # Displays a proxy report for one or more apps proxy:set <app> <proxy-type> # Set proxy type for app In Dokku 0.5.0, port proxying was decoupled from the nginx-vhosts plugin into the proxy plugin. Dokku 0.6.0 introduced the ability to map host ports to specific container ports. In the future this will allow other proxy software - such as HAProxy or Caddy - to be used in place of nginx. Usage Container network interface binding Changed as of 0.11.0 From Dokku versions 0.5.0 until 0.11.0 , enabling or disabling an application's proxy would also control whether or not the application was bound to all interfaces - e.g. 0.0.0.0 . As of 0.11.0 , this is now controlled by the network plugin. Please see the network documentation for more information. Displaying proxy reports about an app New as of 0.8.1 You can get a report about the app's proxy status using the proxy:report command: dokku proxy:report =====> node-js-app proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 https:443:5000 =====> python-sample proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 =====> ruby-sample proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 You can run the command for a specific app also. dokku proxy:report node-js-app =====> node-js-app proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 https:443:5000 You can pass flags which will output only the value of the specific information you want. For example: dokku proxy:report node-js-app --proxy-type Proxy Port Scheme The proxy port scheme is as follows: SCHEME:HOST_PORT:CONTAINER_PORT The scheme metadata can be used by proxy implementations in order to properly handle proxying of requests. For example, the built-in nginx-vhosts proxy implementation supports both the http and https schemes. Developers of proxy implementations are encouraged to use whatever schemes make the most sense, and ignore configurations which they do not support. For instance, a udp proxy implementation can safely ignore http and https port mappings. To change the proxy implementation in use for an application, use the proxy:set command: # no validation will be performed against # the specified proxy implementation dokku proxy:set node-js-app nginx Proxy port mapping See the port management documentation .","title":"Proxy Management"},{"location":"networking/proxy-management/#proxy-management","text":"New as of 0.5.0, Enhanced in 0.6.0 proxy:disable <app> # Disable proxy for app proxy:enable <app> # Enable proxy for app proxy:report [<app>] [<flag>] # Displays a proxy report for one or more apps proxy:set <app> <proxy-type> # Set proxy type for app In Dokku 0.5.0, port proxying was decoupled from the nginx-vhosts plugin into the proxy plugin. Dokku 0.6.0 introduced the ability to map host ports to specific container ports. In the future this will allow other proxy software - such as HAProxy or Caddy - to be used in place of nginx.","title":"Proxy Management"},{"location":"networking/proxy-management/#usage","text":"","title":"Usage"},{"location":"networking/proxy-management/#container-network-interface-binding","text":"Changed as of 0.11.0 From Dokku versions 0.5.0 until 0.11.0 , enabling or disabling an application's proxy would also control whether or not the application was bound to all interfaces - e.g. 0.0.0.0 . As of 0.11.0 , this is now controlled by the network plugin. Please see the network documentation for more information.","title":"Container network interface binding"},{"location":"networking/proxy-management/#displaying-proxy-reports-about-an-app","text":"New as of 0.8.1 You can get a report about the app's proxy status using the proxy:report command: dokku proxy:report =====> node-js-app proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 https:443:5000 =====> python-sample proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 =====> ruby-sample proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 You can run the command for a specific app also. dokku proxy:report node-js-app =====> node-js-app proxy information Proxy enabled: true Proxy type: nginx Proxy port map: http:80:5000 https:443:5000 You can pass flags which will output only the value of the specific information you want. For example: dokku proxy:report node-js-app --proxy-type","title":"Displaying proxy reports about an app"},{"location":"networking/proxy-management/#proxy-port-scheme","text":"The proxy port scheme is as follows: SCHEME:HOST_PORT:CONTAINER_PORT The scheme metadata can be used by proxy implementations in order to properly handle proxying of requests. For example, the built-in nginx-vhosts proxy implementation supports both the http and https schemes. Developers of proxy implementations are encouraged to use whatever schemes make the most sense, and ignore configurations which they do not support. For instance, a udp proxy implementation can safely ignore http and https port mappings. To change the proxy implementation in use for an application, use the proxy:set command: # no validation will be performed against # the specified proxy implementation dokku proxy:set node-js-app nginx","title":"Proxy Port Scheme"},{"location":"networking/proxy-management/#proxy-port-mapping","text":"See the port management documentation .","title":"Proxy port mapping"}]}