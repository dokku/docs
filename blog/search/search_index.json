{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"/*hide the duplicate blog heading*/ .md-nav__item--nested .md-nav__item--active .md-nav__link:first-of-type { display: none; } /*drop icon*/ .md-nav__link .md-nav__icon.md-icon { display: none; } .md-sidebar--secondary:not([hidden]) { visibility: hidden; } /*remove padding on blog posts*/ .md-nav__item--nested .md-nav__item--nested .md-nav .md-nav__list .md-nav__item { padding: 0; } Blog Release 1.2.0 The 1.2.0 release introduces team-based access control and many internal refactors aimed at easing future development of the product. Dokku has traditionally been a single-tenant PaaS solution, where all users had access to all functionality on the server. While there were community plugins that tackled authentication, each implementation had it's rough edges due to interfaces in Dokku itself. Dokku Pro 1.2.0 polishes those edges while introducing a flexible permission system for organizations that need it. Continue reading Release 1.1.0 The 1.1.0 release is the first substantive update to Dokku Pro, and it brings with it great changes around usability and functionality. Dokku Pro was released in late 2021 to early bird users willing to deal with a bit of pain in exchange for supporting the project and vision. While it technically worked, there were quite a few places for easy improvement, as well as obvious holes in the existing functionality. Dokku Pro 1.1.0 aims to fill some of those needs, laying the groundwork for future enhancements Continue reading","title":"Blog"},{"location":"#blog","text":"","title":"Blog"},{"location":"#release-120","text":"The 1.2.0 release introduces team-based access control and many internal refactors aimed at easing future development of the product. Dokku has traditionally been a single-tenant PaaS solution, where all users had access to all functionality on the server. While there were community plugins that tackled authentication, each implementation had it's rough edges due to interfaces in Dokku itself. Dokku Pro 1.2.0 polishes those edges while introducing a flexible permission system for organizations that need it. Continue reading","title":"Release 1.2.0"},{"location":"#release-110","text":"The 1.1.0 release is the first substantive update to Dokku Pro, and it brings with it great changes around usability and functionality. Dokku Pro was released in late 2021 to early bird users willing to deal with a bit of pain in exchange for supporting the project and vision. While it technically worked, there were quite a few places for easy improvement, as well as obvious holes in the existing functionality. Dokku Pro 1.1.0 aims to fill some of those needs, laying the groundwork for future enhancements Continue reading","title":"Release 1.1.0"},{"location":"2016/deploying-gogs-to-dokku/","tags":["dokku","ports","gogs","tutorial"],"text":"Hot off the release of Dokku 0.6.3, here is a sweet tutorial made possible by the new port handling feature of Dokku. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. What is Gogs? Gogs (Go Git Service) is a painless self-hosted Git service. But what does that mean? Gogs is a self-hosted git management tool that can be used to host git repositories, issues, and releases on your own server. For this tutorial, we will be deploying gogs to a single Dokku server running at least Dokku 0.6.3. You may upgrade your Dokku instance to this version or install it from scratch. Please setup any ssh keys necessary for pushing applications, as we will not go over initial installation. Application Preparation Let's start by creating an application! While Dokku automatically creates an application on push, we will need to initialize some settings before the application will work, so it's best to do this manually. dokku apps:create gogs Before we continue, lets ensure that the proper domains and ports are setup for gogs. By default, the include Dockerfile exposes ports 3000 and 22 for the http and ssh processes, respectively. We will want our application to listen externally on port 80 , and will need to expose the ssh port on a different port as 22 is used by the host. We will not be using TCP load-balancing in our case, and instead will rely on the docker-options plugin to expose ssh properly. # expose container `http` port 3000 on host `http` port 80 dokku proxy:ports-add gogs http:80:3000 # expose the container port 22 on host port 2222 dokku docker-options:add gogs deploy -p 2222 :22 Next, we need to ensure there is persistent storage for Gogs. The Gogs docker image uses a directory mounted in /data , and we'll need either a docker volume or host directory to contain this data. For our purposes, we'll use a directory on the host. The official recommendation is to place persistent storage in the /var/lib/dokku/data/storage directory for cases where a user is not using a docker volume. As such, we'll create a subdirectory there for our application. # create the directory mkdir -p /var/lib/dokku/data/storage/gogs # ensure the proper permissions are set for the gogs directory chown -R dokku:dokku /var/lib/dokku/data/storage/gogs We can now mount the directory as persistent storage using the official storage plugin. The storage plugin does not check that the directory or volume exists, hence the need to create it beforehand. dokku storage:mount gogs /var/lib/dokku/data/storage/gogs:/data At this point, we need to setup our database for gogs. We will use the official dokku-mysql plugin, though you are welcome to use the dokku-postgres plugin or any other MySQL/Postgres installation you choose. dokku plugin:install https://github.com/dokku/dokku-mysql.git mysql dokku mysql:create gogs dokku mysql:link gogs gogs Pushing our Code Lets clone gogs locally. I have a ~/src directory in which I place all the applications I am currently working on and deploying, though any such directory should be fine. git clone git@github.com:gogits/gogs.git ~/src/gogs When pushing an application, you need to set the dokku host. For the purposes of this tutorial, the hostname of our dokku server is dokku.me . Note that the application name - gogs in this case - should be appended to the remote so that dokku knows what application you are pushing. git remote add dokku dokku@dokku.me:gogs And finally you can trigger a push of the gogs repository to your dokku server. This push will take a while as a few things need to happen: The actual repository needs to be pushed to your server The docker image must be built Not to worry though! Everything from this point on is cake :) git push dokku master Configuring Gogs Here is where it gets slightly tricky. You will want to use the following settings to configure Gogs: MySQL connection information can be retrieved from dokku mysql:info gogs Set the SSH port as 2222 . Gogs will use this to format your projects' SSH connection info in the UI. Do not change the application port. The application url should be changed to match your attached domain. In our case, it would be http://gogs.dokku.me/ The domain field should also be changed to match your attached domain, but without the 'http'. In our case, it would be gogs.dokku.me . This will also be used to format your projects' connection info the UI. Any of the optional settings can be configured as you wish. Once you submit the form, you should have a working Gogs Installation! Wrap-up As we displayed above, Dokku's rich featureset allows developers to quickly and easily setup applications as complex as a git management tool. With it's ability to deploy Dockerfile applications, proxy ports on the fly, and mount persistent storage, Dokku is a great tool to have in your deployment arsenal. Here's hoping it only gets better! If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Tutorial: Deploying Gogs to Dokku"},{"location":"2016/deploying-gogs-to-dokku/#what-is-gogs","text":"Gogs (Go Git Service) is a painless self-hosted Git service. But what does that mean? Gogs is a self-hosted git management tool that can be used to host git repositories, issues, and releases on your own server. For this tutorial, we will be deploying gogs to a single Dokku server running at least Dokku 0.6.3. You may upgrade your Dokku instance to this version or install it from scratch. Please setup any ssh keys necessary for pushing applications, as we will not go over initial installation.","title":"What is Gogs?"},{"location":"2016/deploying-gogs-to-dokku/#application-preparation","text":"Let's start by creating an application! While Dokku automatically creates an application on push, we will need to initialize some settings before the application will work, so it's best to do this manually. dokku apps:create gogs Before we continue, lets ensure that the proper domains and ports are setup for gogs. By default, the include Dockerfile exposes ports 3000 and 22 for the http and ssh processes, respectively. We will want our application to listen externally on port 80 , and will need to expose the ssh port on a different port as 22 is used by the host. We will not be using TCP load-balancing in our case, and instead will rely on the docker-options plugin to expose ssh properly. # expose container `http` port 3000 on host `http` port 80 dokku proxy:ports-add gogs http:80:3000 # expose the container port 22 on host port 2222 dokku docker-options:add gogs deploy -p 2222 :22 Next, we need to ensure there is persistent storage for Gogs. The Gogs docker image uses a directory mounted in /data , and we'll need either a docker volume or host directory to contain this data. For our purposes, we'll use a directory on the host. The official recommendation is to place persistent storage in the /var/lib/dokku/data/storage directory for cases where a user is not using a docker volume. As such, we'll create a subdirectory there for our application. # create the directory mkdir -p /var/lib/dokku/data/storage/gogs # ensure the proper permissions are set for the gogs directory chown -R dokku:dokku /var/lib/dokku/data/storage/gogs We can now mount the directory as persistent storage using the official storage plugin. The storage plugin does not check that the directory or volume exists, hence the need to create it beforehand. dokku storage:mount gogs /var/lib/dokku/data/storage/gogs:/data At this point, we need to setup our database for gogs. We will use the official dokku-mysql plugin, though you are welcome to use the dokku-postgres plugin or any other MySQL/Postgres installation you choose. dokku plugin:install https://github.com/dokku/dokku-mysql.git mysql dokku mysql:create gogs dokku mysql:link gogs gogs","title":"Application Preparation"},{"location":"2016/deploying-gogs-to-dokku/#pushing-our-code","text":"Lets clone gogs locally. I have a ~/src directory in which I place all the applications I am currently working on and deploying, though any such directory should be fine. git clone git@github.com:gogits/gogs.git ~/src/gogs When pushing an application, you need to set the dokku host. For the purposes of this tutorial, the hostname of our dokku server is dokku.me . Note that the application name - gogs in this case - should be appended to the remote so that dokku knows what application you are pushing. git remote add dokku dokku@dokku.me:gogs And finally you can trigger a push of the gogs repository to your dokku server. This push will take a while as a few things need to happen: The actual repository needs to be pushed to your server The docker image must be built Not to worry though! Everything from this point on is cake :) git push dokku master","title":"Pushing our Code"},{"location":"2016/deploying-gogs-to-dokku/#configuring-gogs","text":"Here is where it gets slightly tricky. You will want to use the following settings to configure Gogs: MySQL connection information can be retrieved from dokku mysql:info gogs Set the SSH port as 2222 . Gogs will use this to format your projects' SSH connection info in the UI. Do not change the application port. The application url should be changed to match your attached domain. In our case, it would be http://gogs.dokku.me/ The domain field should also be changed to match your attached domain, but without the 'http'. In our case, it would be gogs.dokku.me . This will also be used to format your projects' connection info the UI. Any of the optional settings can be configured as you wish. Once you submit the form, you should have a working Gogs Installation!","title":"Configuring Gogs"},{"location":"2016/deploying-gogs-to-dokku/#wrap-up","text":"As we displayed above, Dokku's rich featureset allows developers to quickly and easily setup applications as complex as a git management tool. With it's ability to deploy Dockerfile applications, proxy ports on the fly, and mount persistent storage, Dokku is a great tool to have in your deployment arsenal. Here's hoping it only gets better! If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Wrap-up"},{"location":"2016/resource-management/","tags":["dokku","resource-management"],"text":"Every so often, user's ask if it's possible to use Dokku as the basis of a system where each user in Dokku would have access to only their applications. Because of various reasons, this isn't possible out of the box, though it's certainly within the realm of possibility. There are two requirements for such a system, one of which we'll cover here. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. Resource Management A common issue you may come up against is how to limit resource usage for different applications. One user's use of memory should not cause OOM issues in another application. Similarly, you would not want a particular application to hog the network bandwidth unfairly, or saturate disk I/O. These are not new problems to containers, multiple users on a system, or Dokku. These same issues also occur when deploying services directly on a server, or even running applications on your computer. Remember the last time your torrenting application used up all your network and you couldn't load a web page? It's also a solved problem. Applications that tend to use more bandwidth end up implementing quality of service algorithms to ensure your system runs smooth, allow users access to settings which they can modify to crank up/down resource usage, or some combination of the two. Dokku is no different. In Dokku's case, we normally provide users with high-level porcelain to handle the low-level plumbing. This usually comes in the form of plugins (porcelain) which orchestrates docker calls (plumbing). However, we move slowly from the plumbing towards porcelain as we judge just what the requirements are and how to best expose a ui around the given problem. Persistent Storage Take for instance the persistent storage. Dokku has long had plugin hooks, and very specifically implemented the docker-args plugin trigger way back in the 0.2.0 era. Gradually that evolved into the current docker-args-PHASE triggers, with the following phases: build : the container that executes the appropriate buildpack deploy : the container that executes your running/deployed application run : the container that executes any arbitrary command via dokku run myapp We discovered that while providing plugin triggers is great for tinkerers, it wasn't exactly the nicest way to configure docker options. Many users ended up using a plugin by Dyson Simmons , the unofficial docker-options plugin. I even pointed users at it for a while. At some point, we decided to integrate it into the core, and it was implemented in #1080 by Michael Hobbs and released in 0.3.17 . Even back then, the first comment was \"How do I use this to have persistent storage?\" . In retrospect, yes, this is a great feature to have in the core, and the new docker-options plugin was a bit too much like shiny plumbing. While the maintainers were distracted with other issues, the hack-fix was to update the documentation to have persistent storage as the example usage. Dokku implemented this feature in 0.5.0 as the storage plugin thanks to Justin Clark . The interface is a nice piece of porcelain that utilizes the same plugin triggers that the docker-options plugin exposes, except handles the very specific case of attaching persistent storage. It has resulted in many fewer support requests, and I believe has provided developers with a much nicer Dokku experience. Where is the resource porcelain? The Dokku team has yet to see a nice interface to limiting resources of the following kind: Disk I/O RAM usage CPU usage Network I/O These are the common resources which dokku users may wish to limit for specific applications, and having a good ui is more important to us than implementing a feature off the cuff. We also need to consider how such a tool integrates with other Dokku features. The storage plugin works great as a standalone plugin, but it may not be ideal to have a plugin for each type of resource. As well, resource limitation in docker has a few different implementations , depending upon what your exact requirements are. Ideally the Dokku solution is a generic one which 80% of our users are happy with, and the 20% that are not can drop down to plugin triggers or the docker-options plugin. At the end of the day, this porcelain is defined by you, our users. Want this feature sooner rather than later? Submit a pull request with an implementation, and we'll help shepherd it along to a state where everyone will be happy to use it. Alerting on Resource Usage While dokku manages the lifecycle of application containers, it does not and almost certainly will never manage monitoring and alerting on that usage. If your application does not have resource limitations in place, or hasn't run a background task in a while, or maybe just isn't running, that is your responsibility as a server operator to monitor/correct. Our recommendation here is to send logs/metrics to whatever upstream provider of metrics you prefer. Here are some awesome options: DataDog : Server and Application Performance Monitoring Dead Man's Snitch : Make sure your stuff is still running Logentries : Centralized logging and alerting NewRelic : Server and Application Performance Monitoring Papertrail : Centralized logging and alerting Pingdom : Make sure your site is responding to requests As many of our users have never actually maintained a server, we can certainly do more to help push our them in the right direction. In the next few weeks, we will be putting together a document that will gently push our users towards providers that may be able to take care of their needs, as well as clearly delineate where Dokku draws the line in the sand in terms of server management. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Resource Management in Dokku"},{"location":"2016/resource-management/#resource-management","text":"A common issue you may come up against is how to limit resource usage for different applications. One user's use of memory should not cause OOM issues in another application. Similarly, you would not want a particular application to hog the network bandwidth unfairly, or saturate disk I/O. These are not new problems to containers, multiple users on a system, or Dokku. These same issues also occur when deploying services directly on a server, or even running applications on your computer. Remember the last time your torrenting application used up all your network and you couldn't load a web page? It's also a solved problem. Applications that tend to use more bandwidth end up implementing quality of service algorithms to ensure your system runs smooth, allow users access to settings which they can modify to crank up/down resource usage, or some combination of the two. Dokku is no different. In Dokku's case, we normally provide users with high-level porcelain to handle the low-level plumbing. This usually comes in the form of plugins (porcelain) which orchestrates docker calls (plumbing). However, we move slowly from the plumbing towards porcelain as we judge just what the requirements are and how to best expose a ui around the given problem.","title":"Resource Management"},{"location":"2016/resource-management/#persistent-storage","text":"Take for instance the persistent storage. Dokku has long had plugin hooks, and very specifically implemented the docker-args plugin trigger way back in the 0.2.0 era. Gradually that evolved into the current docker-args-PHASE triggers, with the following phases: build : the container that executes the appropriate buildpack deploy : the container that executes your running/deployed application run : the container that executes any arbitrary command via dokku run myapp We discovered that while providing plugin triggers is great for tinkerers, it wasn't exactly the nicest way to configure docker options. Many users ended up using a plugin by Dyson Simmons , the unofficial docker-options plugin. I even pointed users at it for a while. At some point, we decided to integrate it into the core, and it was implemented in #1080 by Michael Hobbs and released in 0.3.17 . Even back then, the first comment was \"How do I use this to have persistent storage?\" . In retrospect, yes, this is a great feature to have in the core, and the new docker-options plugin was a bit too much like shiny plumbing. While the maintainers were distracted with other issues, the hack-fix was to update the documentation to have persistent storage as the example usage. Dokku implemented this feature in 0.5.0 as the storage plugin thanks to Justin Clark . The interface is a nice piece of porcelain that utilizes the same plugin triggers that the docker-options plugin exposes, except handles the very specific case of attaching persistent storage. It has resulted in many fewer support requests, and I believe has provided developers with a much nicer Dokku experience.","title":"Persistent Storage"},{"location":"2016/resource-management/#where-is-the-resource-porcelain","text":"The Dokku team has yet to see a nice interface to limiting resources of the following kind: Disk I/O RAM usage CPU usage Network I/O These are the common resources which dokku users may wish to limit for specific applications, and having a good ui is more important to us than implementing a feature off the cuff. We also need to consider how such a tool integrates with other Dokku features. The storage plugin works great as a standalone plugin, but it may not be ideal to have a plugin for each type of resource. As well, resource limitation in docker has a few different implementations , depending upon what your exact requirements are. Ideally the Dokku solution is a generic one which 80% of our users are happy with, and the 20% that are not can drop down to plugin triggers or the docker-options plugin. At the end of the day, this porcelain is defined by you, our users. Want this feature sooner rather than later? Submit a pull request with an implementation, and we'll help shepherd it along to a state where everyone will be happy to use it.","title":"Where is the resource porcelain?"},{"location":"2016/resource-management/#alerting-on-resource-usage","text":"While dokku manages the lifecycle of application containers, it does not and almost certainly will never manage monitoring and alerting on that usage. If your application does not have resource limitations in place, or hasn't run a background task in a while, or maybe just isn't running, that is your responsibility as a server operator to monitor/correct. Our recommendation here is to send logs/metrics to whatever upstream provider of metrics you prefer. Here are some awesome options: DataDog : Server and Application Performance Monitoring Dead Man's Snitch : Make sure your stuff is still running Logentries : Centralized logging and alerting NewRelic : Server and Application Performance Monitoring Papertrail : Centralized logging and alerting Pingdom : Make sure your site is responding to requests As many of our users have never actually maintained a server, we can certainly do more to help push our them in the right direction. In the next few weeks, we will be putting together a document that will gently push our users towards providers that may be able to take care of their needs, as well as clearly delineate where Dokku draws the line in the sand in terms of server management. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Alerting on Resource Usage"},{"location":"2016/welcome-to-dokku/","tags":["dokku","update"],"text":"Hi all! The dokku maintainers finally decided it was a good idea to have a blog to post thoughts on the development, evolution, and roadmap of Dokku. Our goal with these posts is to help inform you - dokku users and developers - as to where dokku is headed both internally and externally. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. What is dokku? Dokku is a docker-powered PaaS that helps you build and manage the lifecycle of applications. That is the spiel you get from our Site's metadata, the blurb on github, and even the footer on this blog. But what does it actually mean? Dokku is a somewhat loose set of scripts that are combined together as a sort of \"build\" pipeline. The input is your code, and the output is (hopefully) a running application. The pipeline looks something like the following: git push dokku master # magic curl -kSso /dev/null -w \"%{http_code}\" \"http://your-app.example.com\" | grep 200 What is \"magic\" in the dokku pipeline? The \"magic\" comes from several pieces of tech: sshcommand : kicks off the proper dokku command on git push. plugn : allows us to coordinate the stdin/stdout/stderr bits of the pipeline. herokuish : allows us to emulate - to a very high degree - the inner workings of heroku. various scripts that implement the bulk of our feature-set. All three named pieces of software came from the original creator of Dokku, Jeff Lindsay . Both sshcommand and plugn are now wholly maintained by the Dokku Team , while the latter is currently under the care of Glider Labs , with maintenance being done by the Dokku Team as necessary. What are these \"various scripts\"? It's important to note that dokku is by and large composed of shell scripts targeting modern bash. Why? Shell is relatively easy to pick up. Modern bash is available almost everywhere. Interacting with docker was initially only available via shell scripting. Features are built as \"plugins\" which are triggered by plugn . For example, here are a few different official plugins: config : a plugin for managing environment variables. checks : a plugin for checking that your application starts properly before bringing it into rotation. storage : a persistent storage plugin for use with applications that do not (yet) conform to all 12-factor design requirements. Plugins can be built in any language - in fact, some prototypes have been written in a hybrid of golang/bash or python. For the foreseeable future, however, we do not envision rewriting the core in another language. What is the goal of dokku? Dokku's goal is to provide a simple, hackable build environment for developers to quickly get their code from their laptops into the cloud. Our personal goal is to make the deployment part easy, so all you have to do is worry about writing code. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Welcome to Dokku!"},{"location":"2016/welcome-to-dokku/#what-is-dokku","text":"Dokku is a docker-powered PaaS that helps you build and manage the lifecycle of applications. That is the spiel you get from our Site's metadata, the blurb on github, and even the footer on this blog. But what does it actually mean? Dokku is a somewhat loose set of scripts that are combined together as a sort of \"build\" pipeline. The input is your code, and the output is (hopefully) a running application. The pipeline looks something like the following: git push dokku master # magic curl -kSso /dev/null -w \"%{http_code}\" \"http://your-app.example.com\" | grep 200","title":"What is dokku?"},{"location":"2016/welcome-to-dokku/#what-is-magic-in-the-dokku-pipeline","text":"The \"magic\" comes from several pieces of tech: sshcommand : kicks off the proper dokku command on git push. plugn : allows us to coordinate the stdin/stdout/stderr bits of the pipeline. herokuish : allows us to emulate - to a very high degree - the inner workings of heroku. various scripts that implement the bulk of our feature-set. All three named pieces of software came from the original creator of Dokku, Jeff Lindsay . Both sshcommand and plugn are now wholly maintained by the Dokku Team , while the latter is currently under the care of Glider Labs , with maintenance being done by the Dokku Team as necessary.","title":"What is \"magic\" in the dokku pipeline?"},{"location":"2016/welcome-to-dokku/#what-are-these-various-scripts","text":"It's important to note that dokku is by and large composed of shell scripts targeting modern bash. Why? Shell is relatively easy to pick up. Modern bash is available almost everywhere. Interacting with docker was initially only available via shell scripting. Features are built as \"plugins\" which are triggered by plugn . For example, here are a few different official plugins: config : a plugin for managing environment variables. checks : a plugin for checking that your application starts properly before bringing it into rotation. storage : a persistent storage plugin for use with applications that do not (yet) conform to all 12-factor design requirements. Plugins can be built in any language - in fact, some prototypes have been written in a hybrid of golang/bash or python. For the foreseeable future, however, we do not envision rewriting the core in another language.","title":"What are these \"various scripts\"?"},{"location":"2016/welcome-to-dokku/#what-is-the-goal-of-dokku","text":"Dokku's goal is to provide a simple, hackable build environment for developers to quickly get their code from their laptops into the cloud. Our personal goal is to make the deployment part easy, so all you have to do is worry about writing code. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"What is the goal of dokku?"},{"location":"2018/automating-dokku-setup/","tags":["dokku","provisioning","automation"],"text":"When you deploy an app with Dokku, a common workflow is to create an app on git push : git remote add dokku dokku@dokku.me:app git push dokku master This works relatively well, and most folks then stumble through an initial app deploy/configuration cycle. In some cases, a user will create a script to encompass their workflow, or update some document to contain all the commands that were found necessary. However, this fails in at least the following two cases: The existing server fails in some way, and a new server must be provisioned to quickly service all requests. You need to replicate your deployment process on multiple servers/for multiple services. We'll evaluate two patterns to solve these problems, both of which are enabled by Dokku's porcelain interfaces. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. Running Code on Server Boot Regardless of whether this is for a single replacement server, or if it is for a series of servers, running code to provision Dokku and necessary applications at boot time is ideal. Doing so will allow us to reduce the amount of time it takes to recover from service failure, as well as make it easier to do this on a fleet of servers. To this end, we can utilize User Data . \"User Data\" is a bit of configuration that can be run by a process called cloud-init . You should consider cloud-init to be the defacto server initialization tool for cloud servers; many popular server providers support it, such as Amazon Web Services, Azure, Digital Ocean, Google Cloud Provider, Linode, etc. Most folks provide user-data in bash script format, but there are many different modules to integrate with cloud-init . As an example, our own docs for Dreamhost support provide installation instructions in yaml format. Here is the simplest user-data for installing Dokku: #!/bin/bash wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh sudo bash bootstrap.sh Cloud providers generally have a way to specify user data for either a single server or a set of servers being launched, though the method is different depending on the provider. If your provider does not support user data, our recommendation is to switch to one that does. ~~Creating~~ Provisioning an app automatically Taking this further, lets automatically create an app and configure it for deployment when a server starts #!/bin/bash wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh sudo bash bootstrap.sh export APP_NAME = \"node-js-app\" dokku apps:exists \" $APP_NAME \" || dokku apps:create \" $APP_NAME \" dokku config:set \" $APP_NAME \" KEY = value Neat! One thing missing is the initial git clone, which would put our app into service. We can do that with the clone plugin: dokku plugin:install https://github.com/crisward/dokku-clone.git clone dokku clone \" $APP_NAME \" git@github.com:heroku/node-js-sample.git We'll be offering something even fancier soon, but props to Cris Ward for maintaining such a useful plugin! You now have a fully provisioned app on a new server on server boot. Your application downtime with this methodology decreases signficantly, and in many cases, this is enough to keep your business running. For folks using Dokku plugins for datastores, restoring service when all your data was stored on a non-existent server is a longer conversation with no easy solutions. At this time, none of the datastore plugins directly support running in HA mode, though this is something worth investigating. At this time, using managed datastore providers such as AWS RDS, CloudAMQP, etc. are the suggested methods for having HA datastore solutions. A brief introduction to Configuration Management Some of our users may be provisioning quite a few apps to a server, or the same server many times, or even managing a dozen servers for various clients. How do you handle that without a ton of bespoke bash scripts? How do you provision new applications without a tangle of if statements, in a DRY way? There are a few answers, but one common answer is to use a configuration management tool Configuration management tools provide common libraries and patterns for organizing server automation code. There are quite a few different tools in the config management space, but the one we're going show off is Ansible. Ansible requires python to run on a server. Assuming we're on an Ubuntu-based server, the following are roughly the installation instructions: sudo apt-add-repository -y ppa:ansible/ansible sudo apt-get update sudo apt-get install -y ansible Ansible provides an abstraction for executing python modules by writing small bits of yaml. Here is an example for running ansible against the local server. Place the following in a file called dokku.yml --- - hosts : dokku tasks : - name : dokku repo apt_repository : filename : dokku repo : 'deb https://packagecloud.io/dokku/dokku/ubuntu/ {{ ansible_lsb.codename|lower }} main' state : present - name : install dokku apt : pkg : dokku state : installed update_cache : true The above invokes python modules that takes the above as configuration and: creates an apt repository file for dokku ensures dokku is installed, updating the apt cache if apt isn't aware of it To run the above, we'll need to create a hosts file. I've created a dokku group with the IP of the server I'm going to target. [dokku] 127.0.0.1 Now that everything is setup, we can just run the following to execute our provisioning code: ansible-playbook -i hosts -s dokku.yml Provisioning many Dokku apps/servers with Ansible Now that we have a bare minimum ansible setup, we can iterate on this to provision actual Dokku applications. The following will create an app if it does not exist --- - hosts : dokku tasks : - name : does the node-js-app app exist shell : dokku apps:exists node-js-app register : app_exists ignore_errors : True - name : create an app shell : dokku apps:create node-js-app when : app_exists.rc == 1 This is pretty good so far, and uses the built-in shell Ansible libraries to do heavy lifting. However, the following would be much better: --- - hosts : dokku tasks : - name : dokku apps:create node-js-app dokku_app : app : node-js-app The above would use a custom dokku_app Ansible library for provisioning applications, building upon the porcelain we covered previously. While not in the scope of this blog post, I suggest anyone interested in doing so follow along the following tutorial . For our patreon followers, the code for the dokku_app library will be made available, as well as future plans around Ansible integration. Combining the methods into one Assuming we have a repository with our server provisioning code - the yaml and hosts files - we can use the following user-data for automatically setting up a dokku server on boot. #!/bin/bash # install ansible sudo apt-add-repository -y ppa:ansible/ansible sudo apt-get update sudo apt-get install -y ansible git # clone your infra repo git clone git@example.git:infra /tmp/infra # provision the server pushd /tmp/infra > /dev/null ansible-playbook -i hosts -s dokku.yml Going Further Once you have an infra repository containing the provisioning scripts for your servers, the next step is to do all Dokku configuration from this repository. This helps ensure migrating to a new server is as painless as possible, making service restoration a breeze. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Automating Dokku Application Setup with Ansible"},{"location":"2018/automating-dokku-setup/#running-code-on-server-boot","text":"Regardless of whether this is for a single replacement server, or if it is for a series of servers, running code to provision Dokku and necessary applications at boot time is ideal. Doing so will allow us to reduce the amount of time it takes to recover from service failure, as well as make it easier to do this on a fleet of servers. To this end, we can utilize User Data . \"User Data\" is a bit of configuration that can be run by a process called cloud-init . You should consider cloud-init to be the defacto server initialization tool for cloud servers; many popular server providers support it, such as Amazon Web Services, Azure, Digital Ocean, Google Cloud Provider, Linode, etc. Most folks provide user-data in bash script format, but there are many different modules to integrate with cloud-init . As an example, our own docs for Dreamhost support provide installation instructions in yaml format. Here is the simplest user-data for installing Dokku: #!/bin/bash wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh sudo bash bootstrap.sh Cloud providers generally have a way to specify user data for either a single server or a set of servers being launched, though the method is different depending on the provider. If your provider does not support user data, our recommendation is to switch to one that does.","title":"Running Code on Server Boot"},{"location":"2018/automating-dokku-setup/#creating-provisioning-an-app-automatically","text":"Taking this further, lets automatically create an app and configure it for deployment when a server starts #!/bin/bash wget https://raw.githubusercontent.com/dokku/dokku/master/bootstrap.sh sudo bash bootstrap.sh export APP_NAME = \"node-js-app\" dokku apps:exists \" $APP_NAME \" || dokku apps:create \" $APP_NAME \" dokku config:set \" $APP_NAME \" KEY = value Neat! One thing missing is the initial git clone, which would put our app into service. We can do that with the clone plugin: dokku plugin:install https://github.com/crisward/dokku-clone.git clone dokku clone \" $APP_NAME \" git@github.com:heroku/node-js-sample.git We'll be offering something even fancier soon, but props to Cris Ward for maintaining such a useful plugin! You now have a fully provisioned app on a new server on server boot. Your application downtime with this methodology decreases signficantly, and in many cases, this is enough to keep your business running. For folks using Dokku plugins for datastores, restoring service when all your data was stored on a non-existent server is a longer conversation with no easy solutions. At this time, none of the datastore plugins directly support running in HA mode, though this is something worth investigating. At this time, using managed datastore providers such as AWS RDS, CloudAMQP, etc. are the suggested methods for having HA datastore solutions.","title":"~~Creating~~ Provisioning an app automatically"},{"location":"2018/automating-dokku-setup/#a-brief-introduction-to-configuration-management","text":"Some of our users may be provisioning quite a few apps to a server, or the same server many times, or even managing a dozen servers for various clients. How do you handle that without a ton of bespoke bash scripts? How do you provision new applications without a tangle of if statements, in a DRY way? There are a few answers, but one common answer is to use a configuration management tool Configuration management tools provide common libraries and patterns for organizing server automation code. There are quite a few different tools in the config management space, but the one we're going show off is Ansible. Ansible requires python to run on a server. Assuming we're on an Ubuntu-based server, the following are roughly the installation instructions: sudo apt-add-repository -y ppa:ansible/ansible sudo apt-get update sudo apt-get install -y ansible Ansible provides an abstraction for executing python modules by writing small bits of yaml. Here is an example for running ansible against the local server. Place the following in a file called dokku.yml --- - hosts : dokku tasks : - name : dokku repo apt_repository : filename : dokku repo : 'deb https://packagecloud.io/dokku/dokku/ubuntu/ {{ ansible_lsb.codename|lower }} main' state : present - name : install dokku apt : pkg : dokku state : installed update_cache : true The above invokes python modules that takes the above as configuration and: creates an apt repository file for dokku ensures dokku is installed, updating the apt cache if apt isn't aware of it To run the above, we'll need to create a hosts file. I've created a dokku group with the IP of the server I'm going to target. [dokku] 127.0.0.1 Now that everything is setup, we can just run the following to execute our provisioning code: ansible-playbook -i hosts -s dokku.yml","title":"A brief introduction to Configuration Management"},{"location":"2018/automating-dokku-setup/#provisioning-many-dokku-appsservers-with-ansible","text":"Now that we have a bare minimum ansible setup, we can iterate on this to provision actual Dokku applications. The following will create an app if it does not exist --- - hosts : dokku tasks : - name : does the node-js-app app exist shell : dokku apps:exists node-js-app register : app_exists ignore_errors : True - name : create an app shell : dokku apps:create node-js-app when : app_exists.rc == 1 This is pretty good so far, and uses the built-in shell Ansible libraries to do heavy lifting. However, the following would be much better: --- - hosts : dokku tasks : - name : dokku apps:create node-js-app dokku_app : app : node-js-app The above would use a custom dokku_app Ansible library for provisioning applications, building upon the porcelain we covered previously. While not in the scope of this blog post, I suggest anyone interested in doing so follow along the following tutorial . For our patreon followers, the code for the dokku_app library will be made available, as well as future plans around Ansible integration.","title":"Provisioning many Dokku apps/servers with Ansible"},{"location":"2018/automating-dokku-setup/#combining-the-methods-into-one","text":"Assuming we have a repository with our server provisioning code - the yaml and hosts files - we can use the following user-data for automatically setting up a dokku server on boot. #!/bin/bash # install ansible sudo apt-add-repository -y ppa:ansible/ansible sudo apt-get update sudo apt-get install -y ansible git # clone your infra repo git clone git@example.git:infra /tmp/infra # provision the server pushd /tmp/infra > /dev/null ansible-playbook -i hosts -s dokku.yml","title":"Combining the methods into one"},{"location":"2018/automating-dokku-setup/#going-further","text":"Once you have an infra repository containing the provisioning scripts for your servers, the next step is to do all Dokku configuration from this repository. This helps ensure migrating to a new server is as painless as possible, making service restoration a breeze. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Going Further"},{"location":"2018/the-dokku-experience/","tags":["dokku","interfaces"],"text":"Dokku has historically had no way to introspect on the state of an installation. At one point in its history, we included a \"backup\" feature, which allowed users to export - and maybe import - configuration and data. The challenge is in exposing this information in an easily parseable manner. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. Plumbing vs Porcelain To understand the challenges better, it is important to note that the internal representation of the state of Dokku is very different from how users interact with it. Data is stored in either /home/dokku/APP or /var/lib/dokku . Plugins may also store data on another host, and some implementations of the config plugin actually store configuration in distributed datastores. Dokku interacts with this data via a series of plugins - written in various languages - through plugn . This hairy mess is Dokku's Plumbing. Externally, developers use the dokku cli to orchestrate their applications. This is a well-known interface with clear documentation and usage examples. The cli rarely changes drastically, only doing so to allow for new functionality in a way that does not break existing use. The output format also rarely changes in backwards incompatible ways. If you know how to use one Dokku installation from 2 years ago, a modern install will be extremely familiar to you. This nice interface is called the Porcelain. The analogy is thus: most folks using a restroom are well-acquainted with a toilet, every toilet is similar, allowing for differences in color, size, and features - a bidet could be nice, as could an auto-flush feature. Very few folks know anything about the pipes that move waste and water around, only caring when it is broken or needs updating to support newer toilet features. The important thing is that you know how to use the toilet, that it does what you expect, and that you don't need to re-learn how to use it. A Common Interface When you use Dokku, you'll notice a few things: Plugins almost always show help with no specified subcommand. Config is down via :set , and exposed via :report . The primary object being manipulated always comes first, so APP is commonly the first argument. If you use Dokku, you only need to learn those patterns once. It is easy to figure out what is available, and straightforward to introspect upon the state of the system. This translates into the following: Easy decisions around how to expose new functionality (how did we do it the last time?) Decreased support headaches from users getting acquainted with the system (fewer folks hunting for the answer) Delightful experiences for our users! One thing I didn't touch upon is that our output is more or less machine parseable. It is not in json/xml/toml, but you can easily: Hide all extraneous headers and output ( --quiet ) Use flags to grab specific bits of output Split :report output on well-known delimiters ( : ) The consistency here paves the way for automation. Interfacing with Dokku While we have a cli aimed at humans, as developers, we yearn for interfaces computers can automate. Our next blog post will cover how developers may interact with Dokku in a declarative fashion in order to ensure that their servers and applications are configured as expected. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"The Dokku Experience"},{"location":"2018/the-dokku-experience/#plumbing-vs-porcelain","text":"To understand the challenges better, it is important to note that the internal representation of the state of Dokku is very different from how users interact with it. Data is stored in either /home/dokku/APP or /var/lib/dokku . Plugins may also store data on another host, and some implementations of the config plugin actually store configuration in distributed datastores. Dokku interacts with this data via a series of plugins - written in various languages - through plugn . This hairy mess is Dokku's Plumbing. Externally, developers use the dokku cli to orchestrate their applications. This is a well-known interface with clear documentation and usage examples. The cli rarely changes drastically, only doing so to allow for new functionality in a way that does not break existing use. The output format also rarely changes in backwards incompatible ways. If you know how to use one Dokku installation from 2 years ago, a modern install will be extremely familiar to you. This nice interface is called the Porcelain. The analogy is thus: most folks using a restroom are well-acquainted with a toilet, every toilet is similar, allowing for differences in color, size, and features - a bidet could be nice, as could an auto-flush feature. Very few folks know anything about the pipes that move waste and water around, only caring when it is broken or needs updating to support newer toilet features. The important thing is that you know how to use the toilet, that it does what you expect, and that you don't need to re-learn how to use it.","title":"Plumbing vs Porcelain"},{"location":"2018/the-dokku-experience/#a-common-interface","text":"When you use Dokku, you'll notice a few things: Plugins almost always show help with no specified subcommand. Config is down via :set , and exposed via :report . The primary object being manipulated always comes first, so APP is commonly the first argument. If you use Dokku, you only need to learn those patterns once. It is easy to figure out what is available, and straightforward to introspect upon the state of the system. This translates into the following: Easy decisions around how to expose new functionality (how did we do it the last time?) Decreased support headaches from users getting acquainted with the system (fewer folks hunting for the answer) Delightful experiences for our users! One thing I didn't touch upon is that our output is more or less machine parseable. It is not in json/xml/toml, but you can easily: Hide all extraneous headers and output ( --quiet ) Use flags to grab specific bits of output Split :report output on well-known delimiters ( : ) The consistency here paves the way for automation.","title":"A Common Interface"},{"location":"2018/the-dokku-experience/#interfacing-with-dokku","text":"While we have a cli aimed at humans, as developers, we yearn for interfaces computers can automate. Our next blog post will cover how developers may interact with Dokku in a declarative fashion in order to ensure that their servers and applications are configured as expected. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Interfacing with Dokku"},{"location":"2020/comparing-buildpack-v3-to-herokuish/","tags":["dokku","buildpacks","herokuish"],"text":"An upcoming piece of technology in the container space is Cloud Native Buildpacks (CNB). This is an initiative led by Pivotal and Heroku and contributed to by a wide range of community members, and one that the Dokku project has been following fairly closely. CNB builds upon the buildpack \"standard\" initially developed at Heroku, modified at Pivotal for Cloud Foundry, and used/abused by the gliderlabs/herokuish project. This post goes over a small amount of history, compares buildpack implementations across vendors, and talks about the future of buildpacks as they relate to Dokku. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. History Channel Vault When Heroku first launched, they provided support for Rack applications, which worked fairly well for the budding Ruby community. As the Ruby community grew, this initial support started to become limiting for their users, and thus the Heroku community started reworking their internal tech to be more flexible in functionality they supported and how they launched processes, In fact, a lot of the fancy features and patterns you'll see in a modern PaaS - 12 factor apps, Procfile support, etc. - were first prototyped or promoted by Heroku. The process of detecting support, building app slugs, and releasing the built artifacts was one such initiative. Eventually, Heroku rebuilt their platform to support alternative programming runtimes as well as community contributed runtimes in what is now known as a buildpacks. As time marched on, the Cloud Foundry software from Pivotal picked up the buildpack tech. This would seem like an overall great thing for the community - buildpacks that have better support for enterprise environments and needs would certainly help with adoption in the corporate world - but ended up being not as great. As there was no real specification for Buildpack technology, Pivotal ended up diverging from Heroku's implementation, resulting in: Buildpack v2a: Heroku-style buildpacks Buildpack v2b: Cloud Foundry-style buildpacks For buildpack authors, the standards were largely compatible - and it would likely be possible to support both at once - but in practice you really only wrote a buildpack for the platform you were using. This also meant that new features for, say, the NodeJs buildpack would need to be implemented twice in order to be supported on these two platforms. Additionally, the buildpack spec never specified anything about the underlying platform, so building a buildpack for Heroku's platform that depends on some OS-level dependency might not work at all when used with Cloud Foundry or vice versa. Suffice to say, this divergence isn't great for the community, nor great for pushing the technology forward. I'll skip all the details - mostly because I don't know them! - but the emergence of containers and related technologies enabled the folks at Heroku and Pivotal to combine efforts to on a unified v3 specification, which is now CNB. Think of it as two mini lion bots coming together to form one super-bot! Comparing Buildpack tech While the new specification - still under development - provides a new, unified way to create and distribute buildpacks, there can still be differences between platforms. At this point in time, there are actually two different main \"builders\" - a collection of buildpacks - that folks in the community can use to play around with CNBs (both are based on the Bionic stack). They do provide slightly different functionality, so a comparison between them seems like a reasonable thing to do. We'll also compare CNBs to gliderlabs/herokuish , which is the main OSS implementation of the buildpack v2a technology. At the time of writing, Heroku's builder contains v2a buildpacks with a shim to allow them to run under the v3 specification. Additionally, there is a possibility that the organizations will collaborate on buildpacks in the future - who wants to rebuild the wheel? - but this is sort of all in the air. Please keep this in mind if reading this blog post a few months/years from the time of publication. Installing dependencies For local testing, the CNB project provides the pack cli tool to simulate what would be available in a platform. There are related projects for Kubernetes and other tools in the deployment space, but pack is great for local testing, so we'll want to install that. # on a mac with homebrew brew install buildpacks/tap/pack # everywhere else, go to the following page and download a release # https://github.com/buildpacks/pack/releases CNB splits buildpacks such that there is a \"build\" base image and a \"run\" base image. Apps are built within the build base image and then the layers are rebased onto the run image for distribution. This allows for the distributed image to be smaller in size, as well as avoids the need for distribution of compile-time dependencies. Both of these images need to be available on the machine that is running the build process. # cloudfoundry docker image pull cloudfoundry/cnb:latest # build docker image pull cloudfoundry/run:full-cnb # run # heroku docker image pull heroku/buildpacks:18 # build docker image pull heroku/pack:18 # run On the herokuish side, there is a single image that contains both compile and runtime dependencies. You can export a slug from the built image and run that on a system without the installed runtime dependencies, but in practice very few people do so. docker image pull gliderlabs/herokuish:latest # build and run Neither Cloud Foundry nor Heroku currently publish a Dockerfile for their images, so they are still somewhat of a black box. It's also not super clear from the documentation as to what the bionic stack is. We can only hope - but not assume - that these will be published for public recreation in the future. Building apps The app we'll be playing with is the node-js-getting-started app by Heroku. You can play around with your own app to see the results; also NodeJs is currently supported with both builders as well as the gliderlabs/herokuish project. With CNB Building an app with CNB is the same regardless of your chosen builder, which is nice. The following command will build the app in the current directory with the Cloud Foundry builder: pack set-default-builder cloudfoundry/cnb:latest pack build --no-pull --path . \"app/nodejs-cloudfoundry:latest\" Whereas utilizing the Heroku builder is not much different: pack set-default-builder heroku/buildpacks:18 pack build --no-pull --path . \"app/nodejs-heroku:latest\" Note that there is a volume cache used for dependencies for both buildpacks. At the time of writing, this can be computed like so: IMAGE = \"app/nodejs-cloudfoundry:latest\" CACHE_VOLUME = \"pack-cache- $( echo -n \"index.docker.io/ $IMAGE \" | sha256sum | cut -c1-12 ) .build\" At the time of writing, there isn't a way to clear out that cache volume, so you can use the above method to compute the volume name. Please note that clearing this cache volume does not necessarily clear out any app image layers created, so this may not do exactly as you'd expect if you are interacting with a remote registry. If you are rebuilding an app using pack, you'll notice that there doesn't appear to be any caching with the Heroku builder. This might be a bug due to shim usage, and will likely be resolved in the future, but for now should expect this to be the case. As an aside, the buildpacks/lifecycle project - and therefore pack - creates OCI compatible images, so tooling that only works with the older Docker Image Specification may fail when using pack-built images. With Herokuish Building an image with gliderlabs/herokuish is a bit more complicated. While it is distributed as a binary and a docker image, most folks default to using the docker image. Some platforms - notably Gitlab - utilize it via a Dockerfile , but this doesn't allow you to take advantage of build cache. The below simulates the patterns used by the pack cli tool: # use a cache volume # this can also be substituted with a directory on disk CACHE_VOLUME = \"pack-cache- $( echo -n \"index.docker.io/ $IMAGE \" | sha256sum | cut -c1-12 ) .build\" docker volume rm $CACHE_VOLUME >/dev/null 2 > & 1 || true docker volume create $CACHE_VOLUME >/dev/null # run the build process IMAGE = \"app/nodejs-herokuish:latest\" docker container run --cidfile /tmp/cid --env USER = herokuishuser -v \" ${ CACHE_VOLUME } :/tmp/cache\" -v $PWD :/tmp/app gliderlabs/herokuish:latest /bin/herokuish buildpack build # create your final image docker container commit $( cat /tmp/cid ) \" $IMAGE \" # cleanup docker container rm $( cat /tmp/cid ) rm -f /tmp/cid Running an app This part is likely the most similar thing across all platforms. Both the CNB images utilize a special launcher process to run your process type for you, so all you really need to do is specify that process type. # cloudfoundry docker container run -d -p 5000 --env PORT = 5000 --name app.nodejs.cloudfoundry app/nodejs-cloudfoundry:latest web Docker log output on that container looks something like the following: > node-js-getting-started@0.3.0 start /workspace > node index.js Listening on 5000 Heroku is pretty similar # heroku docker container run -d -p 5000 --env PORT = 5000 --name app.nodejs.heroku app/nodejs-heroku:latest web Listening on 5000 With herokuish, you need to execute the process type with the /start prefix. We also need to specify the USER , as this will be used by herokuish to properly set file permissions on the /app directory. docker container run -d -p 5000 --env PORT = 5000 --env USER = herokuishuser --name app.nodejs.herokuish app/nodejs-herokuish:latest /start web Listening on 5000 Startup time is a bit longer with herokuish as it will change ownership on files within the /app directory. Another difference between the two is the environment within which both images run in, which we'll get into next. Inspecting the built image Once we have a running app, lets inspect our artifact. With CNB Executing a command on the CNB-backed containers is the same as executing a command with any other docker image. Processes are automatically invoked within the correct app environment, which is great for one-off commands. # cloudfoundry docker container exec app.nodejs.cloudfoundry id uid=2000(vcap) gid=2000(vcap) groups=2000(vcap) # heroku docker container exec app.nodejs.heroku id uid=1000(heroku) gid=1000(heroku) groups=1000(heroku) Ditto for process inspection: # cloudfoundry docker container exec app.nodejs.cloudfoundry ps auxf USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND vcap 35 0.0 0.1 34404 2856 ? Rs 02:43 0:00 ps auxf vcap 1 1.2 2.2 739020 45136 ? Ssl 02:43 0:00 npm vcap 22 0.0 0.0 4632 828 ? S 02:43 0:00 sh -c node index.js vcap 23 0.6 2.0 573156 41896 ? Sl 02:43 0:00 \\_ node index.js # heroku docker container exec app.nodejs.heroku ps auxf USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND heroku 22 0.0 0.1 34404 2856 ? Rs 02:47 0:00 ps auxf heroku 1 0.9 1.7 566792 36728 ? Ssl 02:46 0:00 node index.js Please bear in mind that PID 1 in the container will depend upon what the buildpack launches. Aside from that note, there is nothing new with CNB and pack in regards to running commands when compared to normal docker operations, so anyone familiar with Docker will feel right at home. With Herokuish On the herokuish platform, a process must be executed with the /exec command as a prefix. This will give you an environment that simulates running a command in the heroku stack. docker container exec app.nodejs.herokuish /exec id The output of the above command is: uid=32767(herokuishuser) gid=32767(herokuishuser) groups=32767(herokuishuser) Inspecting processes is pretty similar: docker container exec app.nodejs.herokuish /exec ps auxf USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 287 0.0 0.1 5628 2448 ? Ssl 02:57 0:00 /exec ps auxf herokui+ 298 0.0 0.1 34404 2844 ? R 02:57 0:00 \\_ ps auxf root 1 0.2 0.1 5628 2448 ? Ssl 02:57 0:00 /start web herokui+ 13 2.7 1.9 566160 40020 ? Sl 02:57 0:00 node index.js You'll notice that, in addition to your app, there is also the /start web process. This spawns your app with the correct environment, so just a bit different from CNB containers. Cleaning up Removing the containers and images is relatively straightforward, as we use traditional docker commands. # cloudfoundry IMAGE = \"app/nodejs-cloudfoundry:latest\" CACHE_VOLUME = \"pack-cache- $( echo -n \"index.docker.io/ $IMAGE \" | sha256sum | cut -c1-12 ) .build\" docker volume rm $CACHE_VOLUME >/dev/null 2 > & 1 || true docker container rm -f app.nodejs.cloudfoundry >/dev/null 2 > & 1 || true docker image rm cloudfoundry/run:base-cnb cloudfoundry/run:full-cnb cloudfoundry/cnb:latest >/dev/null 2 > & 1 || true docker image rm app/nodejs-cloudfoundry:latest >/dev/null 2 > & 1 || true # heroku IMAGE = \"app/nodejs-heroku:latest\" CACHE_VOLUME = \"pack-cache- $( echo -n \"index.docker.io/ $IMAGE \" | sha256sum | cut -c1-12 ) .build\" docker volume rm $CACHE_VOLUME >/dev/null 2 > & 1 || true docker container rm -f app.nodejs.heroku >/dev/null 2 > & 1 || true docker image rm heroku/pack:18 heroku/buildpacks:18 >/dev/null 2 > & 1 || true docker image rm app/nodejs-heroku:latest >/dev/null 2 > & 1 || true # herokuish IMAGE = \"app/nodejs-herokuish:latest\" CACHE_VOLUME = \"pack-cache- $( echo -n \"index.docker.io/ $IMAGE \" | sha256sum | cut -c1-12 ) .build\" docker volume rm $CACHE_VOLUME >/dev/null 2 > & 1 || true docker container rm -f app.nodejs.herokuish >/dev/null 2 > & 1 || true docker image rm gliderlabs/herokuish:latest >/dev/null 2 > & 1 || true docker image rm app/nodejs-herokuish:latest >/dev/null 2 > & 1 || true Dokku and Cloud Native Buildpacks In an ideal world, all the functionality currently provided by Heroku's v2a Buildpacks and its ecosystem would immediately exist with Cloud Native Buildpacks. Unfortunately, the spec is still evolving - though nearing a v1! - and the user-base is comparatively small. If you are a buildpack author or a vendor using buildpack technology, now is likely the best time to get involved and raise concerns with the spec and ecosystem. That said, Dokku has active development towards the addition of CNB to the platform. In our case, we will likely have it as an experimental feature controlled through the use of environment variables, and folks will be able to switch their installations between CNB and Herokuish. This will also likely require changes to certain plugins - in particular, those that interact with the built images - but these will hopefully be fairly minimal. Long-term, the plan is to deprecate and eventually remove gliderlabs/herokuish support. The purpose of the Herokuish project was to allow folks to emulate the Heroku build/runtime environment. Heroku - amongst others - will be moving to CNB at some point, and already provide a shim for existing buildpacks in the new system. So in theory, any CNB platform would be able to use that shim + any tooling that supports CNB for buildpack support. The pack cli tool already provides a way for folks to build and run applications, and analogs for most herokuish cli commands. Given that: pack already exists Can support existing v2a buildpacks via shim (Heroku Buildpacks) Is actively maintained by the CNB folks and a larger community Can run inside of a container with a socket mounted, similar to how herokuish runs The best course of action is for Herokuish to become unsupported once pack hits a stable release. It is unlikely that support for Herokuish will continue at that point, and only general maintenance work (upgrading buildpacks) would be performed at that time. Long-term, the project will likely be archived completely in favor of the upstream CNB projects. There isn't any timeline for the above other than experimental support for CNB in Dokku will land at some point in the near future, so folks installing and using Dokku won't need to worry too much about the process. Long-term, there will be a migration path outlined for users, and how that impacts users will depend on how much tooling is necessary to shim in the existing ecosystem around buildpacks. We hope to keep this minimal, but sometimes you need to break some eggs to make an omelette. Cloud Native Buildpacks are the future The Dokku project is incredibly excited about Cloud Native Buildpacks and it's implications for speeding up how we build secure applications and services. While the existing community is fairly small, the contributors are very dedicated to getting everything just right, and we expect that this will be a great boon to users of both Dokku and buildpacks in general. If you'd like to have a say in how the CNB initiative develops, please feel free to join in with development or comment in the Slack community - they are a bunch of very friendly folks - where much of the current development is focused. Blog: https://medium.com/buildpacks Github: https://github.com/buildpacks Mailing List: https://lists.cncf.io/g/cncf-buildpacks Site: https://buildpacks.io/ Slack: https://slack.buildpacks.io/ Twitter: https://twitter.com/buildpacks_io If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Comparing Cloud Native Buildpacks to Herokuish"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#history-channel-vault","text":"When Heroku first launched, they provided support for Rack applications, which worked fairly well for the budding Ruby community. As the Ruby community grew, this initial support started to become limiting for their users, and thus the Heroku community started reworking their internal tech to be more flexible in functionality they supported and how they launched processes, In fact, a lot of the fancy features and patterns you'll see in a modern PaaS - 12 factor apps, Procfile support, etc. - were first prototyped or promoted by Heroku. The process of detecting support, building app slugs, and releasing the built artifacts was one such initiative. Eventually, Heroku rebuilt their platform to support alternative programming runtimes as well as community contributed runtimes in what is now known as a buildpacks. As time marched on, the Cloud Foundry software from Pivotal picked up the buildpack tech. This would seem like an overall great thing for the community - buildpacks that have better support for enterprise environments and needs would certainly help with adoption in the corporate world - but ended up being not as great. As there was no real specification for Buildpack technology, Pivotal ended up diverging from Heroku's implementation, resulting in: Buildpack v2a: Heroku-style buildpacks Buildpack v2b: Cloud Foundry-style buildpacks For buildpack authors, the standards were largely compatible - and it would likely be possible to support both at once - but in practice you really only wrote a buildpack for the platform you were using. This also meant that new features for, say, the NodeJs buildpack would need to be implemented twice in order to be supported on these two platforms. Additionally, the buildpack spec never specified anything about the underlying platform, so building a buildpack for Heroku's platform that depends on some OS-level dependency might not work at all when used with Cloud Foundry or vice versa. Suffice to say, this divergence isn't great for the community, nor great for pushing the technology forward. I'll skip all the details - mostly because I don't know them! - but the emergence of containers and related technologies enabled the folks at Heroku and Pivotal to combine efforts to on a unified v3 specification, which is now CNB. Think of it as two mini lion bots coming together to form one super-bot!","title":"History Channel Vault"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#comparing-buildpack-tech","text":"While the new specification - still under development - provides a new, unified way to create and distribute buildpacks, there can still be differences between platforms. At this point in time, there are actually two different main \"builders\" - a collection of buildpacks - that folks in the community can use to play around with CNBs (both are based on the Bionic stack). They do provide slightly different functionality, so a comparison between them seems like a reasonable thing to do. We'll also compare CNBs to gliderlabs/herokuish , which is the main OSS implementation of the buildpack v2a technology. At the time of writing, Heroku's builder contains v2a buildpacks with a shim to allow them to run under the v3 specification. Additionally, there is a possibility that the organizations will collaborate on buildpacks in the future - who wants to rebuild the wheel? - but this is sort of all in the air. Please keep this in mind if reading this blog post a few months/years from the time of publication.","title":"Comparing Buildpack tech"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#installing-dependencies","text":"For local testing, the CNB project provides the pack cli tool to simulate what would be available in a platform. There are related projects for Kubernetes and other tools in the deployment space, but pack is great for local testing, so we'll want to install that. # on a mac with homebrew brew install buildpacks/tap/pack # everywhere else, go to the following page and download a release # https://github.com/buildpacks/pack/releases CNB splits buildpacks such that there is a \"build\" base image and a \"run\" base image. Apps are built within the build base image and then the layers are rebased onto the run image for distribution. This allows for the distributed image to be smaller in size, as well as avoids the need for distribution of compile-time dependencies. Both of these images need to be available on the machine that is running the build process. # cloudfoundry docker image pull cloudfoundry/cnb:latest # build docker image pull cloudfoundry/run:full-cnb # run # heroku docker image pull heroku/buildpacks:18 # build docker image pull heroku/pack:18 # run On the herokuish side, there is a single image that contains both compile and runtime dependencies. You can export a slug from the built image and run that on a system without the installed runtime dependencies, but in practice very few people do so. docker image pull gliderlabs/herokuish:latest # build and run Neither Cloud Foundry nor Heroku currently publish a Dockerfile for their images, so they are still somewhat of a black box. It's also not super clear from the documentation as to what the bionic stack is. We can only hope - but not assume - that these will be published for public recreation in the future.","title":"Installing dependencies"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#building-apps","text":"The app we'll be playing with is the node-js-getting-started app by Heroku. You can play around with your own app to see the results; also NodeJs is currently supported with both builders as well as the gliderlabs/herokuish project.","title":"Building apps"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#with-cnb","text":"Building an app with CNB is the same regardless of your chosen builder, which is nice. The following command will build the app in the current directory with the Cloud Foundry builder: pack set-default-builder cloudfoundry/cnb:latest pack build --no-pull --path . \"app/nodejs-cloudfoundry:latest\" Whereas utilizing the Heroku builder is not much different: pack set-default-builder heroku/buildpacks:18 pack build --no-pull --path . \"app/nodejs-heroku:latest\" Note that there is a volume cache used for dependencies for both buildpacks. At the time of writing, this can be computed like so: IMAGE = \"app/nodejs-cloudfoundry:latest\" CACHE_VOLUME = \"pack-cache- $( echo -n \"index.docker.io/ $IMAGE \" | sha256sum | cut -c1-12 ) .build\" At the time of writing, there isn't a way to clear out that cache volume, so you can use the above method to compute the volume name. Please note that clearing this cache volume does not necessarily clear out any app image layers created, so this may not do exactly as you'd expect if you are interacting with a remote registry. If you are rebuilding an app using pack, you'll notice that there doesn't appear to be any caching with the Heroku builder. This might be a bug due to shim usage, and will likely be resolved in the future, but for now should expect this to be the case. As an aside, the buildpacks/lifecycle project - and therefore pack - creates OCI compatible images, so tooling that only works with the older Docker Image Specification may fail when using pack-built images.","title":"With CNB"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#with-herokuish","text":"Building an image with gliderlabs/herokuish is a bit more complicated. While it is distributed as a binary and a docker image, most folks default to using the docker image. Some platforms - notably Gitlab - utilize it via a Dockerfile , but this doesn't allow you to take advantage of build cache. The below simulates the patterns used by the pack cli tool: # use a cache volume # this can also be substituted with a directory on disk CACHE_VOLUME = \"pack-cache- $( echo -n \"index.docker.io/ $IMAGE \" | sha256sum | cut -c1-12 ) .build\" docker volume rm $CACHE_VOLUME >/dev/null 2 > & 1 || true docker volume create $CACHE_VOLUME >/dev/null # run the build process IMAGE = \"app/nodejs-herokuish:latest\" docker container run --cidfile /tmp/cid --env USER = herokuishuser -v \" ${ CACHE_VOLUME } :/tmp/cache\" -v $PWD :/tmp/app gliderlabs/herokuish:latest /bin/herokuish buildpack build # create your final image docker container commit $( cat /tmp/cid ) \" $IMAGE \" # cleanup docker container rm $( cat /tmp/cid ) rm -f /tmp/cid","title":"With Herokuish"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#running-an-app","text":"This part is likely the most similar thing across all platforms. Both the CNB images utilize a special launcher process to run your process type for you, so all you really need to do is specify that process type. # cloudfoundry docker container run -d -p 5000 --env PORT = 5000 --name app.nodejs.cloudfoundry app/nodejs-cloudfoundry:latest web Docker log output on that container looks something like the following: > node-js-getting-started@0.3.0 start /workspace > node index.js Listening on 5000 Heroku is pretty similar # heroku docker container run -d -p 5000 --env PORT = 5000 --name app.nodejs.heroku app/nodejs-heroku:latest web Listening on 5000 With herokuish, you need to execute the process type with the /start prefix. We also need to specify the USER , as this will be used by herokuish to properly set file permissions on the /app directory. docker container run -d -p 5000 --env PORT = 5000 --env USER = herokuishuser --name app.nodejs.herokuish app/nodejs-herokuish:latest /start web Listening on 5000 Startup time is a bit longer with herokuish as it will change ownership on files within the /app directory. Another difference between the two is the environment within which both images run in, which we'll get into next.","title":"Running an app"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#inspecting-the-built-image","text":"Once we have a running app, lets inspect our artifact.","title":"Inspecting the built image"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#with-cnb_1","text":"Executing a command on the CNB-backed containers is the same as executing a command with any other docker image. Processes are automatically invoked within the correct app environment, which is great for one-off commands. # cloudfoundry docker container exec app.nodejs.cloudfoundry id uid=2000(vcap) gid=2000(vcap) groups=2000(vcap) # heroku docker container exec app.nodejs.heroku id uid=1000(heroku) gid=1000(heroku) groups=1000(heroku) Ditto for process inspection: # cloudfoundry docker container exec app.nodejs.cloudfoundry ps auxf USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND vcap 35 0.0 0.1 34404 2856 ? Rs 02:43 0:00 ps auxf vcap 1 1.2 2.2 739020 45136 ? Ssl 02:43 0:00 npm vcap 22 0.0 0.0 4632 828 ? S 02:43 0:00 sh -c node index.js vcap 23 0.6 2.0 573156 41896 ? Sl 02:43 0:00 \\_ node index.js # heroku docker container exec app.nodejs.heroku ps auxf USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND heroku 22 0.0 0.1 34404 2856 ? Rs 02:47 0:00 ps auxf heroku 1 0.9 1.7 566792 36728 ? Ssl 02:46 0:00 node index.js Please bear in mind that PID 1 in the container will depend upon what the buildpack launches. Aside from that note, there is nothing new with CNB and pack in regards to running commands when compared to normal docker operations, so anyone familiar with Docker will feel right at home.","title":"With CNB"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#with-herokuish_1","text":"On the herokuish platform, a process must be executed with the /exec command as a prefix. This will give you an environment that simulates running a command in the heroku stack. docker container exec app.nodejs.herokuish /exec id The output of the above command is: uid=32767(herokuishuser) gid=32767(herokuishuser) groups=32767(herokuishuser) Inspecting processes is pretty similar: docker container exec app.nodejs.herokuish /exec ps auxf USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 287 0.0 0.1 5628 2448 ? Ssl 02:57 0:00 /exec ps auxf herokui+ 298 0.0 0.1 34404 2844 ? R 02:57 0:00 \\_ ps auxf root 1 0.2 0.1 5628 2448 ? Ssl 02:57 0:00 /start web herokui+ 13 2.7 1.9 566160 40020 ? Sl 02:57 0:00 node index.js You'll notice that, in addition to your app, there is also the /start web process. This spawns your app with the correct environment, so just a bit different from CNB containers.","title":"With Herokuish"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#cleaning-up","text":"Removing the containers and images is relatively straightforward, as we use traditional docker commands. # cloudfoundry IMAGE = \"app/nodejs-cloudfoundry:latest\" CACHE_VOLUME = \"pack-cache- $( echo -n \"index.docker.io/ $IMAGE \" | sha256sum | cut -c1-12 ) .build\" docker volume rm $CACHE_VOLUME >/dev/null 2 > & 1 || true docker container rm -f app.nodejs.cloudfoundry >/dev/null 2 > & 1 || true docker image rm cloudfoundry/run:base-cnb cloudfoundry/run:full-cnb cloudfoundry/cnb:latest >/dev/null 2 > & 1 || true docker image rm app/nodejs-cloudfoundry:latest >/dev/null 2 > & 1 || true # heroku IMAGE = \"app/nodejs-heroku:latest\" CACHE_VOLUME = \"pack-cache- $( echo -n \"index.docker.io/ $IMAGE \" | sha256sum | cut -c1-12 ) .build\" docker volume rm $CACHE_VOLUME >/dev/null 2 > & 1 || true docker container rm -f app.nodejs.heroku >/dev/null 2 > & 1 || true docker image rm heroku/pack:18 heroku/buildpacks:18 >/dev/null 2 > & 1 || true docker image rm app/nodejs-heroku:latest >/dev/null 2 > & 1 || true # herokuish IMAGE = \"app/nodejs-herokuish:latest\" CACHE_VOLUME = \"pack-cache- $( echo -n \"index.docker.io/ $IMAGE \" | sha256sum | cut -c1-12 ) .build\" docker volume rm $CACHE_VOLUME >/dev/null 2 > & 1 || true docker container rm -f app.nodejs.herokuish >/dev/null 2 > & 1 || true docker image rm gliderlabs/herokuish:latest >/dev/null 2 > & 1 || true docker image rm app/nodejs-herokuish:latest >/dev/null 2 > & 1 || true","title":"Cleaning up"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#dokku-and-cloud-native-buildpacks","text":"In an ideal world, all the functionality currently provided by Heroku's v2a Buildpacks and its ecosystem would immediately exist with Cloud Native Buildpacks. Unfortunately, the spec is still evolving - though nearing a v1! - and the user-base is comparatively small. If you are a buildpack author or a vendor using buildpack technology, now is likely the best time to get involved and raise concerns with the spec and ecosystem. That said, Dokku has active development towards the addition of CNB to the platform. In our case, we will likely have it as an experimental feature controlled through the use of environment variables, and folks will be able to switch their installations between CNB and Herokuish. This will also likely require changes to certain plugins - in particular, those that interact with the built images - but these will hopefully be fairly minimal. Long-term, the plan is to deprecate and eventually remove gliderlabs/herokuish support. The purpose of the Herokuish project was to allow folks to emulate the Heroku build/runtime environment. Heroku - amongst others - will be moving to CNB at some point, and already provide a shim for existing buildpacks in the new system. So in theory, any CNB platform would be able to use that shim + any tooling that supports CNB for buildpack support. The pack cli tool already provides a way for folks to build and run applications, and analogs for most herokuish cli commands. Given that: pack already exists Can support existing v2a buildpacks via shim (Heroku Buildpacks) Is actively maintained by the CNB folks and a larger community Can run inside of a container with a socket mounted, similar to how herokuish runs The best course of action is for Herokuish to become unsupported once pack hits a stable release. It is unlikely that support for Herokuish will continue at that point, and only general maintenance work (upgrading buildpacks) would be performed at that time. Long-term, the project will likely be archived completely in favor of the upstream CNB projects. There isn't any timeline for the above other than experimental support for CNB in Dokku will land at some point in the near future, so folks installing and using Dokku won't need to worry too much about the process. Long-term, there will be a migration path outlined for users, and how that impacts users will depend on how much tooling is necessary to shim in the existing ecosystem around buildpacks. We hope to keep this minimal, but sometimes you need to break some eggs to make an omelette.","title":"Dokku and Cloud Native Buildpacks"},{"location":"2020/comparing-buildpack-v3-to-herokuish/#cloud-native-buildpacks-are-the-future","text":"The Dokku project is incredibly excited about Cloud Native Buildpacks and it's implications for speeding up how we build secure applications and services. While the existing community is fairly small, the contributors are very dedicated to getting everything just right, and we expect that this will be a great boon to users of both Dokku and buildpacks in general. If you'd like to have a say in how the CNB initiative develops, please feel free to join in with development or comment in the Slack community - they are a bunch of very friendly folks - where much of the current development is focused. Blog: https://medium.com/buildpacks Github: https://github.com/buildpacks Mailing List: https://lists.cncf.io/g/cncf-buildpacks Site: https://buildpacks.io/ Slack: https://slack.buildpacks.io/ Twitter: https://twitter.com/buildpacks_io If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Cloud Native Buildpacks are the future"},{"location":"2020/dokku-0.20.0/","tags":["dokku","release"],"text":"Dokku version 0.20.0 - and a few follow-on bugfixes - was released this week with quite a few major improvements, mostly to proxying and networking. We'll go over major changes below. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. Changes! Code Deprecations and Removals As noted in the migration guide , we removed quite a few default commands. These were replaced with :help output, and :list commands were provided where possible. We've also dropped support for unsupported versions of Debian and Ubuntu. Dokku no longer runs tests on older versions of Ubuntu, and Debian support for older releases was completely untested. While newer packages may work in the future, users should upgrade their operating systems where possible. Finally, quite a bit of code was moved into golang, and as such certain shell functions are deprecated in favor of new plugin triggers . Usage will trigger warnings in logging output. Please switch to the new triggers in custom plugins where possible, as we well continue to remove deprecated code in the future. Custom networks In previous versions of Dokku, containers could only communicate with each other through one of the following methods: An intermediate datastore, whether that be a database, queuing system, or caching layer. Open network Adding --network docker-options flag The first option was great for apps that were architected to do message passing, but almost a non-starter for certain self-hosted apps. Even for new apps, adding an intermediate communication layer will always increase the number of problems that could occur in a system, so it was far from optimal. Sending traffic over the open network is not great as for many users, this would mean traffic over the internet. Sending traffic over the open network increases latency between requests, increases bandwidth usage - and costs! - and opens users to potential security issues regardless of SSL encryption. Suffice to say that this was also not a great solution. Adding a custom --network flag via the docker-options plugin works well enough but has a few issues itself: Does not allow for multiple networks Disables nginx traffic proxying Not great from a UX perspective A user created a custom plugin to attach on to networks after deploy, but this also has the side effect of not supporting containers that need to talk to a specific network on boot. With the new network support added in 0.20.0, users can easily create/destroy attachable docker networks, and ensure apps attach to those networks at the correct time for their apps via two easy-to-configure hooks. From the documentation : attach-post-create : Phase it applies to: build : Intermediate containers created during the build process. deploy : Deployed app containers. run : Containers created by the run command. Container state on attach: created but not running Use case: When the container needs to access a resource on the network. Example: The app needs to talk to a database on the same network when it first boots. attach-post-deploy Phase it applies to: deploy : Deployed app containers. Container state on attach: running Use case: When another container on the network needs to access this container. Example: A background process needs to communicate with the web process exposed by this container. This feature has been a long time coming - it was originally reported in 2016 - and was also a ton of work, but we hope that it provides great value to our users. Here is a fun incoming bandwidth chart of a user switching to the new network support for their apps: See the network documentation for more information Routing non-web containers Users wishing to route non-web containers would previously have to either hack their nginx config or use a custom plugin to try and inject location and upstream blocks into the correct place. The lack of built-in support made it difficult to support cases where there might be a websocket process, or some command-and-conquer service that exposed a tcp connection in addition to the traditional web process. As of 0.20.0, we now inject a custom .DOKKU_APP_${PROCESS_TYPE}_LISTENERS variable into all nginx.conf.sigil files. This will allow folks to inject http(s) processes into the nginx.conf.sigil, which brings initial support for proxying non-web processes. Future improvements might include tcp support - via the nginx stream module - and injection of custom location blocks for even easier proxying of non-web processes. Users are encouraged to switch their custom configs to use the new .DOKKU_APP_WEB_LISTENERS variable when constructing upstreams. See the nginx template documentation for more information . HSTS Enabled by Default If you have an SSL certificate and are proxying requests using the nginx plugin, then HSTS will be enabled by default. It is enabled by default - including for subdomains - though without browser preloading. Please note that the default cache setting is 182 days, so pre-configure this value if you believe you will need to manipulate HSTS support. See the nginx hsts documentation for more information . Restarting docker containers recover from IP changes Docker has undefined behavior around IP address persistence when containers restart, either due to failure or because of server reboot. This has resulted in issues where restarting containers lose their IP addresses, breaking any proxy method that is associated with a container IP instead of the container name (read: how Dokku works!). This sometimes caused nasty issues where apps deployed on Dokku might mistakenly have their nginx route incorrect apps to users on server reboot, or just straight-up fail to serve requests even when the app is working after a container restart. In 0.20.2, we included the dokku-event-listener as a recommended package. It is usable with older versions of dokku, and can be installed like so: # update your apt repository apt update # install it! apt install dokku-event-listener The dokku-event-listener daemon will properly listen to container events - start, restart, delete, destroy, die - and reload the nginx config for the related app as appropriate. It will even rebuild the application if we've hit the max container restart count. It will also output debug logging that you can use to correlate application crashes with service outages. Future development As Dokku continues to mature towards a 1.0 target, the following areas will be of greater focus in upcoming releases: Security Improvements: The web configuration tool is sometimes neglected by new users, which enables malicious clients to run take over servers by running arbitrary apps. We'll replace this with a page that instructs users to connect to the server and run through a sort of \"first start\" process. SELinux is here to stay, but Dokku does not always play nice . In an ideal world, Dokku will be well-tested in common SELinux configurations, with issues and workarounds documented for the more security-minded. High Availability Support: We've traditionally said that Dokku will focus on being the single-server solution for self-hosting apps, but that doesn't mean we cannot have better high availability support through official plugins and dependencies. External configuration storage: The property system first pioneered in 0.12.0 for the git plugin has seen many improvements. The hope is to abstract property manipulation into a third-party project - prop - that can connect to an arbitrary backend. This will require changes within Dokku to migrate to the properties system in addition to the development of the prop tool, but should be a great way to enable easier backups for Dokku installations from a configuration standpoint. Scheduler Plugins: The Kubernetes and Nomad plugins are here to stay, though they'll need more love to become more fleshed out. While there is active development for the kubernetes scheduler plugin, neither has tight proxying integration, so users are somewhat on their own there. Datastore plugins: The existing datastore plugins are meant for single-server installations. Could we wrap a project such as KubeDB or other operators to provide a nicer way of manipulating datastores in your cluster? What does this look like for Nomad? While this might be something of a dead end, it would be an interesting approach to lightly introducing Dokku users to more cloud-native methods of managing datastores. Buildpack V3 : Dokku currently users gliderlabs/herokuish to provide automatic build support through buildpacks. We'll go into more detail in an upcoming post, but Cloud Native Buildpacks are the future of Dokku, and we hope that they will improve the speed and reliability of your builds. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop onto our IRC or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Dokku Release 0.20.0"},{"location":"2020/dokku-0.20.0/#changes","text":"","title":"Changes!"},{"location":"2020/dokku-0.20.0/#code-deprecations-and-removals","text":"As noted in the migration guide , we removed quite a few default commands. These were replaced with :help output, and :list commands were provided where possible. We've also dropped support for unsupported versions of Debian and Ubuntu. Dokku no longer runs tests on older versions of Ubuntu, and Debian support for older releases was completely untested. While newer packages may work in the future, users should upgrade their operating systems where possible. Finally, quite a bit of code was moved into golang, and as such certain shell functions are deprecated in favor of new plugin triggers . Usage will trigger warnings in logging output. Please switch to the new triggers in custom plugins where possible, as we well continue to remove deprecated code in the future.","title":"Code Deprecations and Removals"},{"location":"2020/dokku-0.20.0/#custom-networks","text":"In previous versions of Dokku, containers could only communicate with each other through one of the following methods: An intermediate datastore, whether that be a database, queuing system, or caching layer. Open network Adding --network docker-options flag The first option was great for apps that were architected to do message passing, but almost a non-starter for certain self-hosted apps. Even for new apps, adding an intermediate communication layer will always increase the number of problems that could occur in a system, so it was far from optimal. Sending traffic over the open network is not great as for many users, this would mean traffic over the internet. Sending traffic over the open network increases latency between requests, increases bandwidth usage - and costs! - and opens users to potential security issues regardless of SSL encryption. Suffice to say that this was also not a great solution. Adding a custom --network flag via the docker-options plugin works well enough but has a few issues itself: Does not allow for multiple networks Disables nginx traffic proxying Not great from a UX perspective A user created a custom plugin to attach on to networks after deploy, but this also has the side effect of not supporting containers that need to talk to a specific network on boot. With the new network support added in 0.20.0, users can easily create/destroy attachable docker networks, and ensure apps attach to those networks at the correct time for their apps via two easy-to-configure hooks. From the documentation : attach-post-create : Phase it applies to: build : Intermediate containers created during the build process. deploy : Deployed app containers. run : Containers created by the run command. Container state on attach: created but not running Use case: When the container needs to access a resource on the network. Example: The app needs to talk to a database on the same network when it first boots. attach-post-deploy Phase it applies to: deploy : Deployed app containers. Container state on attach: running Use case: When another container on the network needs to access this container. Example: A background process needs to communicate with the web process exposed by this container. This feature has been a long time coming - it was originally reported in 2016 - and was also a ton of work, but we hope that it provides great value to our users. Here is a fun incoming bandwidth chart of a user switching to the new network support for their apps: See the network documentation for more information","title":"Custom networks"},{"location":"2020/dokku-0.20.0/#routing-non-web-containers","text":"Users wishing to route non-web containers would previously have to either hack their nginx config or use a custom plugin to try and inject location and upstream blocks into the correct place. The lack of built-in support made it difficult to support cases where there might be a websocket process, or some command-and-conquer service that exposed a tcp connection in addition to the traditional web process. As of 0.20.0, we now inject a custom .DOKKU_APP_${PROCESS_TYPE}_LISTENERS variable into all nginx.conf.sigil files. This will allow folks to inject http(s) processes into the nginx.conf.sigil, which brings initial support for proxying non-web processes. Future improvements might include tcp support - via the nginx stream module - and injection of custom location blocks for even easier proxying of non-web processes. Users are encouraged to switch their custom configs to use the new .DOKKU_APP_WEB_LISTENERS variable when constructing upstreams. See the nginx template documentation for more information .","title":"Routing non-web containers"},{"location":"2020/dokku-0.20.0/#hsts-enabled-by-default","text":"If you have an SSL certificate and are proxying requests using the nginx plugin, then HSTS will be enabled by default. It is enabled by default - including for subdomains - though without browser preloading. Please note that the default cache setting is 182 days, so pre-configure this value if you believe you will need to manipulate HSTS support. See the nginx hsts documentation for more information .","title":"HSTS Enabled by Default"},{"location":"2020/dokku-0.20.0/#restarting-docker-containers-recover-from-ip-changes","text":"Docker has undefined behavior around IP address persistence when containers restart, either due to failure or because of server reboot. This has resulted in issues where restarting containers lose their IP addresses, breaking any proxy method that is associated with a container IP instead of the container name (read: how Dokku works!). This sometimes caused nasty issues where apps deployed on Dokku might mistakenly have their nginx route incorrect apps to users on server reboot, or just straight-up fail to serve requests even when the app is working after a container restart. In 0.20.2, we included the dokku-event-listener as a recommended package. It is usable with older versions of dokku, and can be installed like so: # update your apt repository apt update # install it! apt install dokku-event-listener The dokku-event-listener daemon will properly listen to container events - start, restart, delete, destroy, die - and reload the nginx config for the related app as appropriate. It will even rebuild the application if we've hit the max container restart count. It will also output debug logging that you can use to correlate application crashes with service outages.","title":"Restarting docker containers recover from IP changes"},{"location":"2020/dokku-0.20.0/#future-development","text":"As Dokku continues to mature towards a 1.0 target, the following areas will be of greater focus in upcoming releases: Security Improvements: The web configuration tool is sometimes neglected by new users, which enables malicious clients to run take over servers by running arbitrary apps. We'll replace this with a page that instructs users to connect to the server and run through a sort of \"first start\" process. SELinux is here to stay, but Dokku does not always play nice . In an ideal world, Dokku will be well-tested in common SELinux configurations, with issues and workarounds documented for the more security-minded. High Availability Support: We've traditionally said that Dokku will focus on being the single-server solution for self-hosting apps, but that doesn't mean we cannot have better high availability support through official plugins and dependencies. External configuration storage: The property system first pioneered in 0.12.0 for the git plugin has seen many improvements. The hope is to abstract property manipulation into a third-party project - prop - that can connect to an arbitrary backend. This will require changes within Dokku to migrate to the properties system in addition to the development of the prop tool, but should be a great way to enable easier backups for Dokku installations from a configuration standpoint. Scheduler Plugins: The Kubernetes and Nomad plugins are here to stay, though they'll need more love to become more fleshed out. While there is active development for the kubernetes scheduler plugin, neither has tight proxying integration, so users are somewhat on their own there. Datastore plugins: The existing datastore plugins are meant for single-server installations. Could we wrap a project such as KubeDB or other operators to provide a nicer way of manipulating datastores in your cluster? What does this look like for Nomad? While this might be something of a dead end, it would be an interesting approach to lightly introducing Dokku users to more cloud-native methods of managing datastores. Buildpack V3 : Dokku currently users gliderlabs/herokuish to provide automatic build support through buildpacks. We'll go into more detail in an upcoming post, but Cloud Native Buildpacks are the future of Dokku, and we hope that they will improve the speed and reliability of your builds. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop onto our IRC or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Future development"},{"location":"2021/creating-a-datastore-plugin/","tags":["dokku","release"],"text":"It's been a little over two weeks since our 0.26.x release landed. Here is a summary of what features were added during the 0.25.x release and new stuff in 0.26.x. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. Initializing the plugin First, we'll start by cloning an existing datastore plugin. I'll choose the postgres plugin. git clone https://github.com/dokku/dokku-postgres dokku-meillisearch cd dokku-meillisearch rm -rf .git Once this is done, we can modify the plugin.toml to have the following contents: [plugin] description = \"dokku meillisearch service plugin\" version = \"0.0.1\" [plugin.config] Reconfiguring the plugin Now begins the great find/replace. We'll do the following case-sensitive replacements: postgres meillisearch Postgres Meillisearch POSTGRES MEILLISEARCH After the find/replace, we'll need to configure the plugin correctly. There should be a config file that contains runtime configuration for the plugin. We'll need to change the following in this file: PLUGIN_DATASTORE_PORTS : A bash array containing a list of ports exposed by the service. In many cases, this will be a single port. All ports should be listed here. The first port in the list is used when linking the service to an app. For meillisearch , the config should look as follows export PLUGIN_DATASTORE_PORTS=(7700) PLUGIN_DATASTORE_WAIT_PORT : This should be the primary port that Dokku waits to be ready when creating the service. Usually this will be the port used to link the service to an app. For meillisearch , the config should look as follows export PLUGIN_DATASTORE_WAIT_PORT=7700 PLUGIN_SCHEME : The value of this is used in the DSN. Do not leave it blank. It can usually be the lowercase version of the datastore name, but sometimes may need to be something different. For meillisearch , the config should look as follows export PLUGIN_SCHEME=http PLUGIN_DEFAULT_ALIAS : This is used as the prefix for the _URL value. DATABASE_URL is pretty normal for sql datastores. For meillisearch , the config should look as follows` export PLUGIN_DEFAULT_ALIAS=\"MEILLISEARCH\" The config file also contains a PLUGIN_UNIMPLEMENTED_SUBCOMMANDS shell array. This contains a list of commands that are not supported by the plugin. For sql-like plugins, this is usually empty, but sometimes certain functionality is not supported by the datastore (such as backup/restore or connecting to the service using a repl). In our case, we'll set the following value. export PLUGIN_UNIMPLEMENTED_SUBCOMMANDS =( \"backup\" \"backup-auth\" \"backup-deauth\" \"backup-schedule\" \"backup-schedule-cat\" \"backup-set-encryption\" \"backup-unschedule\" \"backup-unset-encryption\" \"clone\" \"connect\" \"export\" \"import\" ) This can always be revisited in the future as functionality becomes available to the datastore. Once this is set, we need to update the default Docker image the datastore plugin will use. This is contained within the Dockerfile. As of the time of writing, the latest stable image tag is v0.23.1 , so we'll have the following as the Dockerfile contents: FROM getmeili/meilisearch:v0.23.1 These cover the general changes. Now on to function updates. Customizing Commands 90% of the plugin is templated, but datastore-specific functions are stored in the functions file. We'll go over each of these below (and describe the customizations for meilisearch ). service_connect : Connects to the datastore via a repl. The repl must be available in the base image in use, and not any customization. For meillisearch , we'll replace the existing psql call with dokku_log_fail \"Not yet implemented\" service_create : Usually only customized if there are password needs (either the datastore doesn't support a password or supports a root password in addition to the normal one). For meillisearch , we don't need to customize anything. service_create_container : The meat and potatos. This creates the container and intiailizes data for the container (if necessary). For meillisearch , we can drop the code that initiliazes container database (from ~line 96-105, which contains the service_port_unpause call). Additionally, the ID=$(docker run ...) command should become the following: ID=$(docker run --name \"$SERVICE_NAME\" $MEMORY_LIMIT $SHM_SIZE -v \"$SERVICE_HOST_ROOT/data:/data.ms\" -e \"MEILI_MASTER_KEY=$PASSWORD\" -e \"MEILI_HTTP_ADDR=0.0.0.0:7700\" -e \"MEILI_NO_ANALYTICS=true\" --env-file=\"$SERVICE_ROOT/ENV\" -d --restart always --label dokku=service --label dokku.service=meillisearch \"$PLUGIN_IMAGE:$PLUGIN_IMAGE_VERSION\" $CONFIG_OPTIONS) service_export : Used for exporting the service data. You can implement this if the container has some way to export the data to stdout For meillisearch , we'll replace the existing psql call with dokku_log_fail \"Not yet implemented\" service_import : Analogous to service_export , used for importing the service data. You can implement this if the container has some way import the data from stdin. For meillisearch , we'll replace the existing psql call with dokku_log_fail \"Not yet implemented\" service_start : The only time this is customized is when the service either has no passwords (so the password check is removed) or has a secondary, root password (so we add another check). For meillisearch , the existing checks the Postgres plugin performs are enough. service_url : This outputs the default DSN-formatted connection string. Docker exposes other variables containing just IPs, PORTs, and other values from the config, so it is heavily encouraged to not come up with your own format here. For meillisearch , this should become the following: echo \"$PLUGIN_SCHEME://:$PASSWORD@$SERVICE_DNS_HOSTNAME:${PLUGIN_DATASTORE_PORTS[0]}\" Fixing tests Usually the following should be modified for tests. Below contains the changes for our meillisearch plugin. Tests matching unimplemented commands should be removed. For meillisearch , this means deleting the following files: tests/service_clone.bats tests/service_connect.bats tests/service_export.bats tests/service_import.bats Port references should be updated. In our case, a find/replace of 5432 with 7700 is enough for this. username:password need to conform to how the datastore works. For meillisearch , we can do two find-replacements: //u:p => //:p //meillisearch:$password => //:$password The plugin scheme should be updated. This is done with two find/replace calls: meillisearch:// => http:// meillisearch2 => http2 The \"database\" in the DSN should be updated to match the plugin's service_url format. In our case, we'll need a few find-replacements: /db\" => \" (basically removing the suffix) /l\" => \" (basically removing the suffix) /test_with_underscores\" => \" (basically removing the suffix) /db : there will be one instance of this in a config:set call. The string should just be removed. The dsn key should be updated to match the PLUGIN_DEFAULT_ALIAS . For meillisearch , we can do the following find/replace: DATABASE_URL => MEILLISEARCH_URL Regenerating the README.md The readme is generated by reading through the plugin source and generating help based on the config file and the source of each subcommand. It is enhanced by files in the docs folder. For our use case, we'll remove everything in the docs folder except for docs/README. This can be done in a single call to bin/generate a script included with each plugin that requries python3 . Commiting everything If everything went well, we can commit and push our new service plugin to Github. The plugin should automatically run tests in Github Actions, at which point you can catch any lingering errors. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Creating a Datastore plugin"},{"location":"2021/creating-a-datastore-plugin/#initializing-the-plugin","text":"First, we'll start by cloning an existing datastore plugin. I'll choose the postgres plugin. git clone https://github.com/dokku/dokku-postgres dokku-meillisearch cd dokku-meillisearch rm -rf .git Once this is done, we can modify the plugin.toml to have the following contents: [plugin] description = \"dokku meillisearch service plugin\" version = \"0.0.1\" [plugin.config]","title":"Initializing the plugin"},{"location":"2021/creating-a-datastore-plugin/#reconfiguring-the-plugin","text":"Now begins the great find/replace. We'll do the following case-sensitive replacements: postgres meillisearch Postgres Meillisearch POSTGRES MEILLISEARCH After the find/replace, we'll need to configure the plugin correctly. There should be a config file that contains runtime configuration for the plugin. We'll need to change the following in this file: PLUGIN_DATASTORE_PORTS : A bash array containing a list of ports exposed by the service. In many cases, this will be a single port. All ports should be listed here. The first port in the list is used when linking the service to an app. For meillisearch , the config should look as follows export PLUGIN_DATASTORE_PORTS=(7700) PLUGIN_DATASTORE_WAIT_PORT : This should be the primary port that Dokku waits to be ready when creating the service. Usually this will be the port used to link the service to an app. For meillisearch , the config should look as follows export PLUGIN_DATASTORE_WAIT_PORT=7700 PLUGIN_SCHEME : The value of this is used in the DSN. Do not leave it blank. It can usually be the lowercase version of the datastore name, but sometimes may need to be something different. For meillisearch , the config should look as follows export PLUGIN_SCHEME=http PLUGIN_DEFAULT_ALIAS : This is used as the prefix for the _URL value. DATABASE_URL is pretty normal for sql datastores. For meillisearch , the config should look as follows` export PLUGIN_DEFAULT_ALIAS=\"MEILLISEARCH\" The config file also contains a PLUGIN_UNIMPLEMENTED_SUBCOMMANDS shell array. This contains a list of commands that are not supported by the plugin. For sql-like plugins, this is usually empty, but sometimes certain functionality is not supported by the datastore (such as backup/restore or connecting to the service using a repl). In our case, we'll set the following value. export PLUGIN_UNIMPLEMENTED_SUBCOMMANDS =( \"backup\" \"backup-auth\" \"backup-deauth\" \"backup-schedule\" \"backup-schedule-cat\" \"backup-set-encryption\" \"backup-unschedule\" \"backup-unset-encryption\" \"clone\" \"connect\" \"export\" \"import\" ) This can always be revisited in the future as functionality becomes available to the datastore. Once this is set, we need to update the default Docker image the datastore plugin will use. This is contained within the Dockerfile. As of the time of writing, the latest stable image tag is v0.23.1 , so we'll have the following as the Dockerfile contents: FROM getmeili/meilisearch:v0.23.1 These cover the general changes. Now on to function updates.","title":"Reconfiguring the plugin"},{"location":"2021/creating-a-datastore-plugin/#customizing-commands","text":"90% of the plugin is templated, but datastore-specific functions are stored in the functions file. We'll go over each of these below (and describe the customizations for meilisearch ). service_connect : Connects to the datastore via a repl. The repl must be available in the base image in use, and not any customization. For meillisearch , we'll replace the existing psql call with dokku_log_fail \"Not yet implemented\" service_create : Usually only customized if there are password needs (either the datastore doesn't support a password or supports a root password in addition to the normal one). For meillisearch , we don't need to customize anything. service_create_container : The meat and potatos. This creates the container and intiailizes data for the container (if necessary). For meillisearch , we can drop the code that initiliazes container database (from ~line 96-105, which contains the service_port_unpause call). Additionally, the ID=$(docker run ...) command should become the following: ID=$(docker run --name \"$SERVICE_NAME\" $MEMORY_LIMIT $SHM_SIZE -v \"$SERVICE_HOST_ROOT/data:/data.ms\" -e \"MEILI_MASTER_KEY=$PASSWORD\" -e \"MEILI_HTTP_ADDR=0.0.0.0:7700\" -e \"MEILI_NO_ANALYTICS=true\" --env-file=\"$SERVICE_ROOT/ENV\" -d --restart always --label dokku=service --label dokku.service=meillisearch \"$PLUGIN_IMAGE:$PLUGIN_IMAGE_VERSION\" $CONFIG_OPTIONS) service_export : Used for exporting the service data. You can implement this if the container has some way to export the data to stdout For meillisearch , we'll replace the existing psql call with dokku_log_fail \"Not yet implemented\" service_import : Analogous to service_export , used for importing the service data. You can implement this if the container has some way import the data from stdin. For meillisearch , we'll replace the existing psql call with dokku_log_fail \"Not yet implemented\" service_start : The only time this is customized is when the service either has no passwords (so the password check is removed) or has a secondary, root password (so we add another check). For meillisearch , the existing checks the Postgres plugin performs are enough. service_url : This outputs the default DSN-formatted connection string. Docker exposes other variables containing just IPs, PORTs, and other values from the config, so it is heavily encouraged to not come up with your own format here. For meillisearch , this should become the following: echo \"$PLUGIN_SCHEME://:$PASSWORD@$SERVICE_DNS_HOSTNAME:${PLUGIN_DATASTORE_PORTS[0]}\"","title":"Customizing Commands"},{"location":"2021/creating-a-datastore-plugin/#fixing-tests","text":"Usually the following should be modified for tests. Below contains the changes for our meillisearch plugin. Tests matching unimplemented commands should be removed. For meillisearch , this means deleting the following files: tests/service_clone.bats tests/service_connect.bats tests/service_export.bats tests/service_import.bats Port references should be updated. In our case, a find/replace of 5432 with 7700 is enough for this. username:password need to conform to how the datastore works. For meillisearch , we can do two find-replacements: //u:p => //:p //meillisearch:$password => //:$password The plugin scheme should be updated. This is done with two find/replace calls: meillisearch:// => http:// meillisearch2 => http2 The \"database\" in the DSN should be updated to match the plugin's service_url format. In our case, we'll need a few find-replacements: /db\" => \" (basically removing the suffix) /l\" => \" (basically removing the suffix) /test_with_underscores\" => \" (basically removing the suffix) /db : there will be one instance of this in a config:set call. The string should just be removed. The dsn key should be updated to match the PLUGIN_DEFAULT_ALIAS . For meillisearch , we can do the following find/replace: DATABASE_URL => MEILLISEARCH_URL","title":"Fixing tests"},{"location":"2021/creating-a-datastore-plugin/#regenerating-the-readmemd","text":"The readme is generated by reading through the plugin source and generating help based on the config file and the source of each subcommand. It is enhanced by files in the docs folder. For our use case, we'll remove everything in the docs folder except for docs/README. This can be done in a single call to bin/generate a script included with each plugin that requries python3 .","title":"Regenerating the README.md"},{"location":"2021/creating-a-datastore-plugin/#commiting-everything","text":"","title":"Commiting everything"},{"location":"2021/creating-a-datastore-plugin/#if-everything-went-well-we-can-commit-and-push-our-new-service-plugin-to-github-the-plugin-should-automatically-run-tests-in-github-actions-at-which-point-you-can-catch-any-lingering-errors","text":"If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"If everything went well, we can commit and push our new service plugin to Github. The plugin should automatically run tests in Github Actions, at which point you can catch any lingering errors."},{"location":"2021/dokku-0.23.0/","tags":["dokku","release"],"text":"Dokku version 0.23.0 was released this weekend with quite a few major improvements for many common workflows. We'll go over major changes below. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. New Core Contributors With the new release, a few folks have been added as contributors to the project. Richard Willis ( @badsyntax ) has been contributing a bit to various projects, most notably some great ideas to the official Github Action . Milan Vit ( @cellane ) has contributed significant bug reports over the past year and has been a great source of community feedback. Leopold Talirz ( @ltalirz ) has been the unofficial (and well, now official) steward of the Ansible Modules for quite a while now, and has made great efforts at making the code testable and reusable. These folks have been added as Github Triagers to various projects. This means they'll have increasing control over the future of the project and features they think they'd like in the core, as well as how those things might be developed over time. You can think of them as community++ :) While they have been added as core contributors, as this is an Open Source Project, there is no requirement of any work from them. This is simply recognition for the great work they've done to support Dokku. How do you join? There are a number of ways to Contribute to the project , code and otherwise. As we continue to clean up various projects under the Dokku umbrella, more folks will be added (and removed as necessary) to help push the project forward. We hope that this helps unblock pull requests from being merged, features from being developed, and bugs from being squashed. Thanks to the folks above and all community contributors. It would be hard to imagine Dokku without all of you pushin the project forward. Changes CircleCI => Github Actions CircleCI was and remains a great service - we'll continue to use them for other projects unless there is a real need to switch. They certainly provide a wide-range of features, and will be the recommended CI stack for folks needing serious CI functionality. That said, our CircleCI usage was limited for a few reasons: Parallelism limits due to using an OSS plan caused CI runs to execute for an hour+, which isn't great for quick feedback cycles. Until recently , CircleCI had no support for self-hosted runners. They are currently only availabe for paid plans. No current ARM support, making any future work towards a potential ARM version of Dokku... not possible. Machine images are limited in OS version, and currently only support 16.04 and 20.04 (in beta). They've also been fairly slow to add support for new OS versions (as shown by the late and still beta 20.04 support). As we continue to work on Dokku, we need to test on modern, supported operating systems, and not being able to do so limits our testing capabilities. With 0.23.0, we've switched to Github Actions, which provides the following benefits: Higher parallelism, to the point that the full test suite runs in around 20 minutes. More varied OS and Architecture support. I for one will love the day when I can finally run Dokku on my Raspberry Pi... Deeper integration with Github itself. While not all functionality has been carried over - in particular, test statistics are missing, it is impossible to re-run only failing jobs, and running jobs with SSH for debugging is a bit more difficult - it is hoped that the change makes the process of developing new functionality much easier for the average contributor. Bug Fixes Image Labeling Dokku introduced label-schema.org support as part of 0.18.0 back in August of 2019. While Label Schema is no longer actively maintained - in favor of OCI Annotations tha we'll properly support in the near future - we still label images and labels according to that spec. Unfortunately, our labeling support left a lot to be desired. Labeling added a new layer and did not take into account previously set layers. Continued ps:restart calls would add the same labels over and over. Labels did not work for Dockerfile or Image deploys that used an ONBUILD directive, and would re-trigger those ONBUILD directives in directories that may not have a build context. We actually disabled labeling support for such images in 0.22.x. Intermediate containers were required for labels, causing deploys to be longer in certain cases. As of 0.23.0, the Dokku project now uses docker-image-labeler to inject labels only when necessary, and avoids building new containers entirely. This should have no real impact on produced images, though will reset layer create times as a side effect (a limitation that may be removed in the future). We'll continue to investigate similar ways to speed up the build process for all of our users in future releases. libpam-tmpdir support As part of an increased focus on security, we've added proper libpam-tmpdir support. The actual problem was due to how we attempt to drop permissions via the sudo binary without resetting certain environment variables. While the fix was relatively simple - just unsetting some variables - our implementation of permission dropping certainly leaves something to be desired. Enterprising individuals who wish to contribute to the project and have expertise in this area would certainly be welcomed! New Features Buildpack Stack Builder Management In previous releases, users of derivative gliderlabs/herokuish images would need to specify a DOKKU_IMAGE environment variable in order to use their version over what we ship by default. While this was a reasonable approach that worked when there was only one herokuish image version being maintained, we've recently decided to add support for building both 18.04 and 20.04 based images. Additionally, this approach does not work at all for our Cloud Native Buildpack support. As of 0.23.0 , there is now a way to set the stack builder image in use. Herokuish users (the majority of Dokku users at this time) will be able to specify either the 18.04, 20.04, or any other image as follows: # app-specific command dokku buildpacks:set-property $APP $SOME_IMAGE # global command dokku buildpacks:set-property --global stack $SOME_IMAGE Any tag listed on Docker Hub can be used, and folks can derive their custom herokuish image as needed for their own platforms. For general users, we highly recommend sticking to the shipped defaults. Cloud Native Buildpack users have access to the same command, and can use it to specify an alternative builder image. Below switches the global builder image from heroku/buildpacks to the packeto buildpacks maintained by CloudFoundry: dokku buildpacks:set-property --global stack paketobuildpacks/build:base-cnb We'll continue working to add full support for buildpacks commands to the Cloud Native Buildpack support, and hope this initial work makes it easier to use. Container Logrotation With the addition of Vector-based Log Shipping in 0.22.x, we still had a need to ensure logs didn't consume host resources. Assuming default docker log settings, it is now possible to set the docker log retention via logs:set : dokku logs:set --global max-size 20m This new setting injects a property into the docker run calls (though is exposed via trigger for alternative schedulers), defaults to 10m , and can be set both globally and on a per-app basis. Please rebuild your apps to have this come into effect. Nginx Configuration While having a sane default is great, often-times users will need to customize their nginx proxy configuration to meet their needs. Vendoring a custom nginx.conf.sigil makes it more difficult for us to ship security updates to users, and thus we're opening the floodgates to new knobs for configuring the nginx config built for apps. The following new properties can now be set on a per-app basis: x-forwarded-for-value x-forwarded-port-value x-forwarded-proto-value client-max-body-size While the hsts property can now be set globally (default on) in addition to on a per-app basis. We'll continue adding support to additional properties (both globally and otherwise) as the needs arise from the community. Checkout our nginx documentation for further details. Scheduled Cron Task Management For years, we've asked folks to manage a custom cron file outside of the Dokku deployment process. While this was all well and good, it doesn't work well for less technical users or those who do not have server access. We've added support to the app.json file for specifying a list of commands and the schedule for which to run said commands. Usage is simple : { \"cron\" : [ { \"command\" : \"node run some-command-here\" , \"schedule\" : \"@daily\" } ] } Scheduled cron tasks are run within isolated Docker containers, and any number of commands can be added to a given app. While this isn't currently supported in alternative schedulers, the functionality was built with such support in mind. Checkout the scheduled cron task documentation for more details on how the functionality works. We'd definitely love your feedback! Git Repository Syncing support This is one of the more exciting features. Users may now run a command to specify a remote repository to sync - and build! - an app from via the git:sync command. This makes it possible to build webhook-like functionality by wrapping the command in a web api of sorts. # just sync some code, maybe to setup a repository dokku git:sync node-js-app https://github.com/heroku/node-js-getting-started.git # sync and build the repository! dokku git:sync --build node-js-app https://github.com/heroku/node-js-getting-started.git We hope to continue adding interesting git-based workflows in upcoming releases, but hope that this feature is well-used by platform developers. Thanks to @crisward for the inspiration via his dokku-clone project. 1.0? Our versioning is getting long in the tooth, and we're quickly winding towards an eventual 1.0 release. It's been teased in the past, but as of this writing, there are currently 18 outstanding issues in the 1.0 milestone. We encourage folks to take a peak at them and help investigate bugs, come up with work plans, or contribute PRs where possible to help bring us over the finish line. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Dokku Release 0.23.0"},{"location":"2021/dokku-0.23.0/#new-core-contributors","text":"With the new release, a few folks have been added as contributors to the project. Richard Willis ( @badsyntax ) has been contributing a bit to various projects, most notably some great ideas to the official Github Action . Milan Vit ( @cellane ) has contributed significant bug reports over the past year and has been a great source of community feedback. Leopold Talirz ( @ltalirz ) has been the unofficial (and well, now official) steward of the Ansible Modules for quite a while now, and has made great efforts at making the code testable and reusable. These folks have been added as Github Triagers to various projects. This means they'll have increasing control over the future of the project and features they think they'd like in the core, as well as how those things might be developed over time. You can think of them as community++ :) While they have been added as core contributors, as this is an Open Source Project, there is no requirement of any work from them. This is simply recognition for the great work they've done to support Dokku. How do you join? There are a number of ways to Contribute to the project , code and otherwise. As we continue to clean up various projects under the Dokku umbrella, more folks will be added (and removed as necessary) to help push the project forward. We hope that this helps unblock pull requests from being merged, features from being developed, and bugs from being squashed. Thanks to the folks above and all community contributors. It would be hard to imagine Dokku without all of you pushin the project forward.","title":"New Core Contributors"},{"location":"2021/dokku-0.23.0/#changes","text":"","title":"Changes"},{"location":"2021/dokku-0.23.0/#circleci-github-actions","text":"CircleCI was and remains a great service - we'll continue to use them for other projects unless there is a real need to switch. They certainly provide a wide-range of features, and will be the recommended CI stack for folks needing serious CI functionality. That said, our CircleCI usage was limited for a few reasons: Parallelism limits due to using an OSS plan caused CI runs to execute for an hour+, which isn't great for quick feedback cycles. Until recently , CircleCI had no support for self-hosted runners. They are currently only availabe for paid plans. No current ARM support, making any future work towards a potential ARM version of Dokku... not possible. Machine images are limited in OS version, and currently only support 16.04 and 20.04 (in beta). They've also been fairly slow to add support for new OS versions (as shown by the late and still beta 20.04 support). As we continue to work on Dokku, we need to test on modern, supported operating systems, and not being able to do so limits our testing capabilities. With 0.23.0, we've switched to Github Actions, which provides the following benefits: Higher parallelism, to the point that the full test suite runs in around 20 minutes. More varied OS and Architecture support. I for one will love the day when I can finally run Dokku on my Raspberry Pi... Deeper integration with Github itself. While not all functionality has been carried over - in particular, test statistics are missing, it is impossible to re-run only failing jobs, and running jobs with SSH for debugging is a bit more difficult - it is hoped that the change makes the process of developing new functionality much easier for the average contributor.","title":"CircleCI =&gt; Github Actions"},{"location":"2021/dokku-0.23.0/#bug-fixes","text":"","title":"Bug Fixes"},{"location":"2021/dokku-0.23.0/#image-labeling","text":"Dokku introduced label-schema.org support as part of 0.18.0 back in August of 2019. While Label Schema is no longer actively maintained - in favor of OCI Annotations tha we'll properly support in the near future - we still label images and labels according to that spec. Unfortunately, our labeling support left a lot to be desired. Labeling added a new layer and did not take into account previously set layers. Continued ps:restart calls would add the same labels over and over. Labels did not work for Dockerfile or Image deploys that used an ONBUILD directive, and would re-trigger those ONBUILD directives in directories that may not have a build context. We actually disabled labeling support for such images in 0.22.x. Intermediate containers were required for labels, causing deploys to be longer in certain cases. As of 0.23.0, the Dokku project now uses docker-image-labeler to inject labels only when necessary, and avoids building new containers entirely. This should have no real impact on produced images, though will reset layer create times as a side effect (a limitation that may be removed in the future). We'll continue to investigate similar ways to speed up the build process for all of our users in future releases.","title":"Image Labeling"},{"location":"2021/dokku-0.23.0/#libpam-tmpdir-support","text":"As part of an increased focus on security, we've added proper libpam-tmpdir support. The actual problem was due to how we attempt to drop permissions via the sudo binary without resetting certain environment variables. While the fix was relatively simple - just unsetting some variables - our implementation of permission dropping certainly leaves something to be desired. Enterprising individuals who wish to contribute to the project and have expertise in this area would certainly be welcomed!","title":"libpam-tmpdir support"},{"location":"2021/dokku-0.23.0/#new-features","text":"","title":"New Features"},{"location":"2021/dokku-0.23.0/#buildpack-stack-builder-management","text":"In previous releases, users of derivative gliderlabs/herokuish images would need to specify a DOKKU_IMAGE environment variable in order to use their version over what we ship by default. While this was a reasonable approach that worked when there was only one herokuish image version being maintained, we've recently decided to add support for building both 18.04 and 20.04 based images. Additionally, this approach does not work at all for our Cloud Native Buildpack support. As of 0.23.0 , there is now a way to set the stack builder image in use. Herokuish users (the majority of Dokku users at this time) will be able to specify either the 18.04, 20.04, or any other image as follows: # app-specific command dokku buildpacks:set-property $APP $SOME_IMAGE # global command dokku buildpacks:set-property --global stack $SOME_IMAGE Any tag listed on Docker Hub can be used, and folks can derive their custom herokuish image as needed for their own platforms. For general users, we highly recommend sticking to the shipped defaults. Cloud Native Buildpack users have access to the same command, and can use it to specify an alternative builder image. Below switches the global builder image from heroku/buildpacks to the packeto buildpacks maintained by CloudFoundry: dokku buildpacks:set-property --global stack paketobuildpacks/build:base-cnb We'll continue working to add full support for buildpacks commands to the Cloud Native Buildpack support, and hope this initial work makes it easier to use.","title":"Buildpack Stack Builder Management"},{"location":"2021/dokku-0.23.0/#container-logrotation","text":"With the addition of Vector-based Log Shipping in 0.22.x, we still had a need to ensure logs didn't consume host resources. Assuming default docker log settings, it is now possible to set the docker log retention via logs:set : dokku logs:set --global max-size 20m This new setting injects a property into the docker run calls (though is exposed via trigger for alternative schedulers), defaults to 10m , and can be set both globally and on a per-app basis. Please rebuild your apps to have this come into effect.","title":"Container Logrotation"},{"location":"2021/dokku-0.23.0/#nginx-configuration","text":"While having a sane default is great, often-times users will need to customize their nginx proxy configuration to meet their needs. Vendoring a custom nginx.conf.sigil makes it more difficult for us to ship security updates to users, and thus we're opening the floodgates to new knobs for configuring the nginx config built for apps. The following new properties can now be set on a per-app basis: x-forwarded-for-value x-forwarded-port-value x-forwarded-proto-value client-max-body-size While the hsts property can now be set globally (default on) in addition to on a per-app basis. We'll continue adding support to additional properties (both globally and otherwise) as the needs arise from the community. Checkout our nginx documentation for further details.","title":"Nginx Configuration"},{"location":"2021/dokku-0.23.0/#scheduled-cron-task-management","text":"For years, we've asked folks to manage a custom cron file outside of the Dokku deployment process. While this was all well and good, it doesn't work well for less technical users or those who do not have server access. We've added support to the app.json file for specifying a list of commands and the schedule for which to run said commands. Usage is simple : { \"cron\" : [ { \"command\" : \"node run some-command-here\" , \"schedule\" : \"@daily\" } ] } Scheduled cron tasks are run within isolated Docker containers, and any number of commands can be added to a given app. While this isn't currently supported in alternative schedulers, the functionality was built with such support in mind. Checkout the scheduled cron task documentation for more details on how the functionality works. We'd definitely love your feedback!","title":"Scheduled Cron Task Management"},{"location":"2021/dokku-0.23.0/#git-repository-syncing-support","text":"This is one of the more exciting features. Users may now run a command to specify a remote repository to sync - and build! - an app from via the git:sync command. This makes it possible to build webhook-like functionality by wrapping the command in a web api of sorts. # just sync some code, maybe to setup a repository dokku git:sync node-js-app https://github.com/heroku/node-js-getting-started.git # sync and build the repository! dokku git:sync --build node-js-app https://github.com/heroku/node-js-getting-started.git We hope to continue adding interesting git-based workflows in upcoming releases, but hope that this feature is well-used by platform developers. Thanks to @crisward for the inspiration via his dokku-clone project.","title":"Git Repository Syncing support"},{"location":"2021/dokku-0.23.0/#10","text":"Our versioning is getting long in the tooth, and we're quickly winding towards an eventual 1.0 release. It's been teased in the past, but as of this writing, there are currently 18 outstanding issues in the 1.0 milestone. We encourage folks to take a peak at them and help investigate bugs, come up with work plans, or contribute PRs where possible to help bring us over the finish line. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"1.0?"},{"location":"2021/dokku-0.23.x-wrapup/","tags":["dokku","release"],"text":"Dokku version 0.24.0 was released earlier this week. This post covers the major changes that occurred throughout the lifetime of the 0.23.x series. A future post will cover the 0.24.0 release. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. Additions Release changes Dokku now has support for triggering releases via Github Actions. This will allow any maintainer to make a release of Dokku without needing to set anything up locally. The ability to auto-release plugins and tools in the Dokku ecosystem will slowly be added to all core projects over the coming weeks. In addition, we now update the official Azure ARM template for Dokku during the release process, as well as bump the homebrew repo for the remote cli tool. We hope to extend this official release bumping to other image maintained for Dokku in the near future. Report output as json While undocumented, all of the golang plugins now support displaying report output as json ( #4369 ). This makes it easier for tools to parse the reports. A future release will hopefully extend this to all plugins, and provide a framework for non-core plugins to also have json formatting support in :report output. Modifying X-Forwarded-Ssl in nginx configurations Some load balancers require specifying a value for X-Forwarded-Ssl . The ability to do so was added in #4420 . Note that this is a non-standard version of setting x-forwarded-proto to https , and should only be done as a last resort. Add support for injected cron entries from external plugins One of the things lost by the addition of scheduled cron task support in 0.23.0 was the ability to set cron tasks from plugins. This functionality was used by the dokku-letsencrypt plugin to support it's auto-renew functionality. The change in #4384 allows alternative plugins - such as dokku-letsencrypt - to inject scheduled cron tasks into the cron system used by Dokku. Cron systems can choose to include or not include a cron task based on the specified scheduler, and can also optionally use a third parameter to store arbitrary information. Ability to clear an individual resource value As of (#4372)[https://github.com/dokku/dokku/pull/4372], a resource value can be individually cleared by setting the value to the special value clear . dokku resource:limit --cpu clear node-js-app =====> Setting resource limits for node-js-app cpu: cleared A new 'null' buildpack was added Herokuish 0.5.25 introduces a new null buildpack. This buildpack does nothing, which is useful if your app vendors all it's dependencies and does not need to be built. To use it, include a .null file in your app repository. No other changes are necessary. Changes Documentation is now at dokku.com The documentation has moved from the global viewdocs to it's own fork, hosted at dokku.com . Future documentation changes will enable embedded docs for official plugins, doc search, as well as including the blog on the main domain. As an added bonus, our documentation now has SSL! Checking if an app was deployed Previously, checking if an app was deployed actually checked if there were any running processes. This is not only incorrect, but also fails to take into account applications that do not have running processes and are only used for one-off commands. The fix in #4402 migrates apps to the new \"deployed\" property which is set in core-post-deploy. The result is a slightly faster \"deployed\" check that is correct and allows non-scaled apps to actually work. Better Procfile extraction As of #4373 , the Procfile is now extracted in the pre-deploy step for every deploy and otherwise not removed. Thus, it should always exist when necessary - web will be scale to 1 automatically and it won't need to be present on future ps:scale calls since we'll have the scale file - and the command can execute faster. It's a wrap And that's it for 0.23.x. Our next post will cover 0.24.0, as well as plans for future releases. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Dokku 0.23.x Wrapup"},{"location":"2021/dokku-0.23.x-wrapup/#additions","text":"","title":"Additions"},{"location":"2021/dokku-0.23.x-wrapup/#release-changes","text":"Dokku now has support for triggering releases via Github Actions. This will allow any maintainer to make a release of Dokku without needing to set anything up locally. The ability to auto-release plugins and tools in the Dokku ecosystem will slowly be added to all core projects over the coming weeks. In addition, we now update the official Azure ARM template for Dokku during the release process, as well as bump the homebrew repo for the remote cli tool. We hope to extend this official release bumping to other image maintained for Dokku in the near future.","title":"Release changes"},{"location":"2021/dokku-0.23.x-wrapup/#report-output-as-json","text":"While undocumented, all of the golang plugins now support displaying report output as json ( #4369 ). This makes it easier for tools to parse the reports. A future release will hopefully extend this to all plugins, and provide a framework for non-core plugins to also have json formatting support in :report output.","title":"Report output as json"},{"location":"2021/dokku-0.23.x-wrapup/#modifying-x-forwarded-ssl-in-nginx-configurations","text":"Some load balancers require specifying a value for X-Forwarded-Ssl . The ability to do so was added in #4420 . Note that this is a non-standard version of setting x-forwarded-proto to https , and should only be done as a last resort.","title":"Modifying X-Forwarded-Ssl in nginx configurations"},{"location":"2021/dokku-0.23.x-wrapup/#add-support-for-injected-cron-entries-from-external-plugins","text":"One of the things lost by the addition of scheduled cron task support in 0.23.0 was the ability to set cron tasks from plugins. This functionality was used by the dokku-letsencrypt plugin to support it's auto-renew functionality. The change in #4384 allows alternative plugins - such as dokku-letsencrypt - to inject scheduled cron tasks into the cron system used by Dokku. Cron systems can choose to include or not include a cron task based on the specified scheduler, and can also optionally use a third parameter to store arbitrary information.","title":"Add support for injected cron entries from external plugins"},{"location":"2021/dokku-0.23.x-wrapup/#ability-to-clear-an-individual-resource-value","text":"As of (#4372)[https://github.com/dokku/dokku/pull/4372], a resource value can be individually cleared by setting the value to the special value clear . dokku resource:limit --cpu clear node-js-app =====> Setting resource limits for node-js-app cpu: cleared","title":"Ability to clear an individual resource value"},{"location":"2021/dokku-0.23.x-wrapup/#a-new-null-buildpack-was-added","text":"Herokuish 0.5.25 introduces a new null buildpack. This buildpack does nothing, which is useful if your app vendors all it's dependencies and does not need to be built. To use it, include a .null file in your app repository. No other changes are necessary.","title":"A new 'null' buildpack was added"},{"location":"2021/dokku-0.23.x-wrapup/#changes","text":"","title":"Changes"},{"location":"2021/dokku-0.23.x-wrapup/#documentation-is-now-at-dokkucom","text":"The documentation has moved from the global viewdocs to it's own fork, hosted at dokku.com . Future documentation changes will enable embedded docs for official plugins, doc search, as well as including the blog on the main domain. As an added bonus, our documentation now has SSL!","title":"Documentation is now at dokku.com"},{"location":"2021/dokku-0.23.x-wrapup/#checking-if-an-app-was-deployed","text":"Previously, checking if an app was deployed actually checked if there were any running processes. This is not only incorrect, but also fails to take into account applications that do not have running processes and are only used for one-off commands. The fix in #4402 migrates apps to the new \"deployed\" property which is set in core-post-deploy. The result is a slightly faster \"deployed\" check that is correct and allows non-scaled apps to actually work.","title":"Checking if an app was deployed"},{"location":"2021/dokku-0.23.x-wrapup/#better-procfile-extraction","text":"As of #4373 , the Procfile is now extracted in the pre-deploy step for every deploy and otherwise not removed. Thus, it should always exist when necessary - web will be scale to 1 automatically and it won't need to be present on future ps:scale calls since we'll have the scale file - and the command can execute faster.","title":"Better Procfile extraction"},{"location":"2021/dokku-0.23.x-wrapup/#its-a-wrap","text":"And that's it for 0.23.x. Our next post will cover 0.24.0, as well as plans for future releases. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"It's a wrap"},{"location":"2021/dokku-0.24.0/","tags":["dokku","release"],"text":"Dokku version 0.24.0 was released earlier this week with a few new features that some power users may find useful. We'll go over major changes below. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. Changes Change exit code when app does not exist This will allow wrappers around dokku to avoid needing two calls to dokku - one for apps:exists, the other for the command you want to run itself - to see if the app does not exist or if the error was something else. Builders of UI systems on top of Dokku may wish to take advantage of this functionality to decrease the number of calls they need to make to Dokku. Finally, plugin developers should always use verify_app_name() (shell) and common.VerifyAppName() (go) when verifying the app name to ensure they also receive this same functionality. New Features Support for heroku's postdeploy deployment task Our existing deployment task support covered a wide range of use cases, but of course did not implement Heroku's own postdeploy support. This deployment task is commonly used to seed data into apps, especially for Heroku's \"review app\" functionality. As of 0.24.0, Dokku implements support for Heroku's postdeploy hook. This is currently triggered during the postdeploy on the first deploy of an app, mimicking heroku. It currently happens after the release task, during the pre-deploy trigger, which more or less mimics the release phase. Git Authentication handling via .netrc With the new git:sync functionality introduced in 0.23.0 , users of private repositories immediately saw an issue with their ability to use the feature. To enable those users to deploy private apps, the netrc binary was built, and a wrapper git:auth command was added to Dokku. This new command allows users to specify custom git server authentication information for use with git:sync by modifying the ~dokku/.netrc file. The alternative is to use ssh keys, which is still supported. This PR additionally outputs an error message when we detect an auth error: There is no deploy key associated with the dokku user. Generate an ssh key with the following command (do not specify a password): ssh-keygen -t ed25519 -C 'example@example.com' As an alternative, configure the netrc authentication via the git:auth command This should allow folks to figure out what they need to do. Lastly, the clone/fetch commands no longer use -qq or stderr redirection. If there are other errors, this will allow operators to have some debugging information. Simplified docker image deployment via git:from-image There are a ton of people that want to deploy a docker image. To do that, they currently need to: pull the image via docker pull tags:deploy it avoid ps:rebuild , which ignores tags:deploy avoid git repositories, which will result in breaking tags:deploy The above doesn't quite work without root server access, so anyone who only exposes the dokku user cannot use the above workflow without an extra plugin. They can also do a git repository workflow - creating a repository, updating it with the built image, pushing it - but there are more than a few steps needed to do that correctly and keep history. Pull Request #4450 implements git:from-image . Under the hood, this command creates or updates the git repository for the app with the specified image. The workflow implements all the above steps for users in a way that allows ignoring direct exposure of docker pull as a Dokku command (which would open the flood gates to all docker commands). It also keeps the git workflow (so you get history) and enables a whole class of users to properly deploy docker images. There is other stuff this might enable, like an app library, but the main idea is to enable a class of users that has been typically under-served. For tags plugin users, note that this functionality deprecates the tags plugin, which will be removed in the next minor release. Please migrate any workflows currently using the tags plugin to git:from-image . Simplified archive deployment via git:from-archive Similar to git:from-image - and using the same internal infrastructure to manage history - there is a new git:from-archive command. This new command supports deploying .tar , .tar.gz , and .zip files to apps, keeping git history with every deploy. In addition to a url, it also supports piping the archive in via stdin. The git:from-archive command is meant to be used in cases where the deployment model is to deploy from a git tag. This may mean that the artifact is already built and just needs extraction, or can continue to use the normal build process available in Dokku. For tar plugin users, note that this functionality deprecates the tar plugin, which will be removed in the next minor release. Please migrate any workflows currently using the tar plugin to git:from-image . Specifying app builders Dokku currently supports three different types of app builders: Dockerfile Herokuish (for Buildpack Heroku v2a compatibility) Pack (for Cloud Native Buildpacks compatibility) The specification of the app builder is somewhat hard-coded and actually annoying for users that wish to use a specific builder for their app. In addition, it was impossible to inject your own custom builder, frustrating folks that have very specific constraints about how they generate Docker images. Rather than hardcode the various builders, this new feature allows builder plugins to specify a builder-detect trigger. This trigger can be used to specify if the builder should or should not be used for an application. Each builder takes the app directory and can decide if it should emit it's own image source type. If the final list of detected builders is empty, then Dokku will default to herokuish (and pack/CNB once that is stable). Users may also override the builder via the builder:set command. This change enables users to build custom builder plugins and have those plugins used for building an image asset. By way of example, an enterprising user could create a builder-lambda based on lambci, and then pair this with a scheduler plugin that updates a lambda function on AWS. Alternatively, a user might decide they wish to place their Dockerfile in a specific directory for their applications - such as an _infrastructure directory - and create a plugin to override how that is detected within Dokku. An enterprising user has already built a builder-nix plugin that builds Docker images via NixOS. Parallelism for some proxy commands Being able to specify --all and increase parallelism of save commands is always great. As of 0.24.0, the commands proxy:enable , proxy:disable and proxy:build-config now support the --all flag in addition to general parallelism. If parallelism is needed for a specific command, please file an issue to get it added :) The Next Minor Release Our next release will continue on the 16 outstanding 1.0 issues . We hope to knock out a few of these, especially those related to Dockerfile and ports handling. We encourage folks to take a peak at them and help investigate bugs, come up with work plans, or contribute PRs where possible to help bring us over the finish line. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Dokku Release 0.24.0"},{"location":"2021/dokku-0.24.0/#changes","text":"","title":"Changes"},{"location":"2021/dokku-0.24.0/#change-exit-code-when-app-does-not-exist","text":"This will allow wrappers around dokku to avoid needing two calls to dokku - one for apps:exists, the other for the command you want to run itself - to see if the app does not exist or if the error was something else. Builders of UI systems on top of Dokku may wish to take advantage of this functionality to decrease the number of calls they need to make to Dokku. Finally, plugin developers should always use verify_app_name() (shell) and common.VerifyAppName() (go) when verifying the app name to ensure they also receive this same functionality.","title":"Change exit code when app does not exist"},{"location":"2021/dokku-0.24.0/#new-features","text":"","title":"New Features"},{"location":"2021/dokku-0.24.0/#support-for-herokus-postdeploy-deployment-task","text":"Our existing deployment task support covered a wide range of use cases, but of course did not implement Heroku's own postdeploy support. This deployment task is commonly used to seed data into apps, especially for Heroku's \"review app\" functionality. As of 0.24.0, Dokku implements support for Heroku's postdeploy hook. This is currently triggered during the postdeploy on the first deploy of an app, mimicking heroku. It currently happens after the release task, during the pre-deploy trigger, which more or less mimics the release phase.","title":"Support for heroku's postdeploy deployment task"},{"location":"2021/dokku-0.24.0/#git-authentication-handling-via-netrc","text":"With the new git:sync functionality introduced in 0.23.0 , users of private repositories immediately saw an issue with their ability to use the feature. To enable those users to deploy private apps, the netrc binary was built, and a wrapper git:auth command was added to Dokku. This new command allows users to specify custom git server authentication information for use with git:sync by modifying the ~dokku/.netrc file. The alternative is to use ssh keys, which is still supported. This PR additionally outputs an error message when we detect an auth error: There is no deploy key associated with the dokku user. Generate an ssh key with the following command (do not specify a password): ssh-keygen -t ed25519 -C 'example@example.com' As an alternative, configure the netrc authentication via the git:auth command This should allow folks to figure out what they need to do. Lastly, the clone/fetch commands no longer use -qq or stderr redirection. If there are other errors, this will allow operators to have some debugging information.","title":"Git Authentication handling via .netrc"},{"location":"2021/dokku-0.24.0/#simplified-docker-image-deployment-via-gitfrom-image","text":"There are a ton of people that want to deploy a docker image. To do that, they currently need to: pull the image via docker pull tags:deploy it avoid ps:rebuild , which ignores tags:deploy avoid git repositories, which will result in breaking tags:deploy The above doesn't quite work without root server access, so anyone who only exposes the dokku user cannot use the above workflow without an extra plugin. They can also do a git repository workflow - creating a repository, updating it with the built image, pushing it - but there are more than a few steps needed to do that correctly and keep history. Pull Request #4450 implements git:from-image . Under the hood, this command creates or updates the git repository for the app with the specified image. The workflow implements all the above steps for users in a way that allows ignoring direct exposure of docker pull as a Dokku command (which would open the flood gates to all docker commands). It also keeps the git workflow (so you get history) and enables a whole class of users to properly deploy docker images. There is other stuff this might enable, like an app library, but the main idea is to enable a class of users that has been typically under-served. For tags plugin users, note that this functionality deprecates the tags plugin, which will be removed in the next minor release. Please migrate any workflows currently using the tags plugin to git:from-image .","title":"Simplified docker image deployment via git:from-image"},{"location":"2021/dokku-0.24.0/#simplified-archive-deployment-via-gitfrom-archive","text":"Similar to git:from-image - and using the same internal infrastructure to manage history - there is a new git:from-archive command. This new command supports deploying .tar , .tar.gz , and .zip files to apps, keeping git history with every deploy. In addition to a url, it also supports piping the archive in via stdin. The git:from-archive command is meant to be used in cases where the deployment model is to deploy from a git tag. This may mean that the artifact is already built and just needs extraction, or can continue to use the normal build process available in Dokku. For tar plugin users, note that this functionality deprecates the tar plugin, which will be removed in the next minor release. Please migrate any workflows currently using the tar plugin to git:from-image .","title":"Simplified archive deployment via git:from-archive"},{"location":"2021/dokku-0.24.0/#specifying-app-builders","text":"Dokku currently supports three different types of app builders: Dockerfile Herokuish (for Buildpack Heroku v2a compatibility) Pack (for Cloud Native Buildpacks compatibility) The specification of the app builder is somewhat hard-coded and actually annoying for users that wish to use a specific builder for their app. In addition, it was impossible to inject your own custom builder, frustrating folks that have very specific constraints about how they generate Docker images. Rather than hardcode the various builders, this new feature allows builder plugins to specify a builder-detect trigger. This trigger can be used to specify if the builder should or should not be used for an application. Each builder takes the app directory and can decide if it should emit it's own image source type. If the final list of detected builders is empty, then Dokku will default to herokuish (and pack/CNB once that is stable). Users may also override the builder via the builder:set command. This change enables users to build custom builder plugins and have those plugins used for building an image asset. By way of example, an enterprising user could create a builder-lambda based on lambci, and then pair this with a scheduler plugin that updates a lambda function on AWS. Alternatively, a user might decide they wish to place their Dockerfile in a specific directory for their applications - such as an _infrastructure directory - and create a plugin to override how that is detected within Dokku. An enterprising user has already built a builder-nix plugin that builds Docker images via NixOS.","title":"Specifying app builders"},{"location":"2021/dokku-0.24.0/#parallelism-for-some-proxy-commands","text":"Being able to specify --all and increase parallelism of save commands is always great. As of 0.24.0, the commands proxy:enable , proxy:disable and proxy:build-config now support the --all flag in addition to general parallelism. If parallelism is needed for a specific command, please file an issue to get it added :)","title":"Parallelism for some proxy commands"},{"location":"2021/dokku-0.24.0/#the-next-minor-release","text":"Our next release will continue on the 16 outstanding 1.0 issues . We hope to knock out a few of these, especially those related to Dockerfile and ports handling. We encourage folks to take a peak at them and help investigate bugs, come up with work plans, or contribute PRs where possible to help bring us over the finish line. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"The Next Minor Release"},{"location":"2021/dokku-0.25.0/","tags":["dokku","release"],"text":"With the 0.25.x release of Dokku a few weeks ago, a folks may have questions as to why they would want to upgrade and how it would impact their workflows. We've cherry-picked a few more important changes, but feel free to go through the release notes for more information. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. Changes Make heroku-20/focal the default stack for herokuish builds With the release of newer versions of Ubuntu, the heroku-18 stack (based on Ubuntu 18.04) was getting a bit long in the tooth. We've since switched to heroku-20 as our default. Many apps will continue to work as before, though some with compiled dependencies may have issues. This may be fixed by either of the following: Clearing build cache, which will force a rebuild: dokku repo:purge-cache $APP Setting the stack to heroku-18 : dokku buildpacks:set-property $APP stack gliderlabs/herokuish:latest-18 Users may also set the stack property globally by specifying --global instead of an app name. Drop web installer in favor of setup via cli Dokku has had a Web installer for years. This installer has been useful for getting started - especially when setup via a cloud image on popular hosting providers - but has been an open security risk for those that forget that it exists. Rather than try weird schemes to lock it down or notify users that it is still around, we've decided to remove it completely. It's usage is replaced by the following commands: # usually your key is already available under the current user's `~/.ssh/authorized_keys` file cat ~/.ssh/authorized_keys | dokku ssh-keys:add admin # you can use any domain you already have access to, also takes an IP address dokku domains:set-global dokku.me We strive to make Dokku secure by default, and this is a step in that direction. Drop support for Ubuntu 16.04 While our debian packages are generic enough to use on any Debian-based operating system, we've dropped support for Ubuntu 16.04 as it reached the public End of Life in April of 2021. This allows us to spend more time testing on newer systems. We've also added initial support for Debian Bullseye (in 0.25.2) for those using Debian's latest release. We will continue to add support for other operating systems as time goes on. New Features Add support for the formation key in app.json Dokku has long had support for a DOKKU_SCALE file that tracked repo-specified scaling settings for apps. This was also the name for a file on disk that held the scale contents. Code handling whether a user could scale or not was quite brittle. Users may now specify a formation key in their app.json file. This is similar to heroku, and currently supports scale quantity on a per-process basis. { \"formation\" : { \"web\" : { \"quantity\" : 1 }, \"worker\" : { \"quantity\" : 4 } } } The goal here is to consolidate various app config stored in a variety of files in repo into one app.json file. We'll be following Heroku's specification around this file where possible, but will extend it where necessary - as we did with Cron support in 0.23.x . See the process management documentation for more information on how to use this in your apps. Add monorepo support Some users may find a need to deploy an app several times with slightly different settings each time. This generally works by setting environment variables as necessary, but some things require changing which in-repo files are used. We've made changes across Dokku to respect changing the following: appjson-path : description: Controls what the path is to the app.json file command: dokku app-json:set $APP appjson-path build-dir : description: Controls the root app directory for builds command: dokku builder:set $APP build-dir projecttoml-path : description: Controls the project.toml path used for Cloud Native Buildpack builds command: dokku builder-pack:set $APP projecttoml-path dockerfile-path : description: Controls the Dockerfile path for dockerfile-based builds command: dokku builder-dockerfile:set $APP dockerfile-path procfile-path : description: Controls the path to the Procfile command: dokku ps:set $APP procfile-path Feel free to file issues for any other files in use by Dokku that should be changed to allow better monorepo support. Implement the registry plugin Users of the new git:from-image functionality introduced in 0.24 may have noticed missing support for authenticating against remote registries. This was added in the new registry management plugin , and generally supports the same interface you'd see with docker login : # hub.docker.com dokku registry:login docker.io $USERNAME $PASSWORD # password via stdin echo \" $PASSWORD \" | dokku registry:login --password-stdin docker.io $USERNAME Additionally, schedulers other than the docker-local scheduler require that the deployed image be available on a registry. This plugin can be used for upload images after the build process completes. dokku registry:set node-js-app push-on-release true Images will be pushed to Docker Hub by default. Users may specify an alternative registry by setting the server property: dokku registry:set node-js-app server registry.digitalocean.com/ Users of the community dokku-registry plugin should uninstall that plugin before upgrading Dokku, and then ensure that their apps are re-configured with the built-in plugin. See the registry management documentation for more information on how to use the registry plugin. Revamp the dokku run command The dokku run command was often misunderstood. Users assumed the containers would disappear after use, and there was no way to understand what containers were running via dokku run . The new release automatically includes the --rm flag on containers created by dokku run . Users wishing to run detached containers should use the dokku run:detached command. We also introduced the run:list command, which can be used to list all containers created by dokku run (by filtering on the com.dokku.container-type=run docker label). Users will be able to quickly see what is currently running. In the future, users may be able to enter those running containers via run:enter , and remove any errant ones via run:destroy . Please note that implementation and semantics of dokku run are up to individual scheduler plugins. Routing to non-Dokku managed apps In some cases, it may be necessary to route an app to an existing $IP:$PORT combination. This is particularly the case for internal admin tools or services that aren't run by Dokku but have a web ui that would benefit from being exposed by Dokku. This can be done by setting a value for static-web-lister network property and running a few other commands when creating an app. # for a service listening on: # - ip address: 127.0.0.1 # - port: 8080 # create the app dokku apps:create local-app # set the builder to the null builder, which does nothing dokku builder:set local-app selected null # set the scheduler to the null scheduler, which does nothing # for dokku 0.25.x dokku config:set local-app DOKKU_SCHEDULER = null # for dokku 0.26+ dokku scheduler:set local-app selected null # set the static-web-listener network property to the ip:port combination for your app. dokku network:set local-app static-web-listener 127 .0.0.1:8080 # set the port map as desired for the port specified in your static-web-listener dokku proxy:ports-set local-app http:80:8080 # set the domains desired dokku domains:set local-app local-app.dokku.me # build the proxy config dokku proxy:build-config local-app The above takes advantage of new null builder and scheduler plugins that do nothing during the build or schedule phases. This functionality can be used when trying to expose non-Dokku maintained services to the external world without requiring a deployed proxy. One nice side-effect is that this also means users can expose services with letsencrypt support. The Next Minor Release Our next release will continue on the 14 outstanding 1.0 issues . We encourage folks to take a peak at them and help investigate bugs, come up with work plans, or contribute PRs where possible to help bring us over the finish line. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Dokku Release 0.25.0"},{"location":"2021/dokku-0.25.0/#changes","text":"","title":"Changes"},{"location":"2021/dokku-0.25.0/#make-heroku-20focal-the-default-stack-for-herokuish-builds","text":"With the release of newer versions of Ubuntu, the heroku-18 stack (based on Ubuntu 18.04) was getting a bit long in the tooth. We've since switched to heroku-20 as our default. Many apps will continue to work as before, though some with compiled dependencies may have issues. This may be fixed by either of the following: Clearing build cache, which will force a rebuild: dokku repo:purge-cache $APP Setting the stack to heroku-18 : dokku buildpacks:set-property $APP stack gliderlabs/herokuish:latest-18 Users may also set the stack property globally by specifying --global instead of an app name.","title":"Make heroku-20/focal the default stack for herokuish builds"},{"location":"2021/dokku-0.25.0/#drop-web-installer-in-favor-of-setup-via-cli","text":"Dokku has had a Web installer for years. This installer has been useful for getting started - especially when setup via a cloud image on popular hosting providers - but has been an open security risk for those that forget that it exists. Rather than try weird schemes to lock it down or notify users that it is still around, we've decided to remove it completely. It's usage is replaced by the following commands: # usually your key is already available under the current user's `~/.ssh/authorized_keys` file cat ~/.ssh/authorized_keys | dokku ssh-keys:add admin # you can use any domain you already have access to, also takes an IP address dokku domains:set-global dokku.me We strive to make Dokku secure by default, and this is a step in that direction.","title":"Drop web installer in favor of setup via cli"},{"location":"2021/dokku-0.25.0/#drop-support-for-ubuntu-1604","text":"While our debian packages are generic enough to use on any Debian-based operating system, we've dropped support for Ubuntu 16.04 as it reached the public End of Life in April of 2021. This allows us to spend more time testing on newer systems. We've also added initial support for Debian Bullseye (in 0.25.2) for those using Debian's latest release. We will continue to add support for other operating systems as time goes on.","title":"Drop support for Ubuntu 16.04"},{"location":"2021/dokku-0.25.0/#new-features","text":"","title":"New Features"},{"location":"2021/dokku-0.25.0/#add-support-for-the-formation-key-in-appjson","text":"Dokku has long had support for a DOKKU_SCALE file that tracked repo-specified scaling settings for apps. This was also the name for a file on disk that held the scale contents. Code handling whether a user could scale or not was quite brittle. Users may now specify a formation key in their app.json file. This is similar to heroku, and currently supports scale quantity on a per-process basis. { \"formation\" : { \"web\" : { \"quantity\" : 1 }, \"worker\" : { \"quantity\" : 4 } } } The goal here is to consolidate various app config stored in a variety of files in repo into one app.json file. We'll be following Heroku's specification around this file where possible, but will extend it where necessary - as we did with Cron support in 0.23.x . See the process management documentation for more information on how to use this in your apps.","title":"Add support for the formation key in app.json"},{"location":"2021/dokku-0.25.0/#add-monorepo-support","text":"Some users may find a need to deploy an app several times with slightly different settings each time. This generally works by setting environment variables as necessary, but some things require changing which in-repo files are used. We've made changes across Dokku to respect changing the following: appjson-path : description: Controls what the path is to the app.json file command: dokku app-json:set $APP appjson-path build-dir : description: Controls the root app directory for builds command: dokku builder:set $APP build-dir projecttoml-path : description: Controls the project.toml path used for Cloud Native Buildpack builds command: dokku builder-pack:set $APP projecttoml-path dockerfile-path : description: Controls the Dockerfile path for dockerfile-based builds command: dokku builder-dockerfile:set $APP dockerfile-path procfile-path : description: Controls the path to the Procfile command: dokku ps:set $APP procfile-path Feel free to file issues for any other files in use by Dokku that should be changed to allow better monorepo support.","title":"Add monorepo support"},{"location":"2021/dokku-0.25.0/#implement-the-registry-plugin","text":"Users of the new git:from-image functionality introduced in 0.24 may have noticed missing support for authenticating against remote registries. This was added in the new registry management plugin , and generally supports the same interface you'd see with docker login : # hub.docker.com dokku registry:login docker.io $USERNAME $PASSWORD # password via stdin echo \" $PASSWORD \" | dokku registry:login --password-stdin docker.io $USERNAME Additionally, schedulers other than the docker-local scheduler require that the deployed image be available on a registry. This plugin can be used for upload images after the build process completes. dokku registry:set node-js-app push-on-release true Images will be pushed to Docker Hub by default. Users may specify an alternative registry by setting the server property: dokku registry:set node-js-app server registry.digitalocean.com/ Users of the community dokku-registry plugin should uninstall that plugin before upgrading Dokku, and then ensure that their apps are re-configured with the built-in plugin. See the registry management documentation for more information on how to use the registry plugin.","title":"Implement the registry plugin"},{"location":"2021/dokku-0.25.0/#revamp-the-dokku-run-command","text":"The dokku run command was often misunderstood. Users assumed the containers would disappear after use, and there was no way to understand what containers were running via dokku run . The new release automatically includes the --rm flag on containers created by dokku run . Users wishing to run detached containers should use the dokku run:detached command. We also introduced the run:list command, which can be used to list all containers created by dokku run (by filtering on the com.dokku.container-type=run docker label). Users will be able to quickly see what is currently running. In the future, users may be able to enter those running containers via run:enter , and remove any errant ones via run:destroy . Please note that implementation and semantics of dokku run are up to individual scheduler plugins.","title":"Revamp the dokku run command"},{"location":"2021/dokku-0.25.0/#routing-to-non-dokku-managed-apps","text":"In some cases, it may be necessary to route an app to an existing $IP:$PORT combination. This is particularly the case for internal admin tools or services that aren't run by Dokku but have a web ui that would benefit from being exposed by Dokku. This can be done by setting a value for static-web-lister network property and running a few other commands when creating an app. # for a service listening on: # - ip address: 127.0.0.1 # - port: 8080 # create the app dokku apps:create local-app # set the builder to the null builder, which does nothing dokku builder:set local-app selected null # set the scheduler to the null scheduler, which does nothing # for dokku 0.25.x dokku config:set local-app DOKKU_SCHEDULER = null # for dokku 0.26+ dokku scheduler:set local-app selected null # set the static-web-listener network property to the ip:port combination for your app. dokku network:set local-app static-web-listener 127 .0.0.1:8080 # set the port map as desired for the port specified in your static-web-listener dokku proxy:ports-set local-app http:80:8080 # set the domains desired dokku domains:set local-app local-app.dokku.me # build the proxy config dokku proxy:build-config local-app The above takes advantage of new null builder and scheduler plugins that do nothing during the build or schedule phases. This functionality can be used when trying to expose non-Dokku maintained services to the external world without requiring a deployed proxy. One nice side-effect is that this also means users can expose services with letsencrypt support.","title":"Routing to non-Dokku managed apps"},{"location":"2021/dokku-0.25.0/#the-next-minor-release","text":"Our next release will continue on the 14 outstanding 1.0 issues . We encourage folks to take a peak at them and help investigate bugs, come up with work plans, or contribute PRs where possible to help bring us over the finish line. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"The Next Minor Release"},{"location":"2021/dokku-0.26.0/","tags":["dokku","release"],"text":"It's been a little over two weeks since our 0.26.x release landed. Here is a summary of what features were added during the 0.25.x release and new stuff in 0.26.x. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. New Features during the 0.25.x Series Debian Bullseye Support #4742 Dokku has supported both Debian and Ubuntu for quite a while - our packages are universal and actually can be installed all the way back to Ubuntu 14.04, even though we no longer officially support it. Bullseye came in a few days after the 0.25.0 release, so adding support for it made total sense. Faster Herokuish builds when injecting environment variables #4741 Previously, herokuish buildpack builds would use intermediate containers for injecting the initial environment variables during the build process. This was actually quite slow - a container is created, started, some command is run, and then we create the image from that container - and also sometimes resulted in leftover containers if a build failed. We now initialize app environment variables via a special Dockerfile, which skips the intermediate container completely. Not only is this a bit faster, but we also no longer need to cleanup after the intermediate container. VSCode Remote Container Support #4785 #4791 #4800 #4814 For anyone doing Dokku development, being able to simulate the entire environment is :major: for productivity. Setting up a virtual machine can be: Slow: you are competing for system resource during the build Error Prone: Virtualbox doesn\u2019t work for me, but also the entire build may fail if you are not on a network Impossible: Our development environment isn\u2019t tested at all on Windows, knocking off a ton of potential contributors We\u2019ve since added more complete support for developing in VSCode\u2019s Remote Container environment. In the future, supporting Azure and GitHub dev containers is in the cards, but this should enable most developers to more smoothly develop, test, and contribute to Dokku. Schedule Process Types in Parallel This functionality was graciously sponsored by Rechat , a company doing remarkable efforts to help simplify and elevate how Real Estate Agents and Brokers operate. #4829 Previously, we would deploy each container process type one at a time. For most users, this was not a huge deal, but users deploying apps with 10+ apps would encounter multi-minute deploys. As of 0.25.5, users can set the parallelism on processed process types. The web process is now always deployed first, while all other processes will deployed after the fact. The following command will set parallelism to 4 (default: 1) for non-web processes: dokku scheduler-docker-local:set $APP parallel-schedule-count 4 This only applies to the list of process types scheduled at once, not individual containers within a process type. Changes in 0.26.x Removal of deprecated tags and tar plugins #4858 #4859 These two plugins were previously deprecated in 0.24.x in favor of git:from-image and git:from-archive, respectively. Rather than keep an unmaintained, buggy implementation of deployment, we\u2019ve completely removed these two plugins. Users should switch to the recommended methods of deployment, which are much more flexible and better integrate with Dokku. Faster restarts and single-process restarts #4765 Previously a restart would result in a complete rebuild of an application. With this change, restarts will now only rebuild when the image does not exist, and otherwise simply restart processes with the built image. In addition, a user may restart just a single process type. While not common, this can be used as a proxy for killing processes that consume memory, while not requiring a full app rebuild or restart. Increase parallelism for containers within specific process types #4860 As a followup to #4829 , apps deployed via the docker-local scheduler can now perform parallel scheduling for specific process types. The default configuration follows the existing behavior, while engineers that need extra parallelism on a per-process type basis can configure it via the app.json file: { \u201cformation\u201d: { \u201cweb\u201d: { \u201cmax_parallel\u201d: 3 } } } Parallelism defaults to 1 (previous behavior) but can be increased as needed. Scheduler Management Plugin #4857 As we move towards a 1.0 release, Dokku\u2019s internal configuration that can be modified via environment variables is being moved into plugin-specific configuration settings. Setting a scheduler is one of them, and 0.26.0 will migrate the DOKKU_SCHEDULER environment variable to a scheduler plugin setting. Going forward, should set the scheduler via scheduler:set [app|\u2014global] selected call. Raspberry PI Support #4885 #4887 #4888 #4889 Dokku has always lived in the realm of self-hosting, but it was always x86-based. This completely precluded ARM users from using Dokku, which wasn\u2019t great for those who fully self-hosted, servers included. In the first few releases of 0.26.x, we\u2019ve added armhf architecture support, allowing those using Raspbian to install Dokku. Adding support for other ARM architectures should be rather trivial in the future (provided there is Golang support). Some notes: Herokuish builds will never be supported as the heroku Buildpacks only support x86. Cloud Native Buildpack usage pack does not currently support ARM, though we will be helping upstream to get that rolling so developers can use Cloud Native Buildpacks. Dockerfile builds should work if your base image works on ARM. While there are some limitations, the general Dokku experience works quite well on ARM, and hopefully opens up experimentation to the general development community. Dokku Pro Dokku Pro is a commercial offering that provides a familiar Web UI for all common tasks performed by developers. End users can expect an interface that provides various complex cli commands in an intuitive, app-centric manner, quickly speeding up tasks that might otherwise be difficult for new and old users to perform. Additionally, it provides a way to perform these tasks remotely via a json api, enabling easier, audited remote management of servers. Finally, Dokku Pro provides an alternative, https-based method for deploying code which can be used in environments that lockdown ssh access to servers. We'll have more information in the coming week, but Dokku Pro will be provided under early bird pricing (with the price going up as we continue to release new versions). Server licenses are sold in perpetuity, so lock in lower pricing today! Purchase Now The Next Minor Release Our next release will continue on the 9 outstanding 1.0 issues . We encourage folks to take a peak at them and help investigate bugs, come up with work plans, or contribute PRs where possible to help bring us over the finish line. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Dokku Release 0.26.0"},{"location":"2021/dokku-0.26.0/#new-features-during-the-025x-series","text":"","title":"New Features during the 0.25.x Series"},{"location":"2021/dokku-0.26.0/#debian-bullseye-support","text":"#4742 Dokku has supported both Debian and Ubuntu for quite a while - our packages are universal and actually can be installed all the way back to Ubuntu 14.04, even though we no longer officially support it. Bullseye came in a few days after the 0.25.0 release, so adding support for it made total sense.","title":"Debian Bullseye Support"},{"location":"2021/dokku-0.26.0/#faster-herokuish-builds-when-injecting-environment-variables","text":"#4741 Previously, herokuish buildpack builds would use intermediate containers for injecting the initial environment variables during the build process. This was actually quite slow - a container is created, started, some command is run, and then we create the image from that container - and also sometimes resulted in leftover containers if a build failed. We now initialize app environment variables via a special Dockerfile, which skips the intermediate container completely. Not only is this a bit faster, but we also no longer need to cleanup after the intermediate container.","title":"Faster Herokuish builds when injecting environment variables"},{"location":"2021/dokku-0.26.0/#vscode-remote-container-support","text":"#4785 #4791 #4800 #4814 For anyone doing Dokku development, being able to simulate the entire environment is :major: for productivity. Setting up a virtual machine can be: Slow: you are competing for system resource during the build Error Prone: Virtualbox doesn\u2019t work for me, but also the entire build may fail if you are not on a network Impossible: Our development environment isn\u2019t tested at all on Windows, knocking off a ton of potential contributors We\u2019ve since added more complete support for developing in VSCode\u2019s Remote Container environment. In the future, supporting Azure and GitHub dev containers is in the cards, but this should enable most developers to more smoothly develop, test, and contribute to Dokku.","title":"VSCode Remote Container Support"},{"location":"2021/dokku-0.26.0/#schedule-process-types-in-parallel","text":"This functionality was graciously sponsored by Rechat , a company doing remarkable efforts to help simplify and elevate how Real Estate Agents and Brokers operate. #4829 Previously, we would deploy each container process type one at a time. For most users, this was not a huge deal, but users deploying apps with 10+ apps would encounter multi-minute deploys. As of 0.25.5, users can set the parallelism on processed process types. The web process is now always deployed first, while all other processes will deployed after the fact. The following command will set parallelism to 4 (default: 1) for non-web processes: dokku scheduler-docker-local:set $APP parallel-schedule-count 4 This only applies to the list of process types scheduled at once, not individual containers within a process type.","title":"Schedule Process Types in Parallel"},{"location":"2021/dokku-0.26.0/#changes-in-026x","text":"","title":"Changes in 0.26.x"},{"location":"2021/dokku-0.26.0/#removal-of-deprecated-tags-and-tar-plugins","text":"#4858 #4859 These two plugins were previously deprecated in 0.24.x in favor of git:from-image and git:from-archive, respectively. Rather than keep an unmaintained, buggy implementation of deployment, we\u2019ve completely removed these two plugins. Users should switch to the recommended methods of deployment, which are much more flexible and better integrate with Dokku.","title":"Removal of deprecated tags and tar plugins"},{"location":"2021/dokku-0.26.0/#faster-restarts-and-single-process-restarts","text":"#4765 Previously a restart would result in a complete rebuild of an application. With this change, restarts will now only rebuild when the image does not exist, and otherwise simply restart processes with the built image. In addition, a user may restart just a single process type. While not common, this can be used as a proxy for killing processes that consume memory, while not requiring a full app rebuild or restart.","title":"Faster restarts and single-process restarts"},{"location":"2021/dokku-0.26.0/#increase-parallelism-for-containers-within-specific-process-types","text":"#4860 As a followup to #4829 , apps deployed via the docker-local scheduler can now perform parallel scheduling for specific process types. The default configuration follows the existing behavior, while engineers that need extra parallelism on a per-process type basis can configure it via the app.json file: { \u201cformation\u201d: { \u201cweb\u201d: { \u201cmax_parallel\u201d: 3 } } } Parallelism defaults to 1 (previous behavior) but can be increased as needed.","title":"Increase parallelism for containers within specific process types"},{"location":"2021/dokku-0.26.0/#scheduler-management-plugin","text":"#4857 As we move towards a 1.0 release, Dokku\u2019s internal configuration that can be modified via environment variables is being moved into plugin-specific configuration settings. Setting a scheduler is one of them, and 0.26.0 will migrate the DOKKU_SCHEDULER environment variable to a scheduler plugin setting. Going forward, should set the scheduler via scheduler:set [app|\u2014global] selected call.","title":"Scheduler Management Plugin"},{"location":"2021/dokku-0.26.0/#raspberry-pi-support","text":"#4885 #4887 #4888 #4889 Dokku has always lived in the realm of self-hosting, but it was always x86-based. This completely precluded ARM users from using Dokku, which wasn\u2019t great for those who fully self-hosted, servers included. In the first few releases of 0.26.x, we\u2019ve added armhf architecture support, allowing those using Raspbian to install Dokku. Adding support for other ARM architectures should be rather trivial in the future (provided there is Golang support). Some notes: Herokuish builds will never be supported as the heroku Buildpacks only support x86. Cloud Native Buildpack usage pack does not currently support ARM, though we will be helping upstream to get that rolling so developers can use Cloud Native Buildpacks. Dockerfile builds should work if your base image works on ARM. While there are some limitations, the general Dokku experience works quite well on ARM, and hopefully opens up experimentation to the general development community.","title":"Raspberry PI Support"},{"location":"2021/dokku-0.26.0/#dokku-pro","text":"Dokku Pro is a commercial offering that provides a familiar Web UI for all common tasks performed by developers. End users can expect an interface that provides various complex cli commands in an intuitive, app-centric manner, quickly speeding up tasks that might otherwise be difficult for new and old users to perform. Additionally, it provides a way to perform these tasks remotely via a json api, enabling easier, audited remote management of servers. Finally, Dokku Pro provides an alternative, https-based method for deploying code which can be used in environments that lockdown ssh access to servers. We'll have more information in the coming week, but Dokku Pro will be provided under early bird pricing (with the price going up as we continue to release new versions). Server licenses are sold in perpetuity, so lock in lower pricing today! Purchase Now","title":"Dokku Pro"},{"location":"2021/dokku-0.26.0/#the-next-minor-release","text":"Our next release will continue on the 9 outstanding 1.0 issues . We encourage folks to take a peak at them and help investigate bugs, come up with work plans, or contribute PRs where possible to help bring us over the finish line. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"The Next Minor Release"},{"location":"2021/dokku-0.28.0/","tags":["dokku","release"],"text":"It's been a little over two weeks since our 0.28.x release landed. Here is a summary of what new stuff is in 0.28.x. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. Changes in 0.26.x Removal of deprecated tags and tar plugins #4858 #4859 These two plugins were previously deprecated in 0.24.x in favor of git:from-image and git:from-archive, respectively. Rather than keep an unmaintained, buggy implementation of deployment, we\u2019ve completely removed these two plugins. Users should switch to the recommended methods of deployment, which are much more flexible and better integrate with Dokku. Faster restarts and single-process restarts #4765 Previously a restart would result in a complete rebuild of an application. With this change, restarts will now only rebuild when the image does not exist, and otherwise simply restart processes with the built image. In addition, a user may restart just a single process type. While not common, this can be used as a proxy for killing processes that consume memory, while not requiring a full app rebuild or restart. Increase parallelism for containers within specific process types #4860 As a followup to #4829 , apps deployed via the docker-local scheduler can now perform parallel scheduling for specific process types. The default configuration follows the existing behavior, while engineers that need extra parallelism on a per-process type basis can configure it via the app.json file: { \u201cformation\u201d: { \u201cweb\u201d: { \u201cmax_parallel\u201d: 3 } } } Parallelism defaults to 1 (previous behavior) but can be increased as needed. Scheduler Management Plugin #4857 As we move towards a 1.0 release, Dokku\u2019s internal configuration that can be modified via environment variables is being moved into plugin-specific configuration settings. Setting a scheduler is one of them, and 0.26.0 will migrate the DOKKU_SCHEDULER environment variable to a scheduler plugin setting. Going forward, should set the scheduler via scheduler:set [app|\u2014global] selected call. Raspberry PI Support #4885 #4887 #4888 #4889 Dokku has always lived in the realm of self-hosting, but it was always x86-based. This completely precluded ARM users from using Dokku, which wasn\u2019t great for those who fully self-hosted, servers included. In the first few releases of 0.26.x, we\u2019ve added armhf architecture support, allowing those using Raspbian to install Dokku. Adding support for other ARM architectures should be rather trivial in the future (provided there is Golang support). Some notes: Herokuish builds will never be supported as the heroku Buildpacks only support x86. Cloud Native Buildpack usage pack does not currently support ARM, though we will be helping upstream to get that rolling so developers can use Cloud Native Buildpacks. Dockerfile builds should work if your base image works on ARM. While there are some limitations, the general Dokku experience works quite well on ARM, and hopefully opens up experimentation to the general development community. Dokku Pro Dokku Pro is a commercial offering that provides a familiar Web UI for all common tasks performed by developers. End users can expect an interface that provides various complex cli commands in an intuitive, app-centric manner, quickly speeding up tasks that might otherwise be difficult for new and old users to perform. Additionally, it provides a way to perform these tasks remotely via a json api, enabling easier, audited remote management of servers. Finally, Dokku Pro provides an alternative, https-based method for deploying code which can be used in environments that lockdown ssh access to servers. We'll have more information in the coming week, but Dokku Pro will be provided under early bird pricing (with the price going up as we continue to release new versions). Server licenses are sold in perpetuity, so lock in lower pricing today! Purchase Now The Next Minor Release Our next release will continue on the 9 outstanding 1.0 issues . We encourage folks to take a peak at them and help investigate bugs, come up with work plans, or contribute PRs where possible to help bring us over the finish line. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Dokku Release 0.28.0"},{"location":"2021/dokku-0.28.0/#changes-in-026x","text":"","title":"Changes in 0.26.x"},{"location":"2021/dokku-0.28.0/#removal-of-deprecated-tags-and-tar-plugins","text":"#4858 #4859 These two plugins were previously deprecated in 0.24.x in favor of git:from-image and git:from-archive, respectively. Rather than keep an unmaintained, buggy implementation of deployment, we\u2019ve completely removed these two plugins. Users should switch to the recommended methods of deployment, which are much more flexible and better integrate with Dokku.","title":"Removal of deprecated tags and tar plugins"},{"location":"2021/dokku-0.28.0/#faster-restarts-and-single-process-restarts","text":"#4765 Previously a restart would result in a complete rebuild of an application. With this change, restarts will now only rebuild when the image does not exist, and otherwise simply restart processes with the built image. In addition, a user may restart just a single process type. While not common, this can be used as a proxy for killing processes that consume memory, while not requiring a full app rebuild or restart.","title":"Faster restarts and single-process restarts"},{"location":"2021/dokku-0.28.0/#increase-parallelism-for-containers-within-specific-process-types","text":"#4860 As a followup to #4829 , apps deployed via the docker-local scheduler can now perform parallel scheduling for specific process types. The default configuration follows the existing behavior, while engineers that need extra parallelism on a per-process type basis can configure it via the app.json file: { \u201cformation\u201d: { \u201cweb\u201d: { \u201cmax_parallel\u201d: 3 } } } Parallelism defaults to 1 (previous behavior) but can be increased as needed.","title":"Increase parallelism for containers within specific process types"},{"location":"2021/dokku-0.28.0/#scheduler-management-plugin","text":"#4857 As we move towards a 1.0 release, Dokku\u2019s internal configuration that can be modified via environment variables is being moved into plugin-specific configuration settings. Setting a scheduler is one of them, and 0.26.0 will migrate the DOKKU_SCHEDULER environment variable to a scheduler plugin setting. Going forward, should set the scheduler via scheduler:set [app|\u2014global] selected call.","title":"Scheduler Management Plugin"},{"location":"2021/dokku-0.28.0/#raspberry-pi-support","text":"#4885 #4887 #4888 #4889 Dokku has always lived in the realm of self-hosting, but it was always x86-based. This completely precluded ARM users from using Dokku, which wasn\u2019t great for those who fully self-hosted, servers included. In the first few releases of 0.26.x, we\u2019ve added armhf architecture support, allowing those using Raspbian to install Dokku. Adding support for other ARM architectures should be rather trivial in the future (provided there is Golang support). Some notes: Herokuish builds will never be supported as the heroku Buildpacks only support x86. Cloud Native Buildpack usage pack does not currently support ARM, though we will be helping upstream to get that rolling so developers can use Cloud Native Buildpacks. Dockerfile builds should work if your base image works on ARM. While there are some limitations, the general Dokku experience works quite well on ARM, and hopefully opens up experimentation to the general development community.","title":"Raspberry PI Support"},{"location":"2021/dokku-0.28.0/#dokku-pro","text":"Dokku Pro is a commercial offering that provides a familiar Web UI for all common tasks performed by developers. End users can expect an interface that provides various complex cli commands in an intuitive, app-centric manner, quickly speeding up tasks that might otherwise be difficult for new and old users to perform. Additionally, it provides a way to perform these tasks remotely via a json api, enabling easier, audited remote management of servers. Finally, Dokku Pro provides an alternative, https-based method for deploying code which can be used in environments that lockdown ssh access to servers. We'll have more information in the coming week, but Dokku Pro will be provided under early bird pricing (with the price going up as we continue to release new versions). Server licenses are sold in perpetuity, so lock in lower pricing today! Purchase Now","title":"Dokku Pro"},{"location":"2021/dokku-0.28.0/#the-next-minor-release","text":"Our next release will continue on the 9 outstanding 1.0 issues . We encourage folks to take a peak at them and help investigate bugs, come up with work plans, or contribute PRs where possible to help bring us over the finish line. As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"The Next Minor Release"},{"location":"2021/dokkus-roaring-20s/","tags":["dokku","release"],"text":"It's been a few months since the last release post, so we'll summarize whats been going on in Dokku Land in 2020. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. Discussions Where should you get help? We've added Github Discussions support to the main project. Folks are encouraged to post questions and seek help from the community there. This will be a monitored channel, and is subject to the Code of Conduct . If you are seeking more \"live\" support, join the #dokku channel on the Gliderlabs Slack . A member of the core team - in addition to community members! - will attempt to help you given enough time and information. Users can continue posting to Stackoverflow or other locations, though those will not be actively monitored for issues. Releases 0.21.x We released quite a few major things in the 0.21.0 release: Ubuntu 20.04 support: Our packages generally support all releases of Debian and Ubuntu, though having an official package repository for your OS is always nice. Go Module usage: Glide was great for the time it was created, but as the Golang community has moved on, so should we. Upgrades of herokuish, plugn, procfile-util, sigil, and sshcommand: Dokku occasionally reaches out to single-purpose tooling for certain functionality, and our tight integration means we occasionally need to do things internally to support toolchain upgrades. Other than the above, 0.21.0 was mostly a bugfix release. Hopefully it was to your liking. 0.22.x The 0.22.x was a bit more expansive in the number of changes it introduced. There were a number of changes and deprecations , the most major of which were: Process type names specified in Procfile files and app names may no longer use characters not valid in DNS Label Names (RFC 1123). This allows us to properly support networking in alternative schedulers - such as Kubernetes and Nomad - as well as internal app networking with the default Docker Local scheduler. The ps plugin had it's *all commands removed in favor of a --all flag. This was actually fairly major, as it changes how parallelism works within Dokku, and makes it easier to support parallel commands against multiple applications. In the future, you'll be seeing more --all flag support in Dokku (as well as --global as necessary). What else showed up in 0.22.x? Cloud Native Buildpacks support Cloud Native Buildpacks are the future of Dokku's Buildpack support. We previously blogged about it , comparing it to our current Herokuish support. This new initiative is supported by a wide range of folks affiliated with the Cloud Native Computing Foundation , and we're hoping to see tighter integration with Dokku in the future. While it's still in development, this functionality is currently behind an app-specific environment variable and depends on the pack binary. To use it: # where $APP is your app name dokku config:set $APP DOKKU_CNB_EXPERIMENTAL = 1 # install pack: https://buildpacks.io/docs/tools/pack/ # apt based installation in use here, but use what you are comfortable with sudo add-apt-repository ppa:cncf-buildpacks/pack-cli sudo apt-get update sudo apt-get install pack-cli Some future improvements: buildpacks command support allowing users to specify CNB usage globally builder specification (currently uses heroku/buildpacks ) default to CNB Definitely a space to watch. Aggressive Container Cleanup Previous releases of Dokku would leave behind intermediate containers for debugging purposes. As Dokku has largely stabilized, these containers are no longer as necessary. The intermediate containers are commonly confused for containers that utilize server resources. Even worse, Docker will occasionally start these intermediate containers on reboot (Docker does not keep track of whether a container was manually stopped or not), causing actual performance issues for servers. In 0.22.x, we start deleting these intermediate containers at most 5 minutes after a deploy, and sometimes even sooner. We also cleanup images that may have been used during this process. While the cleanup time is not currently configurable, we hope that this change allows folks to feel better about resource utilization on more constrained servers. Nginx Configuration Knobs While we attempt to ship with the best nginx configuration by default, folks may want to tune specific knobs to match their setup without needing to ship an nginx.conf.sigil that may become outdated. We've added an nginx:set command that can be used to set various nginx settings, and will continue to add more settings over time. Additionally, for installations that have a single nginx.conf.sigil that should be used amongst all apps by default, we've added the ability to set the location of the global defaults via a plugin trigger. This is exceptionally useful for platform creators that must inject some special configuration to integrate with their platform. Finally, if you wish to disable app-side nginx.conf.sigil extraction, we've added a tunable property for this via nginx:set ( disable-custom-config ). While this cannot currently be set globally or as a default, enterprising platform developers may create plugins that inject properties on app creation... Vector-based Log Shipping This came late in the 0.22.x lifecycle (0.22.6/0.22.7), but was added to address the logging options issue ( #2268 ). Vector is an open-source, lightweight and ultra-fast tool for building observability pipelines. Dokku integrates with it for shipping container logs for the docker-local scheduler. Users may configure log-shipping on a per-app or global basis, neither of which interfere with the dokku logs commands. Vector is based on the idea of inputs , transforms and sinks . Dokku will automatically inject the correct inputs for all Docker containers, and it is up to you to define a sink to which you can send container logs (globally or per-app). Dokku does not currently support customizing transforms, though this may come in a future release. Checkout the Vector Log Shipping docs for more usage information. Golang Plugin Rewrites A few plugins have been rewritten in Golang: app-json logs ps Generally speaking, plugins are rewritten when the complexity of writing future features outweighs keeping the plugin implemented in shell code. In particular, any plugins that perform one of the following tasks are good candidates for higher-level languages: Argument parsing JSON handling (reading and writing) Network requests Interacting with APIs Managing structured data While all of these have been performed one time or another in bash, the fact is that there are a ton of edge cases that have popped up over the years that make it super difficult to even reason about some of the code, whereas it is fairly easy for me to handle these within Golang (either with the standard library or something off-the-shelf). All that said, not all plugins will be rewritten in Golang - the git plugin is likely to stay as is - and some plugins may see hybrid rewrites as necessary, but this should hopefully give folks a bit of an idea as to why the Dokku codebase is not predominantly written in shell. Future Development 0.22.x was a feature-packed release, and we're not slowing down. 0.23.x is around the corner, and will include quite a few interesting features for folks. We'll save those notes for the next blog post :) As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Dokku's Roaring 0.20s"},{"location":"2021/dokkus-roaring-20s/#discussions","text":"Where should you get help? We've added Github Discussions support to the main project. Folks are encouraged to post questions and seek help from the community there. This will be a monitored channel, and is subject to the Code of Conduct . If you are seeking more \"live\" support, join the #dokku channel on the Gliderlabs Slack . A member of the core team - in addition to community members! - will attempt to help you given enough time and information. Users can continue posting to Stackoverflow or other locations, though those will not be actively monitored for issues.","title":"Discussions"},{"location":"2021/dokkus-roaring-20s/#releases","text":"","title":"Releases"},{"location":"2021/dokkus-roaring-20s/#021x","text":"We released quite a few major things in the 0.21.0 release: Ubuntu 20.04 support: Our packages generally support all releases of Debian and Ubuntu, though having an official package repository for your OS is always nice. Go Module usage: Glide was great for the time it was created, but as the Golang community has moved on, so should we. Upgrades of herokuish, plugn, procfile-util, sigil, and sshcommand: Dokku occasionally reaches out to single-purpose tooling for certain functionality, and our tight integration means we occasionally need to do things internally to support toolchain upgrades. Other than the above, 0.21.0 was mostly a bugfix release. Hopefully it was to your liking.","title":"0.21.x"},{"location":"2021/dokkus-roaring-20s/#022x","text":"The 0.22.x was a bit more expansive in the number of changes it introduced. There were a number of changes and deprecations , the most major of which were: Process type names specified in Procfile files and app names may no longer use characters not valid in DNS Label Names (RFC 1123). This allows us to properly support networking in alternative schedulers - such as Kubernetes and Nomad - as well as internal app networking with the default Docker Local scheduler. The ps plugin had it's *all commands removed in favor of a --all flag. This was actually fairly major, as it changes how parallelism works within Dokku, and makes it easier to support parallel commands against multiple applications. In the future, you'll be seeing more --all flag support in Dokku (as well as --global as necessary). What else showed up in 0.22.x?","title":"0.22.x"},{"location":"2021/dokkus-roaring-20s/#cloud-native-buildpacks-support","text":"Cloud Native Buildpacks are the future of Dokku's Buildpack support. We previously blogged about it , comparing it to our current Herokuish support. This new initiative is supported by a wide range of folks affiliated with the Cloud Native Computing Foundation , and we're hoping to see tighter integration with Dokku in the future. While it's still in development, this functionality is currently behind an app-specific environment variable and depends on the pack binary. To use it: # where $APP is your app name dokku config:set $APP DOKKU_CNB_EXPERIMENTAL = 1 # install pack: https://buildpacks.io/docs/tools/pack/ # apt based installation in use here, but use what you are comfortable with sudo add-apt-repository ppa:cncf-buildpacks/pack-cli sudo apt-get update sudo apt-get install pack-cli Some future improvements: buildpacks command support allowing users to specify CNB usage globally builder specification (currently uses heroku/buildpacks ) default to CNB Definitely a space to watch.","title":"Cloud Native Buildpacks support"},{"location":"2021/dokkus-roaring-20s/#aggressive-container-cleanup","text":"Previous releases of Dokku would leave behind intermediate containers for debugging purposes. As Dokku has largely stabilized, these containers are no longer as necessary. The intermediate containers are commonly confused for containers that utilize server resources. Even worse, Docker will occasionally start these intermediate containers on reboot (Docker does not keep track of whether a container was manually stopped or not), causing actual performance issues for servers. In 0.22.x, we start deleting these intermediate containers at most 5 minutes after a deploy, and sometimes even sooner. We also cleanup images that may have been used during this process. While the cleanup time is not currently configurable, we hope that this change allows folks to feel better about resource utilization on more constrained servers.","title":"Aggressive Container Cleanup"},{"location":"2021/dokkus-roaring-20s/#nginx-configuration-knobs","text":"While we attempt to ship with the best nginx configuration by default, folks may want to tune specific knobs to match their setup without needing to ship an nginx.conf.sigil that may become outdated. We've added an nginx:set command that can be used to set various nginx settings, and will continue to add more settings over time. Additionally, for installations that have a single nginx.conf.sigil that should be used amongst all apps by default, we've added the ability to set the location of the global defaults via a plugin trigger. This is exceptionally useful for platform creators that must inject some special configuration to integrate with their platform. Finally, if you wish to disable app-side nginx.conf.sigil extraction, we've added a tunable property for this via nginx:set ( disable-custom-config ). While this cannot currently be set globally or as a default, enterprising platform developers may create plugins that inject properties on app creation...","title":"Nginx Configuration Knobs"},{"location":"2021/dokkus-roaring-20s/#vector-based-log-shipping","text":"This came late in the 0.22.x lifecycle (0.22.6/0.22.7), but was added to address the logging options issue ( #2268 ). Vector is an open-source, lightweight and ultra-fast tool for building observability pipelines. Dokku integrates with it for shipping container logs for the docker-local scheduler. Users may configure log-shipping on a per-app or global basis, neither of which interfere with the dokku logs commands. Vector is based on the idea of inputs , transforms and sinks . Dokku will automatically inject the correct inputs for all Docker containers, and it is up to you to define a sink to which you can send container logs (globally or per-app). Dokku does not currently support customizing transforms, though this may come in a future release. Checkout the Vector Log Shipping docs for more usage information.","title":"Vector-based Log Shipping"},{"location":"2021/dokkus-roaring-20s/#golang-plugin-rewrites","text":"A few plugins have been rewritten in Golang: app-json logs ps Generally speaking, plugins are rewritten when the complexity of writing future features outweighs keeping the plugin implemented in shell code. In particular, any plugins that perform one of the following tasks are good candidates for higher-level languages: Argument parsing JSON handling (reading and writing) Network requests Interacting with APIs Managing structured data While all of these have been performed one time or another in bash, the fact is that there are a ton of edge cases that have popped up over the years that make it super difficult to even reason about some of the code, whereas it is fairly easy for me to handle these within Golang (either with the standard library or something off-the-shelf). All that said, not all plugins will be rewritten in Golang - the git plugin is likely to stay as is - and some plugins may see hybrid rewrites as necessary, but this should hopefully give folks a bit of an idea as to why the Dokku codebase is not predominantly written in shell.","title":"Golang Plugin Rewrites"},{"location":"2021/dokkus-roaring-20s/#future-development","text":"0.22.x was a feature-packed release, and we're not slowing down. 0.23.x is around the corner, and will include quite a few interesting features for folks. We'll save those notes for the next blog post :) As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Future Development"},{"location":"2022/dokku-0.27.x-wrapup/","tags":["dokku","release"],"text":"Dokku version 0.27.0 was released a few months ago. This post covers the important changes that occurred throughout the lifetime of the 0.27.x series. A future post will cover the 0.28.0 release. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs. Additions OS and Architecture Support Ubuntu Focal was added as a release target. We also added support for ARM (32-bit) and ARM64 architectures. Users on Raspberry Pis should be able to install the latest Dokku, regardless of OS or Architecture. Additionally, the Dokku docker image is now based on Focal :) App and service filtering It is now possible to filter apps and services via the user-auth-app and user-auth-service triggers. These can be implemented in custom plugins to constrain what a user has access to, and is in use within Dokku Pro for it's team-management system . Fixes App domain renames are scoped to global domains Previously, if you had an app named test with a domain of tester.com and renamed it to test-2 , we would rename the domain to test-2er.com . We've now scoped this so app renames only impact domains associated with any global domains on the server. Remove bad intermediate containers Due to how Dokku handles the build process, intermediate containers reuse the internal docker image name for an app. This means that it is sometimes possible to execute dokku run against an intermediate image. Dokku now properly removes intermediate images if the build fails. Support for special characters in docker container options Dokku now supports using special characters, such as parenthesis, in container options. Here is an example: dokku docker-options:add node-js-app deploy '--label \"some.key=Host(\\`node-js-app.dokku.arketyped.net\\`)\"' Some characters should be escaped - and quoting matters! - but label-based proxy-implementations can now take full advantage of apps deployed via Dokku. It's a wrap Those were the major changes in 0.27.x. Our next post will cover 0.28.0! As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"Dokku 0.27.x Wrapup"},{"location":"2022/dokku-0.27.x-wrapup/#additions","text":"","title":"Additions"},{"location":"2022/dokku-0.27.x-wrapup/#os-and-architecture-support","text":"Ubuntu Focal was added as a release target. We also added support for ARM (32-bit) and ARM64 architectures. Users on Raspberry Pis should be able to install the latest Dokku, regardless of OS or Architecture. Additionally, the Dokku docker image is now based on Focal :)","title":"OS and Architecture Support"},{"location":"2022/dokku-0.27.x-wrapup/#app-and-service-filtering","text":"It is now possible to filter apps and services via the user-auth-app and user-auth-service triggers. These can be implemented in custom plugins to constrain what a user has access to, and is in use within Dokku Pro for it's team-management system .","title":"App and service filtering"},{"location":"2022/dokku-0.27.x-wrapup/#fixes","text":"","title":"Fixes"},{"location":"2022/dokku-0.27.x-wrapup/#app-domain-renames-are-scoped-to-global-domains","text":"Previously, if you had an app named test with a domain of tester.com and renamed it to test-2 , we would rename the domain to test-2er.com . We've now scoped this so app renames only impact domains associated with any global domains on the server.","title":"App domain renames are scoped to global domains"},{"location":"2022/dokku-0.27.x-wrapup/#remove-bad-intermediate-containers","text":"Due to how Dokku handles the build process, intermediate containers reuse the internal docker image name for an app. This means that it is sometimes possible to execute dokku run against an intermediate image. Dokku now properly removes intermediate images if the build fails.","title":"Remove bad intermediate containers"},{"location":"2022/dokku-0.27.x-wrapup/#support-for-special-characters-in-docker-container-options","text":"Dokku now supports using special characters, such as parenthesis, in container options. Here is an example: dokku docker-options:add node-js-app deploy '--label \"some.key=Host(\\`node-js-app.dokku.arketyped.net\\`)\"' Some characters should be escaped - and quoting matters! - but label-based proxy-implementations can now take full advantage of apps deployed via Dokku.","title":"Support for special characters in docker container options"},{"location":"2022/dokku-0.27.x-wrapup/#its-a-wrap","text":"Those were the major changes in 0.27.x. Our next post will cover 0.28.0! As always, please post issues with bugs or functionality you think Dokku might benefit from. As well, feel free to hop into Github Discussions or Slack channel if you have questions, comments, or concerns. If you're using Dokku - especially for commercial purposes - consider donating to project development via Github Sponsors , OpenCollective , or Patreon . Funds go to general development, support, and infrastructure costs.","title":"It's a wrap"},{"location":"2022/pro-release-1.1.0/","text":"The 1.1.0 release is the first substantive update to Dokku Pro, and it brings with it great changes around usability and functionality. Get your copy today Dokku Pro was released in late 2021 to early bird users willing to deal with a bit of pain in exchange for supporting the project and vision. While it technically worked, there were quite a few places for easy improvement, as well as obvious holes in the existing functionality. Dokku Pro 1.1.0 aims to fill some of those needs, laying the groundwork for future enhancements. Here are a few of the updates included in Dokku Pro 1.1.0. Major Changes This lovely docs site We've added a more comprehensive documentation site for Dokku Pro. The documentation will continue to improve and will always reference the latest version of Dokku Pro (currently 1.1.0). Enjoy! Requires Dokku 0.27.0 The minimum Dokku version increase was made to ensure memory-scaling worked properly. Users of older version of Dokku may still have working installs, though memory scaling will not work correctly for the docker-local scheduler. To update, run: # update the ``dokku-update` package first sudo apt update sudo apt install dokku-update # update your install (skipping app rebuild) sudo dokku-update run --skip-rebuild Minimum required datastore plugin versions As a reminder, it is also recommended to update all datastore plugins to ensure services are properly listed in the API and UI. In addition, the upgrades are necessary for support for deferred app rebuilds during service linking. Without them, service linking may time out. Here are the versions necessary for this release of Dokku Pro: Plugin Version clickhouse 0.13.3 couchdb 1.21.4 elasticsearch 1.20.3 graphite 1.18.2 mariadb 1.19.2 meilisearch 0.2.1 memcached 1.18.4 mongo 1.17.4 mysql 1.19.4 nats 1.19.3 omnisci 1.19.1 postgres 1.19.3 pushpin 0.9.1 rabbitmq 1.19.4 redis 1.19.2 rethinkdb 1.17.2 solr 1.19.4 To update, run: # update the ``dokku-update` package first sudo apt update sudo apt install dokku-update # update your install (skipping app rebuild) sudo dokku-update run --skip-rebuild Add ability to link an app to a service Users are now able to link apps to services. This required a ton of changes to how datastores worked in the API, and the resulting refactor makes it much easier to add new datastores to Dokku Pro. To manage service links, go to the Settings section of a given app and use the Linked Services subsection. UI for managing service links Refactor datastore and service apis for easier expansion In order to make service linking work, we required a few changes: exposing a single api for listing all available datastores simplifying how datastores are added/removed fixing certain endpoints that just plain didn't work Dokku Pro 1.1.0 brings a simplified /datastores and /services api. The former is used to interact with the datastore plugins as a whole - in the future, this may even include setting global datastore plugin properties. The /services endpoint now abstracts all instances of every datastore, bringing a single api endpoint for querying and interacting with all services installed on your Dokku server. This makes it much simpler to support a new datastore - now a 2-line change - versus the previous method of generating various files that still needed work to plug into the api model layer. These APIs are now considered stable for external use. Enjoy! Implement resource scaling ui The initial release of Dokku Pro included process count scaling, but offered nothing for container resources. New in 1.1.0, we added the ability to set memory reservations. Memory scaling For this rough release, we've opted to avoid limits - so that containers can burst on resource utilization - and have omitted CPU - as this is typically bursty on single-instance Dokku installations. We'll be working on the UI in future releases, and hope to include both memory and CPU for limits and reservations in a way that makes sense for our users. See this tweet thread for more details on how... interesting this functionality ended up. Add swagger support An interactive Swagger UI for Dokku Pro is now available at the /swagger endpoint. Users can also access the OpenAPI 3.0.1 spec at /swagger/openapi.yml . Integrated Swagger UI Add ability to set the scheduler on a per-app basis We've added the ability to set an app scheduler on a per-app basis. This automatically picks up the following schedulers (if installed) and displays them for selection: docker-local kubernetes nomad null Selection a non-standard scheduler Minor Changes Allow customizing the network dokku-pro listens on If you are running Dokku Pro on a local network that doesn't have IPv6 support, you can now set the SERVER_NETWORK configuration variable to tcp4 to listen only on IPv4. Set higher default write timeout to allow for slow service creation calls to complete The default server read and write timeouts were too low for certain tasks - notably datastore creation and destruction - to complete in time, resulting in UI errors. These are now configurable via SERVER_READ_TIMEOUT and SERVER_WRITE_TIMEOUT , and also have higher default values. Folks on slower servers should see significant improvement in their overall user experience. Add cli command for outputting current dokku-pro settings One annoying issue when debugging an installation is ensuring all the configuration variables are set properly. Users can now run dokku-pro config to show a user-friendly version of the current server config. This can be used to verify that the Dokku Pro license and other configuration options are as you expect. UI Changes Always use correct icon size for app status The app status icon was sometimes too large. While big head mode is cool, its not so much in a UI. We now use the correct image size. Fix issue in ui when saving a domain for an app Apps with no domains had issues saving an initial domain without using the CLI. Since one of the goals of Dokku Pro is to supply a web UI, this seems a bit backwards. You can now properly set domains for new apps! Correct process type name in the scaling UI The process scaling ui showed the app name instead of the process type. This made no sense and was confusing for users with multiple process types. Make the env/domains settings pages span the entire page There was a minor change to the environment variable and domain setting pages that made better use of the screen real estate. API Changes Add meilisearch datastore plugin Taking advantage of our new datastore plumbing, we added the Meilisearch plugin to Dokku Pro. Add better error messaging when validating api entities from composite keys When interacting with entities that have composite primary keys - domains, environment variables, formations - users would get somewhat opaque error messages. These have been updated to include more detail. Fix access to service relationships in the api Services now come back as properly associated with apps, making many of the normal json-api relationship endpoints work. Dokku Pro Pricing Now that there is a new release of Dokku Pro, the early bird pricing will increase. This was previously mentioned in various Dokku Pro announcements, but the price will continue to increase by various amounts until the product settles. Please bear in mind that this is a lifetime license, and users are entitled to all upgrades of Dokku Pro as long as they are made. Folks wishing to support continued development of the project are encouraged to purchase today before the price is increased. Get your copy today Coming up next? The next milestone will continue to have many minor additions, with some effort made on the following additions: HTTP Auth management Maintenance Mode management Persistent Storage management UI customizations (branding, push urls, hiding apps) Some form of multi-user support As always, the roadmap is always subject to change, pending time constraints but mostly feature requests by those who have purchased Dokku Pro. Have a feature request or bug complaint? Feel free to file it in the issue tracker here . Thanks everyone for there support during this endeavor, and I hope you all enjoy this release of Dokku Pro!","title":"Pro release 1.1.0"},{"location":"2022/pro-release-1.1.0/#major-changes","text":"","title":"Major Changes"},{"location":"2022/pro-release-1.1.0/#this-lovely-docs-site","text":"We've added a more comprehensive documentation site for Dokku Pro. The documentation will continue to improve and will always reference the latest version of Dokku Pro (currently 1.1.0). Enjoy!","title":"This lovely docs site"},{"location":"2022/pro-release-1.1.0/#requires-dokku-0270","text":"The minimum Dokku version increase was made to ensure memory-scaling worked properly. Users of older version of Dokku may still have working installs, though memory scaling will not work correctly for the docker-local scheduler. To update, run: # update the ``dokku-update` package first sudo apt update sudo apt install dokku-update # update your install (skipping app rebuild) sudo dokku-update run --skip-rebuild","title":"Requires Dokku 0.27.0"},{"location":"2022/pro-release-1.1.0/#minimum-required-datastore-plugin-versions","text":"As a reminder, it is also recommended to update all datastore plugins to ensure services are properly listed in the API and UI. In addition, the upgrades are necessary for support for deferred app rebuilds during service linking. Without them, service linking may time out. Here are the versions necessary for this release of Dokku Pro: Plugin Version clickhouse 0.13.3 couchdb 1.21.4 elasticsearch 1.20.3 graphite 1.18.2 mariadb 1.19.2 meilisearch 0.2.1 memcached 1.18.4 mongo 1.17.4 mysql 1.19.4 nats 1.19.3 omnisci 1.19.1 postgres 1.19.3 pushpin 0.9.1 rabbitmq 1.19.4 redis 1.19.2 rethinkdb 1.17.2 solr 1.19.4 To update, run: # update the ``dokku-update` package first sudo apt update sudo apt install dokku-update # update your install (skipping app rebuild) sudo dokku-update run --skip-rebuild","title":"Minimum required datastore plugin versions"},{"location":"2022/pro-release-1.1.0/#add-ability-to-link-an-app-to-a-service","text":"Users are now able to link apps to services. This required a ton of changes to how datastores worked in the API, and the resulting refactor makes it much easier to add new datastores to Dokku Pro. To manage service links, go to the Settings section of a given app and use the Linked Services subsection. UI for managing service links","title":"Add ability to link an app to a service"},{"location":"2022/pro-release-1.1.0/#refactor-datastore-and-service-apis-for-easier-expansion","text":"In order to make service linking work, we required a few changes: exposing a single api for listing all available datastores simplifying how datastores are added/removed fixing certain endpoints that just plain didn't work Dokku Pro 1.1.0 brings a simplified /datastores and /services api. The former is used to interact with the datastore plugins as a whole - in the future, this may even include setting global datastore plugin properties. The /services endpoint now abstracts all instances of every datastore, bringing a single api endpoint for querying and interacting with all services installed on your Dokku server. This makes it much simpler to support a new datastore - now a 2-line change - versus the previous method of generating various files that still needed work to plug into the api model layer. These APIs are now considered stable for external use. Enjoy!","title":"Refactor datastore and service apis for easier expansion"},{"location":"2022/pro-release-1.1.0/#implement-resource-scaling-ui","text":"The initial release of Dokku Pro included process count scaling, but offered nothing for container resources. New in 1.1.0, we added the ability to set memory reservations. Memory scaling For this rough release, we've opted to avoid limits - so that containers can burst on resource utilization - and have omitted CPU - as this is typically bursty on single-instance Dokku installations. We'll be working on the UI in future releases, and hope to include both memory and CPU for limits and reservations in a way that makes sense for our users. See this tweet thread for more details on how... interesting this functionality ended up.","title":"Implement resource scaling ui"},{"location":"2022/pro-release-1.1.0/#add-swagger-support","text":"An interactive Swagger UI for Dokku Pro is now available at the /swagger endpoint. Users can also access the OpenAPI 3.0.1 spec at /swagger/openapi.yml . Integrated Swagger UI","title":"Add swagger support"},{"location":"2022/pro-release-1.1.0/#add-ability-to-set-the-scheduler-on-a-per-app-basis","text":"We've added the ability to set an app scheduler on a per-app basis. This automatically picks up the following schedulers (if installed) and displays them for selection: docker-local kubernetes nomad null Selection a non-standard scheduler","title":"Add ability to set the scheduler on a per-app basis"},{"location":"2022/pro-release-1.1.0/#minor-changes","text":"","title":"Minor Changes"},{"location":"2022/pro-release-1.1.0/#allow-customizing-the-network-dokku-pro-listens-on","text":"If you are running Dokku Pro on a local network that doesn't have IPv6 support, you can now set the SERVER_NETWORK configuration variable to tcp4 to listen only on IPv4.","title":"Allow customizing the network dokku-pro listens on"},{"location":"2022/pro-release-1.1.0/#set-higher-default-write-timeout-to-allow-for-slow-service-creation-calls-to-complete","text":"The default server read and write timeouts were too low for certain tasks - notably datastore creation and destruction - to complete in time, resulting in UI errors. These are now configurable via SERVER_READ_TIMEOUT and SERVER_WRITE_TIMEOUT , and also have higher default values. Folks on slower servers should see significant improvement in their overall user experience.","title":"Set higher default write timeout to allow for slow service creation calls to complete"},{"location":"2022/pro-release-1.1.0/#add-cli-command-for-outputting-current-dokku-pro-settings","text":"One annoying issue when debugging an installation is ensuring all the configuration variables are set properly. Users can now run dokku-pro config to show a user-friendly version of the current server config. This can be used to verify that the Dokku Pro license and other configuration options are as you expect.","title":"Add cli command for outputting current dokku-pro settings"},{"location":"2022/pro-release-1.1.0/#ui-changes","text":"","title":"UI Changes"},{"location":"2022/pro-release-1.1.0/#always-use-correct-icon-size-for-app-status","text":"The app status icon was sometimes too large. While big head mode is cool, its not so much in a UI. We now use the correct image size.","title":"Always use correct icon size for app status"},{"location":"2022/pro-release-1.1.0/#fix-issue-in-ui-when-saving-a-domain-for-an-app","text":"Apps with no domains had issues saving an initial domain without using the CLI. Since one of the goals of Dokku Pro is to supply a web UI, this seems a bit backwards. You can now properly set domains for new apps!","title":"Fix issue in ui when saving a domain for an app"},{"location":"2022/pro-release-1.1.0/#correct-process-type-name-in-the-scaling-ui","text":"The process scaling ui showed the app name instead of the process type. This made no sense and was confusing for users with multiple process types.","title":"Correct process type name in the scaling UI"},{"location":"2022/pro-release-1.1.0/#make-the-envdomains-settings-pages-span-the-entire-page","text":"There was a minor change to the environment variable and domain setting pages that made better use of the screen real estate.","title":"Make the env/domains settings pages span the entire page"},{"location":"2022/pro-release-1.1.0/#api-changes","text":"","title":"API Changes"},{"location":"2022/pro-release-1.1.0/#add-meilisearch-datastore-plugin","text":"Taking advantage of our new datastore plumbing, we added the Meilisearch plugin to Dokku Pro.","title":"Add meilisearch datastore plugin"},{"location":"2022/pro-release-1.1.0/#add-better-error-messaging-when-validating-api-entities-from-composite-keys","text":"When interacting with entities that have composite primary keys - domains, environment variables, formations - users would get somewhat opaque error messages. These have been updated to include more detail.","title":"Add better error messaging when validating api entities from composite keys"},{"location":"2022/pro-release-1.1.0/#fix-access-to-service-relationships-in-the-api","text":"Services now come back as properly associated with apps, making many of the normal json-api relationship endpoints work.","title":"Fix access to service relationships in the api"},{"location":"2022/pro-release-1.1.0/#dokku-pro-pricing","text":"Now that there is a new release of Dokku Pro, the early bird pricing will increase. This was previously mentioned in various Dokku Pro announcements, but the price will continue to increase by various amounts until the product settles. Please bear in mind that this is a lifetime license, and users are entitled to all upgrades of Dokku Pro as long as they are made. Folks wishing to support continued development of the project are encouraged to purchase today before the price is increased. Get your copy today","title":"Dokku Pro Pricing"},{"location":"2022/pro-release-1.1.0/#coming-up-next","text":"The next milestone will continue to have many minor additions, with some effort made on the following additions: HTTP Auth management Maintenance Mode management Persistent Storage management UI customizations (branding, push urls, hiding apps) Some form of multi-user support As always, the roadmap is always subject to change, pending time constraints but mostly feature requests by those who have purchased Dokku Pro. Have a feature request or bug complaint? Feel free to file it in the issue tracker here . Thanks everyone for there support during this endeavor, and I hope you all enjoy this release of Dokku Pro!","title":"Coming up next?"},{"location":"2022/pro-release-1.2.0/","text":"The 1.2.0 release introduces team-based access control and many internal refactors aimed at easing future development of the product. Get your copy today Dokku has traditionally been a single-tenant PaaS solution, where all users had access to all functionality on the server. While there were community plugins that tackled authentication, each implementation had it's rough edges due to interfaces in Dokku itself. Dokku Pro 1.2.0 polishes those edges while introducing a flexible permission system for organizations that need it. Here are a few of the updates included in Dokku Pro 1.2.0. Major Changes Requires Dokku 0.27.8+ Warning Dokku Pro 1.2+ will refuse to start if the minimum Dokku version is not installed. The minimum Dokku version increase was made to support new functionality in Dokku Pro. The previous 1.1.0 version required at least 0.27.0, so hopefully this upgrade does not cause too many issues for folks. To update, run: # update the ``dokku-update` package first sudo apt update sudo apt install dokku-update # update your install (skipping app rebuild) sudo dokku-update run --skip-rebuild Minimum required service plugin versions Warning Dokku Pro 1.2+ will refuse to start if an installed plugin is not at the minimum supported version. As a reminder, it is also recommended to update all service plugins to ensure services are properly listed in the API and UI. In addition, the upgrades are necessary for support for deferred app rebuilds during service linking. Without them, service linking may time out. Certain new functionality in Dokku Pro required changes to the service plugins. Here are the versions necessary for this release of Dokku Pro: Plugin Version clickhouse 0.17.0 couchdb 1.25.0 elasticsearch 1.24.0 graphite 1.22.0 mariadb 1.24.0 meilisearch 0.6.0 memcached 1.22.0 mongo 1.21.0 mysql 1.23.0 nats 1.24.0 omnisci 1.23.0 postgres 1.24.0 pushpin 0.14.0 rabbitmq 1.24.0 redis 1.24.0 rethinkdb 1.21.0 solr 1.24.0 typesense 1.5.0 To update, run: # update the ``dokku-update` package first sudo apt update sudo apt install dokku-update # update your install (skipping app rebuild) sudo dokku-update run --skip-rebuild New APIs for community plugins Two plugins were added to Dokku Pro's HTTP API. API Support for Dokku features generally comes first, while later releases will include changes to the Web UI to include these additions. API support for the community HTTP Auth Plugin Authentication comes in many forms, and while most apps have this built-in, simpler, pre-packaged applications may not. Dokku Pro introduces support for the community http-auth plugin, with full API support for managing both user-based and IP-based access controls. This comes with documentation in our included Swagger UI. A future release of Dokku Pro will include a section in the UI for managing network components for apps, including HTTP Auth support. API support for the community HTTP Auth Plugin In addition to authentication requirements, it may be necessary to enable or disable all access to your application. The community maintenance plugin provides the ability to do just that. In this release, we've added the ability to enable or disable maintenance mode via API, fully-documented within our included Swagger UI. A future release of Dokku Pro will include a section in the UI for managing network components for apps, including setting apps in maintenance mode. Add ability to set the builder on a per-app basis We've added the ability to set an app builder on a per-app basis. This automatically picks up the following builders (if installed) and displays them for selection: dockerfile docker-compose herokuish lambda nix null pack Selection a non-standard builder It is also possible to set a custom build directory in the same UI. Selection a non-standard builder Both of these include API access, documented in our included Swagger UI. Team Management Access control is a complex topic, and one Dokku has traditionally shied away from. Dokku does not have a traditional user model, and it associates a simple name to each ssh-key that a user uses to interact with the CLI over SSH. Until recently, the only way to limit access was by installing the community dokku-acl plugin and hoping it's rigid model for checking permissions aligned with how you wanted to expose server access. With Dokku Pro 1.2.0, there is now a flexible team-based model for access control. System administrators can continue to access everything, but may create teams with permissions against particular apps, services, and commands. Owners - such as team leads or project managers - can be assigned to teams, delegating access control for those teams to the folks closest to what those teams represent. And finally, team members can perform the commands allowed by their team permissions against the apps and services those teams control, and nothing more. The development of this feature required changes across the Dokku ecosystem. New triggers were exposed in both service plugins as well as Dokku itself to manage filtering of apps and services, while some plugins had to be updated in order to respect the updated command system. Dokku Pro itself had several changes to the permissioning system as it was designed and tested in real world settings. While the initial intent was to release Dokku Pro much more often, the work behind team management hopefully makes the wait worth it. The initial release of team management is available via CLI commands. This decision was made in order to release Dokku Pro sooner. A future release of Dokku Pro will include API support for team management as well as Web UI integration for managing teams. Checkout the team management documentation for more information on how team-based access control works. Minor Changes Some of the more minor changes were made to make development of Dokku Pro itself much more pleasant. Rather than having a \"miscellaneous bug fixes and improvements\" section as you'd see in many other public product release notes, we'll outline them below. Updated Dependencies Dokku Pro uses a ton of code itself. We've started the efforts to get the server-side code up to date in an automatic fashion, and are ramping up efforts to modernize the Web UI as well. Filtering apps in Dokku Pro For some use-cases, it may be necessary to hide some apps from the Web UI and API. In the case of Dokku's own installation of Dokku Pro, there are some testing apps that have no value other than being placeholders for requests, and thus are noise in the UI. It is now possible to filter such apps from being accessible via Dokku Pro's interface (they will still be available via CLI using normal dokku commands). An APPS_FILTER environment variable can be set in the Dokku config with a comma-delimited list of apps to hide. These apps will be hidden from API responses and the Web UI as a result. Checkout the configuration documentation for more information on this new setting. Ability to override the default root username While the password for authentication is configurable, the root username was not. An ROOT_USERNAME can be set in the Dokku config to override the default root username. You can now login as the lollipop user if desired. Checkout the configuration documentation for more information on this new setting. Typesense service support Support for the new typesense plugin has been added to services in Dokku. Users can expect the same functionality they would from other services in Dokku, including complete support in our API, Swagger UI documentation, and exposure in the Web UI. New services will be added to future Dokku Pro releases as they are made available. Version checking for server commands As mentioned above, we now check for specific versions of Dokku and installed plugins on start of the Dokku Pro server. Users wishing to use supported plugins that do not have at least the minimum version specified will have Dokku Pro fail to boot with an error message detailing the problem. Please be sure to keep up to date with the latest and greatest versions of Dokku and any plugins you use. To update, run: # update the ``dokku-update` package first sudo apt update sudo apt install dokku-update # update your install (skipping app rebuild) sudo dokku-update run --skip-rebuild Enhanced output for the config command When running the dokku-pro config command, we previously hardcoded how certain config was output. This has been refactored in such a way that we no longer need to update the config command when adding new configuration properties. Fix log formatting Log output was a bit broken for the help and version commands, and elsewhere. Dokku Pro now will only log in JSON format when there is no TTY - for example, when running under systemd - and will have human-readable output otherwise Additionally, we now use a single logging mechanism across the codebase, ensuring most - if not all - logs are in the proper format, regardless of where the log call is created. Ignoring compiled assets during project search This was actually a fairly painful issue, workflow-wise. Searching for instances of code during refactoring was made painful due to including compiled assets, binary files, and external dependencies. These are now ignored so the editor does not lock up when searching for a random bit of javascript :) Standardized code initialization Previously, Dokku Pro would set up certain checks and load config on-the-fly. This led to race conditions in certain cases, and was messier to understand. All initialization code has now been placed in a central location that is easy to understand when first diving into the code. Dokku Pro Pricing With a new release comes a price increase. Although it was mentioned in the 1.1.0 release post, we previously avoided a price increase to give folks more time to consider supporting Dokku Pro development at a lower price point. With the new functionality, we believe it is time to start the increases. Dokku Pro's price will continue to increase over time by various amounts until the product settles to a more \"feature-complete\" state. Please bear in mind that this is a lifetime license, and users are entitled to all upgrades of Dokku Pro as long as they are made. Folks wishing to support continued development of the project are encouraged to purchase today before the price is increased. Get your copy today Coming up next? Here is what we'll be working towards over the next few releases API and Web UI support for team management Improvements to service UI interactions Exposing HTTP Auth and Maintenance mode in the Web UI Alternative forms of authentication More APIs for core Dokku functionality! Persistent Storage management As always, the roadmap is always subject to change, pending time constraints but mostly feature requests by those who have purchased Dokku Pro. Have a feature request or bug complaint? Feel free to file it in the issue tracker here . Thanks everyone for there support during this endeavor, and I hope you all enjoy this release of Dokku Pro!","title":"Pro release 1.2.0"},{"location":"2022/pro-release-1.2.0/#major-changes","text":"","title":"Major Changes"},{"location":"2022/pro-release-1.2.0/#requires-dokku-0278","text":"Warning Dokku Pro 1.2+ will refuse to start if the minimum Dokku version is not installed. The minimum Dokku version increase was made to support new functionality in Dokku Pro. The previous 1.1.0 version required at least 0.27.0, so hopefully this upgrade does not cause too many issues for folks. To update, run: # update the ``dokku-update` package first sudo apt update sudo apt install dokku-update # update your install (skipping app rebuild) sudo dokku-update run --skip-rebuild","title":"Requires Dokku 0.27.8+"},{"location":"2022/pro-release-1.2.0/#minimum-required-service-plugin-versions","text":"Warning Dokku Pro 1.2+ will refuse to start if an installed plugin is not at the minimum supported version. As a reminder, it is also recommended to update all service plugins to ensure services are properly listed in the API and UI. In addition, the upgrades are necessary for support for deferred app rebuilds during service linking. Without them, service linking may time out. Certain new functionality in Dokku Pro required changes to the service plugins. Here are the versions necessary for this release of Dokku Pro: Plugin Version clickhouse 0.17.0 couchdb 1.25.0 elasticsearch 1.24.0 graphite 1.22.0 mariadb 1.24.0 meilisearch 0.6.0 memcached 1.22.0 mongo 1.21.0 mysql 1.23.0 nats 1.24.0 omnisci 1.23.0 postgres 1.24.0 pushpin 0.14.0 rabbitmq 1.24.0 redis 1.24.0 rethinkdb 1.21.0 solr 1.24.0 typesense 1.5.0 To update, run: # update the ``dokku-update` package first sudo apt update sudo apt install dokku-update # update your install (skipping app rebuild) sudo dokku-update run --skip-rebuild","title":"Minimum required service plugin versions"},{"location":"2022/pro-release-1.2.0/#new-apis-for-community-plugins","text":"Two plugins were added to Dokku Pro's HTTP API. API Support for Dokku features generally comes first, while later releases will include changes to the Web UI to include these additions.","title":"New APIs for community plugins"},{"location":"2022/pro-release-1.2.0/#api-support-for-the-community-http-auth-plugin","text":"Authentication comes in many forms, and while most apps have this built-in, simpler, pre-packaged applications may not. Dokku Pro introduces support for the community http-auth plugin, with full API support for managing both user-based and IP-based access controls. This comes with documentation in our included Swagger UI. A future release of Dokku Pro will include a section in the UI for managing network components for apps, including HTTP Auth support.","title":"API support for the community HTTP Auth Plugin"},{"location":"2022/pro-release-1.2.0/#api-support-for-the-community-http-auth-plugin_1","text":"In addition to authentication requirements, it may be necessary to enable or disable all access to your application. The community maintenance plugin provides the ability to do just that. In this release, we've added the ability to enable or disable maintenance mode via API, fully-documented within our included Swagger UI. A future release of Dokku Pro will include a section in the UI for managing network components for apps, including setting apps in maintenance mode.","title":"API support for the community HTTP Auth Plugin"},{"location":"2022/pro-release-1.2.0/#add-ability-to-set-the-builder-on-a-per-app-basis","text":"We've added the ability to set an app builder on a per-app basis. This automatically picks up the following builders (if installed) and displays them for selection: dockerfile docker-compose herokuish lambda nix null pack Selection a non-standard builder It is also possible to set a custom build directory in the same UI. Selection a non-standard builder Both of these include API access, documented in our included Swagger UI.","title":"Add ability to set the builder on a per-app basis"},{"location":"2022/pro-release-1.2.0/#team-management","text":"Access control is a complex topic, and one Dokku has traditionally shied away from. Dokku does not have a traditional user model, and it associates a simple name to each ssh-key that a user uses to interact with the CLI over SSH. Until recently, the only way to limit access was by installing the community dokku-acl plugin and hoping it's rigid model for checking permissions aligned with how you wanted to expose server access. With Dokku Pro 1.2.0, there is now a flexible team-based model for access control. System administrators can continue to access everything, but may create teams with permissions against particular apps, services, and commands. Owners - such as team leads or project managers - can be assigned to teams, delegating access control for those teams to the folks closest to what those teams represent. And finally, team members can perform the commands allowed by their team permissions against the apps and services those teams control, and nothing more. The development of this feature required changes across the Dokku ecosystem. New triggers were exposed in both service plugins as well as Dokku itself to manage filtering of apps and services, while some plugins had to be updated in order to respect the updated command system. Dokku Pro itself had several changes to the permissioning system as it was designed and tested in real world settings. While the initial intent was to release Dokku Pro much more often, the work behind team management hopefully makes the wait worth it. The initial release of team management is available via CLI commands. This decision was made in order to release Dokku Pro sooner. A future release of Dokku Pro will include API support for team management as well as Web UI integration for managing teams. Checkout the team management documentation for more information on how team-based access control works.","title":"Team Management"},{"location":"2022/pro-release-1.2.0/#minor-changes","text":"Some of the more minor changes were made to make development of Dokku Pro itself much more pleasant. Rather than having a \"miscellaneous bug fixes and improvements\" section as you'd see in many other public product release notes, we'll outline them below.","title":"Minor Changes"},{"location":"2022/pro-release-1.2.0/#updated-dependencies","text":"Dokku Pro uses a ton of code itself. We've started the efforts to get the server-side code up to date in an automatic fashion, and are ramping up efforts to modernize the Web UI as well.","title":"Updated Dependencies"},{"location":"2022/pro-release-1.2.0/#filtering-apps-in-dokku-pro","text":"For some use-cases, it may be necessary to hide some apps from the Web UI and API. In the case of Dokku's own installation of Dokku Pro, there are some testing apps that have no value other than being placeholders for requests, and thus are noise in the UI. It is now possible to filter such apps from being accessible via Dokku Pro's interface (they will still be available via CLI using normal dokku commands). An APPS_FILTER environment variable can be set in the Dokku config with a comma-delimited list of apps to hide. These apps will be hidden from API responses and the Web UI as a result. Checkout the configuration documentation for more information on this new setting.","title":"Filtering apps in Dokku Pro"},{"location":"2022/pro-release-1.2.0/#ability-to-override-the-default-root-username","text":"While the password for authentication is configurable, the root username was not. An ROOT_USERNAME can be set in the Dokku config to override the default root username. You can now login as the lollipop user if desired. Checkout the configuration documentation for more information on this new setting.","title":"Ability to override the default root username"},{"location":"2022/pro-release-1.2.0/#typesense-service-support","text":"Support for the new typesense plugin has been added to services in Dokku. Users can expect the same functionality they would from other services in Dokku, including complete support in our API, Swagger UI documentation, and exposure in the Web UI. New services will be added to future Dokku Pro releases as they are made available.","title":"Typesense service support"},{"location":"2022/pro-release-1.2.0/#version-checking-for-server-commands","text":"As mentioned above, we now check for specific versions of Dokku and installed plugins on start of the Dokku Pro server. Users wishing to use supported plugins that do not have at least the minimum version specified will have Dokku Pro fail to boot with an error message detailing the problem. Please be sure to keep up to date with the latest and greatest versions of Dokku and any plugins you use. To update, run: # update the ``dokku-update` package first sudo apt update sudo apt install dokku-update # update your install (skipping app rebuild) sudo dokku-update run --skip-rebuild","title":"Version checking for server commands"},{"location":"2022/pro-release-1.2.0/#enhanced-output-for-the-config-command","text":"When running the dokku-pro config command, we previously hardcoded how certain config was output. This has been refactored in such a way that we no longer need to update the config command when adding new configuration properties.","title":"Enhanced output for the config command"},{"location":"2022/pro-release-1.2.0/#fix-log-formatting","text":"Log output was a bit broken for the help and version commands, and elsewhere. Dokku Pro now will only log in JSON format when there is no TTY - for example, when running under systemd - and will have human-readable output otherwise Additionally, we now use a single logging mechanism across the codebase, ensuring most - if not all - logs are in the proper format, regardless of where the log call is created.","title":"Fix log formatting"},{"location":"2022/pro-release-1.2.0/#ignoring-compiled-assets-during-project-search","text":"This was actually a fairly painful issue, workflow-wise. Searching for instances of code during refactoring was made painful due to including compiled assets, binary files, and external dependencies. These are now ignored so the editor does not lock up when searching for a random bit of javascript :)","title":"Ignoring compiled assets during project search"},{"location":"2022/pro-release-1.2.0/#standardized-code-initialization","text":"Previously, Dokku Pro would set up certain checks and load config on-the-fly. This led to race conditions in certain cases, and was messier to understand. All initialization code has now been placed in a central location that is easy to understand when first diving into the code.","title":"Standardized code initialization"},{"location":"2022/pro-release-1.2.0/#dokku-pro-pricing","text":"With a new release comes a price increase. Although it was mentioned in the 1.1.0 release post, we previously avoided a price increase to give folks more time to consider supporting Dokku Pro development at a lower price point. With the new functionality, we believe it is time to start the increases. Dokku Pro's price will continue to increase over time by various amounts until the product settles to a more \"feature-complete\" state. Please bear in mind that this is a lifetime license, and users are entitled to all upgrades of Dokku Pro as long as they are made. Folks wishing to support continued development of the project are encouraged to purchase today before the price is increased. Get your copy today","title":"Dokku Pro Pricing"},{"location":"2022/pro-release-1.2.0/#coming-up-next","text":"Here is what we'll be working towards over the next few releases API and Web UI support for team management Improvements to service UI interactions Exposing HTTP Auth and Maintenance mode in the Web UI Alternative forms of authentication More APIs for core Dokku functionality! Persistent Storage management As always, the roadmap is always subject to change, pending time constraints but mostly feature requests by those who have purchased Dokku Pro. Have a feature request or bug complaint? Feel free to file it in the issue tracker here . Thanks everyone for there support during this endeavor, and I hope you all enjoy this release of Dokku Pro!","title":"Coming up next?"}]}