{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The smallest PaaS implementation you've ever seen Docker powered mini-Heroku in around 200 lines of Bash View Documentation Quick-start Instructions ~ $ wget https://raw.github.com/progrium/dokku/v0.3.26/bootstrap.sh ~ $ sudo DOKKU_TAG=v0.3.26 bash bootstrap.sh # => Go to your server's IP and follow the web installer Own Your PaaS. Infrastructure at a fraction of the cost. Powered by Docker, you can install Dokku on any hardware. Use it on inexpensive cloud providers. Use the extra cash to buy a pony or feed kittens. You'll save tens of dollars a year on your dog photo sharing website. Easy Git Deploys. From your command-line to the cloud. Once it's set up on a host, you can push Heroku-compatible applications to it via Git. They'll build using Heroku buildpacks and then run in isolated containers. The end result is your own, single-host version of Heroku. Extensible Platform. Customize your PaaS. Write dokku plugins in any language. Share them online with others, and extend those already available. Dokku's simple core is easy to hack and add the features you need to get your job done.","title":"Home"},{"location":"advanced-installation/","text":"Advanced installation You can always install dokku straight from the latest - potentially unstable - master release via the following bash command: wget -qO- https://raw.github.com/progrium/dokku/master/bootstrap.sh | sudo DOKKU_BRANCH = master bash Development If you plan on developing dokku, the easiest way to install from your own repository is cloning the repository and calling the install script. Example: git clone https://github.com/yourusername/dokku.git cd dokku sudo make install The Makefile allows source URLs to be overridden to include customizations from your own repositories. The DOCKER_URL , PLUGINHOOK_URL , SSHCOMMAND_URL and STACK_URL environment variables may be set to override the defaults (see the Makefile for how these apply). Example: sudo SSHCOMMAND_URL = https://raw.github.com/yourusername/sshcommand/master/sshcommand make install Bootstrap a server from your own repository The bootstrap script allows the dokku repository URL to be overridden to bootstrap a host from your own clone of dokku using the DOKKU_REPO environment variable. Example: wget https://raw.github.com/progrium/dokku/master/bootstrap.sh chmod +x bootstrap.sh sudo DOKKU_REPO = https://github.com/yourusername/dokku.git DOKKU_BRANCH = master ./bootstrap.sh Custom herokuish build Dokku ships with a pre-built version of version of the herokuish component by default. If you want to build your own version you can specify that with an env variable. git clone https://github.com/progrium/dokku.git cd dokku sudo BUILD_STACK = true STACK_URL = https://github.com/gliderlabs/herokuish.git make install Configuring Once dokku is installed, if you are not using the web-installer, you'll want to configure a the virtualhost setup as well as the push user. If you do not, your installation will be considered incomplete and you will not be able to deploy applications. Set up a domain and a wildcard domain pointing to that host. Make sure /home/dokku/VHOST is set to this domain. By default it's set to whatever hostname the host has. This file is only created if the hostname can be resolved by dig ( dig +short $(hostname -f) ). Otherwise you have to create the file manually and set it to your preferred domain. If this file still is not present when you push your app, dokku will publish the app with a port number (i.e. http://example.com:49154 - note the missing subdomain). You'll have to add a public key associated with a username by doing something like this from your local machine: $ cat ~/.ssh/id_rsa.pub | ssh dokku.me \"sudo sshcommand acl-add dokku $USER\" If you are using the vagrant installation, you can use the following command to add your public key to dokku: $ cat ~/.ssh/id_rsa.pub | make vagrant-acl-add That's it! VMs with less than 1GB of memory Having less than 1GB of system memory available for dokku and its containers, for example Digital Ocean's small 512MB machines, might result in unexpected errors, such as ! [remote rejected] master -> master (pre-receive hook declined) during installation of NPM dependencies (https://github.com/npm/npm/issues/3867). To work around this issue, it might suffice to augment the linux swap file size to a maximum of twice the physical memory size. To resize the swap file of a 512MB machine to 1GB, follow these steps while in SSH within your machine: Reference: https://www.digitalocean.com/community/tutorials/how-to-configure-virtual-memory-swap-file-on-a-vps cd /var touch swap.img chmod 600 swap.img dd if = /dev/zero of = /var/swap.img bs = 1024k count = 1000 mkswap /var/swap.img swapon /var/swap.img free echo \"/var/swap.img none swap sw 0 0\" >> /etc/fstab","title":"Advanced installation"},{"location":"advanced-installation/#advanced-installation","text":"You can always install dokku straight from the latest - potentially unstable - master release via the following bash command: wget -qO- https://raw.github.com/progrium/dokku/master/bootstrap.sh | sudo DOKKU_BRANCH = master bash","title":"Advanced installation"},{"location":"advanced-installation/#development","text":"If you plan on developing dokku, the easiest way to install from your own repository is cloning the repository and calling the install script. Example: git clone https://github.com/yourusername/dokku.git cd dokku sudo make install The Makefile allows source URLs to be overridden to include customizations from your own repositories. The DOCKER_URL , PLUGINHOOK_URL , SSHCOMMAND_URL and STACK_URL environment variables may be set to override the defaults (see the Makefile for how these apply). Example: sudo SSHCOMMAND_URL = https://raw.github.com/yourusername/sshcommand/master/sshcommand make install","title":"Development"},{"location":"advanced-installation/#bootstrap-a-server-from-your-own-repository","text":"The bootstrap script allows the dokku repository URL to be overridden to bootstrap a host from your own clone of dokku using the DOKKU_REPO environment variable. Example: wget https://raw.github.com/progrium/dokku/master/bootstrap.sh chmod +x bootstrap.sh sudo DOKKU_REPO = https://github.com/yourusername/dokku.git DOKKU_BRANCH = master ./bootstrap.sh","title":"Bootstrap a server from your own repository"},{"location":"advanced-installation/#custom-herokuish-build","text":"Dokku ships with a pre-built version of version of the herokuish component by default. If you want to build your own version you can specify that with an env variable. git clone https://github.com/progrium/dokku.git cd dokku sudo BUILD_STACK = true STACK_URL = https://github.com/gliderlabs/herokuish.git make install","title":"Custom herokuish build"},{"location":"advanced-installation/#configuring","text":"Once dokku is installed, if you are not using the web-installer, you'll want to configure a the virtualhost setup as well as the push user. If you do not, your installation will be considered incomplete and you will not be able to deploy applications. Set up a domain and a wildcard domain pointing to that host. Make sure /home/dokku/VHOST is set to this domain. By default it's set to whatever hostname the host has. This file is only created if the hostname can be resolved by dig ( dig +short $(hostname -f) ). Otherwise you have to create the file manually and set it to your preferred domain. If this file still is not present when you push your app, dokku will publish the app with a port number (i.e. http://example.com:49154 - note the missing subdomain). You'll have to add a public key associated with a username by doing something like this from your local machine: $ cat ~/.ssh/id_rsa.pub | ssh dokku.me \"sudo sshcommand acl-add dokku $USER\" If you are using the vagrant installation, you can use the following command to add your public key to dokku: $ cat ~/.ssh/id_rsa.pub | make vagrant-acl-add That's it!","title":"Configuring"},{"location":"advanced-installation/#vms-with-less-than-1gb-of-memory","text":"Having less than 1GB of system memory available for dokku and its containers, for example Digital Ocean's small 512MB machines, might result in unexpected errors, such as ! [remote rejected] master -> master (pre-receive hook declined) during installation of NPM dependencies (https://github.com/npm/npm/issues/3867). To work around this issue, it might suffice to augment the linux swap file size to a maximum of twice the physical memory size. To resize the swap file of a 512MB machine to 1GB, follow these steps while in SSH within your machine: Reference: https://www.digitalocean.com/community/tutorials/how-to-configure-virtual-memory-swap-file-on-a-vps cd /var touch swap.img chmod 600 swap.img dd if = /dev/zero of = /var/swap.img bs = 1024k count = 1000 mkswap /var/swap.img swapon /var/swap.img free echo \"/var/swap.img none swap sw 0 0\" >> /etc/fstab","title":"VMs with less than 1GB of memory"},{"location":"application-deployment/","text":"Deploy an App Now you can deploy apps on your Dokku. Let's deploy the Heroku Node.js sample app . All you have to do is add a remote to name the app. It's created on-the-fly. $ cd node-js-sample $ git remote add dokku dokku@dokku.me:node-js-app $ git push dokku master Counting objects: 296, done. Delta compression using up to 4 threads. Compressing objects: 100% (254/254), done. Writing objects: 100% (296/296), 193.59 KiB, done. Total 296 (delta 25), reused 276 (delta 13) -----> Building node-js-app ... Node.js app detected -----> Resolving engine versions ... blah blah blah ... -----> Application deployed: http://node-js-app.dokku.me You're done! Dokku only supports deploying from its master branch, so if you'd like to deploy a different local branch use: git push dokku <local branch>:master Right now Herokuish supports buildpacks for Node.js, Ruby, Python, and more . Please check the documentation for your particular build pack as you may need to include configuration files (such as a Procfile) in your project root. Deploying to server over SSH Pushing to the dokku remote may prompt you to input a password for the dokku user. It's preferable, however, to use key-based authentication, and you can add your public key to the dokku user's authorized_keys file with: cat ~/.ssh/id_rsa.pub | ssh [sudouser]@[yourdomain].com \"sudo sshcommand acl-add dokku [description]\" Deploying with private git submodules Dokku uses git locally (i.e. not a docker image) to build its own copy of your app repo, including submodules. This is done as the dokku user. Therefore, in order to deploy private git submodules, you'll need to drop your deploy key in ~dokku/.ssh and potentially add github.com (or your VCS host key) into ~dokku/.ssh/known_hosts . A decent test like this should help confirm you've done it correctly. su - dokku ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts ssh -T git@github.com Specifying a custom buildpack If buildpack detection isn't working well for you or you want to specify a custom buildpack for one repository you can create & commit a file in the root of your git repository named .env containing export BUILDPACK_URL=<repository> before pushing. This will tell herokuish to fetch the specified buildpack and use it instead of relying on the built-in buildpacks & their detection methods. Dockerfile deployment Deployment of Dockerfile repos is supported as of v0.3.15. Simply place a Dockerfile in the root of your repo and push to dokku. If you are converting from a heroku/dokku buildpack deployment, ensure you are not setting $BUILDPACK_URL or including a .buildpacks file in the root of your repo. By default, we will extract the first EXPOSE port and tell nginx to proxy your app to that port. Alternatively, you can set $DOCKERFILE_PORT in your app's dokku configuration. By default no arguments are passed to docker run when deploying the container and the CMD or ENTRYPOINT defined in the Dockerfile are executed. You can take advantage of docker ability of overriding the CMD or passing parameters to your ENTRYPOINT setting $DOKKU_DOCKERFILE_START_CMD . Let's say for example you are deploying a base nodejs image, with the following ENTRYPOINT : ENTRYPOINT [\"node\"] You can do: dokku config:set DOKKU_DOCKERFILE_START_CMD=\"--harmony server.js\" To tell docker what to run. Setting $DOKKU_DOCKERFILE_CACHE_BUILD to true or false will enable or disable docker's image layer cache. Lastly, for more granular build control, you may also pass any docker build option to docker , by setting $DOKKU_DOCKER_BUILD_OPTS . Default vhost You might notice the default vhost for Nginx will be one of the apps. If an app doesn't exist, it will use this vhost and it may be confusing for it to go to another app. You can create a default vhost using a configuration under sites-enabled . You just have to change one thing in the main nginx.conf: Swap both conf.d include line and the sites-enabled include line. From: include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; to include /etc/nginx/sites-enabled/*; include /etc/nginx/conf.d/*.conf; Alternatively, you may push an app to your dokku host with a name like \"00-default\". As long as it lists first in ls /home/dokku/*/nginx.conf | head , it will be used as the default nginx vhost. Deploying to subdomains The name of remote repository is used as the name of application to be deployed, as for example above: $ git remote add dokku dokku@dokku.me:node-js-app $ git push dokku master Is deployed to, remote: -----> Application deployed: remote: http://node-js-app.dokku.me You can also specify fully qualified names, say app.dokku.me , as $ git remote add dokku dokku@dokku.me:app.dokku.me $ git push dokku master So, after deployment the application will be available at, remote: -----> Application deployed: remote: http://app.dokku.me This is in particular useful, then you want to deploy to root domain, as $ git remote add dokku dokku@dokku.me:dokku.me $ git push dokku master ... deployment ... remote: -----> Application deployed: remote: http://dokku.me Zero downtime deploy Following a deploy, dokku will now wait DOKKU_DEFAULT_CHECKS_WAIT seconds (default: 10 ), and if the container is still running, then route traffic to the new container. This can be problematic for applications whose boot up time can vary and can lead to 502 Bad Gateway errors. Dokku provides a way to run a set of more precise checks against the new container, and only switch traffic over if all checks complete successfully. To specify checks, add a CHECKS file to the root of your project directory. This is a text file with one line per check. Empty lines and lines starting with # are ignored. A check is a relative URL and may be followed by expected content from the page, for example: /about Our Amazing Team Dokku will wait DOKKU_CHECKS_WAIT seconds (default: 5 ) before running the checks to give server time to start. For shorter/longer wait, change the DOKKU_CHECKS_WAIT environment variable. This can also be overridden in the CHECKS file by setting WAIT=nn. Dokku will wait DOKKU_WAIT_TO_RETIRE seconds (default: 60 ) before stopping the old container such that no existing connections to it are dropped. Dokku will retry the checks DOKKU_CHECKS_ATTEMPTS times until the checks are successful or DOKKU_CHECKS_ATTEMPTS is exceeded. In the latter case, the deployment is considered failed. This can be overridden in the CHECKS file by setting ATTEMPTS=nn. Checks can be skipped entirely by setting DOKKU_SKIP_ALL_CHECKS to true either globally or per application. You can choose to skip only default checks by setting DOKKU_SKIP_DEFAULT_CHECKS to true either globally or per application. See checks-examples.md for examples and output. Removing a deployed app SSH onto the server, then execute: dokku apps:destroy myapp Dokku/Docker Container Management Compatibility Dokku is, at it's core, a docker container manager. Thus, it does not necessarily play well with other out-of-band processes interacting with the docker daemon. One thing to note as in issue #1220 , dokku executes a cleanup function prior to every deployment. This function removes all exited containers and all 'unattached' images.","title":"Deploy an App"},{"location":"application-deployment/#deploy-an-app","text":"Now you can deploy apps on your Dokku. Let's deploy the Heroku Node.js sample app . All you have to do is add a remote to name the app. It's created on-the-fly. $ cd node-js-sample $ git remote add dokku dokku@dokku.me:node-js-app $ git push dokku master Counting objects: 296, done. Delta compression using up to 4 threads. Compressing objects: 100% (254/254), done. Writing objects: 100% (296/296), 193.59 KiB, done. Total 296 (delta 25), reused 276 (delta 13) -----> Building node-js-app ... Node.js app detected -----> Resolving engine versions ... blah blah blah ... -----> Application deployed: http://node-js-app.dokku.me You're done! Dokku only supports deploying from its master branch, so if you'd like to deploy a different local branch use: git push dokku <local branch>:master Right now Herokuish supports buildpacks for Node.js, Ruby, Python, and more . Please check the documentation for your particular build pack as you may need to include configuration files (such as a Procfile) in your project root.","title":"Deploy an App"},{"location":"application-deployment/#deploying-to-server-over-ssh","text":"Pushing to the dokku remote may prompt you to input a password for the dokku user. It's preferable, however, to use key-based authentication, and you can add your public key to the dokku user's authorized_keys file with: cat ~/.ssh/id_rsa.pub | ssh [sudouser]@[yourdomain].com \"sudo sshcommand acl-add dokku [description]\"","title":"Deploying to server over SSH"},{"location":"application-deployment/#deploying-with-private-git-submodules","text":"Dokku uses git locally (i.e. not a docker image) to build its own copy of your app repo, including submodules. This is done as the dokku user. Therefore, in order to deploy private git submodules, you'll need to drop your deploy key in ~dokku/.ssh and potentially add github.com (or your VCS host key) into ~dokku/.ssh/known_hosts . A decent test like this should help confirm you've done it correctly. su - dokku ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts ssh -T git@github.com","title":"Deploying with private git submodules"},{"location":"application-deployment/#specifying-a-custom-buildpack","text":"If buildpack detection isn't working well for you or you want to specify a custom buildpack for one repository you can create & commit a file in the root of your git repository named .env containing export BUILDPACK_URL=<repository> before pushing. This will tell herokuish to fetch the specified buildpack and use it instead of relying on the built-in buildpacks & their detection methods.","title":"Specifying a custom buildpack"},{"location":"application-deployment/#dockerfile-deployment","text":"Deployment of Dockerfile repos is supported as of v0.3.15. Simply place a Dockerfile in the root of your repo and push to dokku. If you are converting from a heroku/dokku buildpack deployment, ensure you are not setting $BUILDPACK_URL or including a .buildpacks file in the root of your repo. By default, we will extract the first EXPOSE port and tell nginx to proxy your app to that port. Alternatively, you can set $DOCKERFILE_PORT in your app's dokku configuration. By default no arguments are passed to docker run when deploying the container and the CMD or ENTRYPOINT defined in the Dockerfile are executed. You can take advantage of docker ability of overriding the CMD or passing parameters to your ENTRYPOINT setting $DOKKU_DOCKERFILE_START_CMD . Let's say for example you are deploying a base nodejs image, with the following ENTRYPOINT : ENTRYPOINT [\"node\"] You can do: dokku config:set DOKKU_DOCKERFILE_START_CMD=\"--harmony server.js\" To tell docker what to run. Setting $DOKKU_DOCKERFILE_CACHE_BUILD to true or false will enable or disable docker's image layer cache. Lastly, for more granular build control, you may also pass any docker build option to docker , by setting $DOKKU_DOCKER_BUILD_OPTS .","title":"Dockerfile deployment"},{"location":"application-deployment/#default-vhost","text":"You might notice the default vhost for Nginx will be one of the apps. If an app doesn't exist, it will use this vhost and it may be confusing for it to go to another app. You can create a default vhost using a configuration under sites-enabled . You just have to change one thing in the main nginx.conf: Swap both conf.d include line and the sites-enabled include line. From: include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; to include /etc/nginx/sites-enabled/*; include /etc/nginx/conf.d/*.conf; Alternatively, you may push an app to your dokku host with a name like \"00-default\". As long as it lists first in ls /home/dokku/*/nginx.conf | head , it will be used as the default nginx vhost.","title":"Default vhost"},{"location":"application-deployment/#deploying-to-subdomains","text":"The name of remote repository is used as the name of application to be deployed, as for example above: $ git remote add dokku dokku@dokku.me:node-js-app $ git push dokku master Is deployed to, remote: -----> Application deployed: remote: http://node-js-app.dokku.me You can also specify fully qualified names, say app.dokku.me , as $ git remote add dokku dokku@dokku.me:app.dokku.me $ git push dokku master So, after deployment the application will be available at, remote: -----> Application deployed: remote: http://app.dokku.me This is in particular useful, then you want to deploy to root domain, as $ git remote add dokku dokku@dokku.me:dokku.me $ git push dokku master ... deployment ... remote: -----> Application deployed: remote: http://dokku.me","title":"Deploying to subdomains"},{"location":"application-deployment/#zero-downtime-deploy","text":"Following a deploy, dokku will now wait DOKKU_DEFAULT_CHECKS_WAIT seconds (default: 10 ), and if the container is still running, then route traffic to the new container. This can be problematic for applications whose boot up time can vary and can lead to 502 Bad Gateway errors. Dokku provides a way to run a set of more precise checks against the new container, and only switch traffic over if all checks complete successfully. To specify checks, add a CHECKS file to the root of your project directory. This is a text file with one line per check. Empty lines and lines starting with # are ignored. A check is a relative URL and may be followed by expected content from the page, for example: /about Our Amazing Team Dokku will wait DOKKU_CHECKS_WAIT seconds (default: 5 ) before running the checks to give server time to start. For shorter/longer wait, change the DOKKU_CHECKS_WAIT environment variable. This can also be overridden in the CHECKS file by setting WAIT=nn. Dokku will wait DOKKU_WAIT_TO_RETIRE seconds (default: 60 ) before stopping the old container such that no existing connections to it are dropped. Dokku will retry the checks DOKKU_CHECKS_ATTEMPTS times until the checks are successful or DOKKU_CHECKS_ATTEMPTS is exceeded. In the latter case, the deployment is considered failed. This can be overridden in the CHECKS file by setting ATTEMPTS=nn. Checks can be skipped entirely by setting DOKKU_SKIP_ALL_CHECKS to true either globally or per application. You can choose to skip only default checks by setting DOKKU_SKIP_DEFAULT_CHECKS to true either globally or per application. See checks-examples.md for examples and output.","title":"Zero downtime deploy"},{"location":"application-deployment/#removing-a-deployed-app","text":"SSH onto the server, then execute: dokku apps:destroy myapp","title":"Removing a deployed app"},{"location":"application-deployment/#dokkudocker-container-management-compatibility","text":"Dokku is, at it's core, a docker container manager. Thus, it does not necessarily play well with other out-of-band processes interacting with the docker daemon. One thing to note as in issue #1220 , dokku executes a cleanup function prior to every deployment. This function removes all exited containers and all 'unattached' images.","title":"Dokku/Docker Container Management Compatibility"},{"location":"checks-examples/","text":"Checks Examples The CHECKS file may contain empty lines, comments (lines starting with #), settings (NAME=VALUE) and check instructions. The format of a check instruction is a path, optionally followed by the expected content. For example: / My Amazing App /stylesheets/index.css .body /scripts/index.js $(function() /images/logo.png To check an application that supports multiple hostnames, use relative URLs that include the hostname, for example: //admin.example.com Admin Dashboard //static.example.com/logo.png You can also specify the protocol to explicitly check HTTPS requests. The default behavior is to wait for 5 seconds before running the first check, and timeout each check to 30 seconds. By default, checks will be attempted 5 times. (Retried 4 times) You can change these by setting WAIT, TIMEOUT and ATTEMPTS to different values, for example: WAIT=30 # Wait 1/2 minute TIMEOUT=60 # Timeout after a minute ATTEMPTS=10 # attempt checks 10 times Example: Successful Rails Deployment In this example, a rails applicaiton is successfully deployed to dokku. The initial round of checks fails while the server is starting, but once it starts they succeed and the deployment is successful. ATTEMPTS is set to 6, but the third attempt succeeds. CHECKS file WAIT=5 ATTEMPTS=6 /check.txt simple_check check.txt is a text file returning the string 'simple_check' Deploy Output Note: The output has been trimmed for brevity git push dokku master -----> Cleaning up... -----> Building myapp from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... -----> Discovering process types Procfile declares types -> web -----> Releasing myapp... -----> Deploying myapp... -----> Running pre-flight checks -----> Attempt 1/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" -----> All checks successful! =====> myapp container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop =====> end myapp container output -----> Running post-deploy -----> Configuring myapp.dokku.example.com... -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx -----> Shutting down old container in 60 seconds =====> Application deployed: http://myapp.dokku.example.com Example: Failing Rails Deployment In this example, a Rails application fails to deploy. The reason for the failure is that the postgres database connection fails. The initial checks will fail while we wait for the server to start up, just like in the above example. However, once the server does start accepting connections, we will see an error 500 due to the postgres database connection failure. Once the attempts have been exceeded, the deployment fails and we see the container output, which shows the Postgres connection errors. CHECKS file WAIT=5 ATTEMPTS=6 / The check to the root url '/' would normally access the database. Deploy Output Note: The output has been trimmed for brevity git push dokku master -----> Cleaning up... -----> Building myapp from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... Discovering process types Procfile declares types -> web Releasing myapp... Deploying myapp... Running pre-flight checks -----> Attempt 1/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 3/6 failed. -----> Attempt 4/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 4/6 failed. -----> Attempt 5/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 5/6 failed. -----> Attempt 6/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error Could not start due to 1 failed checks. ! Check attempt 6/6 failed. =====> myapp container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop Started GET \"/\" for 172.17.42.1 at 2015-03-26 21:36:47 +0000 Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? PG::ConnectionBad (could not connect to server: Connection refused Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? ): vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `connect' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:242:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `postgresql_connection =====> end myapp container output /usr/local/bin/dokku: line 49: 23409 Killed dokku deploy \"$APP\" To dokku@dokku.example.com:myapp ! [remote rejected] dokku -> master (pre-receive hook declined) error: failed to push some refs to 'dokku@dokku.example.com:myapp'","title":"Checks Examples"},{"location":"checks-examples/#checks-examples","text":"The CHECKS file may contain empty lines, comments (lines starting with #), settings (NAME=VALUE) and check instructions. The format of a check instruction is a path, optionally followed by the expected content. For example: / My Amazing App /stylesheets/index.css .body /scripts/index.js $(function() /images/logo.png To check an application that supports multiple hostnames, use relative URLs that include the hostname, for example: //admin.example.com Admin Dashboard //static.example.com/logo.png You can also specify the protocol to explicitly check HTTPS requests. The default behavior is to wait for 5 seconds before running the first check, and timeout each check to 30 seconds. By default, checks will be attempted 5 times. (Retried 4 times) You can change these by setting WAIT, TIMEOUT and ATTEMPTS to different values, for example: WAIT=30 # Wait 1/2 minute TIMEOUT=60 # Timeout after a minute ATTEMPTS=10 # attempt checks 10 times","title":"Checks Examples"},{"location":"checks-examples/#example-successful-rails-deployment","text":"In this example, a rails applicaiton is successfully deployed to dokku. The initial round of checks fails while the server is starting, but once it starts they succeed and the deployment is successful. ATTEMPTS is set to 6, but the third attempt succeeds.","title":"Example: Successful Rails Deployment"},{"location":"checks-examples/#checks-file","text":"WAIT=5 ATTEMPTS=6 /check.txt simple_check check.txt is a text file returning the string 'simple_check'","title":"CHECKS file"},{"location":"checks-examples/#deploy-output","text":"Note: The output has been trimmed for brevity git push dokku master -----> Cleaning up... -----> Building myapp from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... -----> Discovering process types Procfile declares types -> web -----> Releasing myapp... -----> Deploying myapp... -----> Running pre-flight checks -----> Attempt 1/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" ! curl: (7) Failed to connect to 172.17.0.155 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/check.txt => \"simple_check\" -----> All checks successful! =====> myapp container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop =====> end myapp container output -----> Running post-deploy -----> Configuring myapp.dokku.example.com... -----> Creating http nginx.conf -----> Running nginx-pre-reload Reloading nginx -----> Shutting down old container in 60 seconds =====> Application deployed: http://myapp.dokku.example.com","title":"Deploy Output"},{"location":"checks-examples/#example-failing-rails-deployment","text":"In this example, a Rails application fails to deploy. The reason for the failure is that the postgres database connection fails. The initial checks will fail while we wait for the server to start up, just like in the above example. However, once the server does start accepting connections, we will see an error 500 due to the postgres database connection failure. Once the attempts have been exceeded, the deployment fails and we see the container output, which shows the Postgres connection errors.","title":"Example: Failing Rails Deployment"},{"location":"checks-examples/#checks-file_1","text":"WAIT=5 ATTEMPTS=6 / The check to the root url '/' would normally access the database.","title":"CHECKS file"},{"location":"checks-examples/#deploy-output_1","text":"Note: The output has been trimmed for brevity git push dokku master -----> Cleaning up... -----> Building myapp from herokuish... -----> Adding BUILD_ENV to build environment... -----> Ruby app detected -----> Compiling Ruby/Rails -----> Using Ruby version: ruby-2.0.0 ..... Discovering process types Procfile declares types -> web Releasing myapp... Deploying myapp... Running pre-flight checks -----> Attempt 1/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 1/6 failed. -----> Attempt 2/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (7) Failed to connect to 172.17.0.188 port 5000: Connection refused ! Check attempt 2/6 failed. -----> Attempt 3/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 3/6 failed. -----> Attempt 4/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 4/6 failed. -----> Attempt 5/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error ! Check attempt 5/6 failed. -----> Attempt 6/6 Waiting for 5 seconds ... CHECKS expected result: http://localhost/ => \"\" ! curl: (22) The requested URL returned error: 500 Internal Server Error Could not start due to 1 failed checks. ! Check attempt 6/6 failed. =====> myapp container output: => Booting Thin => Rails 4.2.0 application starting in production on http://0.0.0.0:5000 => Run `rails server -h` for more startup options => Ctrl-C to shutdown server Thin web server (v1.6.3 codename Protein Powder) Maximum connections set to 1024 Listening on 0.0.0.0:5000, CTRL+C to stop Started GET \"/\" for 172.17.42.1 at 2015-03-26 21:36:47 +0000 Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? PG::ConnectionBad (could not connect to server: Connection refused Is the server running on host \"172.17.42.1\" and accepting TCP/IP connections on port 5431? ): vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:651:in `connect' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:242:in `initialize' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `new' vendor/bundle/ruby/2.0.0/gems/activerecord-4.2.0/lib/active_record/connection_adapters/postgresql_adapter.rb:44:in `postgresql_connection =====> end myapp container output /usr/local/bin/dokku: line 49: 23409 Killed dokku deploy \"$APP\" To dokku@dokku.example.com:myapp ! [remote rejected] dokku -> master (pre-receive hook declined) error: failed to push some refs to 'dokku@dokku.example.com:myapp'","title":"Deploy Output"},{"location":"components/","text":"Components Docker - Container runtime and manager Herokuish - Buildpack builder pluginhook - Shell based plugins and hooks sshcommand - Fixed commands over SSH Looking to keep codebase as simple and hackable as possible, so try to keep your line count down.","title":"Components"},{"location":"components/#components","text":"Docker - Container runtime and manager Herokuish - Buildpack builder pluginhook - Shell based plugins and hooks sshcommand - Fixed commands over SSH Looking to keep codebase as simple and hackable as possible, so try to keep your line count down.","title":"Components"},{"location":"configuration-management/","text":"Configuration management Typically an application will require some configuration to run properly. Dokku supports application configuration via environment variables. Environment variables may contain private data, such as passwords or API keys, so it is not recommended to store them in your application's repository. The config plugin provides the following commands to manage your variables: config <app> - display the config vars for an app config:get <app> KEY - display a config value for an app config:set <app> KEY1=VALUE1 [KEY2=VALUE2 ...] - set one or more config vars config:unset <app> KEY1 [KEY2 ...] - unset one or more config vars The variables are available both at run time and during the application build/compilation step. You no longer need a user-env plugin as Dokku handles this functionality in a way equivalent to how Heroku handles it. Note: Global BUILD_ENV files are currently migrated into a global ENV file and sourced before app-specific variables. This means that app-specific variables will take precedence over global variables. Configuring your global ENV file is manual, and should be considered potentially dangerous as configuration applies to all applications.","title":"Configuration management"},{"location":"configuration-management/#configuration-management","text":"Typically an application will require some configuration to run properly. Dokku supports application configuration via environment variables. Environment variables may contain private data, such as passwords or API keys, so it is not recommended to store them in your application's repository. The config plugin provides the following commands to manage your variables: config <app> - display the config vars for an app config:get <app> KEY - display a config value for an app config:set <app> KEY1=VALUE1 [KEY2=VALUE2 ...] - set one or more config vars config:unset <app> KEY1 [KEY2 ...] - unset one or more config vars The variables are available both at run time and during the application build/compilation step. You no longer need a user-env plugin as Dokku handles this functionality in a way equivalent to how Heroku handles it. Note: Global BUILD_ENV files are currently migrated into a global ENV file and sourced before app-specific variables. This means that app-specific variables will take precedence over global variables. Configuring your global ENV file is manual, and should be considered potentially dangerous as configuration applies to all applications.","title":"Configuration management"},{"location":"dns/","text":"Overview This is a work in progress. DNS Versions There are many different DNS servers 'in the wild'. Some of the popular ones on Linux are BIND, dnsmasq, and pdns. Windows has its own built-in DNS server as well as Unbound, Posadis, and more. A full list of DNS packages can be found on Wikipedia under Comparison of DNS Server Software . In addition to the various DNS packages, there are tens of thousands of Managed DNS Providers out that all have different DNS interfaces. Focus Because there are so many different DNS server packages out there as well as a tremendous number of Managed DNS Providers, we will focus on the concepts of DNS as well as providing examples in the 'BIND' format so you can adapt the information to your own server package or managed DNS provider. Assumptions We assume you have a passing familiarity with DNS. If not, you can read an in-depth article on DNS. But basically you need to know that DNS changes names (like example.tld) into addresses (like 127.0.0.1) We assume you already have a domain name registered and pointed to your favorite Managed DNS Provider or have your own BIND DNS server running. You have a server on the internet and are about to follow the instructions in the README to get dokku installed. Don't do the install just yet though. HELP! Don't be afraid to ask if you need help. Create a new issue and someone will be glad to assist you. Getting started For the examples, we will use the domain name 'example.tld' and the IP address '127.0.0.1'. Dokku uses a DNS to differentiate between apps on your dokku-powered server. If you are using the domain 'example.tld', and you have two apps 'myapp1' and 'myapp2', dokku will make them available at 'myapp1.example.tld' and 'myapp2.example.tld'. To get started, you need to know the IP address of your dokku server. Connect in to it and run 'ifconfig' or 'ip addr' to see the IP address. Caching Please remember that DNS relies heavily on caching . Changes you make to DNS could take anywhere from a few seconds to a few days to 'propagate'. If you tried surfing to example.tld, then changed the IP address in DNS, it could be a while before your computer picks up on the changes. The two methods Now you have to make a decision about your domain. Do you want everything and anything at example.tld to go to your dokku server, or would you rather use a 'sub domain' for your dokku server? In other words, do you want your applications on your dokku server accessible via myapp.example.tld or via myapp.myserver.example.tld? Using a sub-domain (myapp.myserver.example.tld) Using a sub-domain is easy. When you set up your server, you probably gave it a name like myserver.example.tld. Go in to your Managed DNS provider and create an 'A' record named 'myserver' and put in the IP address you got from your server a few moments ago. Hopefully your managed DNS provider also supports wildcards. Create a second 'A' record named '*.myserver' along with the IP address you got from your server a few moments ago. If you are using BIND, your zone file will look similar to this: $ORIGIN example.tld $TTL 5m myserver IN A 127.0.0.1 *.myserver IN A 127.0.0.1 You can verify your changes in Linux by trying one or more of the following commands: host myserver.example.tld dig -t A myserver.example.tld nslookup myserver.example.tld Now is a good time to remind you that the answers you get MAY BE CACHED. If everything is working correctly, you should also be able to query for any other name 'under' myserver.example.tld and get back the IP address of your server. Try: host test.myserver.example.tld host xyzzy.myserver.example.tld If they all return your IP address, you have set DNS up properly for dokku. You should also be able to 'ssh root@myserver.example.tld' and access your server. Proceed with the setup instructions in the README Using the root of your domain (myapp.example.tld) This section is a work in progress. It is incomplete. Using the 'root' of your domain is nearly identical to the previous example. hostname is under example.tld, still needs A record Need to modify /home/dokku/HOSTNAME and /home/dokku/VHOST","title":"Overview"},{"location":"dns/#overview","text":"This is a work in progress.","title":"Overview"},{"location":"dns/#dns-versions","text":"There are many different DNS servers 'in the wild'. Some of the popular ones on Linux are BIND, dnsmasq, and pdns. Windows has its own built-in DNS server as well as Unbound, Posadis, and more. A full list of DNS packages can be found on Wikipedia under Comparison of DNS Server Software . In addition to the various DNS packages, there are tens of thousands of Managed DNS Providers out that all have different DNS interfaces.","title":"DNS Versions"},{"location":"dns/#focus","text":"Because there are so many different DNS server packages out there as well as a tremendous number of Managed DNS Providers, we will focus on the concepts of DNS as well as providing examples in the 'BIND' format so you can adapt the information to your own server package or managed DNS provider.","title":"Focus"},{"location":"dns/#assumptions","text":"We assume you have a passing familiarity with DNS. If not, you can read an in-depth article on DNS. But basically you need to know that DNS changes names (like example.tld) into addresses (like 127.0.0.1) We assume you already have a domain name registered and pointed to your favorite Managed DNS Provider or have your own BIND DNS server running. You have a server on the internet and are about to follow the instructions in the README to get dokku installed. Don't do the install just yet though.","title":"Assumptions"},{"location":"dns/#help","text":"Don't be afraid to ask if you need help. Create a new issue and someone will be glad to assist you.","title":"HELP!"},{"location":"dns/#getting-started","text":"For the examples, we will use the domain name 'example.tld' and the IP address '127.0.0.1'. Dokku uses a DNS to differentiate between apps on your dokku-powered server. If you are using the domain 'example.tld', and you have two apps 'myapp1' and 'myapp2', dokku will make them available at 'myapp1.example.tld' and 'myapp2.example.tld'. To get started, you need to know the IP address of your dokku server. Connect in to it and run 'ifconfig' or 'ip addr' to see the IP address.","title":"Getting started"},{"location":"dns/#caching","text":"Please remember that DNS relies heavily on caching . Changes you make to DNS could take anywhere from a few seconds to a few days to 'propagate'. If you tried surfing to example.tld, then changed the IP address in DNS, it could be a while before your computer picks up on the changes.","title":"Caching"},{"location":"dns/#the-two-methods","text":"Now you have to make a decision about your domain. Do you want everything and anything at example.tld to go to your dokku server, or would you rather use a 'sub domain' for your dokku server? In other words, do you want your applications on your dokku server accessible via myapp.example.tld or via myapp.myserver.example.tld?","title":"The two methods"},{"location":"dns/#using-a-sub-domain-myappmyserverexampletld","text":"Using a sub-domain is easy. When you set up your server, you probably gave it a name like myserver.example.tld. Go in to your Managed DNS provider and create an 'A' record named 'myserver' and put in the IP address you got from your server a few moments ago. Hopefully your managed DNS provider also supports wildcards. Create a second 'A' record named '*.myserver' along with the IP address you got from your server a few moments ago. If you are using BIND, your zone file will look similar to this: $ORIGIN example.tld $TTL 5m myserver IN A 127.0.0.1 *.myserver IN A 127.0.0.1 You can verify your changes in Linux by trying one or more of the following commands: host myserver.example.tld dig -t A myserver.example.tld nslookup myserver.example.tld Now is a good time to remind you that the answers you get MAY BE CACHED. If everything is working correctly, you should also be able to query for any other name 'under' myserver.example.tld and get back the IP address of your server. Try: host test.myserver.example.tld host xyzzy.myserver.example.tld If they all return your IP address, you have set DNS up properly for dokku. You should also be able to 'ssh root@myserver.example.tld' and access your server. Proceed with the setup instructions in the README","title":"Using a sub-domain (myapp.myserver.example.tld)"},{"location":"dns/#using-the-root-of-your-domain-myappexampletld","text":"This section is a work in progress. It is incomplete. Using the 'root' of your domain is nearly identical to the previous example. hostname is under example.tld, still needs A record Need to modify /home/dokku/HOSTNAME and /home/dokku/VHOST","title":"Using the root of your domain (myapp.example.tld)"},{"location":"docker-options/","text":"docker-options Usage $ dokku help ... docker-options <app> Display apps docker options for all phases docker-options <app> <phase ( s ) > Display apps docker options for phase ( comma-separated phase list ) docker-options:add <app> <phase ( s ) > OPTION Add docker option to app for phase ( comma-separated phase list ) docker-options:remove <app> <phase ( s ) > OPTION Remove docker option from app for phase ( comma-separated phase list ) ... ```` Add some options ( first, for the deployed/running app and second when executing ` dokku run ` ) ``` bash $ dokku docker-options:add myapp deploy \"-v /host/path:/container/path\" $ dokku docker-options:add myapp run \"-v /another/container/path\" Check what we added $ dokku docker-options myapp Deploy options: -v /host/path:/container/path Run options: -v /another/container/path Remove an option $ dokku docker-options:remove myapp run \"--link container_name:alias\" Note about dokku phases and docker-options dokku deploys your application in multiple \"phases\" and the docker-options plugin allows you to pass arguments to the underlying docker container in the following 3 phases/containers - build : the container that executes the appropriate buildpack - deploy : the container that executes your running/deployed application - run : the container that executes any arbitrary command via dokku run myapp Advanced Usage (avoid if possible) In your applications folder ( /home/dokku/app_name ) create a file called DOCKER_OPTIONS_RUN (or DOCKER_OPTIONS_BUILD or DOCKER_OPTIONS_DEPLOY ). Inside this file list one docker option per line. For example: --link container_name:alias -v /host/path:/container/path -v /another/container/path The above example will result in the following options being passed to docker during dokku run : --link container_name:alias -v /host/path:/container/path -v /another/container/path You may also include comments (lines beginning with a #) and blank lines in the DOCKER_OPTIONS file. Move information on docker options can be found here: http://docs.docker.io/en/latest/reference/run/ .","title":"Docker options"},{"location":"docker-options/#docker-options","text":"","title":"docker-options"},{"location":"docker-options/#usage","text":"$ dokku help ... docker-options <app> Display apps docker options for all phases docker-options <app> <phase ( s ) > Display apps docker options for phase ( comma-separated phase list ) docker-options:add <app> <phase ( s ) > OPTION Add docker option to app for phase ( comma-separated phase list ) docker-options:remove <app> <phase ( s ) > OPTION Remove docker option from app for phase ( comma-separated phase list ) ... ```` Add some options ( first, for the deployed/running app and second when executing ` dokku run ` ) ``` bash $ dokku docker-options:add myapp deploy \"-v /host/path:/container/path\" $ dokku docker-options:add myapp run \"-v /another/container/path\" Check what we added $ dokku docker-options myapp Deploy options: -v /host/path:/container/path Run options: -v /another/container/path Remove an option $ dokku docker-options:remove myapp run \"--link container_name:alias\"","title":"Usage"},{"location":"docker-options/#note-about-dokku-phases-and-docker-options","text":"dokku deploys your application in multiple \"phases\" and the docker-options plugin allows you to pass arguments to the underlying docker container in the following 3 phases/containers - build : the container that executes the appropriate buildpack - deploy : the container that executes your running/deployed application - run : the container that executes any arbitrary command via dokku run myapp","title":"Note about dokku phases and docker-options"},{"location":"docker-options/#advanced-usage-avoid-if-possible","text":"In your applications folder ( /home/dokku/app_name ) create a file called DOCKER_OPTIONS_RUN (or DOCKER_OPTIONS_BUILD or DOCKER_OPTIONS_DEPLOY ). Inside this file list one docker option per line. For example: --link container_name:alias -v /host/path:/container/path -v /another/container/path The above example will result in the following options being passed to docker during dokku run : --link container_name:alias -v /host/path:/container/path -v /another/container/path You may also include comments (lines beginning with a #) and blank lines in the DOCKER_OPTIONS file. Move information on docker options can be found here: http://docs.docker.io/en/latest/reference/run/ .","title":"Advanced Usage (avoid if possible)"},{"location":"dokku-events-logs/","text":"Dokku Event Logs Docker provides an events command to show system's real time events. Likewise, Dokku can record events as syslog entries and also provides a plugin to display the last ones. events [-t] Show the last events (-t follows) events:list List logged events events:on Enable events logger events:off Disable events logger Usage Enable the plugin: $ dokku events:on Enabling dokku events logger Dokku will then write log entries to /var/log/syslog as well as a Dokku-specific logs sub-directory /var/log/dokku/events.log , which can be easily displayed with the command dokku events : Jul 3 16:09:48 dokku.me dokku[127630]: INVOKED: pre-release-buildstep( pythonapp ) Jul 3 16:10:02 dokku.me dokku[128095]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:10:02 dokku.me dokku[128114]: INVOKED: docker-args-run( nhl ) Jul 3 16:10:03 dokku.me dokku[128136]: INVOKED: post-release-buildstep( pythonapp ) Jul 3 16:10:03 dokku.me dokku[128195]: INVOKED: pre-deploy( pythonapp ) Jul 3 16:10:23 dokku.me dokku[129253]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:24 dokku.me dokku[129337]: INVOKED: bind-external-ip( pythonapp ) Jul 3 16:10:24 dokku.me dokku[129451]: INVOKED: check-deploy( pythonapp 6274ced0d4be11af4490cd18abaf77cdd593f025133f403d984e80d86a39acec web 5000 10.0.16.80 ) Jul 3 16:10:35 dokku.me dokku[129561]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:35 dokku.me dokku[129649]: INVOKED: bind-external-ip( pythonapp ) Jul 3 16:10:36 dokku.me dokku[129760]: INVOKED: check-deploy( pythonapp ac88a56ee4161ff37e4b92d1498c3eadc91f0aa7c8b81b44fc077e2a51d54cc0 worker ) Jul 3 16:10:46 dokku.me dokku[129851]: INVOKED: post-deploy( pythonapp ) Jul 3 16:10:46 dokku.me dokku[129945]: INVOKED: nginx-pre-reload( pythonapp ) Jul 3 16:15:02 dokku.me dokku[130397]: INVOKED: docker-args-run( goapp ) Jul 3 16:21:02 dokku.me dokku[130796]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:30:02 dokku.me dokku[131384]: INVOKED: docker-args-run( rubyapp ) You can list all events that are currently being recorded via dokku events:list : =====> Events currently logged backup-check docker-args-build pre-delete post-deploy receive-app pre-release-buildstep nginx-pre-reload docker-args-deploy post-build-buildstep post-domains-update post-release-dockerfile check-deploy backup-import backup-export git-pre-pull git-post-pull nginx-hostname bind-external-ip pre-deploy post-delete dependencies pre-build-buildstep docker-args-run pre-build-dockerfile post-release-buildstep post-build-dockerfile pre-release-dockerfile update","title":"Dokku Event Logs"},{"location":"dokku-events-logs/#dokku-event-logs","text":"Docker provides an events command to show system's real time events. Likewise, Dokku can record events as syslog entries and also provides a plugin to display the last ones. events [-t] Show the last events (-t follows) events:list List logged events events:on Enable events logger events:off Disable events logger","title":"Dokku Event Logs"},{"location":"dokku-events-logs/#usage","text":"Enable the plugin: $ dokku events:on Enabling dokku events logger Dokku will then write log entries to /var/log/syslog as well as a Dokku-specific logs sub-directory /var/log/dokku/events.log , which can be easily displayed with the command dokku events : Jul 3 16:09:48 dokku.me dokku[127630]: INVOKED: pre-release-buildstep( pythonapp ) Jul 3 16:10:02 dokku.me dokku[128095]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:10:02 dokku.me dokku[128114]: INVOKED: docker-args-run( nhl ) Jul 3 16:10:03 dokku.me dokku[128136]: INVOKED: post-release-buildstep( pythonapp ) Jul 3 16:10:03 dokku.me dokku[128195]: INVOKED: pre-deploy( pythonapp ) Jul 3 16:10:23 dokku.me dokku[129253]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:24 dokku.me dokku[129337]: INVOKED: bind-external-ip( pythonapp ) Jul 3 16:10:24 dokku.me dokku[129451]: INVOKED: check-deploy( pythonapp 6274ced0d4be11af4490cd18abaf77cdd593f025133f403d984e80d86a39acec web 5000 10.0.16.80 ) Jul 3 16:10:35 dokku.me dokku[129561]: INVOKED: docker-args-deploy( pythonapp ) Jul 3 16:10:35 dokku.me dokku[129649]: INVOKED: bind-external-ip( pythonapp ) Jul 3 16:10:36 dokku.me dokku[129760]: INVOKED: check-deploy( pythonapp ac88a56ee4161ff37e4b92d1498c3eadc91f0aa7c8b81b44fc077e2a51d54cc0 worker ) Jul 3 16:10:46 dokku.me dokku[129851]: INVOKED: post-deploy( pythonapp ) Jul 3 16:10:46 dokku.me dokku[129945]: INVOKED: nginx-pre-reload( pythonapp ) Jul 3 16:15:02 dokku.me dokku[130397]: INVOKED: docker-args-run( goapp ) Jul 3 16:21:02 dokku.me dokku[130796]: INVOKED: docker-args-run( rubyapp ) Jul 3 16:30:02 dokku.me dokku[131384]: INVOKED: docker-args-run( rubyapp ) You can list all events that are currently being recorded via dokku events:list : =====> Events currently logged backup-check docker-args-build pre-delete post-deploy receive-app pre-release-buildstep nginx-pre-reload docker-args-deploy post-build-buildstep post-domains-update post-release-dockerfile check-deploy backup-import backup-export git-pre-pull git-post-pull nginx-hostname bind-external-ip pre-deploy post-delete dependencies pre-build-buildstep docker-args-run pre-build-dockerfile post-release-buildstep post-build-dockerfile pre-release-dockerfile update","title":"Usage"},{"location":"installation/","text":"Installation Requirements A fresh VM running Ubuntu 14.04 x64 At least 1GB of system memory ( workaround for 512MB machines ) The VM should have a FQDN set before installation (check by running sudo hostname -f ). Ubuntu 14.04 x64. Ideally have a domain ready to point to your host. It's designed for and is probably best to use a fresh VM. The bootstrapper will install everything it needs. Installing the latest Stable version To install the latest stable version of dokku, you can run the following bootstrapper command: # installs dokku via apt-get wget https://raw.github.com/progrium/dokku/v0.3.26/bootstrap.sh sudo DOKKU_TAG = v0.3.26 bash bootstrap.sh # By default, this will do cli-based setup, though you may *also* # go to your server's IP and follow the web installer For various reasons, certain hosting providers may have other steps that should be preferred to the above. If hosted on any of the following popular hosts, please follow the linked to instructions: Digital Ocean Installation Notes Linode Installation Notes As well, you may wish to customize your installation in some other fashion. or experiment with vagrant. The guides below should get you started: Debian Package Installation Notes Vagrant Installation Notes Advanced Install Customization","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#requirements","text":"A fresh VM running Ubuntu 14.04 x64 At least 1GB of system memory ( workaround for 512MB machines ) The VM should have a FQDN set before installation (check by running sudo hostname -f ). Ubuntu 14.04 x64. Ideally have a domain ready to point to your host. It's designed for and is probably best to use a fresh VM. The bootstrapper will install everything it needs.","title":"Requirements"},{"location":"installation/#installing-the-latest-stable-version","text":"To install the latest stable version of dokku, you can run the following bootstrapper command: # installs dokku via apt-get wget https://raw.github.com/progrium/dokku/v0.3.26/bootstrap.sh sudo DOKKU_TAG = v0.3.26 bash bootstrap.sh # By default, this will do cli-based setup, though you may *also* # go to your server's IP and follow the web installer For various reasons, certain hosting providers may have other steps that should be preferred to the above. If hosted on any of the following popular hosts, please follow the linked to instructions: Digital Ocean Installation Notes Linode Installation Notes As well, you may wish to customize your installation in some other fashion. or experiment with vagrant. The guides below should get you started: Debian Package Installation Notes Vagrant Installation Notes Advanced Install Customization","title":"Installing the latest Stable version"},{"location":"nginx/","text":"Nginx Dokku uses nginx as it's server for routing requests to specific applications. By default, access and error logs are written for each app to /var/log/nginx/${APP}-access.log and /var/log/nginx/${APP}-error.log respectively TLS/SPDY support Dokku provides easy TLS/SPDY support out of the box. This can be done app-by-app or for all subdomains at once. Note that whenever TLS support is enabled SPDY is also enabled. Per App To enable TLS connections to to one of your applications, do the following: Create a key file and a cert file. You can find detailed steps for generating a self-signed certificate at https://devcenter.heroku.com/articles/ssl-certificate-self If you are not paranoid and need it just for a DEV or STAGING app, you can use http://www.selfsignedcertificate.com/ to generate your 2 files more easily. Rename your files to server.key and server.crt tar these 2 files together, without subdirectories. Example: tar cvf cert-key.tar server.crt server.key Install the pair for your app, like this: ssh dokku@ip-of-your-dokku-server nginx:import-ssl < cert-key.tar You will need to repeat the steps above for each domain used to serve your app. You can't simply create a single tar with all key/cert files in it (see https://github.com/progrium/dokku/issues/1195). All Subdomains To enable TLS connections for all your applications at once you will need a wildcard TLS certificate. To enable TLS across all apps, copy or symlink the .crt and .key files into the /home/dokku/tls folder (create this folder if it doesn't exist) as server.crt and server.key respectively. Then, enable the certificates by editing /etc/nginx/conf.d/dokku.conf and uncommenting these two lines (remove the #): ssl_certificate /home/dokku/tls/server.crt; ssl_certificate_key /home/dokku/tls/server.key; The nginx configuration will need to be reloaded in order for the updated TLS configuration to be applied. This can be done either via the init system or by re-deploying the application. Once TLS is enabled, the application will be accessible by https:// (redirection from http:// is applied as well). Note : TLS will not be enabled unless the application's VHOST matches the certificate's name. (i.e. if you have a cert for *.example.com TLS won't be enabled for something.example.org or example.net) HSTS Header The HSTS header is an HTTP header that can inform browsers that all requests to a given site should be made via HTTPS. dokku does not, by default, enable this header. It is thus left up to you, the user, to enable it for your site. Beware that if you enable the header and a subsequent deploy of your application results in an HTTP deploy (for whatever reason), the way the header works means that a browser will not attempt to request the HTTP version of your site if the HTTPS version fails. Importing ssl certificates You can import ssl certificates via tarball using the following command: dokku nginx:import-ssl myapp < archive-of-certs.tar This archive should is expanded via tar xvf . It should contain server.crt and server.key . Customizing the nginx configuration New Introduced in 0.3.17. Dokku currently templates out an nginx configuration that is included in the nginx-vhosts plugin. If you'd like to provide a custom template for your application, you should copy the existing template - ssl or non-ssl - into your application repository's root directory as the file nginx.conf.template . The next time you deploy, Nginx will use your template instead of the default. New Introduced in 0.3.10. You may also place this file on disk at the path /home/dokku/myapp/nginx.conf.template . If placed on disk on the dokku server, the template file must be owned by the user dokku:dokku . For instance - assuming defaults - to customize the nginx template in use for the myapp application, create the file nginx.conf.template in your repo or on disk with the with the following contents: server { listen [::]:80; listen 80; server_name $NOSSL_SERVER_NAME; access_log /var/log/nginx/${APP}-access.log; error_log /var/log/nginx/${APP}-error.log; # set a custom header for requests add_header X-Served-By www-ec2-01; location / { proxy_pass http://$APP; proxy_http_version 1.1; proxy_set_header Upgrade \\$http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host \\$http_host; proxy_set_header X-Forwarded-Proto \\$scheme; proxy_set_header X-Forwarded-For \\$remote_addr; proxy_set_header X-Forwarded-Port \\$server_port; proxy_set_header X-Request-Start \\$msec; } include $DOKKU_ROOT/$APP/nginx.conf.d/*.conf; } The above is a sample http configuration that adds an X-Served-By header to requests. A few tips for custom nginx templates: Special characters - dollar signs, spaces inside of quotes, etc. - should be escaped with a single backslash or can cause deploy failures. Templated files will be validated via nginx -t . Application environment variables can be used within your nginx configuration. After your changes a dokku deploy myapp will regenerate the /home/dokku/myapp/nginx.conf file which is then used. Customizing via configuration files included by the default templates The default nginx.conf- templates will include everything from your apps nginx.conf.d/ subdirectory in the main server {} block (see above): include $DOKKU_ROOT/$APP/nginx.conf.d/*.conf; . That means you can put additional configuration in separate files, for example to limit the uploaded body size to 50 megabytes, do mkdir /home/dokku/myapp/nginx.conf.d/ echo 'client_max_body_size 50M;' > /home/dokku/myapp/nginx.conf.d/upload.conf chown dokku:dokku /home/dokku/myapp/nginx.conf.d/upload.conf service nginx reload Customizing hostnames Applications typically have the following structure for their hostname: scheme://subdomain.domain.tld The subdomain is inferred from the pushed application name, while the domain is set during initial configuration in the $DOKKU_ROOT/VHOST file. You can optionally override this in a plugin by implementing the nginx-hostname pluginhook. For example, you can reverse the subdomain with the following sample nginx-hostname pluginhook: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" If the nginx-hostname has no output, the normal hostname algorithm will be executed. You can also use the built-in domains plugin to handle: Disabling VHOSTS If desired, it is possible to disable vhosts by setting the NO_VHOST environment variable: dokku config:set myapp NO_VHOST = 1 On subsequent deploys, the nginx virtualhost will be discarded. This is useful when deploying internal-facing services that should not be publicly routeable. Domains plugin New Introduced in 0.3.10 The domains plugin allows you to specify custom domains for applications. This plugin is aware of any ssl certificates that are imported via nginx:import-ssl . Be aware that setting NO_VHOST will override any custom domains. Custom domains are also backed up via the built-in backup plugin # where `myapp` is the name of your app # add a domain to an app dokku domains:add myapp example.com # list custom domains for app dokku domains myapp # clear all custom domains for app dokku domains:clear myapp # remove a custom domain from app dokku domains:remove myapp example.com Container network interface binding New Introduced in 0.3.13 The deployed docker container running your app's web process will bind to either the internal docker network interface (i.e. docker inspect --format '{{ .NetworkSettings.IPAddress }}' $CONTAINER_ID ) or an external interface (i.e. 0.0.0.0) depending on dokku's VHOST configuration. Dokku will attempt to bind to the internal docker network interface unless you specifically set NO_VHOST for the given app or your dokku installation is not setup to use VHOSTS (i.e. $DOKKU_ROOT/VHOST is missing or $DOKKU_ROOT/HOSTNAME is set to an IPv4 or IPv6 address) # container bound to docker interface root@dokku:~/dokku# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b88d8aec3d1 dokku/node-js-app:latest \"/bin/bash -c '/star About a minute ago Up About a minute goofy_albattani root@dokku:~/dokku# docker inspect --format '{{ .NetworkSettings.IPAddress }}' goofy_albattani 172.17.0.6 # container bound to all interfaces (previous default) root@dokku:/home/dokku# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d6499edb0edb dokku/node-js-app:latest \" /bin/bash -c ' /star About a minute ago Up About a minute 0 .0.0.0:49153->5000/tcp nostalgic_tesla Default site By default, dokku will route any received request with an unknown HOST header value to the lexicographically first site in the nginx config stack. If this is not the desired behavior, you may want to add the following configuration to nginx. This will catch all unknown HOST header values and return a 410 Gone response. You can replace the return 410; with return 444; which will cause nginx to not respond to requests that do not match known domains (connection refused). server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 410; log_not_found off; }","title":"Nginx"},{"location":"nginx/#nginx","text":"Dokku uses nginx as it's server for routing requests to specific applications. By default, access and error logs are written for each app to /var/log/nginx/${APP}-access.log and /var/log/nginx/${APP}-error.log respectively","title":"Nginx"},{"location":"nginx/#tlsspdy-support","text":"Dokku provides easy TLS/SPDY support out of the box. This can be done app-by-app or for all subdomains at once. Note that whenever TLS support is enabled SPDY is also enabled.","title":"TLS/SPDY support"},{"location":"nginx/#per-app","text":"To enable TLS connections to to one of your applications, do the following: Create a key file and a cert file. You can find detailed steps for generating a self-signed certificate at https://devcenter.heroku.com/articles/ssl-certificate-self If you are not paranoid and need it just for a DEV or STAGING app, you can use http://www.selfsignedcertificate.com/ to generate your 2 files more easily. Rename your files to server.key and server.crt tar these 2 files together, without subdirectories. Example: tar cvf cert-key.tar server.crt server.key Install the pair for your app, like this: ssh dokku@ip-of-your-dokku-server nginx:import-ssl < cert-key.tar You will need to repeat the steps above for each domain used to serve your app. You can't simply create a single tar with all key/cert files in it (see https://github.com/progrium/dokku/issues/1195).","title":"Per App"},{"location":"nginx/#all-subdomains","text":"To enable TLS connections for all your applications at once you will need a wildcard TLS certificate. To enable TLS across all apps, copy or symlink the .crt and .key files into the /home/dokku/tls folder (create this folder if it doesn't exist) as server.crt and server.key respectively. Then, enable the certificates by editing /etc/nginx/conf.d/dokku.conf and uncommenting these two lines (remove the #): ssl_certificate /home/dokku/tls/server.crt; ssl_certificate_key /home/dokku/tls/server.key; The nginx configuration will need to be reloaded in order for the updated TLS configuration to be applied. This can be done either via the init system or by re-deploying the application. Once TLS is enabled, the application will be accessible by https:// (redirection from http:// is applied as well). Note : TLS will not be enabled unless the application's VHOST matches the certificate's name. (i.e. if you have a cert for *.example.com TLS won't be enabled for something.example.org or example.net)","title":"All Subdomains"},{"location":"nginx/#hsts-header","text":"The HSTS header is an HTTP header that can inform browsers that all requests to a given site should be made via HTTPS. dokku does not, by default, enable this header. It is thus left up to you, the user, to enable it for your site. Beware that if you enable the header and a subsequent deploy of your application results in an HTTP deploy (for whatever reason), the way the header works means that a browser will not attempt to request the HTTP version of your site if the HTTPS version fails.","title":"HSTS Header"},{"location":"nginx/#importing-ssl-certificates","text":"You can import ssl certificates via tarball using the following command: dokku nginx:import-ssl myapp < archive-of-certs.tar This archive should is expanded via tar xvf . It should contain server.crt and server.key .","title":"Importing ssl certificates"},{"location":"nginx/#customizing-the-nginx-configuration","text":"New Introduced in 0.3.17. Dokku currently templates out an nginx configuration that is included in the nginx-vhosts plugin. If you'd like to provide a custom template for your application, you should copy the existing template - ssl or non-ssl - into your application repository's root directory as the file nginx.conf.template . The next time you deploy, Nginx will use your template instead of the default. New Introduced in 0.3.10. You may also place this file on disk at the path /home/dokku/myapp/nginx.conf.template . If placed on disk on the dokku server, the template file must be owned by the user dokku:dokku . For instance - assuming defaults - to customize the nginx template in use for the myapp application, create the file nginx.conf.template in your repo or on disk with the with the following contents: server { listen [::]:80; listen 80; server_name $NOSSL_SERVER_NAME; access_log /var/log/nginx/${APP}-access.log; error_log /var/log/nginx/${APP}-error.log; # set a custom header for requests add_header X-Served-By www-ec2-01; location / { proxy_pass http://$APP; proxy_http_version 1.1; proxy_set_header Upgrade \\$http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host \\$http_host; proxy_set_header X-Forwarded-Proto \\$scheme; proxy_set_header X-Forwarded-For \\$remote_addr; proxy_set_header X-Forwarded-Port \\$server_port; proxy_set_header X-Request-Start \\$msec; } include $DOKKU_ROOT/$APP/nginx.conf.d/*.conf; } The above is a sample http configuration that adds an X-Served-By header to requests. A few tips for custom nginx templates: Special characters - dollar signs, spaces inside of quotes, etc. - should be escaped with a single backslash or can cause deploy failures. Templated files will be validated via nginx -t . Application environment variables can be used within your nginx configuration. After your changes a dokku deploy myapp will regenerate the /home/dokku/myapp/nginx.conf file which is then used.","title":"Customizing the nginx configuration"},{"location":"nginx/#customizing-via-configuration-files-included-by-the-default-templates","text":"The default nginx.conf- templates will include everything from your apps nginx.conf.d/ subdirectory in the main server {} block (see above): include $DOKKU_ROOT/$APP/nginx.conf.d/*.conf; . That means you can put additional configuration in separate files, for example to limit the uploaded body size to 50 megabytes, do mkdir /home/dokku/myapp/nginx.conf.d/ echo 'client_max_body_size 50M;' > /home/dokku/myapp/nginx.conf.d/upload.conf chown dokku:dokku /home/dokku/myapp/nginx.conf.d/upload.conf service nginx reload","title":"Customizing via configuration files included by the default templates"},{"location":"nginx/#customizing-hostnames","text":"Applications typically have the following structure for their hostname: scheme://subdomain.domain.tld The subdomain is inferred from the pushed application name, while the domain is set during initial configuration in the $DOKKU_ROOT/VHOST file. You can optionally override this in a plugin by implementing the nginx-hostname pluginhook. For example, you can reverse the subdomain with the following sample nginx-hostname pluginhook: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" If the nginx-hostname has no output, the normal hostname algorithm will be executed. You can also use the built-in domains plugin to handle:","title":"Customizing hostnames"},{"location":"nginx/#disabling-vhosts","text":"If desired, it is possible to disable vhosts by setting the NO_VHOST environment variable: dokku config:set myapp NO_VHOST = 1 On subsequent deploys, the nginx virtualhost will be discarded. This is useful when deploying internal-facing services that should not be publicly routeable.","title":"Disabling VHOSTS"},{"location":"nginx/#domains-plugin","text":"New Introduced in 0.3.10 The domains plugin allows you to specify custom domains for applications. This plugin is aware of any ssl certificates that are imported via nginx:import-ssl . Be aware that setting NO_VHOST will override any custom domains. Custom domains are also backed up via the built-in backup plugin # where `myapp` is the name of your app # add a domain to an app dokku domains:add myapp example.com # list custom domains for app dokku domains myapp # clear all custom domains for app dokku domains:clear myapp # remove a custom domain from app dokku domains:remove myapp example.com","title":"Domains plugin"},{"location":"nginx/#container-network-interface-binding","text":"New Introduced in 0.3.13 The deployed docker container running your app's web process will bind to either the internal docker network interface (i.e. docker inspect --format '{{ .NetworkSettings.IPAddress }}' $CONTAINER_ID ) or an external interface (i.e. 0.0.0.0) depending on dokku's VHOST configuration. Dokku will attempt to bind to the internal docker network interface unless you specifically set NO_VHOST for the given app or your dokku installation is not setup to use VHOSTS (i.e. $DOKKU_ROOT/VHOST is missing or $DOKKU_ROOT/HOSTNAME is set to an IPv4 or IPv6 address) # container bound to docker interface root@dokku:~/dokku# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b88d8aec3d1 dokku/node-js-app:latest \"/bin/bash -c '/star About a minute ago Up About a minute goofy_albattani root@dokku:~/dokku# docker inspect --format '{{ .NetworkSettings.IPAddress }}' goofy_albattani 172.17.0.6 # container bound to all interfaces (previous default) root@dokku:/home/dokku# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d6499edb0edb dokku/node-js-app:latest \" /bin/bash -c ' /star About a minute ago Up About a minute 0 .0.0.0:49153->5000/tcp nostalgic_tesla","title":"Container network interface binding"},{"location":"nginx/#default-site","text":"By default, dokku will route any received request with an unknown HOST header value to the lexicographically first site in the nginx config stack. If this is not the desired behavior, you may want to add the following configuration to nginx. This will catch all unknown HOST header values and return a 410 Gone response. You can replace the return 410; with return 444; which will cause nginx to not respond to requests that do not match known domains (connection refused). server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 410; log_not_found off; }","title":"Default site"},{"location":"plugins/","text":"Plugins Dokku itself is built out of plugins and uses pluginhook for its plugin system. In essence a plugin is a collection of scripts that will be run based on naming convention. Let's take a quick look at the current dokku nginx plugin that's shipped with dokku by default. nginx-vhosts/ \u251c\u2500\u2500 commands # contains additional commands \u251c\u2500\u2500 install # runs on dokku installation \u2514\u2500\u2500 post-deploy # runs after an app is deployed Installing a plugin Creating your own plugin cd /var/lib/dokku/plugins git clone <git url> dokku plugins-install See the full documentation . Community plugins Note: The following plugins have been supplied by our community and may not have been tested by dokku maintainers. Datastores Relational Plugin Author Compatibility MariaDB Kloadut Compatible with 0.2.0 MariaDB (single container) ohardy Compatible with 0.2.0 MySQL hughfletcher PostgreSQL Kloadut Compatible with 0.2.0 PostgreSQL jlachowski IP & PORT available directly in linked app container env variables (requires link plugin) PostgreSQL (single container) jeffutter This plugin creates a single postgresql container that all your apps can use. Thus only one instance of postgresql running (good for servers without a ton of memory). PostgreSQL (single container) ohardy Compatible with 0.2.0 PostgreSQL (single container) Flink Single Postgresql container with official Postgresql docker image. Compatible with 0.3.16 PostGIS fermuch Caching Plugin Author Compatibility Memcached jlachowski IP & PORT available directly in linked app container env variables (requires link plugin) Redis luxifer Redis sekjun9878 A better Redis plugin with automatic instance creation and Dokku Link support Redis (single container) ohardy Compatible with 0.2.0 Varnish Zenedith Varnish cache between nginx and application with base configuration Queuing Plugin Author Compatibility RabbitMQ jlachowski IP & PORT available directly in linked app container env variables (requires link plugin) RabbitMQ (single container) jlachowski IP & PORT available directly in linked app container env variables (requires link plugin) Other Plugin Author Compatibility CouchDB RaceHub Compatible with 0.2.0 Elasticsearch robv Not compatible with >= 0.3.0 (still uses /home/git) Elasticsearch 1 blag Compatible with 0.2.0 MongoDB (single container) jeffutter Neo4j Aomitayo RethinkDB stuartpb 2014-02-22: targeting dokku @ latest ; will fail with Dokku earlier than 28de3ec . RiakCS (single container) jeffutter Incompatible with 0.2.0 (checked at dccee02 ) Process Managers Plugin Author Compatibility Circus apmorton Forego iskandar Compatible with 0.2.x Logging Supervisord sehrope Works with dokku @ c77cbf1 - no 0.2.0 compatibility Monit cjblomqvist Shoreman statianzo Compatible with 0.2.0 Supervisord statianzo Compatible with 0.2.0 Dokku Features Plugin Author Compatibility app-url mikecsh Works with 0.2.0 Docker Direct heichblatt Dokku Name alex-sherwin dokku >= c77cbf1 Dokku Registry 1 agco-adm git rev-parse HEAD in env cjblomqvist Compatible with 0.3.0 Graduate (Environment Management) Benjamin-Dobell dokku >= v0.3.14 HTTP Auth Flink HTTP Auth Secure Apps matto1990 Works with v0.2.3 Hostname michaelshobbs Link Containers rlaneve dokku >= c77cbf1 Maintenance mode Flink Multi-Buildpack pauldub Ports heichblatt Pre-Deploy Tasks michaelshobbs SSH Deployment Keys 2 cedricziel 2014-01-17: compatible with upstream/master SSH Hostkeys 3 cedricziel 2014-01-17: compatible with upstream/master Volume (persistent storage) ohardy Compatible with 0.2.0 App Configfiles alexkruegger Compatible with 0.3.17+ 1 On Heroku similar functionality is offered by the heroku-labs pipeline feature , which allows you to promote builds across multiple environments (staging -> production) 2 Adds the possibility to add SSH deployment keys to receive private hosted packages 3 Adds the ability to add custom hosts to the containers known_hosts file to be able to ssh them easily (useful with deployment keys) Other Plugins Plugin Author Compatibility Airbrake deploy Flink APT F4-Group Chef cookbooks fgrehm Bower install alexanderbeletsky Bower/Grunt thrashr888 Bower/Gulp gdi2290 Bower/Gulp jagandecapri Docker auto volumes Flink 0.3.17+, auto-persist docker volumes HipChat Notifications cef Graphite/statsd jlachowski Logspout michaelshobbs Node pnegahdar Node ademuk Rails logs Flink Reset mtime mixxorz 0.3.15+, Dockerfile support Slack Notifications ribot User ACL Maciej \u0141ebkowski Webhooks nickstenning Wordpress abossard Dokku dev, mariadb, volume, domains 1 Forked from jezdez/dokku-elasticsearch-plugin : uses Elasticsearch 1.2 (instead of 0.90), doesn't depend on dokku-link, runs as elasticsearch user instead of root, and turns off multicast autodiscovery for use in a VPS environment. Deprecated Plugins The following plugins have been removed as their functionality is now in Dokku Core. Plugin Author In Dokku Since Custom Domains motin v0.3.10 (domains plugin) Debug heichblatt v0.3.9 (trace command) Docker Options dyson v0.3.17 (docker-options plugin) Events Logger alessio v0.3.21 (events plugin) Host Port binding stuartpb v0.3.17 (docker-options plugin) Multiple Domains 1 wmluke v0.3.10 (domains plugin) Nginx-Alt mikexstudios v0.3.10 (domains plugin) Persistent Storage dyson v0.3.17 (docker-options plugin) PrimeCache darkpixel v0.3.0 (zero downtime deploys) Rebuild application scottatron v0.3.14 (ps plugin) Supply env vars to buildpacks 2 cameron-martin v0.3.9 (build-env plugin) user-env-compile 2 musicglue v0.3.9 (build-env plugin) user-env-compile 2 motin v0.3.9 (build-env plugin) VHOSTS Custom Configuration motin v0.3.10 (domains plugin) 1 Conflicts with VHOSTS Custom Configuration 2 Similar to the heroku-labs feature (see https://devcenter.heroku.com/articles/labs-user-env-compile)","title":"Plugins"},{"location":"plugins/#plugins","text":"Dokku itself is built out of plugins and uses pluginhook for its plugin system. In essence a plugin is a collection of scripts that will be run based on naming convention. Let's take a quick look at the current dokku nginx plugin that's shipped with dokku by default. nginx-vhosts/ \u251c\u2500\u2500 commands # contains additional commands \u251c\u2500\u2500 install # runs on dokku installation \u2514\u2500\u2500 post-deploy # runs after an app is deployed","title":"Plugins"},{"location":"plugins/#installing-a-plugin","text":"","title":"Installing a plugin"},{"location":"plugins/#creating-your-own-plugin","text":"cd /var/lib/dokku/plugins git clone <git url> dokku plugins-install See the full documentation .","title":"Creating your own plugin"},{"location":"plugins/#community-plugins","text":"Note: The following plugins have been supplied by our community and may not have been tested by dokku maintainers.","title":"Community plugins"},{"location":"plugins/#datastores","text":"","title":"Datastores"},{"location":"plugins/#relational","text":"Plugin Author Compatibility MariaDB Kloadut Compatible with 0.2.0 MariaDB (single container) ohardy Compatible with 0.2.0 MySQL hughfletcher PostgreSQL Kloadut Compatible with 0.2.0 PostgreSQL jlachowski IP & PORT available directly in linked app container env variables (requires link plugin) PostgreSQL (single container) jeffutter This plugin creates a single postgresql container that all your apps can use. Thus only one instance of postgresql running (good for servers without a ton of memory). PostgreSQL (single container) ohardy Compatible with 0.2.0 PostgreSQL (single container) Flink Single Postgresql container with official Postgresql docker image. Compatible with 0.3.16 PostGIS fermuch","title":"Relational"},{"location":"plugins/#caching","text":"Plugin Author Compatibility Memcached jlachowski IP & PORT available directly in linked app container env variables (requires link plugin) Redis luxifer Redis sekjun9878 A better Redis plugin with automatic instance creation and Dokku Link support Redis (single container) ohardy Compatible with 0.2.0 Varnish Zenedith Varnish cache between nginx and application with base configuration","title":"Caching"},{"location":"plugins/#queuing","text":"Plugin Author Compatibility RabbitMQ jlachowski IP & PORT available directly in linked app container env variables (requires link plugin) RabbitMQ (single container) jlachowski IP & PORT available directly in linked app container env variables (requires link plugin)","title":"Queuing"},{"location":"plugins/#other","text":"Plugin Author Compatibility CouchDB RaceHub Compatible with 0.2.0 Elasticsearch robv Not compatible with >= 0.3.0 (still uses /home/git) Elasticsearch 1 blag Compatible with 0.2.0 MongoDB (single container) jeffutter Neo4j Aomitayo RethinkDB stuartpb 2014-02-22: targeting dokku @ latest ; will fail with Dokku earlier than 28de3ec . RiakCS (single container) jeffutter Incompatible with 0.2.0 (checked at dccee02 )","title":"Other"},{"location":"plugins/#process-managers","text":"Plugin Author Compatibility Circus apmorton Forego iskandar Compatible with 0.2.x Logging Supervisord sehrope Works with dokku @ c77cbf1 - no 0.2.0 compatibility Monit cjblomqvist Shoreman statianzo Compatible with 0.2.0 Supervisord statianzo Compatible with 0.2.0","title":"Process Managers"},{"location":"plugins/#dokku-features","text":"Plugin Author Compatibility app-url mikecsh Works with 0.2.0 Docker Direct heichblatt Dokku Name alex-sherwin dokku >= c77cbf1 Dokku Registry 1 agco-adm git rev-parse HEAD in env cjblomqvist Compatible with 0.3.0 Graduate (Environment Management) Benjamin-Dobell dokku >= v0.3.14 HTTP Auth Flink HTTP Auth Secure Apps matto1990 Works with v0.2.3 Hostname michaelshobbs Link Containers rlaneve dokku >= c77cbf1 Maintenance mode Flink Multi-Buildpack pauldub Ports heichblatt Pre-Deploy Tasks michaelshobbs SSH Deployment Keys 2 cedricziel 2014-01-17: compatible with upstream/master SSH Hostkeys 3 cedricziel 2014-01-17: compatible with upstream/master Volume (persistent storage) ohardy Compatible with 0.2.0 App Configfiles alexkruegger Compatible with 0.3.17+ 1 On Heroku similar functionality is offered by the heroku-labs pipeline feature , which allows you to promote builds across multiple environments (staging -> production) 2 Adds the possibility to add SSH deployment keys to receive private hosted packages 3 Adds the ability to add custom hosts to the containers known_hosts file to be able to ssh them easily (useful with deployment keys)","title":"Dokku Features"},{"location":"plugins/#other-plugins","text":"Plugin Author Compatibility Airbrake deploy Flink APT F4-Group Chef cookbooks fgrehm Bower install alexanderbeletsky Bower/Grunt thrashr888 Bower/Gulp gdi2290 Bower/Gulp jagandecapri Docker auto volumes Flink 0.3.17+, auto-persist docker volumes HipChat Notifications cef Graphite/statsd jlachowski Logspout michaelshobbs Node pnegahdar Node ademuk Rails logs Flink Reset mtime mixxorz 0.3.15+, Dockerfile support Slack Notifications ribot User ACL Maciej \u0141ebkowski Webhooks nickstenning Wordpress abossard Dokku dev, mariadb, volume, domains 1 Forked from jezdez/dokku-elasticsearch-plugin : uses Elasticsearch 1.2 (instead of 0.90), doesn't depend on dokku-link, runs as elasticsearch user instead of root, and turns off multicast autodiscovery for use in a VPS environment.","title":"Other Plugins"},{"location":"plugins/#deprecated-plugins","text":"The following plugins have been removed as their functionality is now in Dokku Core. Plugin Author In Dokku Since Custom Domains motin v0.3.10 (domains plugin) Debug heichblatt v0.3.9 (trace command) Docker Options dyson v0.3.17 (docker-options plugin) Events Logger alessio v0.3.21 (events plugin) Host Port binding stuartpb v0.3.17 (docker-options plugin) Multiple Domains 1 wmluke v0.3.10 (domains plugin) Nginx-Alt mikexstudios v0.3.10 (domains plugin) Persistent Storage dyson v0.3.17 (docker-options plugin) PrimeCache darkpixel v0.3.0 (zero downtime deploys) Rebuild application scottatron v0.3.14 (ps plugin) Supply env vars to buildpacks 2 cameron-martin v0.3.9 (build-env plugin) user-env-compile 2 musicglue v0.3.9 (build-env plugin) user-env-compile 2 motin v0.3.9 (build-env plugin) VHOSTS Custom Configuration motin v0.3.10 (domains plugin) 1 Conflicts with VHOSTS Custom Configuration 2 Similar to the heroku-labs feature (see https://devcenter.heroku.com/articles/labs-user-env-compile)","title":"Deprecated Plugins"},{"location":"process-management/","text":"Process/Container management Dokku supports rudimentary process (really container) management via the ps plugin. ps <app> List processes running in app container(s) ps:rebuildall Rebuild all apps ps:rebuild <app> Rebuild an app ps:restartall Restart all deployed app containers ps:restart <app> Restart app container(s) ps:scale <app> <proc>=<count> [<proc>=<count>] Set how many processes of a given process to run ps:start <app> Start app container(s) ps:stop <app> Stop app container(s) NOTE : As of v0.3.14, dokku deploy:all in now deprecated by ps:restartall and will be removed in a future version. Scaling Dokku allows you to run multiple process types at different container counts. For example, if you had an app that contained 1 web app listener and 1 background job processor, dokku can, spin up 1 container for each process type defined in the Procfile. By default we will only start the web process. However, if you wanted 2 job processors running simultaneously, you can modify this behavior in a few ways. DOKKU_SCALE file You can optionally create a DOKKU_SCALE file in the root of your repository. Dokku expects this file to contain one line for every process defined in your Procfile. Example: web=1 worker=2 ps:scale command Dokku can also manage scaling itself via the ps:scale command. This command can be used to scale multiple process types at the same time. dokku ps:scale app_name web=1 worker=2 NOTE : Dokku will always use the DOKKU_SCALE file that ships with the repo to override any local settings. The web proctype Like Heroku, we handle the web proctype differently from others. The web proctype is the only proctype that will invoke custom checks as defined by a CHECKS file. It is also the only proctype that will be launched in a container that is either proxied via nginx or bound to an external port.","title":"Process/Container management"},{"location":"process-management/#processcontainer-management","text":"Dokku supports rudimentary process (really container) management via the ps plugin. ps <app> List processes running in app container(s) ps:rebuildall Rebuild all apps ps:rebuild <app> Rebuild an app ps:restartall Restart all deployed app containers ps:restart <app> Restart app container(s) ps:scale <app> <proc>=<count> [<proc>=<count>] Set how many processes of a given process to run ps:start <app> Start app container(s) ps:stop <app> Stop app container(s) NOTE : As of v0.3.14, dokku deploy:all in now deprecated by ps:restartall and will be removed in a future version.","title":"Process/Container management"},{"location":"process-management/#scaling","text":"Dokku allows you to run multiple process types at different container counts. For example, if you had an app that contained 1 web app listener and 1 background job processor, dokku can, spin up 1 container for each process type defined in the Procfile. By default we will only start the web process. However, if you wanted 2 job processors running simultaneously, you can modify this behavior in a few ways.","title":"Scaling"},{"location":"process-management/#dokku_scale-file","text":"You can optionally create a DOKKU_SCALE file in the root of your repository. Dokku expects this file to contain one line for every process defined in your Procfile. Example: web=1 worker=2","title":"DOKKU_SCALE file"},{"location":"process-management/#psscale-command","text":"Dokku can also manage scaling itself via the ps:scale command. This command can be used to scale multiple process types at the same time. dokku ps:scale app_name web=1 worker=2 NOTE : Dokku will always use the DOKKU_SCALE file that ships with the repo to override any local settings.","title":"ps:scale command"},{"location":"process-management/#the-web-proctype","text":"Like Heroku, we handle the web proctype differently from others. The web proctype is the only proctype that will invoke custom checks as defined by a CHECKS file. It is also the only proctype that will be launched in a container that is either proxied via nginx or bound to an external port.","title":"The web proctype"},{"location":"remote-commands/","text":"Remote commands Dokku commands can be run over ssh. Anywhere you would run dokku <command> , just run ssh -t dokku@dokku.me <command> The -t is used to request a pty. It is highly recommended to do so. To avoid the need to type the -t option each time, simply create/modify a section in the .ssh/config on the client side, as follows: Host dokku.me RequestTTY yes Run a command in the app environment It's possible to run commands in the environment of the deployed application: dokku run node-js-app ls -alh dokku run <app> <cmd> Behavioral modifiers Dokku also supports certain command-line arguments that augment it's behavior. If using these over ssh, you must use the form ssh -t dokku@dokku.me -- <command> in order to avoid ssh interpretting dokku arguments for itself. --quiet suppress output headers --trace enable DOKKU_TRACE for current execution only --rm | --rm-container remove docker container after successful dokku run <app> <command> --force force flag. currently used in apps:destroy","title":"Remote commands"},{"location":"remote-commands/#remote-commands","text":"Dokku commands can be run over ssh. Anywhere you would run dokku <command> , just run ssh -t dokku@dokku.me <command> The -t is used to request a pty. It is highly recommended to do so. To avoid the need to type the -t option each time, simply create/modify a section in the .ssh/config on the client side, as follows: Host dokku.me RequestTTY yes","title":"Remote commands"},{"location":"remote-commands/#run-a-command-in-the-app-environment","text":"It's possible to run commands in the environment of the deployed application: dokku run node-js-app ls -alh dokku run <app> <cmd>","title":"Run a command in the app environment"},{"location":"remote-commands/#behavioral-modifiers","text":"Dokku also supports certain command-line arguments that augment it's behavior. If using these over ssh, you must use the form ssh -t dokku@dokku.me -- <command> in order to avoid ssh interpretting dokku arguments for itself. --quiet suppress output headers --trace enable DOKKU_TRACE for current execution only --rm | --rm-container remove docker container after successful dokku run <app> <command> --force force flag. currently used in apps:destroy","title":"Behavioral modifiers"},{"location":"troubleshooting/","text":"Troubleshooting Symptom: I deployed my app but I am getting the default nginx page Solution: Most of the time it's caused by some defaults newer versions of nginx set. To make sure that's the issue you're having run the following: root@dockerapps:/home/git# nginx nginx: [emerg] could not build the server_names_hash, you should increase server_names_hash_bucket_size: 32 If you get a similar error just edit /etc/nginx/nginx.conf and add the following line to your http section: http { (... existing content ...) server_names_hash_bucket_size 64; (...) } Note that the server_names_hash_bucket_size setting defines the maximum domain name length. A value of 64 would allow domains with up to 64 characters. Set it to 128 if you need longer ones. Save the file and try stopping nginx and starting it again: root@dockerapps:~/dokku# /etc/init.d/nginx stop * Stopping nginx nginx [ OK ] root@dockerapps:~/dokku# /etc/init.d/nginx start * Starting nginx nginx [ OK ] Symptom: I want to deploy my app, but while pushing I get the following error ! [remote rejected] master -> master (pre-receive hook declined) Solution: The remote rejected error does not give enough information. Anything could have failed. To enable dokku tracing, simply run the following command: # Since 0.3.9 dokku trace In versions older than 0.3.9, you can create a /home/dokku/dokkurc file containing the following : export DOKKU_TRACE=1 This will trace all of dokku's activity. If this does not help you, create a gist containing the full log, and create an issue. Symptom: I get the aforementioned error in the build phase (after turning on dokku tracing) Most errors that happen in this phase are due to transient network issues (either locally or remotely) buildpack bugs. Solution (Less solution, more helpful troubleshooting steps): Find the failed phase's container image ( 077581956a92 in this example) ``` root@dokku:~# docker ps -a | grep build 94d9515e6d93 077581956a92 \"/build\" 29 minutes ago Exited (0) 25 minutes ago cocky_bell ``` Start a new container with the failed image and poke around (i.e. ensure you can access the internet from within the container or attempt the failed command, if known) ``` root@dokku:~# docker run -ti 077581956a92 /bin/bash root@9763ab86e1b4:/# curl -s -S icanhazip.com 192.168.0.1 curl http://s3pository.heroku.com/node/v0.10.30/node-v0.10.30-linux-x64.tar.gz -o node-v0.10.30-linux-x64.tar.gz tar tzf node-v0.10.30-linux-x64.tar.gz ... ``` Sometimes (especially on DO) deploying again seems to get past these seemingly transient issues Additionally we've seen issues if changing networks that have different DNS resolvers. In this case, you can run the following to update your resolv.conf root@dokku:~# resolvconf -u Please see https://github.com/progrium/dokku/issues/841 and https://github.com/progrium/dokku/issues/649 Symptom: I want to deploy my app but I am getting asked for the password of the git user and the error message fatal: 'NAME' does not appear to be a git repository fatal: Could not read from remote repository. Solution: You get asked for a password because your ssh secret key can't be found. This may happen if the private key corresponding to the public key you added with sshcommand acl-add is not located in the default location ~/.ssh/id_rsa . You have to point ssh to the correct secret key for your domain name. Add the following to your ~/.ssh/config : Host DOKKU_HOSTNAME IdentityFile \"~/.ssh/KEYNAME\" Also see issue #116 Symptom: I successfully deployed my application with no deployment errors and receiving Bad Gateway when attempting to access the application Solution: In many cases the application will require the a process.env.PORT port opposed to a specified port. When specifying your port you may want to use something similar to: var port = process.env.PORT || 3000 Please see https://github.com/progrium/dokku/issues/282 Symptom: Deployment fails because of slow internet connection, messages shows gzip: stdin: unexpected end of file Solution: If you see output similar this when deploying: Command: 'set -o pipefail; curl --fail --retry 3 --retry-delay 1 --connect-timeout 3 --max-time 30 https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/ruby-2.0.0-p451-default-cache.tgz -s -o - | tar zxf -' failed unexpectedly: ! ! gzip: stdin: unexpected end of file ! tar: Unexpected EOF in archive ! tar: Unexpected EOF in archive ! tar: Error is not recoverable: exiting now it might that the curl command that is supposed to fetch the buildpack (anything in the low megabyte file size range) takes too long to finish, due to slowish connection. To overwrite the default values (connection timeout: 3 seconds, total maximum time for operation: 30 seconds), edit /home/dokku/ENV like the following: #/home/dokku/ENV export CURL_TIMEOUT=600 export CURL_CONNECT_TIMEOUT=30 References * https://github.com/progrium/dokku/issues/509 * https://github.com/dokku-alt/dokku-alt/issues/169","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"Symptom: I deployed my app but I am getting the default nginx page Solution: Most of the time it's caused by some defaults newer versions of nginx set. To make sure that's the issue you're having run the following: root@dockerapps:/home/git# nginx nginx: [emerg] could not build the server_names_hash, you should increase server_names_hash_bucket_size: 32 If you get a similar error just edit /etc/nginx/nginx.conf and add the following line to your http section: http { (... existing content ...) server_names_hash_bucket_size 64; (...) } Note that the server_names_hash_bucket_size setting defines the maximum domain name length. A value of 64 would allow domains with up to 64 characters. Set it to 128 if you need longer ones. Save the file and try stopping nginx and starting it again: root@dockerapps:~/dokku# /etc/init.d/nginx stop * Stopping nginx nginx [ OK ] root@dockerapps:~/dokku# /etc/init.d/nginx start * Starting nginx nginx [ OK ] Symptom: I want to deploy my app, but while pushing I get the following error ! [remote rejected] master -> master (pre-receive hook declined) Solution: The remote rejected error does not give enough information. Anything could have failed. To enable dokku tracing, simply run the following command: # Since 0.3.9 dokku trace In versions older than 0.3.9, you can create a /home/dokku/dokkurc file containing the following : export DOKKU_TRACE=1 This will trace all of dokku's activity. If this does not help you, create a gist containing the full log, and create an issue. Symptom: I get the aforementioned error in the build phase (after turning on dokku tracing) Most errors that happen in this phase are due to transient network issues (either locally or remotely) buildpack bugs. Solution (Less solution, more helpful troubleshooting steps): Find the failed phase's container image ( 077581956a92 in this example) ``` root@dokku:~# docker ps -a | grep build 94d9515e6d93 077581956a92 \"/build\" 29 minutes ago Exited (0) 25 minutes ago cocky_bell ``` Start a new container with the failed image and poke around (i.e. ensure you can access the internet from within the container or attempt the failed command, if known) ``` root@dokku:~# docker run -ti 077581956a92 /bin/bash root@9763ab86e1b4:/# curl -s -S icanhazip.com 192.168.0.1 curl http://s3pository.heroku.com/node/v0.10.30/node-v0.10.30-linux-x64.tar.gz -o node-v0.10.30-linux-x64.tar.gz tar tzf node-v0.10.30-linux-x64.tar.gz ... ``` Sometimes (especially on DO) deploying again seems to get past these seemingly transient issues Additionally we've seen issues if changing networks that have different DNS resolvers. In this case, you can run the following to update your resolv.conf root@dokku:~# resolvconf -u Please see https://github.com/progrium/dokku/issues/841 and https://github.com/progrium/dokku/issues/649 Symptom: I want to deploy my app but I am getting asked for the password of the git user and the error message fatal: 'NAME' does not appear to be a git repository fatal: Could not read from remote repository. Solution: You get asked for a password because your ssh secret key can't be found. This may happen if the private key corresponding to the public key you added with sshcommand acl-add is not located in the default location ~/.ssh/id_rsa . You have to point ssh to the correct secret key for your domain name. Add the following to your ~/.ssh/config : Host DOKKU_HOSTNAME IdentityFile \"~/.ssh/KEYNAME\" Also see issue #116 Symptom: I successfully deployed my application with no deployment errors and receiving Bad Gateway when attempting to access the application Solution: In many cases the application will require the a process.env.PORT port opposed to a specified port. When specifying your port you may want to use something similar to: var port = process.env.PORT || 3000 Please see https://github.com/progrium/dokku/issues/282 Symptom: Deployment fails because of slow internet connection, messages shows gzip: stdin: unexpected end of file Solution: If you see output similar this when deploying: Command: 'set -o pipefail; curl --fail --retry 3 --retry-delay 1 --connect-timeout 3 --max-time 30 https://s3-external-1.amazonaws.com/heroku-buildpack-ruby/ruby-2.0.0-p451-default-cache.tgz -s -o - | tar zxf -' failed unexpectedly: ! ! gzip: stdin: unexpected end of file ! tar: Unexpected EOF in archive ! tar: Unexpected EOF in archive ! tar: Error is not recoverable: exiting now it might that the curl command that is supposed to fetch the buildpack (anything in the low megabyte file size range) takes too long to finish, due to slowish connection. To overwrite the default values (connection timeout: 3 seconds, total maximum time for operation: 30 seconds), edit /home/dokku/ENV like the following: #/home/dokku/ENV export CURL_TIMEOUT=600 export CURL_CONNECT_TIMEOUT=30 References * https://github.com/progrium/dokku/issues/509 * https://github.com/dokku-alt/dokku-alt/issues/169","title":"Troubleshooting"},{"location":"upgrading/","text":"Upgrading This document covers upgrades for the 0.3.0 series and up. If upgrading from previous versions, we recommend a fresh install on a new server. Info As of 0.3.18, dokku is installed by default via a debian package. Source-based installations are still available, though not recommended. Dokku If dokku was installed via a debian package, you can upgrade dokku via the following command: sudo apt-get install dokku For unattended upgrades, you may run the following command: sudo apt-get install -qq -y dokku If you have installed dokku from source, you may run the following commands to upgrade: cd ~/dokku git pull --tags origin master # continue to install from source sudo DOKKU_BRANCH = master make install # upgrade to debian package-based installation sudo make install All changes will take effect upon next application deployment. To trigger a rebuild of every application, simply run the following command: dokku ps:rebuildall Herokuish image If dokku was installed via a debian package, you can upgrade herokuish via the following command: sudo apt-get install Herokush For unattended upgrades, you may run the following command: sudo apt-get install -qq -y herokuish In some cases, it may be desirable to run a specific version of herokuish. To install/upgrade herokuish from source, run the following commands: cd /tmp git clone https://github.com/gliderlabs/herokuish.git cd herokuish git pull origin master IMAGE_NAME = gliderlabs/herokuish BUILD_TAG = latest VERSION = master make -e build-in-docker","title":"Upgrading"},{"location":"upgrading/#upgrading","text":"This document covers upgrades for the 0.3.0 series and up. If upgrading from previous versions, we recommend a fresh install on a new server. Info As of 0.3.18, dokku is installed by default via a debian package. Source-based installations are still available, though not recommended.","title":"Upgrading"},{"location":"upgrading/#dokku","text":"If dokku was installed via a debian package, you can upgrade dokku via the following command: sudo apt-get install dokku For unattended upgrades, you may run the following command: sudo apt-get install -qq -y dokku If you have installed dokku from source, you may run the following commands to upgrade: cd ~/dokku git pull --tags origin master # continue to install from source sudo DOKKU_BRANCH = master make install # upgrade to debian package-based installation sudo make install All changes will take effect upon next application deployment. To trigger a rebuild of every application, simply run the following command: dokku ps:rebuildall","title":"Dokku"},{"location":"upgrading/#herokuish-image","text":"If dokku was installed via a debian package, you can upgrade herokuish via the following command: sudo apt-get install Herokush For unattended upgrades, you may run the following command: sudo apt-get install -qq -y herokuish In some cases, it may be desirable to run a specific version of herokuish. To install/upgrade herokuish from source, run the following commands: cd /tmp git clone https://github.com/gliderlabs/herokuish.git cd herokuish git pull origin master IMAGE_NAME = gliderlabs/herokuish BUILD_TAG = latest VERSION = master make -e build-in-docker","title":"Herokuish image"},{"location":"community/clients/","text":"Clients Given the constraints, running dokku commands remotely via SSH is fine. For certain configurations, the extra complication of manually invoking ssh can be a burden. While dokku does not yet have an official client, there are a multitude of ways in which you can interact with your dokku installation. The easiest is to use the bash client, though you may wish to use another. (bash, zsh, etc.) dokku_client.sh Of all methods, this is the most official method of interacting with your dokku installation. It is a bash script that interacts with a remote dokku installation via ssh. It is available in contrib/dokku_client.sh in the root of the dokku repository. To install, simply clone the dokku repository down and add the dokku alias pointing at the script: git clone git@github.com:progrium/dokku.git ~/.dokku # add the following to either your # .bashrc, .bash_profile, or .profile file alias dokku = '$HOME/.dokku/contrib/dokku_client.sh' Alternatively, if using another shell such as zsh , create an alias command which invokes the script using bash : # zsh: add the following to either .zshenv or .zshrc alias dokku = 'bash $HOME/.dokku/contrib/dokku_client.sh' # fish: add the following to ~/.config/fish/config.fish alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' # csh: add the following to .cshrc alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' Configure the DOKKU_HOST environment variable or run dokku from a repository with a git remote named dokku pointed at your dokku host in order to use the script as normal. (nodejs) dokku-toolbelt Dokku-toolbelt is a node-based cli wrapper that proxies requests to the dokku command running on remote hosts. You can install it via the following shell command (assuming you have nodejs and npm installed): npm install -g dokku-toolbelt See documentation here for more information. (python) dokku-client dokku-client is an extensible python-based cli wrapper for remote dokku hosts. You can install it via the following shell command (assuming you have python and pip installed): pip install dokku-client See documentation here for more information. (ruby) Dokku CLI Dokku CLI is a rubygem that acts as a client for your dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku-cli See documentation here for more information. (ruby) DokkuClient DokkuClient is another rubygem that acts as a client for your dokku installation with built-in support for certain external plugins. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku_client See documentation here for more information. (ruby) Dokkufy Dokkufy is a rubygem that handles automation of certain tasks, such as dokku setup, plugin installation, etc. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokkufy See documentation here for more information. (ruby) Dockland Dockland is a rubygem that acts as a client for your dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dockland See documentation here for more information.","title":"Clients"},{"location":"community/clients/#clients","text":"Given the constraints, running dokku commands remotely via SSH is fine. For certain configurations, the extra complication of manually invoking ssh can be a burden. While dokku does not yet have an official client, there are a multitude of ways in which you can interact with your dokku installation. The easiest is to use the bash client, though you may wish to use another.","title":"Clients"},{"location":"community/clients/#bash-zsh-etc-dokku_clientsh","text":"Of all methods, this is the most official method of interacting with your dokku installation. It is a bash script that interacts with a remote dokku installation via ssh. It is available in contrib/dokku_client.sh in the root of the dokku repository. To install, simply clone the dokku repository down and add the dokku alias pointing at the script: git clone git@github.com:progrium/dokku.git ~/.dokku # add the following to either your # .bashrc, .bash_profile, or .profile file alias dokku = '$HOME/.dokku/contrib/dokku_client.sh' Alternatively, if using another shell such as zsh , create an alias command which invokes the script using bash : # zsh: add the following to either .zshenv or .zshrc alias dokku = 'bash $HOME/.dokku/contrib/dokku_client.sh' # fish: add the following to ~/.config/fish/config.fish alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' # csh: add the following to .cshrc alias dokku 'bash $HOME/.dokku/contrib/dokku_client.sh' Configure the DOKKU_HOST environment variable or run dokku from a repository with a git remote named dokku pointed at your dokku host in order to use the script as normal.","title":"(bash, zsh, etc.) dokku_client.sh"},{"location":"community/clients/#nodejs-dokku-toolbelt","text":"Dokku-toolbelt is a node-based cli wrapper that proxies requests to the dokku command running on remote hosts. You can install it via the following shell command (assuming you have nodejs and npm installed): npm install -g dokku-toolbelt See documentation here for more information.","title":"(nodejs) dokku-toolbelt"},{"location":"community/clients/#python-dokku-client","text":"dokku-client is an extensible python-based cli wrapper for remote dokku hosts. You can install it via the following shell command (assuming you have python and pip installed): pip install dokku-client See documentation here for more information.","title":"(python) dokku-client"},{"location":"community/clients/#ruby-dokku-cli","text":"Dokku CLI is a rubygem that acts as a client for your dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku-cli See documentation here for more information.","title":"(ruby) Dokku CLI"},{"location":"community/clients/#ruby-dokkuclient","text":"DokkuClient is another rubygem that acts as a client for your dokku installation with built-in support for certain external plugins. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokku_client See documentation here for more information.","title":"(ruby) DokkuClient"},{"location":"community/clients/#ruby-dokkufy","text":"Dokkufy is a rubygem that handles automation of certain tasks, such as dokku setup, plugin installation, etc. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dokkufy See documentation here for more information.","title":"(ruby) Dokkufy"},{"location":"community/clients/#ruby-dockland","text":"Dockland is a rubygem that acts as a client for your dokku installation. You can install it via the following shell command (assuming you have ruby and rubygems installed): gem install dockland See documentation here for more information.","title":"(ruby) Dockland"},{"location":"development/plugin-creation/","text":"Plugin Creation If you create your own plugin: Take a look at the plugins shipped with dokku and hack away! Check out the list of hooks your plugin can implement. Upload your plugin to github with a repository name in form of dokku-<name> (e.g. dokku-mariadb ) Edit this page and add a link to it. Subscribe to the dokku development blog to be notified about API changes and releases Sample plugin The below plugin is a dummy dokku hello plugin. If your plugin exposes commands, this is a good template for your commands file: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $( dirname $0 ) /../common/functions\" case \" $1 \" in hello ) [[ -z $2 ]] && echo \"Please specify an app to run the command on\" && exit 1 verify_app_name \" $2 \" APP = \" $2 \" ; echo \"Hello $APP \" ;; hello:world ) echo \"Hello world\" ;; help ) cat && cat <<EOF hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" EOF ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac A few notes: You should always support DOKKU_TRACE as specified on the 2nd line of the plugin. If your command requires that an application exists, ensure you check for it's existence in the manner prescribed above. A help command is required, though it is allowed to be empty. Also, the command syntax will need to separated by , in order to maintain columnar output alignment. Commands should be namespaced. As of 0.3.3, a catch-all should be implemented which exits with a DOKKU_NOT_IMPLEMENTED_EXIT code. This allows dokku to output a command not found message. Be sure you want the \"set -eo pipefail\" option. Look at the following example : IMAGE = $( docker images | grep \"user/repo\" | awk '{print $3}' ) if [[ -z $IMAGE ]] ; then echo \"user/repo image not found... Did you run 'dokku plugins-install'?\" exit 1 fi In the case where the \"user/repo\" is not installed, dokku exits just before the awk command, you will never see the message printed with echo. You just want \"set -e\" in this case. Here is the documentation of the 'set -eo pipefail' option: help set Options: -e Exit immediately if a command exits with a non-zero status. -o option-name pipefail the return value of a pipeline is the status of the last command to exit with a non-zero status, or zero if no command exited with a non-zero status - As some plugins require access to set app config settings and do not want/require the default Heroku-style behavior of a restart, we have the following \"internal\" commands that provide this functionality : dokku config:set-norestart APP KEY1 = VALUE1 [ KEY2 = VALUE2 ... ] dokku config:unset-norestart APP KEY1 [ KEY2 ... ]","title":"Plugin Creation"},{"location":"development/plugin-creation/#plugin-creation","text":"If you create your own plugin: Take a look at the plugins shipped with dokku and hack away! Check out the list of hooks your plugin can implement. Upload your plugin to github with a repository name in form of dokku-<name> (e.g. dokku-mariadb ) Edit this page and add a link to it. Subscribe to the dokku development blog to be notified about API changes and releases","title":"Plugin Creation"},{"location":"development/plugin-creation/#sample-plugin","text":"The below plugin is a dummy dokku hello plugin. If your plugin exposes commands, this is a good template for your commands file: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $( dirname $0 ) /../common/functions\" case \" $1 \" in hello ) [[ -z $2 ]] && echo \"Please specify an app to run the command on\" && exit 1 verify_app_name \" $2 \" APP = \" $2 \" ; echo \"Hello $APP \" ;; hello:world ) echo \"Hello world\" ;; help ) cat && cat <<EOF hello <app>, Says \"Hello <app>\" hello:world, Says \"Hello world\" EOF ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac A few notes: You should always support DOKKU_TRACE as specified on the 2nd line of the plugin. If your command requires that an application exists, ensure you check for it's existence in the manner prescribed above. A help command is required, though it is allowed to be empty. Also, the command syntax will need to separated by , in order to maintain columnar output alignment. Commands should be namespaced. As of 0.3.3, a catch-all should be implemented which exits with a DOKKU_NOT_IMPLEMENTED_EXIT code. This allows dokku to output a command not found message. Be sure you want the \"set -eo pipefail\" option. Look at the following example : IMAGE = $( docker images | grep \"user/repo\" | awk '{print $3}' ) if [[ -z $IMAGE ]] ; then echo \"user/repo image not found... Did you run 'dokku plugins-install'?\" exit 1 fi In the case where the \"user/repo\" is not installed, dokku exits just before the awk command, you will never see the message printed with echo. You just want \"set -e\" in this case. Here is the documentation of the 'set -eo pipefail' option: help set Options: -e Exit immediately if a command exits with a non-zero status. -o option-name pipefail the return value of a pipeline is the status of the last command to exit with a non-zero status, or zero if no command exited with a non-zero status - As some plugins require access to set app config settings and do not want/require the default Heroku-style behavior of a restart, we have the following \"internal\" commands that provide this functionality : dokku config:set-norestart APP KEY1 = VALUE1 [ KEY2 = VALUE2 ... ] dokku config:unset-norestart APP KEY1 [ KEY2 ... ]","title":"Sample plugin"},{"location":"development/pluginhooks/","text":"Pluginhooks Pluginhooks are a good way to jack into existing dokku infrastructure. You can use them to modify the output of various dokku commands or override internal configuration. Pluginhooks are simply scripts that are executed by the system. You can use any language you want, so long as the script: Is executable Has the proper language requirements installed For instance, if you wanted to write a pluginhook in PHP, you would need to have php installed and available on the CLI prior to pluginhook invocation. The following is an example for the nginx-hostname pluginhook. It reverses the hostname that is provided to nginx during deploys. If you created an executable file named nginx-hostname with the following code in your plugin, it would be invoked by dokku during the normal app deployment process: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" Available Pluginhooks There are a number of plugin-related pluginhooks. These can be optionally implemented by plugins and allow integration into the standard dokku plugin setup/backup/teardown process. The following pluginhooks describe those available to a dokku installation. As well, there is an example for each pluginhook that you can use as templates for your own plugin development. Info The example pluginhook code is not guaranteed to be implemented as in within dokkku, and are merely simplified examples. Please look at the dokku source for larger, more in-depth examples. install Description: Used to setup any files/configuration for a plugin. Invoked by: dokku plugins-install . Arguments: None Example: #!/usr/bin/env bash # Sets the hostname of the dokku server # based on the output of `hostname -f` set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x if [[ ! -f \" $DOKKU_ROOT /HOSTNAME\" ]] ; then hostname -f > $DOKKU_ROOT /HOSTNAME fi dependencies Description: Used to install system-level dependencies. Invoked by plugins-install-dependencies . Invoked by: dokku plugins-install-dependencies Arguments: None Example: #!/usr/bin/env bash # Installs nginx for the current plugin # Supports both opensuse and ubuntu set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $DOKKU_DISTRO \" in ubuntu ) export DEBIAN_FRONTEND = noninteractive apt-get install --force-yes -qq -y nginx ;; opensuse ) zypper -q in -y nginx ;; esac update Description: Can be used to run plugin updates on a regular interval. You can schedule the invoker in a cron-task to ensure your system gets regular updates. Invoked by: dokku plugins-update . Arguments: None Example: #!/usr/bin/env bash # Update the herokuish image from git source set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x cd /root/dokku sudo BUILD_STACK = true make install commands help Description: Used to aggregate all plugin help output. Your plugin should implement a help command in your commands file to take advantage of this pluginhook. This must be implemented inside the commands pluginhook file. Invoked by: dokku help Arguments: None Example: #!/usr/bin/env bash # Outputs help for the derp plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | derp:help ) cat && cat <<EOF derp:herp, Herps the derp derp:serp [file], Shows the file's serp EOF ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac backup-export Description: Used to backup files for a given plugin. If your plugin writes files to disk, this pluginhook should be used to echo out their full paths. Any files listed will be copied by the backup plugin to the backup tar.gz. Invoked by: dokku backup:export Arguments: $VERSION $DOKKU_ROOT Example: #!/usr/bin/env bash # Echos out the location of every `REDIRECT` file # that are used by the apps set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x shopt -s nullglob VERSION = \" $1 \" DOKKU_ROOT = \" $2 \" cat ; for i in $DOKKU_ROOT /*/REDIRECT ; do echo $i ; done backup-check Description: Checks that a backup being imported passes sanity checks. Invoked by: dokku backup:import Arguments: $VERSION $BACKUP_ROOT $DOKKU_ROOT $BACKUP_TMP_DIR/.dokku_backup_apps Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO backup-import Description: Allows a plugin to import specific files from a $BACKUP_ROOT to the DOKKU_ROOT directory. Invoked by: dokku backup:import Arguments: $VERSION $BACKUP_ROOT $DOKKU_ROOT $BACKUP_TMP_DIR/.dokku_backup_apps Example: #!/usr/bin/env bash # Copies all redirect files from the backup # into the correct app path. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x shopt -s nullglob VERSION = \" $1 \" BACKUP_ROOT = \" $2 \" DOKKU_ROOT = \" $3 \" cd $BACKUP_ROOT for file in */REDIRECT ; do cp $file \" $DOKKU_ROOT / $file \" done pre-build-buildpack Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to applications using buildpacks. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-build-buildpack Description: Allows you to run commands after the build image is create for a given app. Only applies to applications using buildpacks. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO pre-build-dockerfile Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to applications using a dockerfile. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-build-dockerfile Description: Allows you to run commands after the build image is create for a given app. Only applies to applications using a dockerfile. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO pre-release-buildpack Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to applications using buildpacks. Invoked by: dokku release Arguments: $APP Example: #!/usr/bin/env bash # Installs the graphicsmagick package into the container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $( dirname $0 ) /../common/functions\" dokku_log_info1 \" Installing GraphicsMagick...\" CMD = \"cat > gm && \\ dpkg -s graphicsmagick > /dev/null 2>&1 || \\ (apt-get update && apt-get install -y graphicsmagick && apt-get clean)\" ID = $( docker run -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $ID ) -eq 0 docker commit $ID $IMAGE > /dev/null post-release-buildpack Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to applications using buildpacks. Invoked by: dokku release Arguments: $APP Example: #!/usr/bin/env bash # Installs a package specified by the `CONTAINER_PACKAGE` env var set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $( dirname $0 ) /../common/functions\" dokku_log_info1 \" Installing $CONTAINER_PACKAGE ...\" CMD = \"cat > gm && \\ dpkg -s CONTAINER_PACKAGE > /dev/null 2>&1 || \\ (apt-get update && apt-get install -y CONTAINER_PACKAGE && apt-get clean)\" ID = $( docker run -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $ID ) -eq 0 docker commit $ID $IMAGE > /dev/null pre-release-dockerfile Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to applications using a dockerfile. Invoked by: dokku release Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO post-release-dockerfile Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to applications using a dockerfile. Invoked by: dokku release Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO check-deploy Description: Allows you to run checks on a deploy before dokku allows the container to handle requests. Invoked by: dokku deploy Arguments: $CONTAINER_ID $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Disables deploys of containers based on whether the # `DOKKU_DISABLE_DEPLOY` env var is set to `true` for an app set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x CONTAINERID = \" $1 \" ; APP = \" $2 \" ; PORT = \" $3 \" ; HOSTNAME = \" ${ 4 :- localhost } \" [[ -f \" $DOKKU_ROOT / $APP /ENV\" ]] && source $DOKKU_ROOT / $APP /ENV DOKKU_DISABLE_DEPLOY = \" ${ DOKKU_DISABLE_DEPLOY :- false } \" if [[ \" $DOKKU_DISABLE_DEPLOY \" = \"true\" ]] ; then echo -e \"\\033[31m\\033[1mDeploys disabled, sorry.\\033[0m\" exit 1 fi pre-deploy Description: Allows the running of code before the container's process is started. Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash # Runs gulp in our container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $( dirname $0 ) /../common/functions\" APP = \" $1 \" IMAGE = \"dokku/ $APP \" dokku_log_info1 \"Running gulp\" id = $( docker run -d $IMAGE /bin/bash -c \"cd /app && gulp default\" ) test $( docker wait $id ) -eq 0 docker commit $id $IMAGE > /dev/null dokku_log_info1 \"Building UI Complete\" post-deploy Description: Allows running of commands after a deploy has completed. Dokku core currently uses this to switch traffic on nginx. Invoked by: dokku deploy Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Notify an external service that a successful deploy has occurred. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x curl \"http://httpstat.us/200\" pre-delete Description: Can be used to run commands before an app is deleted. Invoked by: dokku apps:destroy Arguments: $APP Example: #!/usr/bin/env bash # Clears out the gulp asset build cache for applications set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE = \"dokku/ $APP \" ; GULP_CACHE_DIR = \" $DOKKU_ROOT / $APP /gulp\" if [[ -d $GULP_CACHE_DIR ]] ; then docker run --rm -v \" $GULP_CACHE_DIR :/gulp\" \" $IMAGE \" find /gulp -depth -mindepth 1 -maxdepth 1 -exec rm -Rf {} \\; || true fi post-delete Description: Can be used to run commands after an application is deleted. Invoked by: dokku apps:destroy Arguments: $APP Example: #!/usr/bin/env bash # Runs a command to ensure that an app's # postgres installation is removed set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku postgres:destroy $APP docker-args-build Description: Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO docker-args-deploy Description: Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO docker-args-run Description: Invoked by: dokku run Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO bind-external-ip Description: Allows you to disable binding to the external box ip Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash # Force always binding to the docker ip, no matter # what the settings are for a given app. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x echo false post-domains-update Description: Allows you to run commands once the domain for an application has been updated. Invoked by: dokku domains:add , dokku domains:clear , dokku domains:remove Arguments: $APP Example: #!/usr/bin/env bash # Reloads haproxy for our imaginary haproxy plugin # that replaces the nginx-vhosts plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x sudo service haproxy reload git-pre-pull Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO git-post-pull Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO nginx-hostname Description: Allows you to customize the hostname for a given application. Invoked by: dokku domains:setup Arguments: $APP $SUBDOMAIN $VHOST Example: #!/usr/bin/env bash # Reverses the hostname for the application set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \" nginx-pre-reload Description: Run before nginx reloads hosts Invoked by: dokku nginx:build-config Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Runs a check against all nginx conf files # to ensure they are valid set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x nginx -t receive-app Description: Allows you to customize what occurs when an app is received. Normally just triggers an application build. Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV Example: #!/usr/bin/env bash # For our imaginary mercurial plugin, triggers a rebuild set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; REV = \" $2 \" dokku hg-build $APP $REV receive-branch Description: Allows you to customize what occurs when a specific branch is received. Can be used to add support for specific branch names Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV $REFNAME Example: #!/bin/bash # Gives dokku the ability to support multiple branches for a given service # Allowing you to have multiple staging environments on a per-branch basis reference_app = $1 refname = $3 newrev = $2 APP = ${ refname /* \\/ / } . $reference_app if [[ ! -d \" $DOKKU_ROOT / $APP \" ]] ; then REFERENCE_REPO = \" $DOKKU_ROOT / $reference_app git clone --bare --shared --reference \" $REFERENCE_REPO \" \" $REFERENCE_REPO \" \" $DOKKU_ROOT / $APP \" > /dev/null fi pluginhook receive-app $APP $newrev","title":"Pluginhooks"},{"location":"development/pluginhooks/#pluginhooks","text":"Pluginhooks are a good way to jack into existing dokku infrastructure. You can use them to modify the output of various dokku commands or override internal configuration. Pluginhooks are simply scripts that are executed by the system. You can use any language you want, so long as the script: Is executable Has the proper language requirements installed For instance, if you wanted to write a pluginhook in PHP, you would need to have php installed and available on the CLI prior to pluginhook invocation. The following is an example for the nginx-hostname pluginhook. It reverses the hostname that is provided to nginx during deploys. If you created an executable file named nginx-hostname with the following code in your plugin, it would be invoked by dokku during the normal app deployment process: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \"","title":"Pluginhooks"},{"location":"development/pluginhooks/#available-pluginhooks","text":"There are a number of plugin-related pluginhooks. These can be optionally implemented by plugins and allow integration into the standard dokku plugin setup/backup/teardown process. The following pluginhooks describe those available to a dokku installation. As well, there is an example for each pluginhook that you can use as templates for your own plugin development. Info The example pluginhook code is not guaranteed to be implemented as in within dokkku, and are merely simplified examples. Please look at the dokku source for larger, more in-depth examples.","title":"Available Pluginhooks"},{"location":"development/pluginhooks/#install","text":"Description: Used to setup any files/configuration for a plugin. Invoked by: dokku plugins-install . Arguments: None Example: #!/usr/bin/env bash # Sets the hostname of the dokku server # based on the output of `hostname -f` set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x if [[ ! -f \" $DOKKU_ROOT /HOSTNAME\" ]] ; then hostname -f > $DOKKU_ROOT /HOSTNAME fi","title":"install"},{"location":"development/pluginhooks/#dependencies","text":"Description: Used to install system-level dependencies. Invoked by plugins-install-dependencies . Invoked by: dokku plugins-install-dependencies Arguments: None Example: #!/usr/bin/env bash # Installs nginx for the current plugin # Supports both opensuse and ubuntu set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $DOKKU_DISTRO \" in ubuntu ) export DEBIAN_FRONTEND = noninteractive apt-get install --force-yes -qq -y nginx ;; opensuse ) zypper -q in -y nginx ;; esac","title":"dependencies"},{"location":"development/pluginhooks/#update","text":"Description: Can be used to run plugin updates on a regular interval. You can schedule the invoker in a cron-task to ensure your system gets regular updates. Invoked by: dokku plugins-update . Arguments: None Example: #!/usr/bin/env bash # Update the herokuish image from git source set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x cd /root/dokku sudo BUILD_STACK = true make install","title":"update"},{"location":"development/pluginhooks/#commands-help","text":"Description: Used to aggregate all plugin help output. Your plugin should implement a help command in your commands file to take advantage of this pluginhook. This must be implemented inside the commands pluginhook file. Invoked by: dokku help Arguments: None Example: #!/usr/bin/env bash # Outputs help for the derp plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x case \" $1 \" in help | derp:help ) cat && cat <<EOF derp:herp, Herps the derp derp:serp [file], Shows the file's serp EOF ;; * ) exit $DOKKU_NOT_IMPLEMENTED_EXIT ;; esac","title":"commands help"},{"location":"development/pluginhooks/#backup-export","text":"Description: Used to backup files for a given plugin. If your plugin writes files to disk, this pluginhook should be used to echo out their full paths. Any files listed will be copied by the backup plugin to the backup tar.gz. Invoked by: dokku backup:export Arguments: $VERSION $DOKKU_ROOT Example: #!/usr/bin/env bash # Echos out the location of every `REDIRECT` file # that are used by the apps set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x shopt -s nullglob VERSION = \" $1 \" DOKKU_ROOT = \" $2 \" cat ; for i in $DOKKU_ROOT /*/REDIRECT ; do echo $i ; done","title":"backup-export"},{"location":"development/pluginhooks/#backup-check","text":"Description: Checks that a backup being imported passes sanity checks. Invoked by: dokku backup:import Arguments: $VERSION $BACKUP_ROOT $DOKKU_ROOT $BACKUP_TMP_DIR/.dokku_backup_apps Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"backup-check"},{"location":"development/pluginhooks/#backup-import","text":"Description: Allows a plugin to import specific files from a $BACKUP_ROOT to the DOKKU_ROOT directory. Invoked by: dokku backup:import Arguments: $VERSION $BACKUP_ROOT $DOKKU_ROOT $BACKUP_TMP_DIR/.dokku_backup_apps Example: #!/usr/bin/env bash # Copies all redirect files from the backup # into the correct app path. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x shopt -s nullglob VERSION = \" $1 \" BACKUP_ROOT = \" $2 \" DOKKU_ROOT = \" $3 \" cd $BACKUP_ROOT for file in */REDIRECT ; do cp $file \" $DOKKU_ROOT / $file \" done","title":"backup-import"},{"location":"development/pluginhooks/#pre-build-buildpack","text":"Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to applications using buildpacks. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"pre-build-buildpack"},{"location":"development/pluginhooks/#post-build-buildpack","text":"Description: Allows you to run commands after the build image is create for a given app. Only applies to applications using buildpacks. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-build-buildpack"},{"location":"development/pluginhooks/#pre-build-dockerfile","text":"Description: Allows you to run commands before the build image is created for a given app. For instance, this can be useful to add env vars to your container. Only applies to applications using a dockerfile. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"pre-build-dockerfile"},{"location":"development/pluginhooks/#post-build-dockerfile","text":"Description: Allows you to run commands after the build image is create for a given app. Only applies to applications using a dockerfile. Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-build-dockerfile"},{"location":"development/pluginhooks/#pre-release-buildpack","text":"Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to applications using buildpacks. Invoked by: dokku release Arguments: $APP Example: #!/usr/bin/env bash # Installs the graphicsmagick package into the container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $( dirname $0 ) /../common/functions\" dokku_log_info1 \" Installing GraphicsMagick...\" CMD = \"cat > gm && \\ dpkg -s graphicsmagick > /dev/null 2>&1 || \\ (apt-get update && apt-get install -y graphicsmagick && apt-get clean)\" ID = $( docker run -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $ID ) -eq 0 docker commit $ID $IMAGE > /dev/null","title":"pre-release-buildpack"},{"location":"development/pluginhooks/#post-release-buildpack","text":"Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to applications using buildpacks. Invoked by: dokku release Arguments: $APP Example: #!/usr/bin/env bash # Installs a package specified by the `CONTAINER_PACKAGE` env var set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $( dirname $0 ) /../common/functions\" dokku_log_info1 \" Installing $CONTAINER_PACKAGE ...\" CMD = \"cat > gm && \\ dpkg -s CONTAINER_PACKAGE > /dev/null 2>&1 || \\ (apt-get update && apt-get install -y CONTAINER_PACKAGE && apt-get clean)\" ID = $( docker run -i -a stdin $IMAGE /bin/bash -c \" $CMD \" ) test $( docker wait $ID ) -eq 0 docker commit $ID $IMAGE > /dev/null","title":"post-release-buildpack"},{"location":"development/pluginhooks/#pre-release-dockerfile","text":"Description: Allows you to run commands before environment variables are set for the release step of the deploy. Only applies to applications using a dockerfile. Invoked by: dokku release Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"pre-release-dockerfile"},{"location":"development/pluginhooks/#post-release-dockerfile","text":"Description: Allows you to run commands after environment variables are set for the release step of the deploy. Only applies to applications using a dockerfile. Invoked by: dokku release Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"post-release-dockerfile"},{"location":"development/pluginhooks/#check-deploy","text":"Description: Allows you to run checks on a deploy before dokku allows the container to handle requests. Invoked by: dokku deploy Arguments: $CONTAINER_ID $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Disables deploys of containers based on whether the # `DOKKU_DISABLE_DEPLOY` env var is set to `true` for an app set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x CONTAINERID = \" $1 \" ; APP = \" $2 \" ; PORT = \" $3 \" ; HOSTNAME = \" ${ 4 :- localhost } \" [[ -f \" $DOKKU_ROOT / $APP /ENV\" ]] && source $DOKKU_ROOT / $APP /ENV DOKKU_DISABLE_DEPLOY = \" ${ DOKKU_DISABLE_DEPLOY :- false } \" if [[ \" $DOKKU_DISABLE_DEPLOY \" = \"true\" ]] ; then echo -e \"\\033[31m\\033[1mDeploys disabled, sorry.\\033[0m\" exit 1 fi","title":"check-deploy"},{"location":"development/pluginhooks/#pre-deploy","text":"Description: Allows the running of code before the container's process is started. Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash # Runs gulp in our container set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x source \" $( dirname $0 ) /../common/functions\" APP = \" $1 \" IMAGE = \"dokku/ $APP \" dokku_log_info1 \"Running gulp\" id = $( docker run -d $IMAGE /bin/bash -c \"cd /app && gulp default\" ) test $( docker wait $id ) -eq 0 docker commit $id $IMAGE > /dev/null dokku_log_info1 \"Building UI Complete\"","title":"pre-deploy"},{"location":"development/pluginhooks/#post-deploy","text":"Description: Allows running of commands after a deploy has completed. Dokku core currently uses this to switch traffic on nginx. Invoked by: dokku deploy Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Notify an external service that a successful deploy has occurred. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x curl \"http://httpstat.us/200\"","title":"post-deploy"},{"location":"development/pluginhooks/#pre-delete","text":"Description: Can be used to run commands before an app is deleted. Invoked by: dokku apps:destroy Arguments: $APP Example: #!/usr/bin/env bash # Clears out the gulp asset build cache for applications set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; IMAGE = \"dokku/ $APP \" ; GULP_CACHE_DIR = \" $DOKKU_ROOT / $APP /gulp\" if [[ -d $GULP_CACHE_DIR ]] ; then docker run --rm -v \" $GULP_CACHE_DIR :/gulp\" \" $IMAGE \" find /gulp -depth -mindepth 1 -maxdepth 1 -exec rm -Rf {} \\; || true fi","title":"pre-delete"},{"location":"development/pluginhooks/#post-delete","text":"Description: Can be used to run commands after an application is deleted. Invoked by: dokku apps:destroy Arguments: $APP Example: #!/usr/bin/env bash # Runs a command to ensure that an app's # postgres installation is removed set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; dokku postgres:destroy $APP","title":"post-delete"},{"location":"development/pluginhooks/#docker-args-build","text":"Description: Invoked by: dokku build Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"docker-args-build"},{"location":"development/pluginhooks/#docker-args-deploy","text":"Description: Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"docker-args-deploy"},{"location":"development/pluginhooks/#docker-args-run","text":"Description: Invoked by: dokku run Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"docker-args-run"},{"location":"development/pluginhooks/#bind-external-ip","text":"Description: Allows you to disable binding to the external box ip Invoked by: dokku deploy Arguments: $APP Example: #!/usr/bin/env bash # Force always binding to the docker ip, no matter # what the settings are for a given app. set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x echo false","title":"bind-external-ip"},{"location":"development/pluginhooks/#post-domains-update","text":"Description: Allows you to run commands once the domain for an application has been updated. Invoked by: dokku domains:add , dokku domains:clear , dokku domains:remove Arguments: $APP Example: #!/usr/bin/env bash # Reloads haproxy for our imaginary haproxy plugin # that replaces the nginx-vhosts plugin set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x sudo service haproxy reload","title":"post-domains-update"},{"location":"development/pluginhooks/#git-pre-pull","text":"Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"git-pre-pull"},{"location":"development/pluginhooks/#git-post-pull","text":"Description: Invoked by: dokku git-upload-pack Arguments: $APP Example: #!/usr/bin/env bash set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x # TODO","title":"git-post-pull"},{"location":"development/pluginhooks/#nginx-hostname","text":"Description: Allows you to customize the hostname for a given application. Invoked by: dokku domains:setup Arguments: $APP $SUBDOMAIN $VHOST Example: #!/usr/bin/env bash # Reverses the hostname for the application set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; SUBDOMAIN = \" $2 \" ; VHOST = \" $3 \" NEW_SUBDOMAIN = ` echo $SUBDOMAIN | rev ` echo \" $NEW_SUBDOMAIN . $VHOST \"","title":"nginx-hostname"},{"location":"development/pluginhooks/#nginx-pre-reload","text":"Description: Run before nginx reloads hosts Invoked by: dokku nginx:build-config Arguments: $APP $INTERNAL_PORT $INTERNAL_IP_ADDRESS Example: #!/usr/bin/env bash # Runs a check against all nginx conf files # to ensure they are valid set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x nginx -t","title":"nginx-pre-reload"},{"location":"development/pluginhooks/#receive-app","text":"Description: Allows you to customize what occurs when an app is received. Normally just triggers an application build. Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV Example: #!/usr/bin/env bash # For our imaginary mercurial plugin, triggers a rebuild set -eo pipefail ; [[ $DOKKU_TRACE ]] && set -x APP = \" $1 \" ; REV = \" $2 \" dokku hg-build $APP $REV","title":"receive-app"},{"location":"development/pluginhooks/#receive-branch","text":"Description: Allows you to customize what occurs when a specific branch is received. Can be used to add support for specific branch names Invoked by: dokku git-hook , dokku ps:rebuild Arguments: $APP $REV $REFNAME Example: #!/bin/bash # Gives dokku the ability to support multiple branches for a given service # Allowing you to have multiple staging environments on a per-branch basis reference_app = $1 refname = $3 newrev = $2 APP = ${ refname /* \\/ / } . $reference_app if [[ ! -d \" $DOKKU_ROOT / $APP \" ]] ; then REFERENCE_REPO = \" $DOKKU_ROOT / $reference_app git clone --bare --shared --reference \" $REFERENCE_REPO \" \" $REFERENCE_REPO \" \" $DOKKU_ROOT / $APP \" > /dev/null fi pluginhook receive-app $APP $newrev","title":"receive-branch"},{"location":"development/release-process/","text":"Release Process Dokku is released in intervals at most three weeks apart, though may be released much quicker. To propose a release, the following tasks need to be performed: The installable version must be changed in the docs/installation.md file. The installable version must be changed in the README.md file. The installable version must be changed in the contrib/dokku-installer.rb file. A list of changes must be made in the HISTORY.md . A tag must be created locally with your release version Debian packages must be created via vagrant up build The packages should be uploaded to packagecloud.io All changes are pushed to master and the tag should be turned into a release which will contain the changelog. Versioning Dokku follows semver standards. As we are not yet at a stable release, breaking changes will require only a minor release, while all other changes only require a patch release. Once we hit stable, breaking changes will require a major release. Tags should be created via the following method: git tag v0.9.9 At the moment, tags need not be signed, though that may change in the future. Debian Packages The build target in the dokku Vagrantfile creates debian packages for dokku at a point in time. The version will be based upon the latest local tag - you may create your own, internal tags/releases if that is so desired. Debian package information is held in the debian directory of the dokku project. For the public project, releases should be pushed to packagecloud.io after a tag is created but before said tag is pushed to github. The following may be the release workflow: git tag v0.9.9 vagrant up build export PACKAGECLOUD_TOKEN = SOME_TOKEN package_cloud push dokku/dokku/ubuntu/trusty dokku_0.9.9_amd64.deb If new versions of other packages were created, these should also be pushed at this time. Info If you are a maintainer and need the PACKAGECLOUD_TOKEN in order to make a release, please contact @josegonzalez to get this information. Changelog format The HISTORY.md should be added to based on the changes made since the previous release. This can be done by reviewing all merged pull requests to the master branch on github. The format is as follows: ## 0.9.9 Some description concerning major changes in this release, or potential incompatibilities. ### New Features - #SOME_ID: @pull-request-creator Description ### Bug Fixes - #SOME_ID: @pull-request-creator Description ### Docs Changes - #SOME_ID: @pull-request-creator Description","title":"Release Process"},{"location":"development/release-process/#release-process","text":"Dokku is released in intervals at most three weeks apart, though may be released much quicker. To propose a release, the following tasks need to be performed: The installable version must be changed in the docs/installation.md file. The installable version must be changed in the README.md file. The installable version must be changed in the contrib/dokku-installer.rb file. A list of changes must be made in the HISTORY.md . A tag must be created locally with your release version Debian packages must be created via vagrant up build The packages should be uploaded to packagecloud.io All changes are pushed to master and the tag should be turned into a release which will contain the changelog.","title":"Release Process"},{"location":"development/release-process/#versioning","text":"Dokku follows semver standards. As we are not yet at a stable release, breaking changes will require only a minor release, while all other changes only require a patch release. Once we hit stable, breaking changes will require a major release. Tags should be created via the following method: git tag v0.9.9 At the moment, tags need not be signed, though that may change in the future.","title":"Versioning"},{"location":"development/release-process/#debian-packages","text":"The build target in the dokku Vagrantfile creates debian packages for dokku at a point in time. The version will be based upon the latest local tag - you may create your own, internal tags/releases if that is so desired. Debian package information is held in the debian directory of the dokku project. For the public project, releases should be pushed to packagecloud.io after a tag is created but before said tag is pushed to github. The following may be the release workflow: git tag v0.9.9 vagrant up build export PACKAGECLOUD_TOKEN = SOME_TOKEN package_cloud push dokku/dokku/ubuntu/trusty dokku_0.9.9_amd64.deb If new versions of other packages were created, these should also be pushed at this time. Info If you are a maintainer and need the PACKAGECLOUD_TOKEN in order to make a release, please contact @josegonzalez to get this information.","title":"Debian Packages"},{"location":"development/release-process/#changelog-format","text":"The HISTORY.md should be added to based on the changes made since the previous release. This can be done by reviewing all merged pull requests to the master branch on github. The format is as follows: ## 0.9.9 Some description concerning major changes in this release, or potential incompatibilities. ### New Features - #SOME_ID: @pull-request-creator Description ### Bug Fixes - #SOME_ID: @pull-request-creator Description ### Docs Changes - #SOME_ID: @pull-request-creator Description","title":"Changelog format"},{"location":"development/testing/","text":"Dokku test suite Dokku now has a full test suite to assist in quick iterating development. These tests include a linter using shellcheck , functional unit tests using the bats testing framework , and a deployment suite of example apps that use the most popular languages and frameworks. Bats tests can be found here: tests/unit/*.bats Example apps can be found here: tests/apps/ Executing tests locally Setup dokku in a vagrant vm Test setup and execution $ vagrant ssh $ sudo su - $ cd ~/dokku $ make ci-dependencies setup-deploy-tests $ make test # run the entire test suite (linter, bats tests, and app deployment tests) $ $ make lint # linter $ make unit-tests # bats tests $ make deploy-tests # app deployment tests - Additionally you may run a specific app deployment tests with a target similar to: make deploy-test-nodejs-express - For a full list of test make targets check out tests.mk in the root of the dokku repository.","title":"Dokku test suite"},{"location":"development/testing/#dokku-test-suite","text":"Dokku now has a full test suite to assist in quick iterating development. These tests include a linter using shellcheck , functional unit tests using the bats testing framework , and a deployment suite of example apps that use the most popular languages and frameworks. Bats tests can be found here: tests/unit/*.bats Example apps can be found here: tests/apps/","title":"Dokku test suite"},{"location":"development/testing/#executing-tests-locally","text":"Setup dokku in a vagrant vm Test setup and execution $ vagrant ssh $ sudo su - $ cd ~/dokku $ make ci-dependencies setup-deploy-tests $ make test # run the entire test suite (linter, bats tests, and app deployment tests) $ $ make lint # linter $ make unit-tests # bats tests $ make deploy-tests # app deployment tests - Additionally you may run a specific app deployment tests with a target similar to: make deploy-test-nodejs-express - For a full list of test make targets check out tests.mk in the root of the dokku repository.","title":"Executing tests locally"},{"location":"getting-started/where-to-get-help/","text":"Where to Get Help If you\u2019re stuck, there are a number of places you can get help: The Official Dokku Website http://progrium.viewdocs.io/dokku The Official Dokku website is always a great place to visit. It features links to oft-used developer tools, community plugins, and guides on using dokku. The IRC Channel IRC Channel on irc.freenode.net: dokku \u2013 General Discussion If you\u2019re stumped, give us a holler in the Dokku IRC channel. Someone from the development team is usually there, especially during the daylight hours for North and South America users. We\u2019d love to hear from you, whether you need some help, want to find users in your area, or would like to donate your brand new sports car. If here for a web-based client IRC client. Stackoverflow http://stackoverflow.com/ Tag your questions with dokku to enable existing users of stackoverflow to find your questions.","title":"Where to Get Help"},{"location":"getting-started/where-to-get-help/#where-to-get-help","text":"If you\u2019re stuck, there are a number of places you can get help:","title":"Where to Get Help"},{"location":"getting-started/where-to-get-help/#the-official-dokku-website","text":"http://progrium.viewdocs.io/dokku The Official Dokku website is always a great place to visit. It features links to oft-used developer tools, community plugins, and guides on using dokku.","title":"The Official Dokku Website"},{"location":"getting-started/where-to-get-help/#the-irc-channel","text":"IRC Channel on irc.freenode.net:","title":"The IRC Channel"},{"location":"getting-started/where-to-get-help/#dokku-general-discussion","text":"If you\u2019re stumped, give us a holler in the Dokku IRC channel. Someone from the development team is usually there, especially during the daylight hours for North and South America users. We\u2019d love to hear from you, whether you need some help, want to find users in your area, or would like to donate your brand new sports car. If here for a web-based client IRC client.","title":"dokku \u2013 General Discussion"},{"location":"getting-started/where-to-get-help/#stackoverflow","text":"http://stackoverflow.com/ Tag your questions with dokku to enable existing users of stackoverflow to find your questions.","title":"Stackoverflow"},{"location":"getting-started/install/debian/","text":"Debian Package Installation Notes As of 0.3.18, dokku defaults to being installed via debian package. While certain hosts may require extra work to get running, you may optionally wish to automate the installation of dokku without the use of our bootstrap.sh bash script. The following are the steps run by said script: curl -sL https://get.docker.io/gpg 2 > /dev/null | sudo apt-key add - 2 > & 1 >/dev/null curl -sL https://packagecloud.io/gpg.key 2 > /dev/null | sudo apt-key add - 2 > & 1 >/dev/null echo \"deb https://get.docker.io/ubuntu docker main\" | sudo tee /etc/apt/sources.list.d/docker.list >/dev/null echo \"deb https://packagecloud.io/dokku/dokku/ubuntu/ trusty main\" | sudo tee /etc/apt/sources.list.d/dokku.list >/dev/null sudo apt-get update -qq sudo apt-get install -qq -y linux-image-extra- ` uname -r ` apt-transport-https sudo apt-get install -qq -y dokku Unattended installation In case you want to perform an unattended installation of dokku, this is made possible through debconf , which allows you to configure a package before installing it. You can set any of the below options through the debconf-set-selections command, for example to enable vhost-based deployments: sudo echo \"dokku dokku/vhost_enable boolean true\" | debconf-set-selections After setting the desired options, proceed with the installation as described above. debconf options Name Type Default Description dokku/web_config boolean true Use web-based config for below options dokku/vhost_enable boolean false Use vhost-based deployments (e.g. .dokku.me) dokku/hostname string dokku.me Hostname, used as vhost domain and for showing app URL after deploy dokku/key_file string /root/.ssh/id_rsa.pub SSH key to add to the Dokku user (Will be ignored on dpkg-reconfigure )","title":"Debian Package Installation Notes"},{"location":"getting-started/install/debian/#debian-package-installation-notes","text":"As of 0.3.18, dokku defaults to being installed via debian package. While certain hosts may require extra work to get running, you may optionally wish to automate the installation of dokku without the use of our bootstrap.sh bash script. The following are the steps run by said script: curl -sL https://get.docker.io/gpg 2 > /dev/null | sudo apt-key add - 2 > & 1 >/dev/null curl -sL https://packagecloud.io/gpg.key 2 > /dev/null | sudo apt-key add - 2 > & 1 >/dev/null echo \"deb https://get.docker.io/ubuntu docker main\" | sudo tee /etc/apt/sources.list.d/docker.list >/dev/null echo \"deb https://packagecloud.io/dokku/dokku/ubuntu/ trusty main\" | sudo tee /etc/apt/sources.list.d/dokku.list >/dev/null sudo apt-get update -qq sudo apt-get install -qq -y linux-image-extra- ` uname -r ` apt-transport-https sudo apt-get install -qq -y dokku","title":"Debian Package Installation Notes"},{"location":"getting-started/install/debian/#unattended-installation","text":"In case you want to perform an unattended installation of dokku, this is made possible through debconf , which allows you to configure a package before installing it. You can set any of the below options through the debconf-set-selections command, for example to enable vhost-based deployments: sudo echo \"dokku dokku/vhost_enable boolean true\" | debconf-set-selections After setting the desired options, proceed with the installation as described above.","title":"Unattended installation"},{"location":"getting-started/install/debian/#debconf-options","text":"Name Type Default Description dokku/web_config boolean true Use web-based config for below options dokku/vhost_enable boolean false Use vhost-based deployments (e.g. .dokku.me) dokku/hostname string dokku.me Hostname, used as vhost domain and for showing app URL after deploy dokku/key_file string /root/.ssh/id_rsa.pub SSH key to add to the Dokku user (Will be ignored on dpkg-reconfigure )","title":"debconf options"},{"location":"getting-started/install/digitalocean/","text":"Digital Ocean On Digital Ocean, there is a pre-made image that can be run for Dokku. You can choose to run this image on any sized droplet, though larger droplets will allow you to run larger applications. When choosing your Droplet configuration, please disable IPv6 on the droplet. There are known issues with IPv6 on Digital Ocean and Docker, and many have been reported to the Dokku issue tracker. If you would like to run Dokku on an IPv6 Digital Ocean Droplet, please consult this guide for modifying Docker to run under the Digital Ocean IPv6 configuration.","title":"Digital Ocean"},{"location":"getting-started/install/digitalocean/#digital-ocean","text":"On Digital Ocean, there is a pre-made image that can be run for Dokku. You can choose to run this image on any sized droplet, though larger droplets will allow you to run larger applications. When choosing your Droplet configuration, please disable IPv6 on the droplet. There are known issues with IPv6 on Digital Ocean and Docker, and many have been reported to the Dokku issue tracker. If you would like to run Dokku on an IPv6 Digital Ocean Droplet, please consult this guide for modifying Docker to run under the Digital Ocean IPv6 configuration.","title":"Digital Ocean"},{"location":"getting-started/install/linode/","text":"Installing on Linode Due to how Linode installs custom kernels, Linode instances require a reboot before they can fully work with Docker/Dokku. The Official Dokku StackScript should take care of this process for you, and will email notify you when the instance is running and you can proceed with installation. Using StackScript Deploy using the following (experimental) Official StackScript: https://www.linode.com/stackscripts/view/11348 Without StackScript Build a Ubuntu 13.04 instance Follow these instructions: https://www.linode.com/docs/tools-reference/custom-kernels-distros/run-a-distributionsupplied-kernel-with-pvgrub#ubuntu-1304-raring If apt-get update no longer works: Verify if apt-get is trying to use ipv6 instead of ipv4 (e.g. you read something like \"[Connecting to us.archive.ubuntu.com (2001:67c:1562::14)]\" and apt-get would not proceed). In that case, follow these instructions: http://unix.stackexchange.com/questions/9940/convince-apt-get-not-to-use-ipv6-method (append \"precedence ::ffff:0:0/96 100\" to /etc/gai.conf) OR: change /etc/apt/sources.list to one mentioned in http://mirrors.ubuntu.com/mirrors.txt Run the following commands: apt-get update apt-get install lxc wget bsdtar linux-image-extra- $( uname -r ) modprobe aufs * After this, you can install dokku the default way: wget -qO- https://raw.github.com/progrium/dokku/master/bootstrap.sh | sudo bash","title":"Installing on Linode"},{"location":"getting-started/install/linode/#installing-on-linode","text":"Due to how Linode installs custom kernels, Linode instances require a reboot before they can fully work with Docker/Dokku. The Official Dokku StackScript should take care of this process for you, and will email notify you when the instance is running and you can proceed with installation.","title":"Installing on Linode"},{"location":"getting-started/install/linode/#using-stackscript","text":"Deploy using the following (experimental) Official StackScript: https://www.linode.com/stackscripts/view/11348","title":"Using StackScript"},{"location":"getting-started/install/linode/#without-stackscript","text":"Build a Ubuntu 13.04 instance Follow these instructions: https://www.linode.com/docs/tools-reference/custom-kernels-distros/run-a-distributionsupplied-kernel-with-pvgrub#ubuntu-1304-raring If apt-get update no longer works: Verify if apt-get is trying to use ipv6 instead of ipv4 (e.g. you read something like \"[Connecting to us.archive.ubuntu.com (2001:67c:1562::14)]\" and apt-get would not proceed). In that case, follow these instructions: http://unix.stackexchange.com/questions/9940/convince-apt-get-not-to-use-ipv6-method (append \"precedence ::ffff:0:0/96 100\" to /etc/gai.conf) OR: change /etc/apt/sources.list to one mentioned in http://mirrors.ubuntu.com/mirrors.txt Run the following commands: apt-get update apt-get install lxc wget bsdtar linux-image-extra- $( uname -r ) modprobe aufs * After this, you can install dokku the default way: wget -qO- https://raw.github.com/progrium/dokku/master/bootstrap.sh | sudo bash","title":"Without StackScript"},{"location":"getting-started/install/vagrant/","text":"Install Dokku using Vagrant Download and install VirtualBox Download and install Vagrant Clone Dokku git clone https://github.com/progrium/dokku.git Setup SSH hosts in your /etc/hosts 10.0.0.2 dokku.me Create VM # Optional ENV arguments: # - `BOX_NAME` # - `BOX_URI` # - `BOX_MEMORY` # - `DOKKU_DOMAIN` # - `DOKKU_IP` # - `FORWARDED_PORT`. cd path/to/dokku vagrant up Setup SSH Config in ~/.ssh/config . The port listed here is usually correct, though you may want to verify that it is the same as the one listed in the output of vagrant ssh-config dokku Host dokku.me Port 22 Copy your SSH key via cat ~/.ssh/id_rsa.pub | pbcopy and paste it into the dokku-installer at http://dokku.me . Change the Hostname field on the Dokku Setup screen to your domain and then check the box that says Use virtualhost naming . Then click Finish Setup to install your key. You'll be directed to application deployment instructions from here. You are now ready to deploy an app or install plugins. For a different, complete, example see https://github.com/RyanBalfanz/dokku-vagrant-example.","title":"Install Dokku using Vagrant"},{"location":"getting-started/install/vagrant/#install-dokku-using-vagrant","text":"Download and install VirtualBox Download and install Vagrant Clone Dokku git clone https://github.com/progrium/dokku.git Setup SSH hosts in your /etc/hosts 10.0.0.2 dokku.me Create VM # Optional ENV arguments: # - `BOX_NAME` # - `BOX_URI` # - `BOX_MEMORY` # - `DOKKU_DOMAIN` # - `DOKKU_IP` # - `FORWARDED_PORT`. cd path/to/dokku vagrant up Setup SSH Config in ~/.ssh/config . The port listed here is usually correct, though you may want to verify that it is the same as the one listed in the output of vagrant ssh-config dokku Host dokku.me Port 22 Copy your SSH key via cat ~/.ssh/id_rsa.pub | pbcopy and paste it into the dokku-installer at http://dokku.me . Change the Hostname field on the Dokku Setup screen to your domain and then check the box that says Use virtualhost naming . Then click Finish Setup to install your key. You'll be directed to application deployment instructions from here. You are now ready to deploy an app or install plugins. For a different, complete, example see https://github.com/RyanBalfanz/dokku-vagrant-example.","title":"Install Dokku using Vagrant"}]}